/******/ var __webpack_modules__ = ({

/***/ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-context.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-context.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CheckboxContext: () => (/* binding */ CheckboxContext)
/* harmony export */ });
/* harmony import */ var _use_checkbox_context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./use-checkbox-context.js */ "./node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-context.js");
'use client';


const CheckboxContext = (props) => props.children((0,_use_checkbox_context_js__WEBPACK_IMPORTED_MODULE_0__.useCheckboxContext)());




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-control.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-control.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CheckboxControl: () => (/* binding */ CheckboxControl)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _zag_js_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/react */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../factory.js */ "./node_modules/@ark-ui/react/dist/components/factory.js");
/* harmony import */ var _use_checkbox_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./use-checkbox-context.js */ "./node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-context.js");
'use client';






const CheckboxControl = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref) => {
  const checkbox = (0,_use_checkbox_context_js__WEBPACK_IMPORTED_MODULE_2__.useCheckboxContext)();
  const mergedProps = (0,_zag_js_react__WEBPACK_IMPORTED_MODULE_3__.mergeProps)(checkbox.getControlProps(), props);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_factory_js__WEBPACK_IMPORTED_MODULE_4__.ark.div, { ...mergedProps, ref });
});
CheckboxControl.displayName = "CheckboxControl";




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-group.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-group.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CheckboxGroup: () => (/* binding */ CheckboxGroup)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _utils_create_split_props_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/create-split-props.js */ "./node_modules/@ark-ui/react/dist/utils/create-split-props.js");
/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../factory.js */ "./node_modules/@ark-ui/react/dist/components/factory.js");
/* harmony import */ var _checkbox_anatomy_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./checkbox.anatomy.js */ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox.anatomy.js");
/* harmony import */ var _use_checkbox_group_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./use-checkbox-group.js */ "./node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-group.js");
/* harmony import */ var _use_checkbox_group_context_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./use-checkbox-group-context.js */ "./node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-group-context.js");
'use client';








const CheckboxGroup = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref) => {
  const [checkboxGroupProps, localProps] = (0,_utils_create_split_props_js__WEBPACK_IMPORTED_MODULE_2__.createSplitProps)()(props, [
    "defaultValue",
    "value",
    "onValueChange",
    "disabled",
    "invalid",
    "readOnly",
    "name"
  ]);
  const checkboxGroup = (0,_use_checkbox_group_js__WEBPACK_IMPORTED_MODULE_3__.useCheckboxGroup)(checkboxGroupProps);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_use_checkbox_group_context_js__WEBPACK_IMPORTED_MODULE_4__.CheckboxGroupContextProvider, { value: checkboxGroup, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_factory_js__WEBPACK_IMPORTED_MODULE_5__.ark.div, { ref, role: "group", ...localProps, ..._checkbox_anatomy_js__WEBPACK_IMPORTED_MODULE_6__.checkboxAnatomy.build().group.attrs }) });
});
CheckboxGroup.displayName = "CheckboxGroup";




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-hidden-input.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-hidden-input.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CheckboxHiddenInput: () => (/* binding */ CheckboxHiddenInput)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _zag_js_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/react */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../factory.js */ "./node_modules/@ark-ui/react/dist/components/factory.js");
/* harmony import */ var _field_use_field_context_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../field/use-field-context.js */ "./node_modules/@ark-ui/react/dist/components/field/use-field-context.js");
/* harmony import */ var _use_checkbox_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./use-checkbox-context.js */ "./node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-context.js");
'use client';







const CheckboxHiddenInput = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref) => {
  const checkbox = (0,_use_checkbox_context_js__WEBPACK_IMPORTED_MODULE_2__.useCheckboxContext)();
  const mergedProps = (0,_zag_js_react__WEBPACK_IMPORTED_MODULE_3__.mergeProps)(checkbox.getHiddenInputProps(), props);
  const field = (0,_field_use_field_context_js__WEBPACK_IMPORTED_MODULE_4__.useFieldContext)();
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_factory_js__WEBPACK_IMPORTED_MODULE_5__.ark.input, { "aria-describedby": field?.ariaDescribedby, ...mergedProps, ref });
});
CheckboxHiddenInput.displayName = "CheckboxHiddenInput";




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-label.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-label.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CheckboxLabel: () => (/* binding */ CheckboxLabel)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _zag_js_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/react */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../factory.js */ "./node_modules/@ark-ui/react/dist/components/factory.js");
/* harmony import */ var _use_checkbox_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./use-checkbox-context.js */ "./node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-context.js");
'use client';






const CheckboxLabel = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref) => {
  const checkbox = (0,_use_checkbox_context_js__WEBPACK_IMPORTED_MODULE_2__.useCheckboxContext)();
  const mergedProps = (0,_zag_js_react__WEBPACK_IMPORTED_MODULE_3__.mergeProps)(checkbox.getLabelProps(), props);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_factory_js__WEBPACK_IMPORTED_MODULE_4__.ark.span, { ...mergedProps, ref });
});
CheckboxLabel.displayName = "CheckboxLabel";




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root-provider.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root-provider.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CheckboxRootProvider: () => (/* binding */ CheckboxRootProvider)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _zag_js_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/react */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _utils_create_split_props_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/create-split-props.js */ "./node_modules/@ark-ui/react/dist/utils/create-split-props.js");
/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../factory.js */ "./node_modules/@ark-ui/react/dist/components/factory.js");
/* harmony import */ var _use_checkbox_context_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./use-checkbox-context.js */ "./node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-context.js");
'use client';







const CheckboxRootProvider = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref) => {
  const [{ value: checkbox }, localProps] = (0,_utils_create_split_props_js__WEBPACK_IMPORTED_MODULE_2__.createSplitProps)()(props, ["value"]);
  const mergedProps = (0,_zag_js_react__WEBPACK_IMPORTED_MODULE_3__.mergeProps)(checkbox.getRootProps(), localProps);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_use_checkbox_context_js__WEBPACK_IMPORTED_MODULE_4__.CheckboxProvider, { value: checkbox, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_factory_js__WEBPACK_IMPORTED_MODULE_5__.ark.label, { ...mergedProps, ref }) });
});
CheckboxRootProvider.displayName = "CheckboxRootProvider";




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CheckboxRoot: () => (/* binding */ CheckboxRoot)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _zag_js_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/react */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _utils_create_split_props_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/create-split-props.js */ "./node_modules/@ark-ui/react/dist/utils/create-split-props.js");
/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../factory.js */ "./node_modules/@ark-ui/react/dist/components/factory.js");
/* harmony import */ var _use_checkbox_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./use-checkbox.js */ "./node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox.js");
/* harmony import */ var _use_checkbox_context_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./use-checkbox-context.js */ "./node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-context.js");
'use client';








const CheckboxRoot = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref) => {
  const [useCheckboxProps, localProps] = (0,_utils_create_split_props_js__WEBPACK_IMPORTED_MODULE_2__.createSplitProps)()(props, [
    "checked",
    "defaultChecked",
    "disabled",
    "form",
    "id",
    "ids",
    "invalid",
    "name",
    "onCheckedChange",
    "readOnly",
    "required",
    "value"
  ]);
  const checkbox = (0,_use_checkbox_js__WEBPACK_IMPORTED_MODULE_3__.useCheckbox)(useCheckboxProps);
  const mergedProps = (0,_zag_js_react__WEBPACK_IMPORTED_MODULE_4__.mergeProps)(checkbox.getRootProps(), localProps);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_use_checkbox_context_js__WEBPACK_IMPORTED_MODULE_5__.CheckboxProvider, { value: checkbox, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_factory_js__WEBPACK_IMPORTED_MODULE_6__.ark.label, { ...mergedProps, ref }) });
});
CheckboxRoot.displayName = "CheckboxRoot";




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox.anatomy.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/checkbox/checkbox.anatomy.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkboxAnatomy: () => (/* binding */ checkboxAnatomy)
/* harmony export */ });
/* harmony import */ var _zag_js_checkbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/checkbox */ "./node_modules/@zag-js/checkbox/dist/index.mjs");
'use client';


const checkboxAnatomy = _zag_js_checkbox__WEBPACK_IMPORTED_MODULE_0__.anatomy.extendWith("group");




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-context.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-context.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CheckboxProvider: () => (/* binding */ CheckboxProvider),
/* harmony export */   useCheckboxContext: () => (/* binding */ useCheckboxContext)
/* harmony export */ });
/* harmony import */ var _utils_create_context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/create-context.js */ "./node_modules/@ark-ui/react/dist/utils/create-context.js");
'use client';


const [CheckboxProvider, useCheckboxContext] = (0,_utils_create_context_js__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  name: "CheckboxContext",
  hookName: "useCheckboxContext",
  providerName: "<CheckboxProvider />"
});




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-group-context.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-group-context.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CheckboxGroupContextProvider: () => (/* binding */ CheckboxGroupContextProvider),
/* harmony export */   useCheckboxGroupContext: () => (/* binding */ useCheckboxGroupContext)
/* harmony export */ });
/* harmony import */ var _utils_create_context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/create-context.js */ "./node_modules/@ark-ui/react/dist/utils/create-context.js");
'use client';


const [CheckboxGroupContextProvider, useCheckboxGroupContext] = (0,_utils_create_context_js__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  name: "CheckboxGroupContext",
  hookName: "useCheckboxGroupContext",
  providerName: "<CheckboxGroupProvider />",
  strict: false
});




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-group.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-group.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useCheckboxGroup: () => (/* binding */ useCheckboxGroup)
/* harmony export */ });
/* harmony import */ var _utils_use_controllable_state_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/use-controllable-state.js */ "./node_modules/@ark-ui/react/dist/utils/use-controllable-state.js");
/* harmony import */ var _utils_use_event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/use-event.js */ "./node_modules/@ark-ui/react/dist/utils/use-event.js");
'use client';



function useCheckboxGroup(props = {}) {
  const { defaultValue, value: controlledValue, onValueChange, disabled, readOnly, name, invalid } = props;
  const interactive = !(disabled || readOnly);
  const onChangeProp = (0,_utils_use_event_js__WEBPACK_IMPORTED_MODULE_0__.useEvent)(onValueChange, { sync: true });
  const [value, setValue] = (0,_utils_use_controllable_state_js__WEBPACK_IMPORTED_MODULE_1__.useControllableState)({
    value: controlledValue,
    defaultValue: defaultValue || [],
    onChange: onChangeProp
  });
  const isChecked = (val) => {
    return value.some((v) => String(v) === String(val));
  };
  const toggleValue = (val) => {
    isChecked(val) ? removeValue(val) : addValue(val);
  };
  const addValue = (val) => {
    if (!interactive) return;
    if (isChecked(val)) return;
    setValue(value.concat(val));
  };
  const removeValue = (val) => {
    if (!interactive) return;
    setValue(value.filter((v) => String(v) !== String(val)));
  };
  const getItemProps = (props2) => {
    return {
      checked: props2.value != null ? isChecked(props2.value) : void 0,
      onCheckedChange() {
        if (props2.value != null) {
          toggleValue(props2.value);
        }
      },
      name,
      disabled,
      readOnly,
      invalid
    };
  };
  return {
    isChecked,
    value,
    name,
    disabled: !!disabled,
    readOnly: !!readOnly,
    invalid: !!invalid,
    setValue,
    addValue,
    toggleValue,
    getItemProps
  };
}




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useCheckbox: () => (/* binding */ useCheckbox)
/* harmony export */ });
/* harmony import */ var _zag_js_checkbox__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @zag-js/checkbox */ "./node_modules/@zag-js/checkbox/dist/index.mjs");
/* harmony import */ var _zag_js_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/react */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _zag_js_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @zag-js/react */ "./node_modules/@zag-js/react/dist/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _providers_environment_use_environment_context_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../providers/environment/use-environment-context.js */ "./node_modules/@ark-ui/react/dist/providers/environment/use-environment-context.js");
/* harmony import */ var _providers_locale_use_locale_context_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../providers/locale/use-locale-context.js */ "./node_modules/@ark-ui/react/dist/providers/locale/use-locale-context.js");
/* harmony import */ var _field_use_field_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../field/use-field-context.js */ "./node_modules/@ark-ui/react/dist/components/field/use-field-context.js");
/* harmony import */ var _use_checkbox_group_context_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./use-checkbox-group-context.js */ "./node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-group-context.js");
'use client';








const useCheckbox = (ownProps = {}) => {
  const checkboxGroup = (0,_use_checkbox_group_context_js__WEBPACK_IMPORTED_MODULE_1__.useCheckboxGroupContext)();
  const field = (0,_field_use_field_context_js__WEBPACK_IMPORTED_MODULE_2__.useFieldContext)();
  const props = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return (0,_zag_js_react__WEBPACK_IMPORTED_MODULE_3__.mergeProps)(ownProps, checkboxGroup?.getItemProps({ value: ownProps.value }) ?? {});
  }, [ownProps, checkboxGroup]);
  const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();
  const { getRootNode } = (0,_providers_environment_use_environment_context_js__WEBPACK_IMPORTED_MODULE_4__.useEnvironmentContext)();
  const { dir } = (0,_providers_locale_use_locale_context_js__WEBPACK_IMPORTED_MODULE_5__.useLocaleContext)();
  const machineProps = {
    id,
    ids: {
      label: field?.ids.label,
      hiddenInput: field?.ids.control
    },
    dir,
    disabled: field?.disabled,
    readOnly: field?.readOnly,
    invalid: field?.invalid,
    required: field?.required,
    getRootNode,
    ...props
  };
  const service = (0,_zag_js_react__WEBPACK_IMPORTED_MODULE_6__.useMachine)(_zag_js_checkbox__WEBPACK_IMPORTED_MODULE_7__.machine, machineProps);
  return _zag_js_checkbox__WEBPACK_IMPORTED_MODULE_7__.connect(service, _zag_js_react__WEBPACK_IMPORTED_MODULE_6__.normalizeProps);
};




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/color-picker/color-picker.anatomy.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/color-picker/color-picker.anatomy.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   colorPickerAnatomy: () => (/* binding */ colorPickerAnatomy)
/* harmony export */ });
/* harmony import */ var _zag_js_color_picker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/color-picker */ "./node_modules/@zag-js/color-picker/dist/index.mjs");
'use client';


const colorPickerAnatomy = _zag_js_color_picker__WEBPACK_IMPORTED_MODULE_0__.anatomy.extendWith("view");




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/dialog/dialog-backdrop.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/dialog/dialog-backdrop.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DialogBackdrop: () => (/* binding */ DialogBackdrop)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _zag_js_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @zag-js/react */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _utils_compose_refs_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utils/compose-refs.js */ "./node_modules/@ark-ui/react/dist/utils/compose-refs.js");
/* harmony import */ var _utils_render_strategy_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/render-strategy.js */ "./node_modules/@ark-ui/react/dist/utils/render-strategy.js");
/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../factory.js */ "./node_modules/@ark-ui/react/dist/components/factory.js");
/* harmony import */ var _presence_use_presence_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../presence/use-presence.js */ "./node_modules/@ark-ui/react/dist/components/presence/use-presence.js");
/* harmony import */ var _use_dialog_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./use-dialog-context.js */ "./node_modules/@ark-ui/react/dist/components/dialog/use-dialog-context.js");
'use client';









const DialogBackdrop = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref) => {
  const dialog = (0,_use_dialog_context_js__WEBPACK_IMPORTED_MODULE_2__.useDialogContext)();
  const renderStrategyProps = (0,_utils_render_strategy_js__WEBPACK_IMPORTED_MODULE_3__.useRenderStrategyPropsContext)();
  const presence = (0,_presence_use_presence_js__WEBPACK_IMPORTED_MODULE_4__.usePresence)({ ...renderStrategyProps, present: dialog.open });
  const mergedProps = (0,_zag_js_react__WEBPACK_IMPORTED_MODULE_5__.mergeProps)(dialog.getBackdropProps(), presence.getPresenceProps(), props);
  if (presence.unmounted) {
    return null;
  }
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_factory_js__WEBPACK_IMPORTED_MODULE_6__.ark.div, { ...mergedProps, ref: (0,_utils_compose_refs_js__WEBPACK_IMPORTED_MODULE_7__.composeRefs)(presence.ref, ref) });
});
DialogBackdrop.displayName = "DialogBackdrop";




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/dialog/dialog-close-trigger.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/dialog/dialog-close-trigger.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DialogCloseTrigger: () => (/* binding */ DialogCloseTrigger)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _zag_js_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/react */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../factory.js */ "./node_modules/@ark-ui/react/dist/components/factory.js");
/* harmony import */ var _use_dialog_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./use-dialog-context.js */ "./node_modules/@ark-ui/react/dist/components/dialog/use-dialog-context.js");
'use client';






const DialogCloseTrigger = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref) => {
  const dialog = (0,_use_dialog_context_js__WEBPACK_IMPORTED_MODULE_2__.useDialogContext)();
  const mergedProps = (0,_zag_js_react__WEBPACK_IMPORTED_MODULE_3__.mergeProps)(dialog.getCloseTriggerProps(), props);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_factory_js__WEBPACK_IMPORTED_MODULE_4__.ark.button, { ...mergedProps, ref });
});
DialogCloseTrigger.displayName = "DialogCloseTrigger";




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/dialog/dialog-content.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/dialog/dialog-content.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DialogContent: () => (/* binding */ DialogContent)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _zag_js_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/react */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _utils_compose_refs_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/compose-refs.js */ "./node_modules/@ark-ui/react/dist/utils/compose-refs.js");
/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../factory.js */ "./node_modules/@ark-ui/react/dist/components/factory.js");
/* harmony import */ var _presence_use_presence_context_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../presence/use-presence-context.js */ "./node_modules/@ark-ui/react/dist/components/presence/use-presence-context.js");
/* harmony import */ var _use_dialog_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./use-dialog-context.js */ "./node_modules/@ark-ui/react/dist/components/dialog/use-dialog-context.js");
'use client';








const DialogContent = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref) => {
  const dialog = (0,_use_dialog_context_js__WEBPACK_IMPORTED_MODULE_2__.useDialogContext)();
  const presence = (0,_presence_use_presence_context_js__WEBPACK_IMPORTED_MODULE_3__.usePresenceContext)();
  const mergedProps = (0,_zag_js_react__WEBPACK_IMPORTED_MODULE_4__.mergeProps)(dialog.getContentProps(), presence.getPresenceProps(), props);
  if (presence.unmounted) {
    return null;
  }
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_factory_js__WEBPACK_IMPORTED_MODULE_5__.ark.div, { ...mergedProps, ref: (0,_utils_compose_refs_js__WEBPACK_IMPORTED_MODULE_6__.composeRefs)(presence.ref, ref) });
});
DialogContent.displayName = "DialogContent";




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/dialog/dialog-context.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/dialog/dialog-context.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DialogContext: () => (/* binding */ DialogContext)
/* harmony export */ });
/* harmony import */ var _use_dialog_context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./use-dialog-context.js */ "./node_modules/@ark-ui/react/dist/components/dialog/use-dialog-context.js");
'use client';


const DialogContext = (props) => props.children((0,_use_dialog_context_js__WEBPACK_IMPORTED_MODULE_0__.useDialogContext)());




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/dialog/dialog-description.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/dialog/dialog-description.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DialogDescription: () => (/* binding */ DialogDescription)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _zag_js_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/react */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../factory.js */ "./node_modules/@ark-ui/react/dist/components/factory.js");
/* harmony import */ var _use_dialog_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./use-dialog-context.js */ "./node_modules/@ark-ui/react/dist/components/dialog/use-dialog-context.js");
'use client';






const DialogDescription = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref) => {
  const dialog = (0,_use_dialog_context_js__WEBPACK_IMPORTED_MODULE_2__.useDialogContext)();
  const mergedProps = (0,_zag_js_react__WEBPACK_IMPORTED_MODULE_3__.mergeProps)(dialog.getDescriptionProps(), props);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_factory_js__WEBPACK_IMPORTED_MODULE_4__.ark.div, { ...mergedProps, ref });
});
DialogDescription.displayName = "DialogDescription";




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/dialog/dialog-positioner.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/dialog/dialog-positioner.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DialogPositioner: () => (/* binding */ DialogPositioner)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _zag_js_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/react */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../factory.js */ "./node_modules/@ark-ui/react/dist/components/factory.js");
/* harmony import */ var _presence_use_presence_context_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../presence/use-presence-context.js */ "./node_modules/@ark-ui/react/dist/components/presence/use-presence-context.js");
/* harmony import */ var _use_dialog_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./use-dialog-context.js */ "./node_modules/@ark-ui/react/dist/components/dialog/use-dialog-context.js");
'use client';







const DialogPositioner = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref) => {
  const dialog = (0,_use_dialog_context_js__WEBPACK_IMPORTED_MODULE_2__.useDialogContext)();
  const mergedProps = (0,_zag_js_react__WEBPACK_IMPORTED_MODULE_3__.mergeProps)(dialog.getPositionerProps(), props);
  const presence = (0,_presence_use_presence_context_js__WEBPACK_IMPORTED_MODULE_4__.usePresenceContext)();
  if (presence.unmounted) {
    return null;
  }
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_factory_js__WEBPACK_IMPORTED_MODULE_5__.ark.div, { ...mergedProps, ref });
});
DialogPositioner.displayName = "DialogPositioner";




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/dialog/dialog-root-provider.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/dialog/dialog-root-provider.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DialogRootProvider: () => (/* binding */ DialogRootProvider)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _zag_js_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/react */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _utils_render_strategy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/render-strategy.js */ "./node_modules/@ark-ui/react/dist/utils/render-strategy.js");
/* harmony import */ var _presence_split_presence_props_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../presence/split-presence-props.js */ "./node_modules/@ark-ui/react/dist/components/presence/split-presence-props.js");
/* harmony import */ var _presence_use_presence_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../presence/use-presence.js */ "./node_modules/@ark-ui/react/dist/components/presence/use-presence.js");
/* harmony import */ var _presence_use_presence_context_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../presence/use-presence-context.js */ "./node_modules/@ark-ui/react/dist/components/presence/use-presence-context.js");
/* harmony import */ var _use_dialog_context_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./use-dialog-context.js */ "./node_modules/@ark-ui/react/dist/components/dialog/use-dialog-context.js");
'use client';








const DialogRootProvider = (props) => {
  const [presenceProps, { value: dialog, children }] = (0,_presence_split_presence_props_js__WEBPACK_IMPORTED_MODULE_1__.splitPresenceProps)(props);
  const [renderStrategyProps] = (0,_utils_render_strategy_js__WEBPACK_IMPORTED_MODULE_2__.splitRenderStrategyProps)(presenceProps);
  const presence = (0,_presence_use_presence_js__WEBPACK_IMPORTED_MODULE_3__.usePresence)((0,_zag_js_react__WEBPACK_IMPORTED_MODULE_4__.mergeProps)({ present: dialog.open }, presenceProps));
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_use_dialog_context_js__WEBPACK_IMPORTED_MODULE_5__.DialogProvider, { value: dialog, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_utils_render_strategy_js__WEBPACK_IMPORTED_MODULE_2__.RenderStrategyPropsProvider, { value: renderStrategyProps, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_presence_use_presence_context_js__WEBPACK_IMPORTED_MODULE_6__.PresenceProvider, { value: presence, children }) }) });
};




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/dialog/dialog-root.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/dialog/dialog-root.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DialogRoot: () => (/* binding */ DialogRoot)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _zag_js_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @zag-js/react */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _utils_render_strategy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/render-strategy.js */ "./node_modules/@ark-ui/react/dist/utils/render-strategy.js");
/* harmony import */ var _presence_split_presence_props_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../presence/split-presence-props.js */ "./node_modules/@ark-ui/react/dist/components/presence/split-presence-props.js");
/* harmony import */ var _presence_use_presence_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../presence/use-presence.js */ "./node_modules/@ark-ui/react/dist/components/presence/use-presence.js");
/* harmony import */ var _presence_use_presence_context_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../presence/use-presence-context.js */ "./node_modules/@ark-ui/react/dist/components/presence/use-presence-context.js");
/* harmony import */ var _use_dialog_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./use-dialog.js */ "./node_modules/@ark-ui/react/dist/components/dialog/use-dialog.js");
/* harmony import */ var _use_dialog_context_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./use-dialog-context.js */ "./node_modules/@ark-ui/react/dist/components/dialog/use-dialog-context.js");
'use client';









const DialogRoot = (props) => {
  const [presenceProps, { children, ...localProps }] = (0,_presence_split_presence_props_js__WEBPACK_IMPORTED_MODULE_1__.splitPresenceProps)(props);
  const [renderStrategyProps] = (0,_utils_render_strategy_js__WEBPACK_IMPORTED_MODULE_2__.splitRenderStrategyProps)(presenceProps);
  const dialog = (0,_use_dialog_js__WEBPACK_IMPORTED_MODULE_3__.useDialog)(localProps);
  const presence = (0,_presence_use_presence_js__WEBPACK_IMPORTED_MODULE_4__.usePresence)((0,_zag_js_react__WEBPACK_IMPORTED_MODULE_5__.mergeProps)({ present: dialog.open }, presenceProps));
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_use_dialog_context_js__WEBPACK_IMPORTED_MODULE_6__.DialogProvider, { value: dialog, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_utils_render_strategy_js__WEBPACK_IMPORTED_MODULE_2__.RenderStrategyPropsProvider, { value: renderStrategyProps, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_presence_use_presence_context_js__WEBPACK_IMPORTED_MODULE_7__.PresenceProvider, { value: presence, children }) }) });
};




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/dialog/dialog-title.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/dialog/dialog-title.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DialogTitle: () => (/* binding */ DialogTitle)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _zag_js_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/react */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../factory.js */ "./node_modules/@ark-ui/react/dist/components/factory.js");
/* harmony import */ var _use_dialog_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./use-dialog-context.js */ "./node_modules/@ark-ui/react/dist/components/dialog/use-dialog-context.js");
'use client';






const DialogTitle = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref) => {
  const dialog = (0,_use_dialog_context_js__WEBPACK_IMPORTED_MODULE_2__.useDialogContext)();
  const mergedProps = (0,_zag_js_react__WEBPACK_IMPORTED_MODULE_3__.mergeProps)(dialog.getTitleProps(), props);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_factory_js__WEBPACK_IMPORTED_MODULE_4__.ark.h2, { ...mergedProps, ref });
});
DialogTitle.displayName = "DialogTitle";




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/dialog/dialog-trigger.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/dialog/dialog-trigger.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DialogTrigger: () => (/* binding */ DialogTrigger)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _zag_js_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/react */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../factory.js */ "./node_modules/@ark-ui/react/dist/components/factory.js");
/* harmony import */ var _presence_use_presence_context_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../presence/use-presence-context.js */ "./node_modules/@ark-ui/react/dist/components/presence/use-presence-context.js");
/* harmony import */ var _use_dialog_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./use-dialog-context.js */ "./node_modules/@ark-ui/react/dist/components/dialog/use-dialog-context.js");
'use client';







const DialogTrigger = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref) => {
  const dialog = (0,_use_dialog_context_js__WEBPACK_IMPORTED_MODULE_2__.useDialogContext)();
  const presence = (0,_presence_use_presence_context_js__WEBPACK_IMPORTED_MODULE_3__.usePresenceContext)();
  const mergedProps = (0,_zag_js_react__WEBPACK_IMPORTED_MODULE_4__.mergeProps)(
    {
      ...dialog.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : dialog.getTriggerProps()["aria-controls"]
    },
    props
  );
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_factory_js__WEBPACK_IMPORTED_MODULE_5__.ark.button, { ...mergedProps, ref });
});
DialogTrigger.displayName = "DialogTrigger";




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/dialog/use-dialog-context.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/dialog/use-dialog-context.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DialogProvider: () => (/* binding */ DialogProvider),
/* harmony export */   useDialogContext: () => (/* binding */ useDialogContext)
/* harmony export */ });
/* harmony import */ var _utils_create_context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/create-context.js */ "./node_modules/@ark-ui/react/dist/utils/create-context.js");
'use client';


const [DialogProvider, useDialogContext] = (0,_utils_create_context_js__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  name: "DialogContext",
  hookName: "useDialogContext",
  providerName: "<DialogProvider />"
});




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/dialog/use-dialog.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/dialog/use-dialog.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useDialog: () => (/* binding */ useDialog)
/* harmony export */ });
/* harmony import */ var _zag_js_dialog__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/dialog */ "./node_modules/@zag-js/dialog/dist/index.mjs");
/* harmony import */ var _zag_js_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/react */ "./node_modules/@zag-js/react/dist/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _providers_environment_use_environment_context_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../providers/environment/use-environment-context.js */ "./node_modules/@ark-ui/react/dist/providers/environment/use-environment-context.js");
/* harmony import */ var _providers_locale_use_locale_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../providers/locale/use-locale-context.js */ "./node_modules/@ark-ui/react/dist/providers/locale/use-locale-context.js");
'use client';






const useDialog = (props) => {
  const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();
  const { getRootNode } = (0,_providers_environment_use_environment_context_js__WEBPACK_IMPORTED_MODULE_1__.useEnvironmentContext)();
  const { dir } = (0,_providers_locale_use_locale_context_js__WEBPACK_IMPORTED_MODULE_2__.useLocaleContext)();
  const machineProps = {
    id,
    getRootNode,
    dir,
    ...props
  };
  const service = (0,_zag_js_react__WEBPACK_IMPORTED_MODULE_3__.useMachine)(_zag_js_dialog__WEBPACK_IMPORTED_MODULE_4__.machine, machineProps);
  return _zag_js_dialog__WEBPACK_IMPORTED_MODULE_4__.connect(service, _zag_js_react__WEBPACK_IMPORTED_MODULE_3__.normalizeProps);
};




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/factory.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/factory.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ark: () => (/* binding */ ark),
/* harmony export */   jsxFactory: () => (/* binding */ jsxFactory)
/* harmony export */ });
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _utils_compose_refs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/compose-refs.js */ "./node_modules/@ark-ui/react/dist/utils/compose-refs.js");




function getRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
const withAsChild = (Component) => {
  const Comp = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(
    (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref) => {
      const { asChild, children, ...restProps } = props;
      if (!asChild) {
        return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Component, { ...restProps, ref }, children);
      }
      const onlyChild = react__WEBPACK_IMPORTED_MODULE_0__.Children.only(children);
      if (!(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(onlyChild)) {
        return null;
      }
      const childRef = getRef(onlyChild);
      return (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(onlyChild, {
        ...(0,_zag_js_core__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(restProps, onlyChild.props),
        ref: ref ? (0,_utils_compose_refs_js__WEBPACK_IMPORTED_MODULE_2__.composeRefs)(ref, childRef) : childRef
      });
    })
  );
  Comp.displayName = Component.displayName || Component.name;
  return Comp;
};
const jsxFactory = () => {
  const cache = /* @__PURE__ */ new Map();
  return new Proxy(withAsChild, {
    apply(_target, _thisArg, argArray) {
      return withAsChild(argArray[0]);
    },
    get(_, element) {
      const asElement = element;
      if (!cache.has(asElement)) {
        cache.set(asElement, withAsChild(asElement));
      }
      return cache.get(asElement);
    }
  });
};
const ark = jsxFactory();




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/field/field.anatomy.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/field/field.anatomy.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fieldAnatomy: () => (/* binding */ fieldAnatomy),
/* harmony export */   parts: () => (/* binding */ parts)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
'use client';


const fieldAnatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("field").parts(
  "root",
  "errorText",
  "helperText",
  "input",
  "label",
  "select",
  "textarea",
  "requiredIndicator"
);
const parts = fieldAnatomy.build();




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/field/use-field-context.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/field/use-field-context.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FieldProvider: () => (/* binding */ FieldProvider),
/* harmony export */   useFieldContext: () => (/* binding */ useFieldContext)
/* harmony export */ });
/* harmony import */ var _utils_create_context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/create-context.js */ "./node_modules/@ark-ui/react/dist/utils/create-context.js");
'use client';


const [FieldProvider, useFieldContext] = (0,_utils_create_context_js__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  name: "FieldContext",
  hookName: "useFieldContext",
  providerName: "<FieldProvider />",
  strict: false
});




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/fieldset/fieldset.anatomy.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/fieldset/fieldset.anatomy.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fieldsetAnatomy: () => (/* binding */ fieldsetAnatomy),
/* harmony export */   parts: () => (/* binding */ parts)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
'use client';


const fieldsetAnatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("fieldset").parts("root", "errorText", "helperText", "legend");
const parts = fieldsetAnatomy.build();




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/portal/portal.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/portal/portal.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Portal: () => (/* binding */ Portal)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var _providers_environment_use_environment_context_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../providers/environment/use-environment-context.js */ "./node_modules/@ark-ui/react/dist/providers/environment/use-environment-context.js");
'use client';






const Portal = (props) => {
  const { children, disabled } = props;
  const [container, setContainer] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(props.container?.current);
  const isServer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(
    subscribe,
    () => false,
    () => true
  );
  const { getRootNode } = (0,_providers_environment_use_environment_context_js__WEBPACK_IMPORTED_MODULE_3__.useEnvironmentContext)();
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    setContainer(() => props.container?.current);
  }, [props.container]);
  if (isServer || disabled) return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children });
  const mountNode = container ?? getPortalNode(getRootNode);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: react__WEBPACK_IMPORTED_MODULE_1__.Children.map(children, (child) => (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(child, mountNode)) });
};
const getPortalNode = (cb) => {
  const node = cb?.();
  const rootNode = node.getRootNode();
  if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.isShadowRoot)(rootNode)) return rootNode;
  return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.getDocument)(node).body;
};
const subscribe = () => () => {
};




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/presence/split-presence-props.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/presence/split-presence-props.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   splitPresenceProps: () => (/* binding */ splitPresenceProps)
/* harmony export */ });
/* harmony import */ var _utils_create_split_props_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/create-split-props.js */ "./node_modules/@ark-ui/react/dist/utils/create-split-props.js");
'use client';


const splitPresenceProps = (props) => (0,_utils_create_split_props_js__WEBPACK_IMPORTED_MODULE_0__.createSplitProps)()(props, [
  "immediate",
  "lazyMount",
  "onExitComplete",
  "present",
  "skipAnimationOnMount",
  "unmountOnExit"
]);




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/presence/use-presence-context.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/presence/use-presence-context.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PresenceProvider: () => (/* binding */ PresenceProvider),
/* harmony export */   usePresenceContext: () => (/* binding */ usePresenceContext)
/* harmony export */ });
/* harmony import */ var _utils_create_context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/create-context.js */ "./node_modules/@ark-ui/react/dist/utils/create-context.js");
'use client';


const [PresenceProvider, usePresenceContext] = (0,_utils_create_context_js__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  name: "PresenceContext",
  hookName: "usePresenceContext",
  providerName: "<PresenceProvider />"
});




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/presence/use-presence.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/presence/use-presence.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   usePresence: () => (/* binding */ usePresence)
/* harmony export */ });
/* harmony import */ var _zag_js_presence__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/presence */ "./node_modules/@zag-js/presence/dist/index.mjs");
/* harmony import */ var _zag_js_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/react */ "./node_modules/@zag-js/react/dist/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _utils_use_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/use-event.js */ "./node_modules/@ark-ui/react/dist/utils/use-event.js");
'use client';





const usePresence = (props = {}) => {
  const { lazyMount, unmountOnExit, present, skipAnimationOnMount = false, ...rest } = props;
  const wasEverPresent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);
  const machineProps = {
    ...rest,
    present,
    onExitComplete: (0,_utils_use_event_js__WEBPACK_IMPORTED_MODULE_1__.useEvent)(props.onExitComplete)
  };
  const service = (0,_zag_js_react__WEBPACK_IMPORTED_MODULE_2__.useMachine)(_zag_js_presence__WEBPACK_IMPORTED_MODULE_3__.machine, machineProps);
  const api = _zag_js_presence__WEBPACK_IMPORTED_MODULE_3__.connect(service, _zag_js_react__WEBPACK_IMPORTED_MODULE_2__.normalizeProps);
  if (api.present) {
    wasEverPresent.current = true;
  }
  const unmounted = !api.present && !wasEverPresent.current && lazyMount || unmountOnExit && !api.present && wasEverPresent.current;
  const getPresenceProps = () => ({
    "data-state": api.skip && skipAnimationOnMount ? void 0 : present ? "open" : "closed",
    hidden: !api.present
  });
  return {
    ref: api.setNode,
    getPresenceProps,
    present: api.present,
    unmounted
  };
};




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/components/segment-group/segment-group.anatomy.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/components/segment-group/segment-group.anatomy.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parts: () => (/* binding */ parts),
/* harmony export */   segmentGroupAnatomy: () => (/* binding */ segmentGroupAnatomy)
/* harmony export */ });
/* harmony import */ var _zag_js_radio_group__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/radio-group */ "./node_modules/@zag-js/radio-group/dist/index.mjs");
'use client';


const segmentGroupAnatomy = _zag_js_radio_group__WEBPACK_IMPORTED_MODULE_0__.anatomy.rename("segment-group");
const parts = segmentGroupAnatomy.build();




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/providers/environment/use-environment-context.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/providers/environment/use-environment-context.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnvironmentContextProvider: () => (/* binding */ EnvironmentContextProvider),
/* harmony export */   useEnvironmentContext: () => (/* binding */ useEnvironmentContext)
/* harmony export */ });
/* harmony import */ var _utils_create_context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/create-context.js */ "./node_modules/@ark-ui/react/dist/utils/create-context.js");
'use client';


const [EnvironmentContextProvider, useEnvironmentContext] = (0,_utils_create_context_js__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  name: "EnvironmentContext",
  hookName: "useEnvironmentContext",
  providerName: "<EnvironmentProvider />",
  strict: false,
  defaultValue: {
    getRootNode: () => document,
    getDocument: () => document,
    getWindow: () => window
  }
});




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/providers/locale/use-locale-context.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/providers/locale/use-locale-context.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LocaleContextProvider: () => (/* binding */ LocaleContextProvider),
/* harmony export */   useLocaleContext: () => (/* binding */ useLocaleContext)
/* harmony export */ });
/* harmony import */ var _utils_create_context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/create-context.js */ "./node_modules/@ark-ui/react/dist/utils/create-context.js");
'use client';


const [LocaleContextProvider, useLocaleContext] = (0,_utils_create_context_js__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  name: "LocaleContext",
  hookName: "useLocaleContext",
  providerName: "<LocaleProvider />",
  strict: false,
  defaultValue: { dir: "ltr", locale: "en-US" }
});




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/utils/compose-refs.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/utils/compose-refs.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   composeRefs: () => (/* binding */ composeRefs)
/* harmony export */ });
function composeRefs(...refs) {
  return (node) => {
    const cleanUps = [];
    for (const ref of refs) {
      if (typeof ref === "function") {
        const cb = ref(node);
        if (typeof cb === "function") {
          cleanUps.push(cb);
        }
      } else if (ref) {
        ref.current = node;
      }
    }
    if (cleanUps.length) {
      return () => {
        for (const cleanUp of cleanUps) {
          cleanUp();
        }
      };
    }
  };
}




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/utils/create-context.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/utils/create-context.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createContext: () => (/* binding */ createContext)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
'use client';


function getErrorMessage(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext(options = {}) {
  const {
    name,
    strict = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage,
    defaultValue
  } = options;
  const Context = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(defaultValue);
  Context.displayName = name;
  function useContext$1() {
    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);
    if (!context && strict) {
      const error = new Error(errorMessage ?? getErrorMessage(hookName, providerName));
      error.name = "ContextError";
      Error.captureStackTrace?.(error, useContext$1);
      throw error;
    }
    return context;
  }
  return [Context.Provider, useContext$1, Context];
}




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/utils/create-split-props.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/utils/create-split-props.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSplitProps: () => (/* binding */ createSplitProps)
/* harmony export */ });
'use client';
const createSplitProps = () => (props, keys) => keys.reduce(
  (previousValue, currentValue) => {
    const [target, source] = previousValue;
    const key = currentValue;
    if (source[key] !== void 0) {
      target[key] = source[key];
    }
    delete source[key];
    return [target, source];
  },
  [{}, { ...props }]
);




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/utils/render-strategy.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/utils/render-strategy.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RenderStrategyPropsProvider: () => (/* binding */ RenderStrategyPropsProvider),
/* harmony export */   splitRenderStrategyProps: () => (/* binding */ splitRenderStrategyProps),
/* harmony export */   useRenderStrategyPropsContext: () => (/* binding */ useRenderStrategyPropsContext)
/* harmony export */ });
/* harmony import */ var _create_context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create-context.js */ "./node_modules/@ark-ui/react/dist/utils/create-context.js");
/* harmony import */ var _create_split_props_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./create-split-props.js */ "./node_modules/@ark-ui/react/dist/utils/create-split-props.js");
'use client';



const [RenderStrategyPropsProvider, useRenderStrategyPropsContext] = (0,_create_context_js__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  name: "RenderStrategyContext",
  hookName: "useRenderStrategyContext",
  providerName: "<RenderStrategyPropsProvider />"
});
const splitRenderStrategyProps = (props) => (0,_create_split_props_js__WEBPACK_IMPORTED_MODULE_1__.createSplitProps)()(props, ["lazyMount", "unmountOnExit"]);




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/utils/use-controllable-state.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/utils/use-controllable-state.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useControllableState: () => (/* binding */ useControllableState)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
'use client';


function useControllableState(props) {
  const { value, onChange, defaultValue } = props;
  const [uncontrolledValue, setUncontrolledValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultValue);
  const controlled = value !== void 0;
  const currentValue = controlled ? value : uncontrolledValue;
  const setValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(
    (value2) => {
      if (controlled) {
        return onChange?.(value2);
      }
      setUncontrolledValue(value2);
      return onChange?.(value2);
    },
    [controlled, onChange]
  );
  return [currentValue, setValue];
}




/***/ }),

/***/ "./node_modules/@ark-ui/react/dist/utils/use-event.js":
/*!************************************************************!*\
  !*** ./node_modules/@ark-ui/react/dist/utils/use-event.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useEvent: () => (/* binding */ useEvent)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
'use client';


function useEvent(callback, opts = {}) {
  const { sync = false } = opts;
  const callbackRef = useLatestRef(callback);
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    (...args) => {
      if (sync) return queueMicrotask(() => callbackRef.current?.(...args));
      return callbackRef.current?.(...args);
    },
    [sync, callbackRef]
  );
}
function useLatestRef(value) {
  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);
  ref.current = value;
  return ref;
}




/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/extends.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _extends)
/* harmony export */ });
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}


/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js":
/*!***********************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/anatomy.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   accordionAnatomy: () => (/* binding */ accordionAnatomy),
/* harmony export */   actionBarAnatomy: () => (/* binding */ actionBarAnatomy),
/* harmony export */   alertAnatomy: () => (/* binding */ alertAnatomy),
/* harmony export */   avatarAnatomy: () => (/* reexport safe */ _ark_ui_react_avatar__WEBPACK_IMPORTED_MODULE_0__.anatomy),
/* harmony export */   blockquoteAnatomy: () => (/* binding */ blockquoteAnatomy),
/* harmony export */   breadcrumbAnatomy: () => (/* binding */ breadcrumbAnatomy),
/* harmony export */   cardAnatomy: () => (/* binding */ cardAnatomy),
/* harmony export */   checkboxAnatomy: () => (/* reexport safe */ _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_1__.checkboxAnatomy),
/* harmony export */   checkboxCardAnatomy: () => (/* binding */ checkboxCardAnatomy),
/* harmony export */   collapsibleAnatomy: () => (/* reexport safe */ _ark_ui_react_collapsible__WEBPACK_IMPORTED_MODULE_2__.anatomy),
/* harmony export */   colorPickerAnatomy: () => (/* binding */ colorPickerAnatomy),
/* harmony export */   dataListAnatomy: () => (/* binding */ dataListAnatomy),
/* harmony export */   dialogAnatomy: () => (/* binding */ dialogAnatomy),
/* harmony export */   drawerAnatomy: () => (/* binding */ drawerAnatomy),
/* harmony export */   editableAnatomy: () => (/* binding */ editableAnatomy),
/* harmony export */   emptyStateAnatomy: () => (/* binding */ emptyStateAnatomy),
/* harmony export */   fieldAnatomy: () => (/* binding */ fieldAnatomy),
/* harmony export */   fieldsetAnatomy: () => (/* binding */ fieldsetAnatomy),
/* harmony export */   fileUploadAnatomy: () => (/* binding */ fileUploadAnatomy),
/* harmony export */   hoverCardAnatomy: () => (/* reexport safe */ _ark_ui_react_hover_card__WEBPACK_IMPORTED_MODULE_3__.anatomy),
/* harmony export */   listAnatomy: () => (/* binding */ listAnatomy),
/* harmony export */   menuAnatomy: () => (/* binding */ menuAnatomy),
/* harmony export */   nativeSelectAnatomy: () => (/* binding */ nativeSelectAnatomy),
/* harmony export */   numberInputAnatomy: () => (/* reexport safe */ _ark_ui_react_number_input__WEBPACK_IMPORTED_MODULE_4__.anatomy),
/* harmony export */   pinInputAnatomy: () => (/* reexport safe */ _ark_ui_react_pin_input__WEBPACK_IMPORTED_MODULE_5__.anatomy),
/* harmony export */   popoverAnatomy: () => (/* binding */ popoverAnatomy),
/* harmony export */   progressAnatomy: () => (/* reexport safe */ _ark_ui_react_progress__WEBPACK_IMPORTED_MODULE_6__.anatomy),
/* harmony export */   qrCodeAnatomy: () => (/* reexport safe */ _ark_ui_react_qr_code__WEBPACK_IMPORTED_MODULE_7__.anatomy),
/* harmony export */   radioCardAnatomy: () => (/* binding */ radioCardAnatomy),
/* harmony export */   radioGroupAnatomy: () => (/* binding */ radioGroupAnatomy),
/* harmony export */   ratingGroupAnatomy: () => (/* binding */ ratingGroupAnatomy),
/* harmony export */   segmentGroupAnatomy: () => (/* reexport safe */ _ark_ui_react_segment_group__WEBPACK_IMPORTED_MODULE_8__.segmentGroupAnatomy),
/* harmony export */   selectAnatomy: () => (/* binding */ selectAnatomy),
/* harmony export */   sliderAnatomy: () => (/* binding */ sliderAnatomy),
/* harmony export */   statAnatomy: () => (/* binding */ statAnatomy),
/* harmony export */   statusAnatomy: () => (/* binding */ statusAnatomy),
/* harmony export */   stepsAnatomy: () => (/* binding */ stepsAnatomy),
/* harmony export */   switchAnatomy: () => (/* binding */ switchAnatomy),
/* harmony export */   tableAnatomy: () => (/* binding */ tableAnatomy),
/* harmony export */   tabsAnatomy: () => (/* binding */ tabsAnatomy),
/* harmony export */   tagAnatomy: () => (/* binding */ tagAnatomy),
/* harmony export */   timelineAnatomy: () => (/* binding */ timelineAnatomy),
/* harmony export */   toastAnatomy: () => (/* binding */ toastAnatomy),
/* harmony export */   tooltipAnatomy: () => (/* reexport safe */ _ark_ui_react_tooltip__WEBPACK_IMPORTED_MODULE_9__.anatomy)
/* harmony export */ });
/* harmony import */ var _ark_ui_react_accordion__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ark-ui/react/accordion */ "./node_modules/@zag-js/accordion/dist/index.mjs");
/* harmony import */ var _ark_ui_react_anatomy__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @ark-ui/react/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
/* harmony import */ var _ark_ui_react_color_picker__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @ark-ui/react/color-picker */ "./node_modules/@ark-ui/react/dist/components/color-picker/color-picker.anatomy.js");
/* harmony import */ var _ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @ark-ui/react/dialog */ "./node_modules/@zag-js/dialog/dist/index.mjs");
/* harmony import */ var _ark_ui_react_editable__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @ark-ui/react/editable */ "./node_modules/@zag-js/editable/dist/index.mjs");
/* harmony import */ var _ark_ui_react_field__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @ark-ui/react/field */ "./node_modules/@ark-ui/react/dist/components/field/field.anatomy.js");
/* harmony import */ var _ark_ui_react_fieldset__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @ark-ui/react/fieldset */ "./node_modules/@ark-ui/react/dist/components/fieldset/fieldset.anatomy.js");
/* harmony import */ var _ark_ui_react_file_upload__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @ark-ui/react/file-upload */ "./node_modules/@zag-js/file-upload/dist/index.mjs");
/* harmony import */ var _ark_ui_react_menu__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @ark-ui/react/menu */ "./node_modules/@zag-js/menu/dist/index.mjs");
/* harmony import */ var _ark_ui_react_popover__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @ark-ui/react/popover */ "./node_modules/@zag-js/popover/dist/index.mjs");
/* harmony import */ var _ark_ui_react_radio_group__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @ark-ui/react/radio-group */ "./node_modules/@zag-js/radio-group/dist/index.mjs");
/* harmony import */ var _ark_ui_react_rating_group__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @ark-ui/react/rating-group */ "./node_modules/@zag-js/rating-group/dist/index.mjs");
/* harmony import */ var _ark_ui_react_select__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @ark-ui/react/select */ "./node_modules/@zag-js/select/dist/index.mjs");
/* harmony import */ var _ark_ui_react_slider__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @ark-ui/react/slider */ "./node_modules/@zag-js/slider/dist/index.mjs");
/* harmony import */ var _ark_ui_react_switch__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @ark-ui/react/switch */ "./node_modules/@zag-js/switch/dist/index.mjs");
/* harmony import */ var _ark_ui_react_avatar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ark-ui/react/avatar */ "./node_modules/@zag-js/avatar/dist/index.mjs");
/* harmony import */ var _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ark-ui/react/checkbox */ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox.anatomy.js");
/* harmony import */ var _ark_ui_react_collapsible__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ark-ui/react/collapsible */ "./node_modules/@zag-js/collapsible/dist/index.mjs");
/* harmony import */ var _ark_ui_react_hover_card__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ark-ui/react/hover-card */ "./node_modules/@zag-js/hover-card/dist/index.mjs");
/* harmony import */ var _ark_ui_react_number_input__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ark-ui/react/number-input */ "./node_modules/@zag-js/number-input/dist/index.mjs");
/* harmony import */ var _ark_ui_react_pin_input__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ark-ui/react/pin-input */ "./node_modules/@zag-js/pin-input/dist/index.mjs");
/* harmony import */ var _ark_ui_react_progress__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ark-ui/react/progress */ "./node_modules/@zag-js/progress/dist/index.mjs");
/* harmony import */ var _ark_ui_react_qr_code__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ark-ui/react/qr-code */ "./node_modules/@zag-js/qr-code/dist/index.mjs");
/* harmony import */ var _ark_ui_react_segment_group__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ark-ui/react/segment-group */ "./node_modules/@ark-ui/react/dist/components/segment-group/segment-group.anatomy.js");
/* harmony import */ var _ark_ui_react_tooltip__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ark-ui/react/tooltip */ "./node_modules/@zag-js/tooltip/dist/index.mjs");



























const accordionAnatomy = _ark_ui_react_accordion__WEBPACK_IMPORTED_MODULE_10__.anatomy.extendWith("itemBody");
const actionBarAnatomy = (0,_ark_ui_react_anatomy__WEBPACK_IMPORTED_MODULE_11__.createAnatomy)("action-bar").parts(
  "positioner",
  "content",
  "separator",
  "selectionTrigger",
  "closeTrigger"
);
const alertAnatomy = (0,_ark_ui_react_anatomy__WEBPACK_IMPORTED_MODULE_11__.createAnatomy)("alert").parts(
  "title",
  "description",
  "root",
  "indicator",
  "content"
);
const breadcrumbAnatomy = (0,_ark_ui_react_anatomy__WEBPACK_IMPORTED_MODULE_11__.createAnatomy)("breadcrumb").parts(
  "link",
  "currentLink",
  "item",
  "list",
  "root",
  "ellipsis",
  "separator"
);
const blockquoteAnatomy = (0,_ark_ui_react_anatomy__WEBPACK_IMPORTED_MODULE_11__.createAnatomy)("blockquote").parts(
  "root",
  "icon",
  "content",
  "caption"
);
const cardAnatomy = (0,_ark_ui_react_anatomy__WEBPACK_IMPORTED_MODULE_11__.createAnatomy)("card").parts(
  "root",
  "header",
  "body",
  "footer",
  "title",
  "description"
);
const checkboxCardAnatomy = (0,_ark_ui_react_anatomy__WEBPACK_IMPORTED_MODULE_11__.createAnatomy)("checkbox-card", [
  "root",
  "control",
  "label",
  "description",
  "addon",
  "indicator",
  "content"
]);
const dataListAnatomy = (0,_ark_ui_react_anatomy__WEBPACK_IMPORTED_MODULE_11__.createAnatomy)("data-list").parts(
  "root",
  "item",
  "itemLabel",
  "itemValue"
);
const dialogAnatomy = _ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_12__.anatomy.extendWith(
  "header",
  "body",
  "footer",
  "backdrop"
);
const drawerAnatomy = _ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_12__.anatomy.extendWith(
  "header",
  "body",
  "footer",
  "backdrop"
);
const editableAnatomy = _ark_ui_react_editable__WEBPACK_IMPORTED_MODULE_13__.anatomy.extendWith("textarea");
const emptyStateAnatomy = (0,_ark_ui_react_anatomy__WEBPACK_IMPORTED_MODULE_11__.createAnatomy)("empty-state", [
  "root",
  "content",
  "indicator",
  "title",
  "description"
]);
const fieldAnatomy = _ark_ui_react_field__WEBPACK_IMPORTED_MODULE_14__.fieldAnatomy.extendWith("requiredIndicator");
const fieldsetAnatomy = _ark_ui_react_fieldset__WEBPACK_IMPORTED_MODULE_15__.fieldsetAnatomy.extendWith("content");
const fileUploadAnatomy = _ark_ui_react_file_upload__WEBPACK_IMPORTED_MODULE_16__.anatomy.extendWith(
  "itemContent",
  "dropzoneContent",
  "fileText"
);
const listAnatomy = (0,_ark_ui_react_anatomy__WEBPACK_IMPORTED_MODULE_11__.createAnatomy)("list").parts(
  "root",
  "item",
  "indicator"
);
const menuAnatomy = _ark_ui_react_menu__WEBPACK_IMPORTED_MODULE_17__.anatomy.extendWith("itemCommand");
const nativeSelectAnatomy = (0,_ark_ui_react_anatomy__WEBPACK_IMPORTED_MODULE_11__.createAnatomy)("select").parts(
  "root",
  "field",
  "indicator"
);
const popoverAnatomy = _ark_ui_react_popover__WEBPACK_IMPORTED_MODULE_18__.anatomy.extendWith(
  "header",
  "body",
  "footer"
);
const radioGroupAnatomy = _ark_ui_react_radio_group__WEBPACK_IMPORTED_MODULE_19__.anatomy.extendWith(
  "itemAddon",
  "itemIndicator"
);
const radioCardAnatomy = radioGroupAnatomy.extendWith(
  "itemContent",
  "itemDescription"
);
const ratingGroupAnatomy = _ark_ui_react_rating_group__WEBPACK_IMPORTED_MODULE_20__.anatomy.extendWith("itemIndicator");
const selectAnatomy = _ark_ui_react_select__WEBPACK_IMPORTED_MODULE_21__.anatomy.extendWith("indicatorGroup");
const sliderAnatomy = _ark_ui_react_slider__WEBPACK_IMPORTED_MODULE_22__.anatomy.extendWith("markerIndicator");
const statAnatomy = (0,_ark_ui_react_anatomy__WEBPACK_IMPORTED_MODULE_11__.createAnatomy)("stat").parts(
  "root",
  "label",
  "helpText",
  "valueText",
  "valueUnit",
  "indicator"
);
const statusAnatomy = (0,_ark_ui_react_anatomy__WEBPACK_IMPORTED_MODULE_11__.createAnatomy)("status").parts("root", "indicator");
const stepsAnatomy = (0,_ark_ui_react_anatomy__WEBPACK_IMPORTED_MODULE_11__.createAnatomy)("steps", [
  "root",
  "list",
  "item",
  "trigger",
  "indicator",
  "separator",
  "content",
  "title",
  "description",
  "nextTrigger",
  "prevTrigger",
  "progress"
]);
const switchAnatomy = _ark_ui_react_switch__WEBPACK_IMPORTED_MODULE_23__.anatomy.extendWith("indicator");
const tableAnatomy = (0,_ark_ui_react_anatomy__WEBPACK_IMPORTED_MODULE_11__.createAnatomy)("table").parts(
  "root",
  "header",
  "body",
  "row",
  "columnHeader",
  "cell",
  "footer",
  "caption"
);
const toastAnatomy = (0,_ark_ui_react_anatomy__WEBPACK_IMPORTED_MODULE_11__.createAnatomy)("toast").parts(
  "root",
  "title",
  "description",
  "indicator",
  "closeTrigger",
  "actionTrigger"
);
const tabsAnatomy = (0,_ark_ui_react_anatomy__WEBPACK_IMPORTED_MODULE_11__.createAnatomy)("tabs").parts(
  "root",
  "trigger",
  "list",
  "content",
  "contentGroup",
  "indicator"
);
const tagAnatomy = (0,_ark_ui_react_anatomy__WEBPACK_IMPORTED_MODULE_11__.createAnatomy)("tag").parts(
  "root",
  "label",
  "closeTrigger",
  "startElement",
  "endElement"
);
const timelineAnatomy = (0,_ark_ui_react_anatomy__WEBPACK_IMPORTED_MODULE_11__.createAnatomy)("timeline").parts(
  "root",
  "item",
  "content",
  "separator",
  "indicator",
  "connector",
  "title",
  "description"
);
const colorPickerAnatomy = _ark_ui_react_color_picker__WEBPACK_IMPORTED_MODULE_24__.colorPickerAnatomy.extendWith("channelText");




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/components/box/span.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/components/box/span.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Span: () => (/* binding */ Span)
/* harmony export */ });
/* harmony import */ var _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/factory.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js");

"use client";


const Span = (0,_styled_system_factory_js__WEBPACK_IMPORTED_MODULE_0__.chakra)("span");




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/components/button/button.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/components/button/button.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Button: () => (/* binding */ Button),
/* harmony export */   ButtonPropsProvider: () => (/* binding */ ButtonPropsProvider)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _merge_props_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../merge-props.js */ "./node_modules/@chakra-ui/react/dist/esm/merge-props.js");
/* harmony import */ var _utils_cx_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/cx.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/cx.js");
/* harmony import */ var _styled_system_create_recipe_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../styled-system/create-recipe-context.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/create-recipe-context.js");
/* harmony import */ var _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../styled-system/factory.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js");
/* harmony import */ var _loader_loader_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../loader/loader.js */ "./node_modules/@chakra-ui/react/dist/esm/components/loader/loader.js");

"use client";








const { useRecipeResult, PropsProvider, usePropsContext } = (0,_styled_system_create_recipe_context_js__WEBPACK_IMPORTED_MODULE_2__.createRecipeContext)(
  { key: "button" }
);
const Button = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(
  function Button2(inProps, ref) {
    const propsContext = usePropsContext();
    const props = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(
      () => (0,_merge_props_js__WEBPACK_IMPORTED_MODULE_3__.mergeProps)(propsContext, inProps),
      [propsContext, inProps]
    );
    const result = useRecipeResult(props);
    const {
      loading,
      loadingText,
      children,
      spinner,
      spinnerPlacement,
      ...rest
    } = result.props;
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_4__.chakra.button,
      {
        type: "button",
        ref,
        ...rest,
        disabled: loading || rest.disabled,
        className: (0,_utils_cx_js__WEBPACK_IMPORTED_MODULE_5__.cx)(result.className, props.className),
        css: [result.styles, props.css],
        children: !props.asChild && loading ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
          _loader_loader_js__WEBPACK_IMPORTED_MODULE_6__.Loader,
          {
            spinner,
            text: loadingText,
            spinnerPlacement,
            children
          }
        ) : children
      }
    );
  }
);
const ButtonPropsProvider = PropsProvider;




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/components/button/close-button.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/components/button/close-button.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CloseButton: () => (/* binding */ CloseButton)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _icons_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../icons.js */ "./node_modules/@chakra-ui/react/dist/esm/components/icons.js");
/* harmony import */ var _icon_button_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icon-button.js */ "./node_modules/@chakra-ui/react/dist/esm/components/button/icon-button.js");






const CloseButton = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(function CloseButton2(props, ref) {
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_icon_button_js__WEBPACK_IMPORTED_MODULE_2__.IconButton, { variant: "ghost", "aria-label": "Close", ref, ...props, children: props.children ?? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_icons_js__WEBPACK_IMPORTED_MODULE_3__.CloseIcon, {}) });
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/components/button/icon-button.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/components/button/icon-button.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IconButton: () => (/* binding */ IconButton)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _button_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./button.js */ "./node_modules/@chakra-ui/react/dist/esm/components/button/button.js");

"use client";




const IconButton = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(
  function IconButton2(props, ref) {
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      _button_js__WEBPACK_IMPORTED_MODULE_2__.Button,
      {
        px: "0",
        py: "0",
        _icon: { fontSize: "1.2em" },
        ref,
        ...props
      }
    );
  }
);




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/components/center/absolute-center.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/components/center/absolute-center.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbsoluteCenter: () => (/* binding */ AbsoluteCenter)
/* harmony export */ });
/* harmony import */ var _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/factory.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js");

"use client";


const AbsoluteCenter = (0,_styled_system_factory_js__WEBPACK_IMPORTED_MODULE_0__.chakra)("div", {
  base: {
    position: "absolute",
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  },
  variants: {
    axis: {
      horizontal: {
        insetStart: "50%",
        translate: "-50%",
        _rtl: {
          translate: "50%"
        }
      },
      vertical: {
        top: "50%",
        translate: "0 -50%"
      },
      both: {
        insetStart: "50%",
        top: "50%",
        translate: "-50% -50%",
        _rtl: {
          translate: "50% -50%"
        }
      }
    }
  },
  defaultVariants: {
    axis: "both"
  }
});
AbsoluteCenter.displayName = "AbsoluteCenter";




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/components/checkbox-card/checkbox-card.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/components/checkbox-card/checkbox-card.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CheckboxCardAddon: () => (/* binding */ CheckboxCardAddon),
/* harmony export */   CheckboxCardContent: () => (/* binding */ CheckboxCardContent),
/* harmony export */   CheckboxCardContext: () => (/* binding */ CheckboxCardContext),
/* harmony export */   CheckboxCardControl: () => (/* binding */ CheckboxCardControl),
/* harmony export */   CheckboxCardDescription: () => (/* binding */ CheckboxCardDescription),
/* harmony export */   CheckboxCardHiddenInput: () => (/* binding */ CheckboxCardHiddenInput),
/* harmony export */   CheckboxCardIndicator: () => (/* binding */ CheckboxCardIndicator),
/* harmony export */   CheckboxCardLabel: () => (/* binding */ CheckboxCardLabel),
/* harmony export */   CheckboxCardRoot: () => (/* binding */ CheckboxCardRoot),
/* harmony export */   CheckboxCardRootPropsProvider: () => (/* binding */ CheckboxCardRootPropsProvider),
/* harmony export */   CheckboxCardRootProvider: () => (/* binding */ CheckboxCardRootProvider),
/* harmony export */   useCheckboxCardStyles: () => (/* binding */ useCheckboxCardStyles)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ark-ui/react/checkbox */ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root-provider.js");
/* harmony import */ var _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ark-ui/react/checkbox */ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root.js");
/* harmony import */ var _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ark-ui/react/checkbox */ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-label.js");
/* harmony import */ var _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ark-ui/react/checkbox */ "./node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-context.js");
/* harmony import */ var _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ark-ui/react/checkbox */ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-control.js");
/* harmony import */ var _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ark-ui/react/checkbox */ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-context.js");
/* harmony import */ var _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @ark-ui/react/checkbox */ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-hidden-input.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _styled_system_create_slot_recipe_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../styled-system/create-slot-recipe-context.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/create-slot-recipe-context.js");
/* harmony import */ var _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../styled-system/factory.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js");
/* harmony import */ var _checkmark_checkmark_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../checkmark/checkmark.js */ "./node_modules/@chakra-ui/react/dist/esm/components/checkmark/checkmark.js");

"use client";







const {
  withProvider,
  withContext,
  useStyles: useCheckboxCardStyles,
  PropsProvider
} = (0,_styled_system_create_slot_recipe_context_js__WEBPACK_IMPORTED_MODULE_2__.createSlotRecipeContext)({ key: "checkboxCard" });
const CheckboxCardRootProvider = withProvider(_ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_3__.CheckboxRootProvider, "root", { forwardAsChild: true });
const CheckboxCardRoot = withProvider(_ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_4__.CheckboxRoot, "root", { forwardAsChild: true });
const CheckboxCardRootPropsProvider = PropsProvider;
const CheckboxCardLabel = withContext(_ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_5__.CheckboxLabel, "label", { forwardAsChild: true });
const CheckboxCardDescription = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function CheckboxCardDescription2(props, ref) {
  const styles = useCheckboxCardStyles();
  const api = (0,_ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_6__.useCheckboxContext)();
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_7__.chakra.div,
    {
      ref,
      ...props,
      css: [styles.description, props.css],
      "data-disabled": api.disabled ? "" : void 0,
      "data-state": api.checked ? "checked" : "unchecked"
    }
  );
});
const CheckboxCardControl = withContext(_ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_8__.CheckboxControl, "control", { forwardAsChild: true });
const CheckboxCardContent = withContext("div", "content");
const CheckboxCardIndicator = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function CheckboxCardIndicator2(props, ref) {
  const api = (0,_ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_6__.useCheckboxContext)();
  const styles = useCheckboxCardStyles();
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    _checkmark_checkmark_js__WEBPACK_IMPORTED_MODULE_9__.Checkmark,
    {
      ref,
      checked: api.checked,
      indeterminate: api.indeterminate,
      disabled: api.disabled,
      unstyled: true,
      ...props,
      css: [styles.indicator, props.css]
    }
  );
});
const CheckboxCardAddon = withContext("div", "addon");
const CheckboxCardContext = _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_10__.CheckboxContext;
const CheckboxCardHiddenInput = _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_11__.CheckboxHiddenInput;




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/components/checkbox/checkbox.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/components/checkbox/checkbox.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CheckboxContext: () => (/* binding */ CheckboxContext),
/* harmony export */   CheckboxControl: () => (/* binding */ CheckboxControl),
/* harmony export */   CheckboxGroup: () => (/* binding */ CheckboxGroup),
/* harmony export */   CheckboxHiddenInput: () => (/* binding */ CheckboxHiddenInput),
/* harmony export */   CheckboxIndicator: () => (/* binding */ CheckboxIndicator),
/* harmony export */   CheckboxLabel: () => (/* binding */ CheckboxLabel),
/* harmony export */   CheckboxPropsProvider: () => (/* binding */ CheckboxPropsProvider),
/* harmony export */   CheckboxRoot: () => (/* binding */ CheckboxRoot),
/* harmony export */   CheckboxRootProvider: () => (/* binding */ CheckboxRootProvider),
/* harmony export */   useCheckboxStyles: () => (/* binding */ useCheckboxStyles)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ark-ui/react/checkbox */ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root-provider.js");
/* harmony import */ var _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ark-ui/react/checkbox */ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root.js");
/* harmony import */ var _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ark-ui/react/checkbox */ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-label.js");
/* harmony import */ var _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ark-ui/react/checkbox */ "./node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-context.js");
/* harmony import */ var _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ark-ui/react/checkbox */ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-control.js");
/* harmony import */ var _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ark-ui/react/checkbox */ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-group.js");
/* harmony import */ var _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @ark-ui/react/checkbox */ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-context.js");
/* harmony import */ var _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @ark-ui/react/checkbox */ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox-hidden-input.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _styled_system_create_slot_recipe_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../styled-system/create-slot-recipe-context.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/create-slot-recipe-context.js");
/* harmony import */ var _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../styled-system/factory.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js");
/* harmony import */ var _checkmark_checkmark_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../checkmark/checkmark.js */ "./node_modules/@chakra-ui/react/dist/esm/components/checkmark/checkmark.js");

"use client";







const {
  withProvider,
  withContext,
  useStyles: useCheckboxStyles,
  PropsProvider
} = (0,_styled_system_create_slot_recipe_context_js__WEBPACK_IMPORTED_MODULE_2__.createSlotRecipeContext)({ key: "checkbox" });
const CheckboxRootProvider = withProvider(_ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_3__.CheckboxRootProvider, "root", { forwardAsChild: true });
const CheckboxRoot = withProvider(
  _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_4__.CheckboxRoot,
  "root",
  { forwardAsChild: true }
);
const CheckboxPropsProvider = PropsProvider;
const CheckboxLabel = withContext(
  _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_5__.CheckboxLabel,
  "label",
  { forwardAsChild: true }
);
const CheckboxIndicator = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function CheckboxIndicator2(props, ref) {
  const { checked, indeterminate, ...rest } = props;
  const api = (0,_ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_6__.useCheckboxContext)();
  const styles = useCheckboxStyles();
  if (checked && api.checked) {
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_7__.chakra.svg,
      {
        ref,
        asChild: true,
        ...rest,
        css: [styles.indicator, props.css],
        children: checked
      }
    );
  }
  if (indeterminate && api.indeterminate) {
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_7__.chakra.svg,
      {
        ref,
        asChild: true,
        ...rest,
        css: [styles.indicator, props.css],
        children: indeterminate
      }
    );
  }
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    _checkmark_checkmark_js__WEBPACK_IMPORTED_MODULE_8__.Checkmark,
    {
      ref,
      checked: api.checked,
      indeterminate: api.indeterminate,
      disabled: api.disabled,
      unstyled: true,
      ...rest,
      css: [styles.indicator, props.css]
    }
  );
});
const CheckboxControl = withContext(
  _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_9__.CheckboxControl,
  "control",
  {
    forwardAsChild: true,
    defaultProps: { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CheckboxIndicator, {}) }
  }
);
const CheckboxGroup = (0,_styled_system_factory_js__WEBPACK_IMPORTED_MODULE_7__.chakra)(
  _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_10__.CheckboxGroup,
  {
    base: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5"
    }
  },
  { forwardAsChild: true }
);
const CheckboxContext = _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_11__.CheckboxContext;
const CheckboxHiddenInput = _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_12__.CheckboxHiddenInput;




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/components/checkmark/checkmark.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/components/checkmark/checkmark.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Checkmark: () => (/* binding */ Checkmark)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _utils_attr_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/attr.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/attr.js");
/* harmony import */ var _styled_system_empty_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../styled-system/empty.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/empty.js");
/* harmony import */ var _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../styled-system/factory.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js");
/* harmony import */ var _styled_system_use_recipe_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../styled-system/use-recipe.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/use-recipe.js");

"use client";







const Checkmark = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(
  function Checkmark2(props, ref) {
    const recipe = (0,_styled_system_use_recipe_js__WEBPACK_IMPORTED_MODULE_2__.useRecipe)({ key: "checkmark", recipe: props.recipe });
    const [variantProps, restProps] = recipe.splitVariantProps(props);
    const { checked, indeterminate, disabled, unstyled, children, ...rest } = restProps;
    const styles = unstyled ? _styled_system_empty_js__WEBPACK_IMPORTED_MODULE_3__.EMPTY_STYLES : recipe(variantProps);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_4__.chakra.svg,
      {
        ref,
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "3px",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        "data-state": indeterminate ? "indeterminate" : checked ? "checked" : "unchecked",
        "data-disabled": (0,_utils_attr_js__WEBPACK_IMPORTED_MODULE_5__.dataAttr)(disabled),
        css: [styles, props.css],
        ...rest,
        children: indeterminate ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M5 12h14" }) : checked ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("polyline", { points: "20 6 9 17 4 12" }) : null
      }
    );
  }
);




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/components/dialog/dialog.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/components/dialog/dialog.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DialogActionTrigger: () => (/* binding */ DialogActionTrigger),
/* harmony export */   DialogBackdrop: () => (/* binding */ DialogBackdrop),
/* harmony export */   DialogBody: () => (/* binding */ DialogBody),
/* harmony export */   DialogCloseTrigger: () => (/* binding */ DialogCloseTrigger),
/* harmony export */   DialogContent: () => (/* binding */ DialogContent),
/* harmony export */   DialogContext: () => (/* binding */ DialogContext),
/* harmony export */   DialogDescription: () => (/* binding */ DialogDescription),
/* harmony export */   DialogFooter: () => (/* binding */ DialogFooter),
/* harmony export */   DialogHeader: () => (/* binding */ DialogHeader),
/* harmony export */   DialogPositioner: () => (/* binding */ DialogPositioner),
/* harmony export */   DialogPropsProvider: () => (/* binding */ DialogPropsProvider),
/* harmony export */   DialogRoot: () => (/* binding */ DialogRoot),
/* harmony export */   DialogRootProvider: () => (/* binding */ DialogRootProvider),
/* harmony export */   DialogTitle: () => (/* binding */ DialogTitle),
/* harmony export */   DialogTrigger: () => (/* binding */ DialogTrigger),
/* harmony export */   useDialogStyles: () => (/* binding */ useDialogStyles)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ark-ui/react/dialog */ "./node_modules/@ark-ui/react/dist/components/dialog/dialog-root-provider.js");
/* harmony import */ var _ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ark-ui/react/dialog */ "./node_modules/@ark-ui/react/dist/components/dialog/dialog-root.js");
/* harmony import */ var _ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ark-ui/react/dialog */ "./node_modules/@ark-ui/react/dist/components/dialog/dialog-trigger.js");
/* harmony import */ var _ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ark-ui/react/dialog */ "./node_modules/@ark-ui/react/dist/components/dialog/dialog-positioner.js");
/* harmony import */ var _ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ark-ui/react/dialog */ "./node_modules/@ark-ui/react/dist/components/dialog/dialog-content.js");
/* harmony import */ var _ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ark-ui/react/dialog */ "./node_modules/@ark-ui/react/dist/components/dialog/dialog-description.js");
/* harmony import */ var _ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ark-ui/react/dialog */ "./node_modules/@ark-ui/react/dist/components/dialog/dialog-title.js");
/* harmony import */ var _ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ark-ui/react/dialog */ "./node_modules/@ark-ui/react/dist/components/dialog/dialog-close-trigger.js");
/* harmony import */ var _ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @ark-ui/react/dialog */ "./node_modules/@ark-ui/react/dist/components/dialog/use-dialog-context.js");
/* harmony import */ var _ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @ark-ui/react/dialog */ "./node_modules/@ark-ui/react/dist/components/dialog/dialog-backdrop.js");
/* harmony import */ var _ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @ark-ui/react/dialog */ "./node_modules/@ark-ui/react/dist/components/dialog/dialog-context.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _styled_system_create_slot_recipe_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../styled-system/create-slot-recipe-context.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/create-slot-recipe-context.js");
/* harmony import */ var _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../styled-system/factory.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js");

"use client";






const {
  withRootProvider,
  withContext,
  useStyles: useDialogStyles,
  PropsProvider
} = (0,_styled_system_create_slot_recipe_context_js__WEBPACK_IMPORTED_MODULE_2__.createSlotRecipeContext)({ key: "dialog" });
const DialogRootProvider = withRootProvider(
  _ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_3__.DialogRootProvider,
  {
    defaultProps: { unmountOnExit: true, lazyMount: true }
  }
);
const DialogRoot = withRootProvider(_ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_4__.DialogRoot, {
  defaultProps: { unmountOnExit: true, lazyMount: true }
});
const DialogPropsProvider = PropsProvider;
const DialogTrigger = withContext(
  _ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_5__.DialogTrigger,
  "trigger",
  { forwardAsChild: true }
);
const DialogPositioner = withContext(_ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_6__.DialogPositioner, "positioner", { forwardAsChild: true });
const DialogContent = withContext(
  _ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_7__.DialogContent,
  "content",
  { forwardAsChild: true }
);
const DialogDescription = withContext(_ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_8__.DialogDescription, "description", { forwardAsChild: true });
const DialogTitle = withContext(
  _ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_9__.DialogTitle,
  "title",
  { forwardAsChild: true }
);
const DialogCloseTrigger = withContext(_ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_10__.DialogCloseTrigger, "closeTrigger", { forwardAsChild: true });
const DialogActionTrigger = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function DialogActionTrigger2(props, ref) {
  const dialog = (0,_ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_11__.useDialogContext)();
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_styled_system_factory_js__WEBPACK_IMPORTED_MODULE_12__.chakra.button, { ...props, ref, onClick: () => dialog.setOpen(false) });
});
const DialogBackdrop = withContext(
  _ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_13__.DialogBackdrop,
  "backdrop",
  { forwardAsChild: true }
);
const DialogBody = withContext(
  "div",
  "body"
);
const DialogFooter = withContext(
  "div",
  "footer"
);
const DialogHeader = withContext(
  "div",
  "header"
);
const DialogContext = _ark_ui_react_dialog__WEBPACK_IMPORTED_MODULE_14__.DialogContext;




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/components/flex/flex.js":
/*!************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/components/flex/flex.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Flex: () => (/* binding */ Flex)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../styled-system/factory.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js");

"use client";




const Flex = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(
  function Flex2(props, ref) {
    const {
      direction,
      align,
      justify,
      wrap,
      basis,
      grow,
      shrink,
      inline,
      ...rest
    } = props;
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_2__.chakra.div,
      {
        ref,
        ...rest,
        css: {
          display: inline ? "inline-flex" : "flex",
          flexDirection: direction,
          alignItems: align,
          justifyContent: justify,
          flexWrap: wrap,
          flexBasis: basis,
          flexGrow: grow,
          flexShrink: shrink,
          ...props.css
        }
      }
    );
  }
);




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/components/icons.js":
/*!********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/components/icons.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArrowDownIcon: () => (/* binding */ ArrowDownIcon),
/* harmony export */   ArrowUpIcon: () => (/* binding */ ArrowUpIcon),
/* harmony export */   CheckCircleIcon: () => (/* binding */ CheckCircleIcon),
/* harmony export */   CheckIcon: () => (/* binding */ CheckIcon),
/* harmony export */   ChevronDownIcon: () => (/* binding */ ChevronDownIcon),
/* harmony export */   ChevronRightIcon: () => (/* binding */ ChevronRightIcon),
/* harmony export */   ChevronUpIcon: () => (/* binding */ ChevronUpIcon),
/* harmony export */   CloseIcon: () => (/* binding */ CloseIcon),
/* harmony export */   CopyIcon: () => (/* binding */ CopyIcon),
/* harmony export */   EllipsisIcon: () => (/* binding */ EllipsisIcon),
/* harmony export */   EllpsisIcon: () => (/* binding */ EllpsisIcon),
/* harmony export */   ErrorIcon: () => (/* binding */ ErrorIcon),
/* harmony export */   FileIcon: () => (/* binding */ FileIcon),
/* harmony export */   InfoIcon: () => (/* binding */ InfoIcon),
/* harmony export */   PipetteIcon: () => (/* binding */ PipetteIcon),
/* harmony export */   QuoteIcon: () => (/* binding */ QuoteIcon),
/* harmony export */   StarIcon: () => (/* binding */ StarIcon),
/* harmony export */   WarningIcon: () => (/* binding */ WarningIcon)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../styled-system/factory.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js");

"use client";



const CheckIcon = (props) => {
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_1__.chakra.svg,
    {
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      ...props,
      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M20 6 9 17l-5-5" })
    }
  );
};
const ChevronUpIcon = (props) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
  _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_1__.chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props,
    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "m18 15-6-6-6 6" })
  }
);
const ChevronDownIcon = (props) => {
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_1__.chakra.svg,
    {
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      ...props,
      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "m6 9 6 6 6-6" })
    }
  );
};
const ChevronRightIcon = (props) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
  _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_1__.chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props,
    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "m9 18 6-6-6-6" })
  }
);
const EllpsisIcon = (props) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(
  _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_1__.chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props,
    children: [
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("circle", { cx: "12", cy: "12", r: "1" }),
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("circle", { cx: "19", cy: "12", r: "1" }),
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("circle", { cx: "5", cy: "12", r: "1" })
    ]
  }
);
const ArrowUpIcon = (props) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(
  _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_1__.chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "3",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props,
    children: [
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "m5 12 7-7 7 7" }),
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M12 19V5" })
    ]
  }
);
const ArrowDownIcon = (props) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(
  _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_1__.chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "3",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props,
    children: [
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M12 5v14" }),
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "m19 12-7 7-7-7" })
    ]
  }
);
const CheckCircleIcon = (props) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
  _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_1__.chakra.svg,
  {
    stroke: "currentColor",
    fill: "currentColor",
    strokeWidth: "0",
    viewBox: "0 0 24 24",
    ...props,
    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11.0026 16L6.75999 11.7574L8.17421 10.3431L11.0026 13.1716L16.6595 7.51472L18.0737 8.92893L11.0026 16Z" })
  }
);
const WarningIcon = (props) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
  _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_1__.chakra.svg,
  {
    stroke: "currentColor",
    fill: "currentColor",
    strokeWidth: "0",
    viewBox: "0 0 24 24",
    ...props,
    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11 15H13V17H11V15ZM11 7H13V13H11V7Z" })
  }
);
const InfoIcon = (props) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
  _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_1__.chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "currentColor",
    stroke: "currentColor",
    strokeWidth: "0",
    ...props,
    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11 7H13V9H11V7ZM11 11H13V17H11V11Z" })
  }
);
const QuoteIcon = (props) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_styled_system_factory_js__WEBPACK_IMPORTED_MODULE_1__.chakra.svg, { viewBox: "0 0 24 24", fill: "currentColor", ...props, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M6.5 10c-.223 0-.437.034-.65.065.069-.232.14-.468.254-.68.114-.308.292-.575.469-.844.148-.291.409-.488.601-.737.201-.242.475-.403.692-.604.213-.21.492-.315.714-.463.232-.133.434-.28.65-.35l.539-.222.474-.197-.485-1.938-.597.144c-.191.048-.424.104-.689.171-.271.05-.56.187-.882.312-.318.142-.686.238-1.028.466-.344.218-.741.4-1.091.692-.339.301-.748.562-1.05.945-.33.358-.656.734-.909 1.162-.293.408-.492.856-.702 1.299-.19.443-.343.896-.468 1.336-.237.882-.343 1.72-.384 2.437-.034.718-.014 1.315.028 1.747.015.204.043.402.063.539l.025.168.026-.006A4.5 4.5 0 1 0 6.5 10zm11 0c-.223 0-.437.034-.65.065.069-.232.14-.468.254-.68.114-.308.292-.575.469-.844.148-.291.409-.488.601-.737.201-.242.475-.403.692-.604.213-.21.492-.315.714-.463.232-.133.434-.28.65-.35l.539-.222.474-.197-.485-1.938-.597.144c-.191.048-.424.104-.689.171-.271.05-.56.187-.882.312-.317.143-.686.238-1.028.467-.344.218-.741.4-1.091.692-.339.301-.748.562-1.05.944-.33.358-.656.734-.909 1.162-.293.408-.492.856-.702 1.299-.19.443-.343.896-.468 1.336-.237.882-.343 1.72-.384 2.437-.034.718-.014 1.315.028 1.747.015.204.043.402.063.539l.025.168.026-.006A4.5 4.5 0 1 0 17.5 10z" }) });
const StarIcon = (props) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_styled_system_factory_js__WEBPACK_IMPORTED_MODULE_1__.chakra.svg, { viewBox: "0 0 24 24", fill: "currentColor", ...props, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z" }) });
const ErrorIcon = (props) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_styled_system_factory_js__WEBPACK_IMPORTED_MODULE_1__.chakra.svg, { viewBox: "0 0 24 24", fill: "currentColor", ...props, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z" }) });
const CloseIcon = (props) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_styled_system_factory_js__WEBPACK_IMPORTED_MODULE_1__.chakra.svg, { viewBox: "0 0 24 24", fill: "currentColor", ...props, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
  "path",
  {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M18.7071 6.70711C19.0976 6.31658 19.0976 5.68342 18.7071 5.29289C18.3166 4.90237 17.6834 4.90237 17.2929 5.29289L12 10.5858L6.70711 5.29289C6.31658 4.90237 5.68342 4.90237 5.29289 5.29289C4.90237 5.68342 4.90237 6.31658 5.29289 6.70711L10.5858 12L5.29289 17.2929C4.90237 17.6834 4.90237 18.3166 5.29289 18.7071C5.68342 19.0976 6.31658 19.0976 6.70711 18.7071L12 13.4142L17.2929 18.7071C17.6834 19.0976 18.3166 19.0976 18.7071 18.7071C19.0976 18.3166 19.0976 17.6834 18.7071 17.2929L13.4142 12L18.7071 6.70711Z"
  }
) });
const FileIcon = (props) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(
  _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_1__.chakra.svg,
  {
    stroke: "currentColor",
    fill: "none",
    strokeWidth: "2",
    viewBox: "0 0 24 24",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props,
    children: [
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }),
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M14 2v4a2 2 0 0 0 2 2h4" })
    ]
  }
);
const CopyIcon = (props) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(
  _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_1__.chakra.svg,
  {
    stroke: "currentColor",
    fill: "none",
    strokeWidth: "2",
    viewBox: "0 0 24 24",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props,
    children: [
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2" }),
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" })
    ]
  }
);
const PipetteIcon = (props) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(
  _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_1__.chakra.svg,
  {
    stroke: "currentColor",
    fill: "none",
    strokeWidth: "2",
    viewBox: "0 0 24 24",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props,
    children: [
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "m2 22 1-1h3l9-9" }),
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M3 21v-3l9-9" }),
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "m15 6 3.4-3.4a2.1 2.1 0 1 1 3 3L18 9l.4.4a2.1 2.1 0 1 1-3 3l-3.8-3.8a2.1 2.1 0 1 1 3-3l.4.4Z" })
    ]
  }
);
const EllipsisIcon = (props) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(
  _styled_system_factory_js__WEBPACK_IMPORTED_MODULE_1__.chakra.svg,
  {
    stroke: "currentColor",
    fill: "none",
    strokeWidth: "2",
    viewBox: "0 0 24 24",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props,
    children: [
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("circle", { cx: "12", cy: "12", r: "1" }),
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("circle", { cx: "19", cy: "12", r: "1" }),
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("circle", { cx: "5", cy: "12", r: "1" })
    ]
  }
);




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/components/loader/loader.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/components/loader/loader.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Loader: () => (/* binding */ Loader)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _spinner_spinner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../spinner/spinner.js */ "./node_modules/@chakra-ui/react/dist/esm/components/spinner/spinner.js");
/* harmony import */ var _box_span_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../box/span.js */ "./node_modules/@chakra-ui/react/dist/esm/components/box/span.js");
/* harmony import */ var _center_absolute_center_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../center/absolute-center.js */ "./node_modules/@chakra-ui/react/dist/esm/components/center/absolute-center.js");







const Loader = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(
  function Loader2(props, ref) {
    const {
      spinner = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_spinner_spinner_js__WEBPACK_IMPORTED_MODULE_2__.Spinner, { size: "inherit", borderWidth: "0.125em", color: "inherit" }),
      spinnerPlacement = "start",
      children,
      text,
      visible = true,
      ...rest
    } = props;
    if (!visible) return children;
    if (text) {
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_box_span_js__WEBPACK_IMPORTED_MODULE_3__.Span, { ref, display: "contents", ...rest, children: [
        spinnerPlacement === "start" && spinner,
        text,
        spinnerPlacement === "end" && spinner
      ] });
    }
    if (spinner) {
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_box_span_js__WEBPACK_IMPORTED_MODULE_3__.Span, { ref, display: "contents", ...rest, children: [
        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_center_absolute_center_js__WEBPACK_IMPORTED_MODULE_4__.AbsoluteCenter, { display: "inline-flex", children: spinner }),
        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_box_span_js__WEBPACK_IMPORTED_MODULE_3__.Span, { opacity: 0, children })
      ] });
    }
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_box_span_js__WEBPACK_IMPORTED_MODULE_3__.Span, { ref, display: "contents", ...rest, children });
  }
);




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/components/spinner/spinner.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/components/spinner/spinner.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Spinner: () => (/* binding */ Spinner),
/* harmony export */   SpinnerPropsProvider: () => (/* binding */ SpinnerPropsProvider)
/* harmony export */ });
/* harmony import */ var _styled_system_create_recipe_context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/create-recipe-context.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/create-recipe-context.js");

"use client";


const { withContext, PropsProvider } = (0,_styled_system_create_recipe_context_js__WEBPACK_IMPORTED_MODULE_0__.createRecipeContext)({
  key: "spinner"
});
const Spinner = withContext("span");
const SpinnerPropsProvider = PropsProvider;




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/components/typography/text.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/components/typography/text.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Text: () => (/* binding */ Text),
/* harmony export */   TextPropsProvider: () => (/* binding */ TextPropsProvider)
/* harmony export */ });
/* harmony import */ var _styled_system_create_recipe_context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/create-recipe-context.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/create-recipe-context.js");

"use client";


const { withContext, PropsProvider } = (0,_styled_system_create_recipe_context_js__WEBPACK_IMPORTED_MODULE_0__.createRecipeContext)({
  key: "text"
});
const Text = withContext("p");
const TextPropsProvider = PropsProvider;




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/create-context.js":
/*!******************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/create-context.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createContext: () => (/* binding */ createContext)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");

"use client";


function getErrorMessage(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext(options = {}) {
  const {
    name,
    strict = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage,
    defaultValue
  } = options;
  const Context = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(defaultValue);
  Context.displayName = name;
  function useContext$1() {
    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);
    if (!context && strict) {
      const error = new Error(
        errorMessage ?? getErrorMessage(hookName, providerName)
      );
      error.name = "ContextError";
      Error.captureStackTrace?.(error, useContext$1);
      throw error;
    }
    return context;
  }
  return [Context.Provider, useContext$1, Context];
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/merge-props.js":
/*!***************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/merge-props.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mergeProps: () => (/* binding */ mergeProps)
/* harmony export */ });
/* harmony import */ var _utils_call_all_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/call-all.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/call-all.js");



const clsx = (...args) => args.map((str) => str?.trim?.()).filter(Boolean).join(" ");
const eventRegex = /^on[A-Z]/;
function mergeProps(...args) {
  let result = {};
  for (let props of args) {
    for (let key in result) {
      if (eventRegex.test(key) && typeof result[key] === "function" && typeof props[key] === "function") {
        result[key] = (0,_utils_call_all_js__WEBPACK_IMPORTED_MODULE_0__.callAll)(result[key], props[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx(result[key], props[key]);
        continue;
      }
      if (key === "style") {
        result[key] = Object.assign({}, result[key] ?? {}, props[key] ?? {});
        continue;
      }
      result[key] = props[key] !== void 0 ? props[key] : result[key];
    }
    for (let key in props) {
      if (result[key] === void 0) {
        result[key] = props[key];
      }
    }
  }
  return result;
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/merge-refs.js":
/*!**************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/merge-refs.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assignRef: () => (/* binding */ assignRef),
/* harmony export */   mergeRefs: () => (/* binding */ mergeRefs)
/* harmony export */ });

function assignRef(ref, value) {
  if (ref == null) return;
  if (typeof ref === "function") {
    ref(value);
    return;
  }
  try {
    ref.current = value;
  } catch (error) {
    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`);
  }
}
function mergeRefs(...refs) {
  return (node) => {
    refs.forEach((ref) => {
      assignRef(ref, node);
    });
  };
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/preset-base.js":
/*!***************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/preset-base.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultBaseConfig: () => (/* binding */ defaultBaseConfig),
/* harmony export */   defaultConditions: () => (/* binding */ defaultConditions)
/* harmony export */ });
/* harmony import */ var _styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styled-system/color-mix.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/color-mix.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _styled_system_css_var_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./styled-system/css-var.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/css-var.js");





const isCssVar = (v) => /^var\(--.+\)$/.test(v);
const wrap = (str, v) => v != null ? `${str}(${v})` : v;
const deg = (v) => {
  if (isCssVar(v) || v == null) return v;
  const unitless = typeof v === "string" && !v.endsWith("deg");
  return typeof v === "number" || unitless ? `${v}deg` : v;
};
const createFocusRing = (selector) => {
  return {
    values: ["outside", "inside", "mixed", "none"],
    transform(value, { token }) {
      const focusRingColor = token("colors.colorPalette.focusRing");
      const styles = {
        inside: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineOffset: "0px",
            outlineWidth: "var(--focus-ring-width, 1px)",
            outlineColor: "var(--focus-ring-color)",
            outlineStyle: "var(--focus-ring-style, solid)",
            borderColor: "var(--focus-ring-color)"
          }
        },
        outside: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineWidth: "var(--focus-ring-width, 2px)",
            outlineOffset: "var(--focus-ring-offset, 2px)",
            outlineStyle: "var(--focus-ring-style, solid)",
            outlineColor: "var(--focus-ring-color)"
          }
        },
        mixed: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineWidth: "var(--focus-ring-width, 3px)",
            outlineStyle: "var(--focus-ring-style, solid)",
            outlineColor: "color-mix(in srgb, var(--focus-ring-color), transparent 60%)",
            borderColor: "var(--focus-ring-color)"
          }
        },
        none: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outline: "none"
          }
        }
      };
      return styles[value] ?? {};
    }
  };
};
const divideColor = (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("borderColor");
const createTransition = (value) => {
  return {
    transition: value,
    transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
    transitionDuration: "150ms"
  };
};
const defaultConditions = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_1__.defineConditions)({
  hover: [
    "@media (hover: hover)",
    "&:is(:hover, [data-hover]):not(:disabled, [data-disabled])"
  ],
  active: "&:is(:active, [data-active]):not(:disabled, [data-disabled], [data-state=open])",
  focus: "&:is(:focus, [data-focus])",
  focusWithin: "&:is(:focus-within, [data-focus-within])",
  focusVisible: "&:is(:focus-visible, [data-focus-visible])",
  disabled: "&:is(:disabled, [disabled], [data-disabled], [aria-disabled=true])",
  visited: "&:visited",
  target: "&:target",
  readOnly: "&:is([data-readonly], [aria-readonly=true], [readonly])",
  readWrite: "&:read-write",
  empty: "&:is(:empty, [data-empty])",
  checked: "&:is(:checked, [data-checked], [aria-checked=true], [data-state=checked])",
  enabled: "&:enabled",
  expanded: "&:is([aria-expanded=true], [data-expanded], [data-state=expanded])",
  highlighted: "&[data-highlighted]",
  complete: "&[data-complete]",
  incomplete: "&[data-incomplete]",
  dragging: "&[data-dragging]",
  before: "&::before",
  after: "&::after",
  firstLetter: "&::first-letter",
  firstLine: "&::first-line",
  marker: "&::marker",
  selection: "&::selection",
  file: "&::file-selector-button",
  backdrop: "&::backdrop",
  first: "&:first-of-type",
  last: "&:last-of-type",
  notFirst: "&:not(:first-of-type)",
  notLast: "&:not(:last-of-type)",
  only: "&:only-child",
  even: "&:nth-of-type(even)",
  odd: "&:nth-of-type(odd)",
  peerFocus: ".peer:is(:focus, [data-focus]) ~ &",
  peerHover: ".peer:is(:hover, [data-hover]):not(:disabled, [data-disabled]) ~ &",
  peerActive: ".peer:is(:active, [data-active]):not(:disabled, [data-disabled]) ~ &",
  peerFocusWithin: ".peer:focus-within ~ &",
  peerFocusVisible: ".peer:is(:focus-visible, [data-focus-visible]) ~ &",
  peerDisabled: ".peer:is(:disabled, [disabled], [data-disabled]) ~ &",
  peerChecked: ".peer:is(:checked, [data-checked], [aria-checked=true], [data-state=checked]) ~ &",
  peerInvalid: ".peer:is(:invalid, [data-invalid], [aria-invalid=true]) ~ &",
  peerExpanded: ".peer:is([aria-expanded=true], [data-expanded], [data-state=expanded]) ~ &",
  peerPlaceholderShown: ".peer:placeholder-shown ~ &",
  groupFocus: ".group:is(:focus, [data-focus]) &",
  groupHover: ".group:is(:hover, [data-hover]):not(:disabled, [data-disabled]) &",
  groupActive: ".group:is(:active, [data-active]):not(:disabled, [data-disabled]) &",
  groupFocusWithin: ".group:focus-within &",
  groupFocusVisible: ".group:is(:focus-visible, [data-focus-visible]) &",
  groupDisabled: ".group:is(:disabled, [disabled], [data-disabled]) &",
  groupChecked: ".group:is(:checked, [data-checked], [aria-checked=true], [data-state=checked]) &",
  groupExpanded: ".group:is([aria-expanded=true], [data-expanded], [data-state=expanded]) &",
  groupInvalid: ".group:invalid &",
  indeterminate: "&:is(:indeterminate, [data-indeterminate], [aria-checked=mixed], [data-state=indeterminate])",
  required: "&:is([data-required], [aria-required=true])",
  valid: "&:is([data-valid], [data-state=valid])",
  invalid: "&:is([data-invalid], [aria-invalid=true], [data-state=invalid])",
  autofill: "&:autofill",
  inRange: "&:is(:in-range, [data-in-range])",
  outOfRange: "&:is(:out-of-range, [data-outside-range])",
  placeholder: "&::placeholder, &[data-placeholder]",
  placeholderShown: "&:is(:placeholder-shown, [data-placeholder-shown])",
  pressed: "&:is([aria-pressed=true], [data-pressed])",
  selected: "&:is([aria-selected=true], [data-selected])",
  grabbed: "&:is([aria-grabbed=true], [data-grabbed])",
  underValue: "&[data-state=under-value]",
  overValue: "&[data-state=over-value]",
  atValue: "&[data-state=at-value]",
  default: "&:default",
  optional: "&:optional",
  open: "&:is([open], [data-open], [data-state=open])",
  closed: "&:is([closed], [data-closed], [data-state=closed])",
  fullscreen: "&is(:fullscreen, [data-fullscreen])",
  loading: "&:is([data-loading], [aria-busy=true])",
  hidden: "&:is([hidden], [data-hidden])",
  current: "&[data-current]",
  currentPage: "&[aria-current=page]",
  currentStep: "&[aria-current=step]",
  today: "&[data-today]",
  unavailable: "&[data-unavailable]",
  rangeStart: "&[data-range-start]",
  rangeEnd: "&[data-range-end]",
  now: "&[data-now]",
  topmost: "&[data-topmost]",
  motionReduce: "@media (prefers-reduced-motion: reduce)",
  motionSafe: "@media (prefers-reduced-motion: no-preference)",
  print: "@media print",
  landscape: "@media (orientation: landscape)",
  portrait: "@media (orientation: portrait)",
  dark: ".dark &, .dark .chakra-theme:not(.light) &",
  light: ":root &, .light &",
  osDark: "@media (prefers-color-scheme: dark)",
  osLight: "@media (prefers-color-scheme: light)",
  highContrast: "@media (forced-colors: active)",
  lessContrast: "@media (prefers-contrast: less)",
  moreContrast: "@media (prefers-contrast: more)",
  ltr: "[dir=ltr] &",
  rtl: "[dir=rtl] &",
  scrollbar: "&::-webkit-scrollbar",
  scrollbarThumb: "&::-webkit-scrollbar-thumb",
  scrollbarTrack: "&::-webkit-scrollbar-track",
  horizontal: "&[data-orientation=horizontal]",
  vertical: "&[data-orientation=vertical]",
  icon: "& :where(svg)",
  starting: "@starting-style"
});
const currentBgVar = (0,_styled_system_css_var_js__WEBPACK_IMPORTED_MODULE_2__.cssVar)("bg-currentcolor");
const isCurrentBgVar = (value) => value === currentBgVar.ref || value === "currentBg";
const colorValues = (theme) => ({
  ...theme("colors"),
  currentBg: currentBgVar
});
const defaultBaseConfig = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_1__.defineConfig)({
  conditions: defaultConditions,
  utilities: {
    // background
    background: {
      values: colorValues,
      shorthand: ["bg"],
      transform(value, args) {
        if (isCurrentBgVar(args.raw)) return { background: currentBgVar.ref };
        const styleObj = (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("background")(value, args);
        return { ...styleObj, [currentBgVar.var]: styleObj?.background };
      }
    },
    backgroundColor: {
      values: colorValues,
      shorthand: ["bgColor"],
      transform(value, args) {
        if (isCurrentBgVar(args.raw))
          return { backgroundColor: currentBgVar.ref };
        const styleObj = (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("backgroundColor")(value, args);
        return {
          ...styleObj,
          [currentBgVar.var]: styleObj?.backgroundColor
        };
      }
    },
    backgroundSize: { shorthand: ["bgSize"] },
    backgroundPosition: { shorthand: ["bgPos"] },
    backgroundRepeat: { shorthand: ["bgRepeat"] },
    backgroundAttachment: { shorthand: ["bgAttachment"] },
    backgroundClip: {
      shorthand: ["bgClip"],
      values: ["text"],
      transform(value) {
        return value === "text" ? { color: "transparent", backgroundClip: "text" } : { backgroundClip: value };
      }
    },
    backgroundGradient: {
      shorthand: ["bgGradient"],
      values(theme) {
        return {
          ...theme("gradients"),
          "to-t": "linear-gradient(to top, var(--gradient))",
          "to-tr": "linear-gradient(to top right, var(--gradient))",
          "to-r": "linear-gradient(to right, var(--gradient))",
          "to-br": "linear-gradient(to bottom right, var(--gradient))",
          "to-b": "linear-gradient(to bottom, var(--gradient))",
          "to-bl": "linear-gradient(to bottom left, var(--gradient))",
          "to-l": "linear-gradient(to left, var(--gradient))",
          "to-tl": "linear-gradient(to top left, var(--gradient))"
        };
      },
      transform(value) {
        return {
          "--gradient-stops": "var(--gradient-from), var(--gradient-to)",
          "--gradient": "var(--gradient-via-stops, var(--gradient-stops))",
          backgroundImage: value
        };
      }
    },
    gradientFrom: {
      values: colorValues,
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("--gradient-from")
    },
    gradientTo: {
      values: colorValues,
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("--gradient-to")
    },
    gradientVia: {
      values: colorValues,
      transform(value, args) {
        const styles = (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("--gradient-via")(value, args);
        return {
          ...styles,
          "--gradient-via-stops": "var(--gradient-from), var(--gradient-via), var(--gradient-to)"
        };
      }
    },
    backgroundImage: {
      values(theme) {
        return { ...theme("gradients"), ...theme("assets") };
      },
      shorthand: ["bgImg", "bgImage"]
    },
    // border
    border: { values: "borders" },
    borderTop: { values: "borders" },
    borderLeft: { values: "borders" },
    borderBlockStart: { values: "borders" },
    borderRight: { values: "borders" },
    borderBottom: { values: "borders" },
    borderBlockEnd: { values: "borders" },
    borderInlineStart: { values: "borders", shorthand: ["borderStart"] },
    borderInlineEnd: { values: "borders", shorthand: ["borderEnd"] },
    borderInline: { values: "borders", shorthand: ["borderX"] },
    borderBlock: { values: "borders", shorthand: ["borderY"] },
    // border colors
    borderColor: {
      values: colorValues,
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("borderColor")
    },
    borderTopColor: {
      values: colorValues,
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("borderTopColor")
    },
    borderBlockStartColor: {
      values: colorValues,
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("borderBlockStartColor")
    },
    borderBottomColor: {
      values: colorValues,
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("borderBottomColor")
    },
    borderBlockEndColor: {
      values: colorValues,
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("borderBlockEndColor")
    },
    borderLeftColor: {
      values: colorValues,
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("borderLeftColor")
    },
    borderInlineStartColor: {
      values: colorValues,
      shorthand: ["borderStartColor"],
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("borderInlineStartColor")
    },
    borderRightColor: {
      values: colorValues,
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("borderRightColor")
    },
    borderInlineEndColor: {
      values: colorValues,
      shorthand: ["borderEndColor"],
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("borderInlineEndColor")
    },
    // border styles
    borderStyle: { values: "borderStyles" },
    borderTopStyle: { values: "borderStyles" },
    borderBlockStartStyle: { values: "borderStyles" },
    borderBottomStyle: { values: "borderStyles" },
    borderBlockEndStyle: {
      values: "borderStyles"
    },
    borderInlineStartStyle: {
      values: "borderStyles",
      shorthand: ["borderStartStyle"]
    },
    borderInlineEndStyle: {
      values: "borderStyles",
      shorthand: ["borderEndStyle"]
    },
    borderLeftStyle: { values: "borderStyles" },
    borderRightStyle: { values: "borderStyles" },
    // border radius
    borderRadius: { values: "radii", shorthand: ["rounded"] },
    borderTopLeftRadius: { values: "radii", shorthand: ["roundedTopLeft"] },
    borderStartStartRadius: {
      values: "radii",
      shorthand: ["roundedStartStart", "borderTopStartRadius"]
    },
    borderEndStartRadius: {
      values: "radii",
      shorthand: ["roundedEndStart", "borderBottomStartRadius"]
    },
    borderTopRightRadius: {
      values: "radii",
      shorthand: ["roundedTopRight"]
    },
    borderStartEndRadius: {
      values: "radii",
      shorthand: ["roundedStartEnd", "borderTopEndRadius"]
    },
    borderEndEndRadius: {
      values: "radii",
      shorthand: ["roundedEndEnd", "borderBottomEndRadius"]
    },
    borderBottomLeftRadius: {
      values: "radii",
      shorthand: ["roundedBottomLeft"]
    },
    borderBottomRightRadius: {
      values: "radii",
      shorthand: ["roundedBottomRight"]
    },
    borderInlineStartRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedStart", "borderStartRadius"],
      transform: (value) => ({
        borderStartStartRadius: value,
        borderEndStartRadius: value
      })
    },
    borderInlineEndRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedEnd", "borderEndRadius"],
      transform: (value) => ({
        borderStartEndRadius: value,
        borderEndEndRadius: value
      })
    },
    borderTopRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedTop"],
      transform: (value) => ({
        borderTopLeftRadius: value,
        borderTopRightRadius: value
      })
    },
    borderBottomRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedBottom"],
      transform: (value) => ({
        borderBottomLeftRadius: value,
        borderBottomRightRadius: value
      })
    },
    borderLeftRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedLeft"],
      transform: (value) => ({
        borderTopLeftRadius: value,
        borderBottomLeftRadius: value
      })
    },
    borderRightRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedRight"],
      transform: (value) => ({
        borderTopRightRadius: value,
        borderBottomRightRadius: value
      })
    },
    borderWidth: { values: "borderWidths" },
    borderBlockStartWidth: { values: "borderWidths" },
    borderTopWidth: { values: "borderWidths" },
    borderBottomWidth: { values: "borderWidths" },
    borderBlockEndWidth: { values: "borderWidths" },
    borderRightWidth: { values: "borderWidths" },
    borderInlineWidth: {
      values: "borderWidths",
      shorthand: ["borderXWidth"]
    },
    borderInlineStartWidth: {
      values: "borderWidths",
      shorthand: ["borderStartWidth"]
    },
    borderInlineEndWidth: {
      values: "borderWidths",
      shorthand: ["borderEndWidth"]
    },
    borderLeftWidth: { values: "borderWidths" },
    borderBlockWidth: {
      values: "borderWidths",
      shorthand: ["borderYWidth"]
    },
    // colors
    color: {
      values: colorValues,
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("color")
    },
    fill: {
      values: colorValues,
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("fill")
    },
    stroke: {
      values: colorValues,
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("stroke")
    },
    accentColor: {
      values: colorValues,
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("accentColor")
    },
    // divide
    divideX: {
      values: { type: "string" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderInlineStartWidth: value,
            borderInlineEndWidth: "0px"
          }
        };
      }
    },
    divideY: {
      values: { type: "string" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderTopWidth: value,
            borderBottomWidth: "0px"
          }
        };
      }
    },
    divideColor: {
      values: colorValues,
      transform(value, args) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": divideColor(
            value,
            args
          )
        };
      }
    },
    divideStyle: {
      property: "borderStyle",
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderStyle: value
          }
        };
      }
    },
    // effects
    boxShadow: { values: "shadows", shorthand: ["shadow"] },
    boxShadowColor: {
      values: colorValues,
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("--shadow-color"),
      shorthand: ["shadowColor"]
    },
    mixBlendMode: { shorthand: ["blendMode"] },
    backgroundBlendMode: { shorthand: ["bgBlendMode"] },
    opacity: { values: "opacity" },
    // filters
    filter: {
      transform(v) {
        if (v !== "auto") {
          return { filter: v };
        }
        return {
          filter: `var(--blur) var(--brightness) var(--contrast) var(--grayscale) var(--hue-rotate) var(--invert) var(--saturate) var(--sepia) var(--drop-shadow)`
        };
      }
    },
    blur: {
      values: "blurs",
      transform: (v) => ({ "--blur": wrap("blur", v) })
    },
    brightness: {
      transform: (v) => ({ "--brightness": wrap("brightness", v) })
    },
    contrast: {
      transform: (v) => ({ "--contrast": wrap("contrast", v) })
    },
    grayscale: {
      transform: (v) => ({ "--grayscale": wrap("grayscale", v) })
    },
    hueRotate: {
      transform: (v) => ({ "--hue-rotate": wrap("hue-rotate", deg(v)) })
    },
    invert: { transform: (v) => ({ "--invert": wrap("invert", v) }) },
    saturate: {
      transform: (v) => ({ "--saturate": wrap("saturate", v) })
    },
    sepia: { transform: (v) => ({ "--sepia": wrap("sepia", v) }) },
    dropShadow: {
      transform: (v) => ({ "--drop-shadow": wrap("drop-shadow", v) })
    },
    // backdrop filters
    backdropFilter: {
      transform(v) {
        if (v !== "auto") {
          return { backdropFilter: v };
        }
        return {
          backdropFilter: `var(--backdrop-blur) var(--backdrop-brightness) var(--backdrop-contrast) var(--backdrop-grayscale) var(--backdrop-hue-rotate) var(--backdrop-invert) var(--backdrop-opacity) var(--backdrop-saturate) var(--backdrop-sepia)`
        };
      }
    },
    backdropBlur: {
      values: "blurs",
      transform: (v) => ({ "--backdrop-blur": wrap("blur", v) })
    },
    backdropBrightness: {
      transform: (v) => ({
        "--backdrop-brightness": wrap("brightness", v)
      })
    },
    backdropContrast: {
      transform: (v) => ({ "--backdrop-contrast": wrap("contrast", v) })
    },
    backdropGrayscale: {
      transform: (v) => ({
        "--backdrop-grayscale": wrap("grayscale", v)
      })
    },
    backdropHueRotate: {
      transform: (v) => ({
        "--backdrop-hue-rotate": wrap("hue-rotate", deg(v))
      })
    },
    backdropInvert: {
      transform: (v) => ({ "--backdrop-invert": wrap("invert", v) })
    },
    backdropOpacity: {
      transform: (v) => ({ "--backdrop-opacity": wrap("opacity", v) })
    },
    backdropSaturate: {
      transform: (v) => ({ "--backdrop-saturate": wrap("saturate", v) })
    },
    backdropSepia: {
      transform: (v) => ({ "--backdrop-sepia": wrap("sepia", v) })
    },
    // flexbox
    flexBasis: { values: "sizes" },
    gap: { values: "spacing" },
    rowGap: { values: "spacing", shorthand: ["gapY"] },
    columnGap: { values: "spacing", shorthand: ["gapX"] },
    flexDirection: { shorthand: ["flexDir"] },
    // grid
    gridGap: { values: "spacing" },
    gridColumnGap: { values: "spacing" },
    gridRowGap: { values: "spacing" },
    // interactivity
    outlineColor: {
      values: colorValues,
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("outlineColor")
    },
    focusRing: createFocusRing("&:is(:focus, [data-focus])"),
    focusVisibleRing: createFocusRing(
      "&:is(:focus-visible, [data-focus-visible])"
    ),
    focusRingColor: {
      values: colorValues,
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("--focus-ring-color")
    },
    focusRingOffset: {
      values: "spacing",
      transform: (v) => ({ "--focus-ring-offset": v })
    },
    focusRingWidth: {
      values: "borderWidths",
      property: "outlineWidth",
      transform: (v) => ({ "--focus-ring-width": v })
    },
    focusRingStyle: {
      values: "borderStyles",
      property: "outlineStyle",
      transform: (v) => ({ "--focus-ring-style": v })
    },
    // layout
    aspectRatio: { values: "aspectRatios" },
    width: { values: "sizes", shorthand: ["w"] },
    inlineSize: { values: "sizes" },
    height: { values: "sizes", shorthand: ["h"] },
    blockSize: { values: "sizes" },
    boxSize: {
      values: "sizes",
      property: "width",
      transform: (v) => ({ width: v, height: v })
    },
    minWidth: { values: "sizes", shorthand: ["minW"] },
    minInlineSize: { values: "sizes" },
    minHeight: { values: "sizes", shorthand: ["minH"] },
    minBlockSize: { values: "sizes" },
    maxWidth: { values: "sizes", shorthand: ["maxW"] },
    maxInlineSize: { values: "sizes" },
    maxHeight: { values: "sizes", shorthand: ["maxH"] },
    maxBlockSize: { values: "sizes" },
    hideFrom: {
      values: "breakpoints",
      //@ts-ignore
      transform: (value, { raw, token }) => {
        const bp = token.raw(`breakpoints.${raw}`);
        const media = bp ? `@breakpoint ${raw}` : `@media screen and (min-width: ${value})`;
        return {
          [media]: { display: "none" }
        };
      }
    },
    hideBelow: {
      values: "breakpoints",
      //@ts-ignore
      transform(value, { raw, token }) {
        const bp = token.raw(`breakpoints.${raw}`);
        const media = bp ? `@breakpoint ${raw}Down` : `@media screen and (max-width: ${value})`;
        return {
          [media]: {
            display: "none"
          }
        };
      }
    },
    // scroll
    overscrollBehavior: { shorthand: ["overscroll"] },
    overscrollBehaviorX: { shorthand: ["overscrollX"] },
    overscrollBehaviorY: { shorthand: ["overscrollY"] },
    scrollbar: {
      values: ["visible", "hidden"],
      transform(v) {
        switch (v) {
          case "visible":
            return {
              msOverflowStyle: "auto",
              scrollbarWidth: "auto",
              "&::-webkit-scrollbar": { display: "block" }
            };
          case "hidden":
            return {
              msOverflowStyle: "none",
              scrollbarWidth: "none",
              "&::-webkit-scrollbar": { display: "none" }
            };
          default:
            return {};
        }
      }
    },
    scrollbarColor: {
      values: colorValues,
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("scrollbarColor")
    },
    scrollbarGutter: { values: "spacing" },
    scrollbarWidth: { values: "sizes" },
    // scroll margin
    scrollMargin: { values: "spacing" },
    scrollMarginTop: { values: "spacing" },
    scrollMarginBottom: { values: "spacing" },
    scrollMarginLeft: { values: "spacing" },
    scrollMarginRight: { values: "spacing" },
    scrollMarginX: {
      values: "spacing",
      transform: (v) => ({ scrollMarginLeft: v, scrollMarginRight: v })
    },
    scrollMarginY: {
      values: "spacing",
      transform: (v) => ({ scrollMarginTop: v, scrollMarginBottom: v })
    },
    // scroll padding
    scrollPadding: { values: "spacing" },
    scrollPaddingTop: { values: "spacing" },
    scrollPaddingBottom: { values: "spacing" },
    scrollPaddingLeft: { values: "spacing" },
    scrollPaddingRight: { values: "spacing" },
    scrollPaddingInline: { values: "spacing", shorthand: ["scrollPaddingX"] },
    scrollPaddingBlock: { values: "spacing", shorthand: ["scrollPaddingY"] },
    // scroll snap
    scrollSnapType: {
      values: {
        none: "none",
        x: "x var(--scroll-snap-strictness)",
        y: "y var(--scroll-snap-strictness)",
        both: "both var(--scroll-snap-strictness)"
      }
    },
    scrollSnapStrictness: {
      values: ["mandatory", "proximity"],
      transform: (v) => ({ "--scroll-snap-strictness": v })
    },
    scrollSnapMargin: { values: "spacing" },
    scrollSnapMarginTop: { values: "spacing" },
    scrollSnapMarginBottom: { values: "spacing" },
    scrollSnapMarginLeft: { values: "spacing" },
    scrollSnapMarginRight: { values: "spacing" },
    // list
    listStylePosition: { shorthand: ["listStylePos"] },
    listStyleImage: { values: "assets", shorthand: ["listStyleImg"] },
    // position
    position: { shorthand: ["pos"] },
    zIndex: { values: "zIndex" },
    inset: { values: "spacing" },
    insetInline: { values: "spacing", shorthand: ["insetX"] },
    insetBlock: { values: "spacing", shorthand: ["insetY"] },
    top: { values: "spacing" },
    insetBlockStart: { values: "spacing" },
    bottom: { values: "spacing" },
    insetBlockEnd: { values: "spacing" },
    left: { values: "spacing" },
    right: { values: "spacing" },
    insetInlineStart: {
      values: "spacing",
      shorthand: ["insetStart"]
    },
    insetInlineEnd: {
      values: "spacing",
      shorthand: ["insetEnd"]
    },
    // shadow / ring
    ring: {
      transform(value) {
        return {
          "--ring-offset-shadow": `var(--ring-inset) 0 0 0 var(--ring-offset-width) var(--ring-offset-color)`,
          "--ring-shadow": `var(--ring-inset) 0 0 0 calc(var(--ring-width) + var(--ring-offset-width)) var(--ring-color)`,
          "--ring-width": value,
          boxShadow: "var(--ring-offset-shadow), var(--ring-shadow), var(--shadow, 0 0 #0000)"
        };
      }
    },
    ringColor: {
      values: colorValues,
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("--ring-color")
    },
    ringOffset: {
      transform: (value) => ({ "--ring-offset-width": value })
    },
    ringOffsetColor: {
      values: colorValues,
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("--ring-offset-color")
    },
    ringInset: {
      transform: (v) => ({ "--ring-inset": v })
    },
    // margin
    margin: { values: "spacing", shorthand: ["m"] },
    marginTop: { values: "spacing", shorthand: ["mt"] },
    marginBlockStart: { values: "spacing" },
    marginRight: { values: "spacing", shorthand: ["mr"] },
    marginBottom: { values: "spacing", shorthand: ["mb"] },
    marginBlockEnd: { values: "spacing" },
    marginLeft: { values: "spacing", shorthand: ["ml"] },
    marginInlineStart: { values: "spacing", shorthand: ["ms", "marginStart"] },
    marginInlineEnd: { values: "spacing", shorthand: ["me", "marginEnd"] },
    marginInline: { values: "spacing", shorthand: ["mx", "marginX"] },
    marginBlock: { values: "spacing", shorthand: ["my", "marginY"] },
    // padding
    padding: { values: "spacing", shorthand: ["p"] },
    paddingTop: { values: "spacing", shorthand: ["pt"] },
    paddingRight: { values: "spacing", shorthand: ["pr"] },
    paddingBottom: { values: "spacing", shorthand: ["pb"] },
    paddingBlockStart: { values: "spacing" },
    paddingBlockEnd: { values: "spacing" },
    paddingLeft: { values: "spacing", shorthand: ["pl"] },
    paddingInlineStart: {
      values: "spacing",
      shorthand: ["ps", "paddingStart"]
    },
    paddingInlineEnd: { values: "spacing", shorthand: ["pe", "paddingEnd"] },
    paddingInline: { values: "spacing", shorthand: ["px", "paddingX"] },
    paddingBlock: { values: "spacing", shorthand: ["py", "paddingY"] },
    // text decoration
    textDecoration: { shorthand: ["textDecor"] },
    textDecorationColor: {
      values: colorValues,
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("textDecorationColor")
    },
    textShadow: { values: "shadows" },
    // transform
    transform: {
      transform: (value) => {
        let v = value;
        if (value === "auto") {
          v = `translateX(var(--translate-x, 0)) translateY(var(--translate-y, 0)) rotate(var(--rotate, 0)) scaleX(var(--scale-x, 1)) scaleY(var(--scale-y, 1)) skewX(var(--skew-x, 0)) skewY(var(--skew-y, 0))`;
        }
        if (value === "auto-gpu") {
          v = `translate3d(var(--translate-x, 0), var(--translate-y, 0), 0) rotate(var(--rotate, 0)) scaleX(var(--scale-x, 1)) scaleY(var(--scale-y, 1)) skewX(var(--skew-x, 0)) skewY(var(--skew-y, 0))`;
        }
        return { transform: v };
      }
    },
    skewX: { transform: (v) => ({ "--skew-x": deg(v) }) },
    skewY: { transform: (v) => ({ "--skew-y": deg(v) }) },
    scaleX: { transform: (v) => ({ "--scale-x": v }) },
    scaleY: { transform: (v) => ({ "--scale-y": v }) },
    scale: {
      transform(value) {
        if (value !== "auto") return { scale: value };
        return {
          scale: `var(--scale-x, 1) var(--scale-y, 1)`
        };
      }
    },
    spaceXReverse: {
      values: { type: "boolean" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            "--space-x-reverse": value ? "1" : void 0
          }
        };
      }
    },
    spaceX: {
      property: "marginInlineStart",
      values: "spacing",
      transform: (v) => ({
        "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
          "--space-x-reverse": "0",
          marginInlineStart: `calc(${v} * calc(1 - var(--space-x-reverse)))`,
          marginInlineEnd: `calc(${v} * var(--space-x-reverse))`
        }
      })
    },
    spaceYReverse: {
      values: { type: "boolean" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            "--space-y-reverse": value ? "1" : void 0
          }
        };
      }
    },
    spaceY: {
      property: "marginTop",
      values: "spacing",
      transform: (v) => ({
        "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
          "--space-y-reverse": "0",
          marginTop: `calc(${v} * calc(1 - var(--space-y-reverse)))`,
          marginBottom: `calc(${v} * var(--space-y-reverse))`
        }
      })
    },
    rotate: {
      transform(value) {
        if (value !== "auto") return { rotate: deg(value) };
        return {
          rotate: `var(--rotate-x, 0) var(--rotate-y, 0) var(--rotate-z, 0)`
        };
      }
    },
    rotateX: {
      transform(value) {
        return { "--rotate-x": deg(value) };
      }
    },
    rotateY: {
      transform(value) {
        return { "--rotate-y": deg(value) };
      }
    },
    // transform / translate
    translate: {
      transform(value) {
        if (value !== "auto") return { translate: value };
        return {
          translate: `var(--translate-x) var(--translate-y)`
        };
      }
    },
    translateX: {
      values: "spacing",
      transform: (v) => ({ "--translate-x": v })
    },
    translateY: {
      values: "spacing",
      transform: (v) => ({ "--translate-y": v })
    },
    // transition
    transition: {
      values: [
        "all",
        "common",
        "colors",
        "opacity",
        "position",
        "backgrounds",
        "size",
        "shadow",
        "transform"
      ],
      transform(value) {
        switch (value) {
          case "all":
            return createTransition("all");
          case "position":
            return createTransition(
              "left, right, top, bottom, inset-inline, inset-block"
            );
          case "colors":
            return createTransition(
              "color, background-color, border-color, text-decoration-color, fill, stroke"
            );
          case "opacity":
            return createTransition("opacity");
          case "shadow":
            return createTransition("box-shadow");
          case "transform":
            return createTransition("transform");
          case "size":
            return createTransition("width, height");
          case "backgrounds":
            return createTransition(
              "background, background-color, background-image, background-position"
            );
          case "common":
            return createTransition(
              "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter"
            );
          default:
            return { transition: value };
        }
      }
    },
    transitionDuration: { values: "durations" },
    transitionProperty: {
      values: {
        common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, translate, transform",
        colors: "background-color, border-color, color, fill, stroke",
        size: "width, height",
        position: "left, right, top, bottom, inset-inline, inset-block",
        background: "background, background-color, background-image, background-position"
      }
    },
    transitionTimingFunction: { values: "easings" },
    // animation
    animation: { values: "animations" },
    animationDuration: { values: "durations" },
    animationDelay: { values: "durations" },
    animationTimingFunction: { values: "easings" },
    // typography
    fontFamily: { values: "fonts" },
    fontSize: { values: "fontSizes" },
    fontWeight: { values: "fontWeights" },
    lineHeight: { values: "lineHeights" },
    letterSpacing: { values: "letterSpacings" },
    textIndent: { values: "spacing" },
    truncate: {
      values: { type: "boolean" },
      transform(value) {
        if (value === true) {
          return {
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
          };
        }
        return {};
      }
    },
    lineClamp: {
      transform(value) {
        if (value === "none") {
          return {
            WebkitLineClamp: "unset"
          };
        }
        return {
          overflow: "hidden",
          display: "-webkit-box",
          WebkitLineClamp: value,
          WebkitBoxOrient: "vertical",
          textWrap: "wrap"
        };
      }
    },
    // helpers
    srOnly: {
      values: { type: "boolean" },
      transform(value) {
        return srMapping[value] || {};
      }
    },
    debug: {
      values: { type: "boolean" },
      transform(value) {
        if (!value) return {};
        return {
          outline: "1px solid blue !important",
          "& > *": {
            outline: "1px solid red !important"
          }
        };
      }
    },
    caretColor: {
      values: colorValues,
      transform: (0,_styled_system_color_mix_js__WEBPACK_IMPORTED_MODULE_0__.createColorMixTransform)("caretColor")
    },
    cursor: { values: "cursor" }
  }
});
const srMapping = {
  true: {
    position: "absolute",
    width: "1px",
    height: "1px",
    padding: "0",
    margin: "-1px",
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    borderWidth: "0"
  },
  false: {
    position: "static",
    width: "auto",
    height: "auto",
    padding: "0",
    margin: "0",
    overflow: "visible",
    clip: "auto",
    whiteSpace: "normal"
  }
};




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/preset.js":
/*!**********************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/preset.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultConfig: () => (/* binding */ defaultConfig),
/* harmony export */   defaultSystem: () => (/* binding */ defaultSystem),
/* harmony export */   system: () => (/* binding */ defaultSystem)
/* harmony export */ });
/* harmony import */ var _preset_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./preset-base.js */ "./node_modules/@chakra-ui/react/dist/esm/preset-base.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _styled_system_system_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./styled-system/system.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/system.js");
/* harmony import */ var _theme_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./theme/index.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/index.js");






const defaultConfig = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.mergeConfigs)(_preset_base_js__WEBPACK_IMPORTED_MODULE_1__.defaultBaseConfig, _theme_index_js__WEBPACK_IMPORTED_MODULE_2__.defaultThemeConfig);
const defaultSystem = (0,_styled_system_system_js__WEBPACK_IMPORTED_MODULE_3__.createSystem)(defaultConfig);




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/breakpoints.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/breakpoints.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createBreakpoints: () => (/* binding */ createBreakpoints)
/* harmony export */ });
/* harmony import */ var _unit_conversion_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./unit-conversion.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/unit-conversion.js");



const capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);
function createBreakpoints(breakpoints) {
  const sorted = sort(breakpoints);
  const values = Object.fromEntries(sorted);
  function get(name) {
    return values[name];
  }
  function only(name) {
    return build(get(name));
  }
  function getRanges() {
    const breakpoints2 = Object.keys(values);
    const permuations = getPermutations(breakpoints2);
    const results = breakpoints2.flatMap((name) => {
      const value = get(name);
      const down2 = [
        `${name}Down`,
        build({ max: adjust(value.min) })
      ];
      const up2 = [name, build({ min: value.min })];
      const _only = [`${name}Only`, only(name)];
      return [up2, _only, down2];
    }).filter(([, value]) => value !== "").concat(
      permuations.map(([min, max]) => {
        const minValue = get(min);
        const maxValue = get(max);
        return [
          `${min}To${capitalize(max)}`,
          build({ min: minValue.min, max: adjust(maxValue.min) })
        ];
      })
    );
    return Object.fromEntries(results);
  }
  function toConditions() {
    const ranges = getRanges();
    return Object.fromEntries(Object.entries(ranges));
  }
  const conditions = toConditions();
  const getCondition = (key) => {
    return conditions[key];
  };
  function keys() {
    return ["base", ...Object.keys(values)];
  }
  function up(name) {
    return build({ min: get(name).min });
  }
  function down(name) {
    return build({ max: adjust(get(name).min) });
  }
  return {
    values: Object.values(values),
    only,
    keys,
    conditions,
    getCondition,
    up,
    down
  };
}
function adjust(value) {
  const computedMax = parseFloat((0,_unit_conversion_js__WEBPACK_IMPORTED_MODULE_0__.toPx)(value) ?? "") - 0.04;
  return (0,_unit_conversion_js__WEBPACK_IMPORTED_MODULE_0__.toRem)(`${computedMax}px`);
}
function sort(breakpoints) {
  const entries = Object.entries(breakpoints).sort(([, minA], [, minB]) => {
    return parseInt(minA, 10) < parseInt(minB, 10) ? -1 : 1;
  });
  return entries.map(([name, min], index, entries2) => {
    let max = null;
    if (index <= entries2.length - 1) {
      max = entries2[index + 1]?.[1];
    }
    if (max != null) {
      max = adjust(max);
    }
    return [name, { name, min: (0,_unit_conversion_js__WEBPACK_IMPORTED_MODULE_0__.toRem)(min), max }];
  });
}
function getPermutations(values) {
  const result = [];
  values.forEach((current, index) => {
    let idx = index;
    idx++;
    let next = values[idx];
    while (next) {
      result.push([current, next]);
      idx++;
      next = values[idx];
    }
  });
  return result;
}
function build({ min, max }) {
  if (min == null && max == null) return "";
  return [
    "@media screen",
    min && `(min-width: ${min})`,
    max && `(max-width: ${max})`
  ].filter(Boolean).join(" and ");
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/calc.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/calc.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calc: () => (/* binding */ calc)
/* harmony export */ });
/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/is.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/is.js");



function resolveReference(operand) {
  if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(operand) && operand.reference) {
    return operand.reference;
  }
  return String(operand);
}
const toExpression = (operator, ...operands) => operands.map(resolveReference).join(` ${operator} `).replace(/calc/g, "");
const add = (...operands) => `calc(${toExpression("+", ...operands)})`;
const subtract = (...operands) => `calc(${toExpression("-", ...operands)})`;
const multiply = (...operands) => `calc(${toExpression("*", ...operands)})`;
const divide = (...operands) => `calc(${toExpression("/", ...operands)})`;
const negate = (x) => {
  const value = resolveReference(x);
  if (value != null && !Number.isNaN(parseFloat(value))) {
    return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
  }
  return multiply(value, -1);
};
const calc = Object.assign(
  (x) => ({
    add: (...operands) => calc(add(x, ...operands)),
    subtract: (...operands) => calc(subtract(x, ...operands)),
    multiply: (...operands) => calc(multiply(x, ...operands)),
    divide: (...operands) => calc(divide(x, ...operands)),
    negate: () => calc(negate(x)),
    toString: () => x.toString()
  }),
  {
    add,
    subtract,
    multiply,
    divide,
    negate
  }
);




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/color-mix.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/color-mix.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   colorMix: () => (/* binding */ colorMix),
/* harmony export */   createColorMixTransform: () => (/* binding */ createColorMixTransform)
/* harmony export */ });

const colorMix = (value, token) => {
  if (!value || typeof value !== "string") {
    return { invalid: true, value };
  }
  const [rawColor, rawOpacity] = value.split("/");
  if (!rawColor || !rawOpacity || rawColor === "currentBg") {
    return { invalid: true, value: rawColor };
  }
  const colorToken = token(`colors.${rawColor}`);
  const opacityToken = token.raw(`opacity.${rawOpacity}`)?.value;
  if (!opacityToken && isNaN(Number(rawOpacity))) {
    return { invalid: true, value: rawColor };
  }
  const percent = opacityToken ? Number(opacityToken) * 100 + "%" : `${rawOpacity}%`;
  const color = colorToken ?? rawColor;
  return {
    invalid: false,
    color,
    value: `color-mix(in srgb, ${color} ${percent}, transparent)`
  };
};
const createColorMixTransform = (prop) => (value, args) => {
  const mix = args.utils.colorMix(value);
  if (mix.invalid) return { [prop]: value };
  const cssVar = "--mix-" + prop;
  return {
    [cssVar]: mix.value,
    [prop]: `var(${cssVar}, ${mix.color})`
  };
};




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/conditions.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/conditions.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createConditions: () => (/* binding */ createConditions)
/* harmony export */ });

const mapEntries = (obj, fn) => {
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => fn(key, value))
  );
};
const createConditions = (options) => {
  const { breakpoints, conditions: conds = {} } = options;
  const conditions = mapEntries(conds, (key, value) => [`_${key}`, value]);
  const values = Object.assign({}, conditions, breakpoints.conditions);
  function keys() {
    return Object.keys(values);
  }
  function has(key) {
    return keys().includes(key) || /^@|&|&$/.test(key) || key.startsWith("_");
  }
  function sort(paths) {
    return paths.filter((v) => v !== "base").sort((a, b) => {
      const aa = has(a);
      const bb = has(b);
      if (aa && !bb) return 1;
      if (!aa && bb) return -1;
      return 0;
    });
  }
  function expandAtRule(key) {
    if (!key.startsWith("@breakpoint")) return key;
    return breakpoints.getCondition(key.replace("@breakpoint ", ""));
  }
  function resolve(key) {
    return Reflect.get(values, key) || key;
  }
  return {
    keys,
    sort,
    has,
    resolve,
    breakpoints: breakpoints.keys(),
    expandAtRule
  };
};




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js":
/*!************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defineAnimationStyles: () => (/* binding */ defineAnimationStyles),
/* harmony export */   defineConditions: () => (/* binding */ defineConditions),
/* harmony export */   defineConfig: () => (/* binding */ defineConfig),
/* harmony export */   defineGlobalStyles: () => (/* binding */ defineGlobalStyles),
/* harmony export */   defineKeyframes: () => (/* binding */ defineKeyframes),
/* harmony export */   defineLayerStyles: () => (/* binding */ defineLayerStyles),
/* harmony export */   defineRecipe: () => (/* binding */ defineRecipe),
/* harmony export */   defineSemanticTokens: () => (/* binding */ defineSemanticTokens),
/* harmony export */   defineSlotRecipe: () => (/* binding */ defineSlotRecipe),
/* harmony export */   defineStyle: () => (/* binding */ defineStyle),
/* harmony export */   defineTextStyles: () => (/* binding */ defineTextStyles),
/* harmony export */   defineTokens: () => (/* binding */ defineTokens),
/* harmony export */   mergeConfigs: () => (/* binding */ mergeConfigs)
/* harmony export */ });
/* harmony import */ var _utils_clone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/clone.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/clone.js");
/* harmony import */ var _utils_merge_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/merge.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/merge.js");




const defineConditions = (v) => v;
const defineRecipe = (v) => v;
const defineSlotRecipe = (v) => v;
const defineKeyframes = (v) => v;
const defineGlobalStyles = (v) => v;
const defineStyle = (v) => v;
const defineTextStyles = (v) => v;
const defineAnimationStyles = (v) => v;
const defineLayerStyles = (v) => v;
function createProxy() {
  const identity = (v) => v;
  return new Proxy(identity, {
    get() {
      return identity;
    }
  });
}
const defineTokens = /* @__PURE__ */ createProxy();
const defineSemanticTokens = /* @__PURE__ */ createProxy();
const defineConfig = (v) => v;
const mergeConfigs = (...configs) => {
  return (0,_utils_merge_js__WEBPACK_IMPORTED_MODULE_0__.mergeWith)({}, ...configs.map(_utils_clone_js__WEBPACK_IMPORTED_MODULE_1__.clone));
};




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/create-recipe-context.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/create-recipe-context.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createRecipeContext: () => (/* binding */ createRecipeContext)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _create_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../create-context.js */ "./node_modules/@chakra-ui/react/dist/esm/create-context.js");
/* harmony import */ var _merge_props_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../merge-props.js */ "./node_modules/@chakra-ui/react/dist/esm/merge-props.js");
/* harmony import */ var _utils_cx_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/cx.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/cx.js");
/* harmony import */ var _empty_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./empty.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/empty.js");
/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./factory.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js");
/* harmony import */ var _use_recipe_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./use-recipe.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/use-recipe.js");

"use client";









const upperFirst = (str) => str.charAt(0).toUpperCase() + str.slice(1);
function createRecipeContext(options) {
  const { key: recipeKey, recipe: recipeConfig } = options;
  const contextName = upperFirst(
    recipeKey || recipeConfig.className || "Component"
  );
  const [PropsProvider, usePropsContext] = (0,_create_context_js__WEBPACK_IMPORTED_MODULE_2__.createContext)({
    strict: false,
    name: `${contextName}PropsContext`,
    providerName: `${contextName}PropsContext`
  });
  function useRecipeResult(props) {
    const { unstyled, ...restProps } = props;
    const recipe = (0,_use_recipe_js__WEBPACK_IMPORTED_MODULE_3__.useRecipe)({
      key: recipeKey,
      recipe: restProps.recipe || recipeConfig
    });
    const [variantProps, otherProps] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(
      () => recipe.splitVariantProps(restProps),
      [recipe, restProps]
    );
    const styles = unstyled ? _empty_js__WEBPACK_IMPORTED_MODULE_4__.EMPTY_STYLES : recipe(variantProps);
    return {
      styles,
      className: recipe.className,
      props: otherProps
    };
  }
  const withContext = (Component, options2) => {
    const SuperComponent = (0,_factory_js__WEBPACK_IMPORTED_MODULE_5__.chakra)(Component, {}, options2);
    const StyledComponent = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((inProps, ref) => {
      const propsContext = usePropsContext();
      const props = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(
        () => (0,_merge_props_js__WEBPACK_IMPORTED_MODULE_6__.mergeProps)(propsContext, inProps),
        [inProps, propsContext]
      );
      const { styles, className, props: localProps } = useRecipeResult(props);
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        SuperComponent,
        {
          ...localProps,
          ref,
          css: [styles, props.css],
          className: (0,_utils_cx_js__WEBPACK_IMPORTED_MODULE_7__.cx)(className, props.className)
        }
      );
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  function withPropsProvider() {
    return PropsProvider;
  }
  return {
    withContext,
    PropsProvider,
    withPropsProvider,
    usePropsContext,
    useRecipeResult
  };
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/create-slot-recipe-context.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/create-slot-recipe-context.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSlotRecipeContext: () => (/* binding */ createSlotRecipeContext)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _create_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../create-context.js */ "./node_modules/@chakra-ui/react/dist/esm/create-context.js");
/* harmony import */ var _merge_props_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../merge-props.js */ "./node_modules/@chakra-ui/react/dist/esm/merge-props.js");
/* harmony import */ var _utils_cx_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/cx.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/cx.js");
/* harmony import */ var _empty_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./empty.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/empty.js");
/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./factory.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js");
/* harmony import */ var _use_slot_recipe_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./use-slot-recipe.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/use-slot-recipe.js");

"use client";









const upperFirst = (str) => str.charAt(0).toUpperCase() + str.slice(1);
const createSlotRecipeContext = (options) => {
  const { key: recipeKey, recipe: recipeConfig } = options;
  const contextName = upperFirst(
    recipeKey || recipeConfig.className || "Component"
  );
  const [StylesProvider, useStyles] = (0,_create_context_js__WEBPACK_IMPORTED_MODULE_2__.createContext)({
    name: `${contextName}StylesContext`,
    errorMessage: `use${contextName}Styles returned is 'undefined'. Seems you forgot to wrap the components in "<${contextName}.Root />" `
  });
  const [ClassNamesProvider, useClassNames] = (0,_create_context_js__WEBPACK_IMPORTED_MODULE_2__.createContext)({
    name: `${contextName}ClassNameContext`,
    errorMessage: `use${contextName}ClassNames returned is 'undefined'. Seems you forgot to wrap the components in "<${contextName}.Root />" `,
    strict: false
  });
  const [PropsProvider, usePropsContext] = (0,_create_context_js__WEBPACK_IMPORTED_MODULE_2__.createContext)({
    strict: false,
    name: `${contextName}PropsContext`,
    providerName: `${contextName}PropsContext`,
    defaultValue: {}
  });
  function useRecipeResult(props) {
    const { unstyled, ...restProps } = props;
    const slotRecipe = (0,_use_slot_recipe_js__WEBPACK_IMPORTED_MODULE_3__.useSlotRecipe)({
      key: recipeKey,
      recipe: restProps.recipe || recipeConfig
    });
    const [variantProps, otherProps] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(
      () => slotRecipe.splitVariantProps(restProps),
      [restProps, slotRecipe]
    );
    const styles = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(
      () => unstyled ? _empty_js__WEBPACK_IMPORTED_MODULE_4__.EMPTY_SLOT_STYLES : slotRecipe(variantProps),
      [unstyled, variantProps, slotRecipe]
    );
    return {
      styles,
      classNames: slotRecipe.classNameMap,
      props: otherProps
    };
  }
  function withRootProvider(Component, options2 = {}) {
    const { defaultProps } = options2;
    const StyledComponent = (inProps) => {
      const propsContext = usePropsContext();
      const props = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(
        () => (0,_merge_props_js__WEBPACK_IMPORTED_MODULE_5__.mergeProps)(defaultProps, propsContext, inProps),
        [propsContext, inProps]
      );
      const { styles, classNames, props: rootProps } = useRecipeResult(props);
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StylesProvider, { value: styles, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ClassNamesProvider, { value: classNames, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Component, { ...rootProps }) }) });
    };
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  }
  const withProvider = (Component, slot, options2) => {
    const { defaultProps, ...restOptions } = options2 ?? {};
    const SuperComponent = (0,_factory_js__WEBPACK_IMPORTED_MODULE_6__.chakra)(Component, {}, restOptions);
    const StyledComponent = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((inProps, ref) => {
      const propsContext = usePropsContext();
      const props = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(
        () => (0,_merge_props_js__WEBPACK_IMPORTED_MODULE_5__.mergeProps)(defaultProps ?? {}, propsContext, inProps),
        [propsContext, inProps]
      );
      const { styles, props: rootProps, classNames } = useRecipeResult(props);
      const className = classNames[slot];
      const element = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StylesProvider, { value: styles, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ClassNamesProvider, { value: classNames, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        SuperComponent,
        {
          ref,
          ...rootProps,
          css: [styles[slot], props.css],
          className: (0,_utils_cx_js__WEBPACK_IMPORTED_MODULE_7__.cx)(props.className, className)
        }
      ) }) });
      return options2?.wrapElement?.(element, props) ?? element;
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  const withContext = (Component, slot, options2) => {
    const SuperComponent = (0,_factory_js__WEBPACK_IMPORTED_MODULE_6__.chakra)(Component, {}, options2);
    const StyledComponent = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref) => {
      const styles = useStyles();
      const classNames = useClassNames();
      const className = classNames?.[slot];
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        SuperComponent,
        {
          ...props,
          css: [slot ? styles[slot] : void 0, props.css],
          ref,
          className: (0,_utils_cx_js__WEBPACK_IMPORTED_MODULE_7__.cx)(props.className, className)
        }
      );
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  return {
    StylesProvider,
    ClassNamesProvider,
    PropsProvider,
    usePropsContext,
    useRecipeResult,
    withProvider,
    withContext,
    withRootProvider,
    useStyles,
    useClassNames
  };
};




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/css-var.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/css-var.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cssVar: () => (/* binding */ cssVar)
/* harmony export */ });

const escRegex = /[^a-zA-Z0-9_\u0081-\uffff-]/g;
function esc(string) {
  return `${string}`.replace(escRegex, (s) => `\\${s}`);
}
const dashCaseRegex = /[A-Z]/g;
function dashCase(string) {
  return string.replace(dashCaseRegex, (match) => `-${match.toLowerCase()}`);
}
function cssVar(name, options = {}) {
  const { fallback = "", prefix = "" } = options;
  const variable = dashCase(["-", prefix, esc(name)].filter(Boolean).join("-"));
  return {
    var: variable,
    ref: `var(${variable}${fallback ? `, ${fallback}` : ""})`
  };
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/css.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/css.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createCssFn: () => (/* binding */ createCssFn)
/* harmony export */ });
/* harmony import */ var _utils_compact_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/compact.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/compact.js");
/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/is.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/is.js");
/* harmony import */ var _utils_memo_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/memo.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/memo.js");
/* harmony import */ var _utils_merge_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/merge.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/merge.js");
/* harmony import */ var _utils_walk_object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/walk-object.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/walk-object.js");
/* harmony import */ var _sort_at_rules_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sort-at-rules.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/sort-at-rules.js");








const importantRegex = /\s*!(important)?/i;
const isImportant = (v) => (0,_utils_is_js__WEBPACK_IMPORTED_MODULE_0__.isString)(v) ? importantRegex.test(v) : false;
const withoutImportant = (v) => (0,_utils_is_js__WEBPACK_IMPORTED_MODULE_0__.isString)(v) ? v.replace(importantRegex, "").trim() : v;
function createCssFn(context) {
  const { transform, conditions, normalize } = context;
  const mergeFn = mergeCss(context);
  return (0,_utils_memo_js__WEBPACK_IMPORTED_MODULE_1__.memo)(function cssFn(...styleArgs) {
    const styles = mergeFn(...styleArgs);
    const normalized = normalize(styles);
    const result = /* @__PURE__ */ Object.create(null);
    (0,_utils_walk_object_js__WEBPACK_IMPORTED_MODULE_2__.walkObject)(normalized, (value, paths) => {
      const important = isImportant(value);
      if (value == null) return;
      const [prop, ...selectors] = conditions.sort(paths).map(conditions.resolve);
      if (important) {
        value = withoutImportant(value);
      }
      let transformed = transform(prop, value) ?? /* @__PURE__ */ Object.create(null);
      transformed = (0,_utils_walk_object_js__WEBPACK_IMPORTED_MODULE_2__.walkObject)(
        transformed,
        (v) => (0,_utils_is_js__WEBPACK_IMPORTED_MODULE_0__.isString)(v) && important ? `${v} !important` : v,
        { getKey: (prop2) => conditions.expandAtRule(prop2) }
      );
      mergeByPath(result, selectors.flat(), transformed);
    });
    return (0,_sort_at_rules_js__WEBPACK_IMPORTED_MODULE_3__.sortAtRules)(result);
  });
}
function mergeByPath(target, paths, value) {
  let acc = target;
  for (const path of paths) {
    if (!path) continue;
    if (!acc[path]) acc[path] = /* @__PURE__ */ Object.create(null);
    acc = acc[path];
  }
  (0,_utils_merge_js__WEBPACK_IMPORTED_MODULE_4__.mergeWith)(acc, value);
}
function compactFn(...styles) {
  return styles.filter(
    (style) => (0,_utils_is_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(style) && Object.keys((0,_utils_compact_js__WEBPACK_IMPORTED_MODULE_5__.compact)(style)).length > 0
  );
}
function mergeCss(ctx) {
  function resolve(styles) {
    const comp = compactFn(...styles);
    if (comp.length === 1) return comp;
    return comp.map((style) => ctx.normalize(style));
  }
  return (0,_utils_memo_js__WEBPACK_IMPORTED_MODULE_1__.memo)(function mergeFn(...styles) {
    return (0,_utils_merge_js__WEBPACK_IMPORTED_MODULE_4__.mergeWith)({}, ...resolve(styles));
  });
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/cva.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/cva.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createRecipeFn: () => (/* binding */ createRecipeFn)
/* harmony export */ });
/* harmony import */ var _utils_compact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/compact.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/compact.js");
/* harmony import */ var _utils_cx_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/cx.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/cx.js");
/* harmony import */ var _utils_merge_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/merge.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/merge.js");
/* harmony import */ var _utils_omit_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/omit.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/omit.js");
/* harmony import */ var _utils_split_props_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/split-props.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/split-props.js");
/* harmony import */ var _utils_uniq_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/uniq.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/uniq.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/css.js");









const defaults = (conf) => ({
  base: {},
  variants: {},
  defaultVariants: {},
  compoundVariants: [],
  ...conf
});
function createRecipeFn(options) {
  const { css, conditions, normalize, layers } = options;
  function cva(config = {}) {
    const { base, variants, defaultVariants, compoundVariants } = defaults(config);
    const getVariantCss = (0,_css_js__WEBPACK_IMPORTED_MODULE_0__.createCssFn)({
      conditions,
      normalize,
      transform(prop, value) {
        return variants[prop]?.[value];
      }
    });
    const resolve = (props = {}) => {
      const variantSelections = normalize({
        ...defaultVariants,
        ...(0,_utils_compact_js__WEBPACK_IMPORTED_MODULE_1__.compact)(props)
      });
      let variantCss = { ...base };
      (0,_utils_merge_js__WEBPACK_IMPORTED_MODULE_2__.mergeWith)(variantCss, getVariantCss(variantSelections));
      const compoundVariantCss = getCompoundVariantCss(
        compoundVariants,
        variantSelections
      );
      return layers.wrap("recipes", css(variantCss, compoundVariantCss));
    };
    const variantKeys = Object.keys(variants);
    const splitVariantProps = (props) => {
      const restProps = (0,_utils_omit_js__WEBPACK_IMPORTED_MODULE_3__.omit)(props, ["recipe"]);
      const [recipeProps, localProps] = (0,_utils_split_props_js__WEBPACK_IMPORTED_MODULE_4__.splitProps)(restProps, variantKeys);
      if (!variantKeys.includes("colorPalette")) {
        recipeProps.colorPalette = props.colorPalette || defaultVariants.colorPalette;
      }
      if (variantKeys.includes("orientation")) {
        localProps.orientation = props.orientation;
      }
      return [recipeProps, localProps];
    };
    const variantMap = Object.fromEntries(
      Object.entries(variants).map(([key, value]) => [
        key,
        Object.keys(value)
      ])
    );
    const cvaFn = (props) => css(resolve(props));
    return Object.assign(cvaFn, {
      className: config.className,
      __cva__: true,
      variantMap,
      variantKeys,
      raw: resolve,
      config,
      splitVariantProps,
      merge(other) {
        return cva(mergeCva(options)(this, other));
      }
    });
  }
  function getCompoundVariantCss(cvs, vm) {
    let result = {};
    cvs.forEach((cv) => {
      const isMatching = Object.entries(cv).every(([key, value]) => {
        if (key === "css") return true;
        const values = Array.isArray(value) ? value : [value];
        return values.some((value2) => vm[key] === value2);
      });
      if (isMatching) {
        result = css(result, cv.css);
      }
    });
    return result;
  }
  return cva;
}
function mergeCva(opts) {
  const { css } = opts;
  return function mergeCva2(cvaA, cvaB) {
    const override = defaults(cvaB.config);
    const variantKeys = (0,_utils_uniq_js__WEBPACK_IMPORTED_MODULE_5__.uniq)(cvaA.variantKeys, Object.keys(cvaB.variants));
    const base = css(cvaA.base, override.base);
    const variants = Object.fromEntries(
      variantKeys.map((key) => [
        key,
        css(cvaA.config.variants[key], override.variants[key])
      ])
    );
    const defaultVariants = (0,_utils_merge_js__WEBPACK_IMPORTED_MODULE_2__.mergeWith)(
      cvaA.config.defaultVariants,
      override.defaultVariants
    );
    const compoundVariants = [
      ...cvaA.compoundVariants,
      ...override.compoundVariants
    ];
    const className = (0,_utils_cx_js__WEBPACK_IMPORTED_MODULE_6__.cx)(cvaA.className, cvaB.className);
    return {
      className,
      base,
      variants,
      defaultVariants,
      compoundVariants
    };
  };
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/empty.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/empty.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EMPTY_SLOT_STYLES: () => (/* binding */ EMPTY_SLOT_STYLES),
/* harmony export */   EMPTY_STYLES: () => (/* binding */ EMPTY_STYLES)
/* harmony export */ });

const EMPTY_STYLES = Object.freeze({});
const EMPTY_SLOT_STYLES = Object.freeze(
  {}
);




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/esc.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/esc.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   esc: () => (/* binding */ esc)
/* harmony export */ });

const rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|^-|[^\x80-\uFFFF\w-]/g;
const fcssescape = function(ch, asCodePoint) {
  if (!asCodePoint) return "\\" + ch;
  if (ch === "\0") return "\uFFFD";
  if (ch === "-" && ch.length === 1) return "\\-";
  return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16);
};
const esc = (sel) => {
  return (sel + "").replace(rcssescape, fcssescape);
};




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/expand-reference.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/expand-reference.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   expandTokenReferences: () => (/* binding */ expandTokenReferences)
/* harmony export */ });
/* harmony import */ var _esc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./esc.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/esc.js");



const expandTokenReferences = (str, resolve) => {
  let expanded = "";
  let index = 0;
  let state = "char";
  let tokenPath = "";
  let fallback = "";
  const currentStates = [];
  while (index < str.length) {
    const char = str[index];
    if (char === "{") {
      const endIndex = str.indexOf("}", index);
      if (endIndex === -1) {
        break;
      }
      const path = str.slice(index + 1, endIndex);
      const resolved = resolve(path);
      expanded += resolved ?? path;
      index = endIndex + 1;
      continue;
    }
    if (state === "token") {
      if (char === ",") {
        if (str[index] === "") {
          index++;
        }
        state = "fallback";
        currentStates.push(state);
        const resolved = resolve(tokenPath);
        if (resolved?.endsWith(")")) {
          expanded += resolved.slice(0, -1);
        }
        tokenPath = "";
        fallback = "";
        continue;
      }
    }
    if (state === "fallback") {
      const nextFallback = fallback + char;
      if (nextFallback === ", var(") {
        const innerEndIndex = cssVarParser(str.slice(index + 1));
        const endIndex = innerEndIndex + index + 1;
        const cssVar = str.slice(index + 1, endIndex);
        if (endIndex === -1) {
          break;
        }
        expanded += ", var(" + cssVar + ")";
        index = endIndex + 1;
        state = currentStates.pop() ?? state;
        fallback = "";
        continue;
      }
    }
    if (state === "token" || state === "fallback") {
      index++;
      if (char === ")") {
        state = currentStates.pop() ?? state ?? "char";
        fallback += char;
        const resolved = tokenPath ? resolve(tokenPath) ?? (0,_esc_js__WEBPACK_IMPORTED_MODULE_0__.esc)(tokenPath) : tokenPath;
        if (fallback) {
          fallback = fallback.slice(1).trim();
          if (!fallback.startsWith("token(") && fallback.endsWith(")")) {
            fallback = fallback.slice(0, -1);
          }
          if (fallback.includes("token(")) {
            const parsed = expandTokenReferences(fallback, resolve);
            if (parsed) {
              fallback = parsed.slice(0, -1);
            }
          } else if (fallback) {
            const resolvedFallback = resolve(fallback);
            if (resolvedFallback) {
              fallback = resolvedFallback;
            }
          }
        }
        const lastChar = expanded.at(-1);
        if (fallback) {
          if (lastChar?.trim()) {
            expanded += resolved.slice(0, -1) + (", " + fallback + ")");
          } else {
            expanded += fallback;
          }
        } else {
          expanded += resolved || ")";
        }
        tokenPath = "";
        fallback = "";
        state = "char";
        continue;
      }
      if (state === "token") {
        tokenPath += char;
      }
      if (state === "fallback") {
        fallback += char;
      }
      continue;
    }
    const tokenIndex = str.indexOf("token(", index);
    if (tokenIndex !== -1) {
      const innerTokenIndex = tokenIndex + "token(".length;
      expanded += str.slice(index, tokenIndex);
      index = innerTokenIndex;
      state = "token";
      currentStates.push(state);
      continue;
    }
    expanded += char;
    index++;
  }
  return expanded;
};
const cssVarParser = (str) => {
  let index = 0;
  const openedParenthesises = ["("];
  while (index < str.length) {
    const char = str[index];
    if (char === "(") {
      openedParenthesises.push(char);
    } else if (char === ")") {
      openedParenthesises.pop();
      if (openedParenthesises.length === 0) {
        return index;
      }
    }
    index++;
  }
  return index;
};




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   chakra: () => (/* binding */ chakra)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _emotion_is_prop_valid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @emotion/is-prop-valid */ "./node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js");
/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @emotion/react */ "./node_modules/@emotion/react/dist/emotion-element-489459f2.browser.development.esm.js");
/* harmony import */ var _emotion_serialize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @emotion/serialize */ "./node_modules/@emotion/serialize/dist/emotion-serialize.development.esm.js");
/* harmony import */ var _emotion_use_insertion_effect_with_fallbacks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @emotion/use-insertion-effect-with-fallbacks */ "./node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js");
/* harmony import */ var _emotion_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @emotion/utils */ "./node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _merge_props_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../merge-props.js */ "./node_modules/@chakra-ui/react/dist/esm/merge-props.js");
/* harmony import */ var _merge_refs_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../merge-refs.js */ "./node_modules/@chakra-ui/react/dist/esm/merge-refs.js");
/* harmony import */ var _utils_compact_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/compact.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/compact.js");
/* harmony import */ var _utils_cx_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/cx.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/cx.js");
/* harmony import */ var _utils_interop_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/interop.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/interop.js");
/* harmony import */ var _utils_ref_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../utils/ref.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/ref.js");
/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./provider.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/provider.js");
/* harmony import */ var _use_resolved_props_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./use-resolved-props.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/use-resolved-props.js");

"use client";
















const isPropValid = (0,_utils_interop_js__WEBPACK_IMPORTED_MODULE_6__.interopDefault)(_emotion_is_prop_valid__WEBPACK_IMPORTED_MODULE_1__["default"]);
const testOmitPropsOnStringTag = isPropValid;
const testOmitPropsOnComponent = (key) => key !== "theme";
const composeShouldForwardProps = (tag, options, isReal) => {
  let shouldForwardProp;
  if (options) {
    const optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? (propName) => tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName) : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp !== "function" && isReal) {
    shouldForwardProp = tag.__emotion_forwardProp;
  }
  return shouldForwardProp;
};
let isBrowser = typeof document !== "undefined";
const Insertion = ({ cache: cache2, serialized, isStringTag }) => {
  (0,_emotion_utils__WEBPACK_IMPORTED_MODULE_4__.registerStyles)(cache2, serialized, isStringTag);
  const rules = (0,_emotion_use_insertion_effect_with_fallbacks__WEBPACK_IMPORTED_MODULE_3__.useInsertionEffectAlwaysWithSyncFallback)(
    () => (0,_emotion_utils__WEBPACK_IMPORTED_MODULE_4__.insertStyles)(cache2, serialized, isStringTag)
  );
  if (!isBrowser && rules !== void 0) {
    let serializedNames = serialized.name;
    let next = serialized.next;
    while (next !== void 0) {
      serializedNames = (0,_utils_cx_js__WEBPACK_IMPORTED_MODULE_7__.cx)(serializedNames, next.name);
      next = next.next;
    }
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      "style",
      {
        ...{
          [`data-emotion`]: (0,_utils_cx_js__WEBPACK_IMPORTED_MODULE_7__.cx)(cache2.key, serializedNames),
          dangerouslySetInnerHTML: { __html: rules },
          nonce: cache2.sheet.nonce
        }
      }
    );
  }
  return null;
};
const createStyled = (tag, configOrCva = {}, options = {}) => {
  if (true) {
    if (tag === void 0) {
      throw new Error(
        "You are trying to create a styled element with an undefined component.\nYou may have forgotten to import it."
      );
    }
  }
  const isReal = tag.__emotion_real === tag;
  const baseTag = isReal && tag.__emotion_base || tag;
  let identifierName;
  let targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  let styles = [];
  const Styled = (0,_emotion_react__WEBPACK_IMPORTED_MODULE_8__.w)((inProps, cache2, ref) => {
    const { cva, isValidProperty } = (0,_provider_js__WEBPACK_IMPORTED_MODULE_9__.useChakraContext)();
    const cvaFn = configOrCva.__cva__ ? configOrCva : cva(configOrCva);
    const cvaRecipe = mergeCva(tag.__emotion_cva, cvaFn);
    const createShouldForwardProps = (props2) => {
      return (prop, variantKeys) => {
        if (props2.includes(prop)) return true;
        return !variantKeys?.includes(prop) && !isValidProperty(prop);
      };
    };
    if (!options.shouldForwardProp && options.forwardProps) {
      options.shouldForwardProp = createShouldForwardProps(options.forwardProps);
    }
    const fallbackShouldForwardProp = (prop, variantKeys) => {
      const emotionSfp = typeof tag === "string" && tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
      const chakraSfp = !variantKeys?.includes(prop) && !isValidProperty(prop);
      return emotionSfp(prop) && chakraSfp;
    };
    const shouldForwardProp = composeShouldForwardProps(tag, options, isReal) || fallbackShouldForwardProp;
    const propsWithDefault = react__WEBPACK_IMPORTED_MODULE_5__.useMemo(
      () => Object.assign({}, options.defaultProps, (0,_utils_compact_js__WEBPACK_IMPORTED_MODULE_10__.compact)(inProps)),
      [inProps]
    );
    const { props, styles: styleProps } = (0,_use_resolved_props_js__WEBPACK_IMPORTED_MODULE_11__.useResolvedProps)(
      propsWithDefault,
      cvaRecipe,
      shouldForwardProp
    );
    let className = "";
    let classInterpolations = [styleProps];
    let mergedProps = props;
    if (props.theme == null) {
      mergedProps = {};
      for (let key in props) {
        mergedProps[key] = props[key];
      }
      mergedProps.theme = react__WEBPACK_IMPORTED_MODULE_5__.useContext(_emotion_react__WEBPACK_IMPORTED_MODULE_8__.T);
    }
    if (typeof props.className === "string") {
      className = (0,_emotion_utils__WEBPACK_IMPORTED_MODULE_4__.getRegisteredStyles)(
        cache2.registered,
        classInterpolations,
        props.className
      );
    } else if (props.className != null) {
      className = (0,_utils_cx_js__WEBPACK_IMPORTED_MODULE_7__.cx)(className, props.className);
    }
    const serialized = (0,_emotion_serialize__WEBPACK_IMPORTED_MODULE_2__.serializeStyles)(
      styles.concat(classInterpolations),
      cache2.registered,
      mergedProps
    );
    className = (0,_utils_cx_js__WEBPACK_IMPORTED_MODULE_7__.cx)(className, `${cache2.key}-${serialized.name}`);
    if (targetClassName !== void 0) {
      className = (0,_utils_cx_js__WEBPACK_IMPORTED_MODULE_7__.cx)(className, targetClassName);
    }
    const shouldUseAs = !shouldForwardProp("as");
    let FinalTag = shouldUseAs && props.as || baseTag;
    let finalProps = {};
    for (let prop in props) {
      if (shouldUseAs && prop === "as") continue;
      if ((0,_use_resolved_props_js__WEBPACK_IMPORTED_MODULE_11__.isHtmlProp)(prop)) {
        const nativeProp = prop.replace("html", "").toLowerCase();
        finalProps[nativeProp] = props[prop];
        continue;
      }
      if (shouldForwardProp(prop)) {
        finalProps[prop] = props[prop];
      }
    }
    finalProps.className = className.trim();
    finalProps.ref = ref;
    const forwardAsChild = options.forwardAsChild || options.forwardProps?.includes("asChild");
    if (props.asChild && !forwardAsChild) {
      const child = react__WEBPACK_IMPORTED_MODULE_5__.Children.only(props.children);
      FinalTag = child.type;
      finalProps.children = null;
      Reflect.deleteProperty(finalProps, "asChild");
      finalProps = (0,_merge_props_js__WEBPACK_IMPORTED_MODULE_12__.mergeProps)(finalProps, child.props);
      finalProps.ref = (0,_merge_refs_js__WEBPACK_IMPORTED_MODULE_13__.mergeRefs)(ref, (0,_utils_ref_js__WEBPACK_IMPORTED_MODULE_14__.getElementRef)(child));
    }
    if (finalProps.as && forwardAsChild) {
      finalProps.as = void 0;
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_5__.Fragment, { children: [
        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
          Insertion,
          {
            cache: cache2,
            serialized,
            isStringTag: typeof FinalTag === "string"
          }
        ),
        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FinalTag, { asChild: true, ...finalProps, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(props.as, { children: finalProps.children }) })
      ] });
    }
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_5__.Fragment, { children: [
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        Insertion,
        {
          cache: cache2,
          serialized,
          isStringTag: typeof FinalTag === "string"
        }
      ),
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FinalTag, { ...finalProps })
    ] });
  });
  Styled.displayName = identifierName !== void 0 ? identifierName : `chakra(${typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component"})`;
  Styled.__emotion_real = Styled;
  Styled.__emotion_base = baseTag;
  Styled.__emotion_forwardProp = options.shouldForwardProp;
  Styled.__emotion_cva = configOrCva;
  Object.defineProperty(Styled, "toString", {
    value() {
      if (targetClassName === void 0 && "development" !== "production") {
        return "NO_COMPONENT_SELECTOR";
      }
      return `.${targetClassName}`;
    }
  });
  return Styled;
};
const styledFn = createStyled.bind();
const cache = /* @__PURE__ */ new Map();
const chakraImpl = new Proxy(styledFn, {
  apply(_, __, args) {
    return styledFn(...args);
  },
  get(_, el) {
    if (!cache.has(el)) {
      cache.set(el, styledFn(el));
    }
    return cache.get(el);
  }
});
const chakra = chakraImpl;
const mergeCva = (cvaA, cvaB) => {
  if (cvaA && !cvaB) return cvaA;
  if (!cvaA && cvaB) return cvaB;
  return cvaA.merge(cvaB);
};




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/layers.js":
/*!************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/layers.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createLayers: () => (/* binding */ createLayers)
/* harmony export */ });

const defaultLayers = {
  reset: "reset",
  base: "base",
  tokens: "tokens",
  recipes: "recipes"
};
const layerOrder = {
  reset: 0,
  base: 1,
  tokens: 2,
  recipes: 3
};
function createLayers(config) {
  const layers = config.layers ?? defaultLayers;
  const values = Object.values(layers);
  const names = values.sort((a, b) => layerOrder[a] - layerOrder[b]);
  return {
    names,
    atRule: `@layer ${names.join(", ")};`,
    wrap(layer, styles) {
      if (config.disableLayers) return styles;
      const params = layers[layer];
      return { [`@layer ${params}`]: styles };
    }
  };
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/map-to-json.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/map-to-json.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapToJson: () => (/* binding */ mapToJson)
/* harmony export */ });

function mapToJson(map) {
  const obj = {};
  map.forEach((value, key) => {
    if (value instanceof Map) {
      obj[key] = Object.fromEntries(value);
    } else {
      obj[key] = value;
    }
  });
  return obj;
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/normalize.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/normalize.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createNormalizeFn: () => (/* binding */ createNormalizeFn)
/* harmony export */ });
/* harmony import */ var _utils_walk_object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/walk-object.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/walk-object.js");



function createNormalizeFn(context) {
  const { utility, normalize } = context;
  const { hasShorthand, resolveShorthand } = utility;
  return function(styles) {
    return (0,_utils_walk_object_js__WEBPACK_IMPORTED_MODULE_0__.walkObject)(styles, normalize, {
      stop: (value) => Array.isArray(value),
      getKey: hasShorthand ? resolveShorthand : void 0
    });
  };
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/preflight.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/preflight.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createPreflight: () => (/* binding */ createPreflight)
/* harmony export */ });
/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/is.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/is.js");



function createPreflight(options) {
  const { preflight } = options;
  if (!preflight) return {};
  const { scope = "", level = "parent" } = (0,_utils_is_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(preflight) ? preflight : {};
  let selector = "";
  if (scope && level === "parent") {
    selector = `${scope} `;
  } else if (scope && level === "element") {
    selector = `&${scope}`;
  }
  const scoped = {
    "*": {
      margin: "0px",
      padding: "0px",
      font: "inherit",
      wordWrap: "break-word",
      WebkitTapHighlightColor: "transparent"
    },
    "*, *::before, *::after, *::backdrop": {
      boxSizing: "border-box",
      borderWidth: "0px",
      borderStyle: "solid",
      borderColor: "var(--global-color-border, currentColor)"
    },
    hr: {
      height: "0px",
      color: "inherit",
      borderTopWidth: "1px"
    },
    body: {
      minHeight: "100dvh",
      position: "relative"
    },
    img: {
      borderStyle: "none"
    },
    "img, svg, video, canvas, audio, iframe, embed, object": {
      display: "block",
      verticalAlign: "middle"
    },
    iframe: { border: "none" },
    "img, video": { maxWidth: "100%", height: "auto" },
    "p, h1, h2, h3, h4, h5, h6": { overflowWrap: "break-word" },
    "ol, ul": { listStyle: "none" },
    "code, kbd, pre, samp": { fontSize: "1em" },
    "button, [type='button'], [type='reset'], [type='submit']": {
      WebkitAppearance: "button",
      backgroundColor: "transparent",
      backgroundImage: "none"
    },
    "button, input, optgroup, select, textarea": { color: "inherit" },
    "button, select": { textTransform: "none" },
    table: {
      textIndent: "0px",
      borderColor: "inherit",
      borderCollapse: "collapse"
    },
    "*::placeholder": {
      opacity: "unset",
      color: "#9ca3af",
      userSelect: "none"
    },
    textarea: {
      resize: "vertical"
    },
    summary: {
      display: "list-item"
    },
    small: {
      fontSize: "80%"
    },
    "sub, sup": {
      fontSize: "75%",
      lineHeight: 0,
      position: "relative",
      verticalAlign: "baseline"
    },
    sub: {
      bottom: "-0.25em"
    },
    sup: {
      top: "-0.5em"
    },
    dialog: {
      padding: "0px"
    },
    a: {
      color: "inherit",
      textDecoration: "inherit"
    },
    "abbr:where([title])": {
      textDecoration: "underline dotted"
    },
    "b, strong": {
      fontWeight: "bolder"
    },
    "code, kbd, samp, pre": {
      fontSize: "1em",
      "--font-mono-fallback": "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New'",
      fontFamily: "var(--global-font-mono, var(--font-mono-fallback))"
    },
    'input[type="text"], input[type="email"], input[type="search"], input[type="password"]': {
      WebkitAppearance: "none",
      MozAppearance: "none"
    },
    "input[type='search']": {
      WebkitAppearance: "textfield",
      outlineOffset: "-2px"
    },
    "::-webkit-search-decoration, ::-webkit-search-cancel-button": {
      WebkitAppearance: "none"
    },
    "::-webkit-file-upload-button": {
      WebkitAppearance: "button",
      font: "inherit"
    },
    'input[type="number"]::-webkit-inner-spin-button, input[type="number"]::-webkit-outer-spin-button': {
      height: "auto"
    },
    "input[type='number']": {
      MozAppearance: "textfield"
    },
    ":-moz-ui-invalid": {
      boxShadow: "none"
    },
    ":-moz-focusring": {
      outline: "auto"
    },
    "[hidden]:where(:not([hidden='until-found']))": {
      display: "none !important"
    }
  };
  const preflightCss = {
    [scope || "html"]: {
      lineHeight: 1.5,
      "--font-fallback": "ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'",
      WebkitTextSizeAdjust: "100%",
      WebkitFontSmoothing: "antialiased",
      MozOsxFontSmoothing: "grayscale",
      textRendering: "optimizeLegibility",
      touchAction: "manipulation",
      MozTabSize: "4",
      tabSize: "4",
      fontFamily: "var(--global-font-body, var(--font-fallback))"
    }
  };
  if (level === "element") {
    const modified = Object.entries(scoped).reduce((acc, [k, v]) => {
      acc[k] = { [selector]: v };
      return acc;
    }, {});
    Object.assign(preflightCss, modified);
  } else if (selector) {
    preflightCss[selector] = scoped;
  } else {
    Object.assign(preflightCss, scoped);
  }
  return preflightCss;
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/provider.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/provider.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ChakraProvider: () => (/* binding */ ChakraProvider),
/* harmony export */   useChakraContext: () => (/* binding */ useChakraContext)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @emotion/react */ "./node_modules/@emotion/react/dist/emotion-react.browser.development.esm.js");
/* harmony import */ var _create_context_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../create-context.js */ "./node_modules/@chakra-ui/react/dist/esm/create-context.js");

"use client";




const [ChakraContextProvider, useChakraContext] = (0,_create_context_js__WEBPACK_IMPORTED_MODULE_1__.createContext)({
  name: "ChakraContext",
  strict: true,
  providerName: "<ChakraProvider />"
});
function ChakraProvider(props) {
  const { value: sys, children } = props;
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(ChakraContextProvider, { value: sys, children: [
    !sys._config.disableLayers && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_emotion_react__WEBPACK_IMPORTED_MODULE_2__.Global, { styles: sys.layers.atRule }),
    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_emotion_react__WEBPACK_IMPORTED_MODULE_2__.Global, { styles: sys._global }),
    children
  ] });
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/references.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/references.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TOKEN_PATH_REGEX: () => (/* binding */ TOKEN_PATH_REGEX),
/* harmony export */   expandReferences: () => (/* binding */ expandReferences),
/* harmony export */   getReferences: () => (/* binding */ getReferences),
/* harmony export */   hasReference: () => (/* binding */ hasReference)
/* harmony export */ });
/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/is.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/is.js");



const REFERENCE_REGEX = /({([^}]*)})/g;
const CURLY_REGEX = /[{}]/g;
const TOKEN_PATH_REGEX = /\w+\.\w+/;
const getReferences = (value) => {
  if (!(0,_utils_is_js__WEBPACK_IMPORTED_MODULE_0__.isString)(value)) return [];
  const matches = value.match(REFERENCE_REGEX);
  if (!matches) return [];
  return matches.map((match) => match.replace(CURLY_REGEX, "")).map((value2) => value2.trim());
};
const hasReference = (value) => REFERENCE_REGEX.test(value);
function expandReferences(token) {
  if (!token.extensions?.references) {
    return token.extensions?.cssVar?.ref ?? token.value;
  }
  const references = token.extensions.references ?? {};
  token.value = Object.keys(references).reduce((valueStr, key) => {
    const referenceToken = references[key];
    if (referenceToken.extensions.conditions) {
      return valueStr;
    }
    const value = expandReferences(referenceToken);
    return valueStr.replace(`{${key}}`, value);
  }, token.value);
  delete token.extensions.references;
  return token.value;
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/serialize.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/serialize.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSerializeFn: () => (/* binding */ createSerializeFn)
/* harmony export */ });
/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/is.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/is.js");
/* harmony import */ var _utils_walk_object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/walk-object.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/walk-object.js");




function createSerializeFn(options) {
  const { conditions, isValidProperty } = options;
  return function serialize(styles) {
    return (0,_utils_walk_object_js__WEBPACK_IMPORTED_MODULE_0__.walkObject)(styles, (value) => value, {
      getKey: (prop, value) => {
        if (!(0,_utils_is_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(value)) return prop;
        if (!conditions.has(prop) && !isValidProperty(prop)) {
          return parseSelectors(prop).map((s) => "&" + s).join(", ");
        }
        return prop;
      }
    });
  };
}
function parseSelectors(selector) {
  const result = [];
  let parenCount = 0;
  let currentSelector = "";
  let inEscape = false;
  for (let i = 0; i < selector.length; i++) {
    const char = selector[i];
    if (char === "\\" && !inEscape) {
      inEscape = true;
      currentSelector += char;
      continue;
    }
    if (inEscape) {
      inEscape = false;
      currentSelector += char;
      continue;
    }
    if (char === "(") {
      parenCount++;
    } else if (char === ")") {
      parenCount--;
    }
    if (char === "," && parenCount === 0) {
      result.push(currentSelector.trim());
      currentSelector = "";
    } else {
      currentSelector += char;
    }
  }
  if (currentSelector) {
    result.push(currentSelector.trim());
  }
  return result;
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/sort-at-params.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/sort-at-params.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sortAtParams: () => (/* binding */ sortAtParams)
/* harmony export */ });
/* harmony import */ var _utils_memo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/memo.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/memo.js");



const createMediaQueryRegex = (dimension) => ({
  minMax: new RegExp(
    `(!?\\(\\s*min(-device-)?-${dimension})(.|
)+\\(\\s*max(-device)?-${dimension}`,
    "i"
  ),
  min: new RegExp(`\\(\\s*min(-device)?-${dimension}`, "i"),
  maxMin: new RegExp(
    `(!?\\(\\s*max(-device)?-${dimension})(.|
)+\\(\\s*min(-device)?-${dimension}`,
    "i"
  ),
  max: new RegExp(`\\(\\s*max(-device)?-${dimension}`, "i")
});
const widthRegex = createMediaQueryRegex("width");
const heightRegex = createMediaQueryRegex("height");
const createQueryTester = (regexSet) => ({
  isMin: _testQuery(regexSet.minMax, regexSet.maxMin, regexSet.min),
  isMax: _testQuery(regexSet.maxMin, regexSet.minMax, regexSet.max)
});
const { isMin: isMinWidth, isMax: isMaxWidth } = createQueryTester(widthRegex);
const { isMin: isMinHeight, isMax: isMaxHeight } = createQueryTester(heightRegex);
const isPrint = /print/i;
const isPrintOnly = /^print$/i;
const isLength = /(-?\d*\.?\d+)(ch|em|ex|px|rem)/;
const lengthExec = /(\d)/;
const maxValue = Number.MAX_VALUE;
const multipliers = { ch: 8.8984375, em: 16, rem: 16, ex: 8.296875, px: 1 };
function getQueryLength(query) {
  const length = isLength.exec(query) || (isMinWidth(query) || isMinHeight(query) ? lengthExec.exec(query) : null);
  if (!length) return maxValue;
  if (length[0] === "0") return 0;
  const number = parseFloat(length[1]);
  const unit = length[2];
  return number * (multipliers[unit] || 1);
}
function _testQuery(doubleTestTrue, doubleTestFalse, singleTest) {
  return (query) => doubleTestTrue.test(query) || !doubleTestFalse.test(query) && singleTest.test(query);
}
function _testIsPrint(a, b) {
  const isPrintA = isPrint.test(a), isPrintOnlyA = isPrintOnly.test(a);
  const isPrintB = isPrint.test(b), isPrintOnlyB = isPrintOnly.test(b);
  if (isPrintA && isPrintB) {
    if (!isPrintOnlyA && isPrintOnlyB) return 1;
    if (isPrintOnlyA && !isPrintOnlyB) return -1;
    return a.localeCompare(b);
  }
  return isPrintA ? 1 : isPrintB ? -1 : null;
}
const sortAtParams = (0,_utils_memo_js__WEBPACK_IMPORTED_MODULE_0__.memo)((a, b) => {
  const testIsPrint = _testIsPrint(a, b);
  if (testIsPrint !== null) return testIsPrint;
  const minA = isMinWidth(a) || isMinHeight(a), maxA = isMaxWidth(a) || isMaxHeight(a);
  const minB = isMinWidth(b) || isMinHeight(b), maxB = isMaxWidth(b) || isMaxHeight(b);
  if (minA && maxB) return -1;
  if (maxA && minB) return 1;
  const lengthA = getQueryLength(a), lengthB = getQueryLength(b);
  if (lengthA === maxValue && lengthB === maxValue) return a.localeCompare(b);
  if (lengthA === maxValue) return 1;
  if (lengthB === maxValue) return -1;
  if (lengthA !== lengthB) {
    return lengthA > lengthB ? maxA ? -1 : 1 : maxA ? 1 : -1;
  }
  return a.localeCompare(b);
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/sort-at-rules.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/sort-at-rules.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sortAtRules: () => (/* binding */ sortAtRules)
/* harmony export */ });
/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/is.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/is.js");
/* harmony import */ var _sort_at_params_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sort-at-params.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/sort-at-params.js");




function sortQueries(queries) {
  return queries.sort(([a], [b]) => (0,_sort_at_params_js__WEBPACK_IMPORTED_MODULE_0__.sortAtParams)(a, b));
}
function sortAtRules(obj) {
  const mediaQueries = [];
  const containerQueries = [];
  const rest = {};
  for (const [key, value] of Object.entries(obj)) {
    if (key.startsWith("@media")) {
      mediaQueries.push([key, value]);
    } else if (key.startsWith("@container")) {
      containerQueries.push([key, value]);
    } else if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(value)) {
      rest[key] = sortAtRules(value);
    } else {
      rest[key] = value;
    }
  }
  const sortedMediaQueries = sortQueries(mediaQueries);
  const sortedContainerQueries = sortQueries(containerQueries);
  return {
    ...rest,
    ...Object.fromEntries(sortedMediaQueries),
    ...Object.fromEntries(sortedContainerQueries)
  };
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/sva.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/sva.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSlotRecipeFn: () => (/* binding */ createSlotRecipeFn),
/* harmony export */   getSlotCompoundVariant: () => (/* binding */ getSlotCompoundVariant)
/* harmony export */ });
/* harmony import */ var _utils_omit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/omit.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/omit.js");
/* harmony import */ var _utils_split_props_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/split-props.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/split-props.js");




const getSlotRecipes = (config = {}) => {
  const init = (slot) => ({
    base: config.base?.[slot] ?? {},
    variants: {},
    defaultVariants: config.defaultVariants ?? {},
    compoundVariants: config.compoundVariants ? getSlotCompoundVariant(config.compoundVariants, slot) : []
  });
  const slots = config.slots ?? [];
  const entries = slots.map((slot) => [slot, init(slot)]);
  for (const [variantsKey, variantsSpec] of Object.entries(
    config.variants ?? {}
  )) {
    for (const [variantKey, variantSpec] of Object.entries(
      variantsSpec
    )) {
      entries.forEach(([slot, slotRecipe]) => {
        var _a;
        (_a = slotRecipe.variants)[variantsKey] ?? (_a[variantsKey] = {});
        slotRecipe.variants[variantsKey][variantKey] = variantSpec[slot] ?? {};
      });
    }
  }
  return Object.fromEntries(entries);
};
const getSlotCompoundVariant = (compoundVariants, slotName) => compoundVariants.filter((compoundVariant) => compoundVariant.css[slotName]).map((compoundVariant) => ({
  ...compoundVariant,
  css: compoundVariant.css[slotName]
}));
function createSlotRecipeFn(options) {
  const { cva } = options;
  return function sva(config = {}) {
    const slots = Object.entries(getSlotRecipes(config)).map(
      ([slot, slotCva]) => [slot, cva(slotCva)]
    );
    function svaFn(props) {
      const result = slots.map(([slot, cvaFn]) => [slot, cvaFn(props)]);
      return Object.fromEntries(result);
    }
    const variants = config.variants ?? {};
    const variantKeys = Object.keys(variants);
    function splitVariantProps(props) {
      const restProps = (0,_utils_omit_js__WEBPACK_IMPORTED_MODULE_0__.omit)(props, ["recipe"]);
      const [recipeProps, localProps] = (0,_utils_split_props_js__WEBPACK_IMPORTED_MODULE_1__.splitProps)(restProps, variantKeys);
      if (!variantKeys.includes("colorPalette")) {
        recipeProps.colorPalette = props.colorPalette || config.defaultVariants?.colorPalette;
      }
      if (variantKeys.includes("orientation")) {
        localProps.orientation = props.orientation;
      }
      return [recipeProps, localProps];
    }
    const variantMap = Object.fromEntries(
      Object.entries(variants).map(([key, value]) => [key, Object.keys(value)])
    );
    let classNameMap = {};
    if (config.className) {
      classNameMap = Object.fromEntries(
        config.slots.map((slot) => [
          slot,
          `${config.className}__${slot}`
        ])
      );
    }
    return Object.assign(svaFn, {
      variantMap,
      variantKeys,
      splitVariantProps,
      classNameMap
    });
  };
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/system.js":
/*!************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/system.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSystem: () => (/* binding */ createSystem),
/* harmony export */   isValidSystem: () => (/* binding */ isValidSystem)
/* harmony export */ });
/* harmony import */ var _pandacss_is_valid_prop__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @pandacss/is-valid-prop */ "./node_modules/@pandacss/is-valid-prop/dist/index.mjs");
/* harmony import */ var _utils_compact_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/compact.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/compact.js");
/* harmony import */ var _utils_flatten_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/flatten.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/flatten.js");
/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/is.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/is.js");
/* harmony import */ var _utils_memo_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/memo.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/memo.js");
/* harmony import */ var _utils_merge_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../utils/merge.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/merge.js");
/* harmony import */ var _utils_split_props_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../utils/split-props.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/split-props.js");
/* harmony import */ var _breakpoints_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./breakpoints.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/breakpoints.js");
/* harmony import */ var _conditions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./conditions.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/conditions.js");
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./css.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/css.js");
/* harmony import */ var _cva_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./cva.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/cva.js");
/* harmony import */ var _layers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layers.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/layers.js");
/* harmony import */ var _normalize_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./normalize.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/normalize.js");
/* harmony import */ var _preflight_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./preflight.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/preflight.js");
/* harmony import */ var _serialize_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./serialize.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/serialize.js");
/* harmony import */ var _sva_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./sva.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/sva.js");
/* harmony import */ var _token_dictionary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./token-dictionary.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/token-dictionary.js");
/* harmony import */ var _utility_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utility.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/utility.js");





















function createSystem(...configs) {
  const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.mergeConfigs)(...configs);
  const {
    theme = {},
    utilities = {},
    globalCss = {},
    cssVarsRoot = ":where(:root, :host)",
    cssVarsPrefix = "chakra",
    preflight
  } = config;
  const layers = (0,_layers_js__WEBPACK_IMPORTED_MODULE_1__.createLayers)(config);
  const tokens = (0,_token_dictionary_js__WEBPACK_IMPORTED_MODULE_2__.createTokenDictionary)({
    breakpoints: theme.breakpoints,
    tokens: theme.tokens,
    semanticTokens: theme.semanticTokens,
    prefix: cssVarsPrefix
  });
  const breakpoints = (0,_breakpoints_js__WEBPACK_IMPORTED_MODULE_3__.createBreakpoints)(theme.breakpoints ?? {});
  const conditions = (0,_conditions_js__WEBPACK_IMPORTED_MODULE_4__.createConditions)({
    conditions: config.conditions ?? {},
    breakpoints
  });
  const utility = (0,_utility_js__WEBPACK_IMPORTED_MODULE_5__.createUtility)({
    config: utilities,
    tokens
  });
  function assignComposition() {
    const { textStyles, layerStyles, animationStyles } = theme;
    const compositions = (0,_utils_compact_js__WEBPACK_IMPORTED_MODULE_6__.compact)({
      textStyle: textStyles,
      layerStyle: layerStyles,
      animationStyle: animationStyles
    });
    for (const [key, values] of Object.entries(compositions)) {
      const flatValues = (0,_utils_flatten_js__WEBPACK_IMPORTED_MODULE_7__.flatten)(
        values ?? {},
        (v) => (0,_utils_is_js__WEBPACK_IMPORTED_MODULE_8__.isObject)(v) && "value" in v
      );
      utility.register(key, {
        values: Object.keys(flatValues),
        transform(value) {
          return css(flatValues[value]);
        }
      });
    }
  }
  assignComposition();
  utility.addPropertyType("animationName", Object.keys(theme.keyframes ?? {}));
  const properties = /* @__PURE__ */ new Set(["css", ...utility.keys(), ...conditions.keys()]);
  const isValidProperty = (0,_utils_memo_js__WEBPACK_IMPORTED_MODULE_9__.memo)(
    (prop) => properties.has(prop) || (0,_pandacss_is_valid_prop__WEBPACK_IMPORTED_MODULE_10__.isCssProperty)(prop)
  );
  const normalizeValue = (value) => {
    if (Array.isArray(value)) {
      return value.reduce((acc, current, index) => {
        const key = conditions.breakpoints[index];
        if (current != null) acc[key] = current;
        return acc;
      }, {});
    }
    return value;
  };
  const normalizeFn = (0,_normalize_js__WEBPACK_IMPORTED_MODULE_11__.createNormalizeFn)({
    utility,
    normalize: normalizeValue
  });
  const serialize = (0,_serialize_js__WEBPACK_IMPORTED_MODULE_12__.createSerializeFn)({
    conditions,
    isValidProperty
  });
  const css = (0,_css_js__WEBPACK_IMPORTED_MODULE_13__.createCssFn)({
    transform: utility.transform,
    conditions,
    normalize: normalizeFn
  });
  const cva = (0,_cva_js__WEBPACK_IMPORTED_MODULE_14__.createRecipeFn)({
    css,
    conditions,
    normalize: normalizeFn,
    layers
  });
  const sva = (0,_sva_js__WEBPACK_IMPORTED_MODULE_15__.createSlotRecipeFn)({ cva });
  function getTokenCss() {
    const result = {};
    for (const [key, values] of tokens.cssVarMap.entries()) {
      const varsObj = Object.fromEntries(values);
      if (Object.keys(varsObj).length === 0) continue;
      const selector = key === "base" ? cssVarsRoot : conditions.resolve(key);
      const cssObject = css(serialize({ [selector]: varsObj }));
      (0,_utils_merge_js__WEBPACK_IMPORTED_MODULE_16__.mergeWith)(result, cssObject);
    }
    return layers.wrap("tokens", result);
  }
  function getGlobalCss() {
    const keyframes = Object.fromEntries(
      Object.entries(theme.keyframes ?? {}).map(([key, value]) => [
        `@keyframes ${key}`,
        value
      ])
    );
    const result = Object.assign({}, keyframes, css(serialize(globalCss)));
    return layers.wrap("base", result);
  }
  function splitCssProps(props) {
    return (0,_utils_split_props_js__WEBPACK_IMPORTED_MODULE_17__.splitProps)(props, isValidProperty);
  }
  function getPreflightCss() {
    const result = (0,_preflight_js__WEBPACK_IMPORTED_MODULE_18__.createPreflight)({ preflight });
    return layers.wrap("reset", result);
  }
  const tokenMap = getTokenMap(tokens);
  const tokenFn = (path, fallback) => {
    return tokenMap.get(path)?.value || fallback;
  };
  tokenFn.var = (path, fallback) => {
    return tokenMap.get(path)?.variable || fallback;
  };
  function getRecipe(key, fallback) {
    return theme.recipes?.[key] ?? fallback;
  }
  function getSlotRecipe(key, fallback) {
    return theme.slotRecipes?.[key] ?? fallback;
  }
  function isRecipe(key) {
    return Object.hasOwnProperty.call(theme.recipes ?? {}, key);
  }
  function isSlotRecipe(key) {
    return Object.hasOwnProperty.call(theme.slotRecipes ?? {}, key);
  }
  function hasRecipe(key) {
    return isRecipe(key) || isSlotRecipe(key);
  }
  const _global = [getPreflightCss(), getGlobalCss(), getTokenCss()];
  return {
    $$chakra: true,
    _config: config,
    _global,
    breakpoints,
    tokens,
    conditions,
    utility,
    token: tokenFn,
    properties,
    layers,
    isValidProperty,
    splitCssProps,
    normalizeValue,
    getTokenCss,
    getGlobalCss,
    getPreflightCss,
    css,
    cva,
    sva,
    getRecipe,
    getSlotRecipe,
    hasRecipe,
    isRecipe,
    isSlotRecipe
  };
}
function getTokenMap(tokens) {
  const map = /* @__PURE__ */ new Map();
  tokens.allTokens.forEach((token) => {
    const { cssVar, virtual, conditions } = token.extensions;
    const value = !!conditions || virtual ? cssVar.ref : token.value;
    map.set(token.name, { value, variable: cssVar.ref });
  });
  return map;
}
const isValidSystem = (mod) => {
  return (0,_utils_is_js__WEBPACK_IMPORTED_MODULE_8__.isObject)(mod) && !!Reflect.get(mod, "$$chakra");
};




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/token-dictionary.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/token-dictionary.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createTokenDictionary: () => (/* binding */ createTokenDictionary),
/* harmony export */   tokenCategories: () => (/* binding */ tokenCategories)
/* harmony export */ });
/* harmony import */ var _utils_compact_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/compact.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/compact.js");
/* harmony import */ var _utils_create_props_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utils/create-props.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/create-props.js");
/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/is.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/is.js");
/* harmony import */ var _utils_memo_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/memo.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/memo.js");
/* harmony import */ var _utils_walk_object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/walk-object.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/walk-object.js");
/* harmony import */ var _css_var_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./css-var.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/css-var.js");
/* harmony import */ var _esc_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./esc.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/esc.js");
/* harmony import */ var _expand_reference_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./expand-reference.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/expand-reference.js");
/* harmony import */ var _map_to_json_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./map-to-json.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/map-to-json.js");
/* harmony import */ var _references_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./references.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/references.js");
/* harmony import */ var _token_middleware_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./token-middleware.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/token-middleware.js");
/* harmony import */ var _token_transforms_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./token-transforms.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/token-transforms.js");














const isToken = (value) => {
  return (0,_utils_is_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && Object.prototype.hasOwnProperty.call(value, "value");
};
function expandBreakpoints(breakpoints) {
  if (!breakpoints) return { breakpoints: {}, sizes: {} };
  return {
    breakpoints: (0,_utils_walk_object_js__WEBPACK_IMPORTED_MODULE_1__.mapObject)(breakpoints, (value) => ({ value })),
    sizes: Object.fromEntries(
      Object.entries(breakpoints).map(([key, value]) => [
        `breakpoint-${key}`,
        { value }
      ])
    )
  };
}
function createTokenDictionary(options) {
  const {
    prefix = "",
    tokens = {},
    semanticTokens = {},
    breakpoints = {}
  } = options;
  const formatTokenName = (path) => path.join(".");
  const formatCssVar = (path, prefix2) => (0,_css_var_js__WEBPACK_IMPORTED_MODULE_2__.cssVar)(path.join("-"), { prefix: prefix2 });
  const allTokens = [];
  const tokenNameMap = /* @__PURE__ */ new Map();
  const conditionMap = /* @__PURE__ */ new Map();
  const cssVarMap = /* @__PURE__ */ new Map();
  const colorPaletteMap = /* @__PURE__ */ new Map();
  const flatMap = /* @__PURE__ */ new Map();
  const byCategory = /* @__PURE__ */ new Map();
  const categoryMap = /* @__PURE__ */ new Map();
  const transforms = /* @__PURE__ */ new Map();
  const middlewares = [];
  function registerToken(token, phase) {
    allTokens.push(token);
    tokenNameMap.set(token.name, token);
    if (phase) {
      transforms.forEach((fn) => {
        if (fn.enforce === phase) transformToken(fn, token);
      });
    }
  }
  const breakpointTokens = expandBreakpoints(breakpoints);
  const computedTokens = (0,_utils_compact_js__WEBPACK_IMPORTED_MODULE_3__.compact)({
    ...tokens,
    breakpoints: breakpointTokens.breakpoints,
    sizes: {
      ...tokens.sizes,
      ...breakpointTokens.sizes
    }
  });
  function registerTokens() {
    (0,_utils_walk_object_js__WEBPACK_IMPORTED_MODULE_1__.walkObject)(
      computedTokens,
      (entry, path) => {
        const isDefault = path.includes("DEFAULT");
        path = filterDefault(path);
        const category = path[0];
        const name = formatTokenName(path);
        const t = (0,_utils_is_js__WEBPACK_IMPORTED_MODULE_0__.isString)(entry) ? { value: entry } : entry;
        const token = {
          value: t.value,
          originalValue: t.value,
          name,
          path,
          extensions: {
            condition: "base",
            originalPath: path,
            category,
            prop: formatTokenName(path.slice(1))
          }
        };
        if (isDefault) {
          token.extensions.default = true;
        }
        registerToken(token);
      },
      { stop: isToken }
    );
    (0,_utils_walk_object_js__WEBPACK_IMPORTED_MODULE_1__.walkObject)(
      semanticTokens,
      (entry, path) => {
        const isDefault = path.includes("DEFAULT");
        path = filterBaseCondition(filterDefault(path));
        const category = path[0];
        const name = formatTokenName(path);
        const t = (0,_utils_is_js__WEBPACK_IMPORTED_MODULE_0__.isString)(entry.value) ? { value: { base: entry.value } } : entry;
        const token = {
          value: t.value.base || "",
          originalValue: t.value.base || "",
          name,
          path,
          extensions: {
            originalPath: path,
            category,
            conditions: t.value,
            condition: "base",
            prop: formatTokenName(path.slice(1))
          }
        };
        if (isDefault) {
          token.extensions.default = true;
        }
        registerToken(token);
      },
      { stop: isToken }
    );
  }
  function getByName(name) {
    return tokenNameMap.get(name);
  }
  function buildConditionMap(token) {
    const { condition } = token.extensions;
    if (!condition) return;
    if (!conditionMap.has(condition)) {
      conditionMap.set(condition, /* @__PURE__ */ new Set());
    }
    conditionMap.get(condition).add(token);
  }
  function buildCategoryMap(token) {
    const { category, prop } = token.extensions;
    if (!category) return;
    if (!categoryMap.has(category)) {
      categoryMap.set(category, /* @__PURE__ */ new Map());
    }
    categoryMap.get(category).set(prop, token);
  }
  function buildCssVars(token) {
    const { condition, negative, virtual, cssVar: cssVar2 } = token.extensions;
    if (negative || virtual || !condition || !cssVar2) return;
    if (!cssVarMap.has(condition)) {
      cssVarMap.set(condition, /* @__PURE__ */ new Map());
    }
    cssVarMap.get(condition).set(cssVar2.var, token.value);
  }
  function buildFlatMap(token) {
    const { category, prop, cssVar: cssVar2, negative } = token.extensions;
    if (!category) return;
    if (!byCategory.has(category)) {
      byCategory.set(category, /* @__PURE__ */ new Map());
    }
    const value = negative ? token.extensions.conditions ? token.originalValue : token.value : cssVar2.ref;
    byCategory.get(category).set(prop, value);
    flatMap.set([category, prop].join("."), value);
  }
  function buildColorPalette(token) {
    const { colorPalette, virtual, default: isDefault } = token.extensions;
    if (!colorPalette || virtual) return;
    colorPalette.roots.forEach((root) => {
      const name = formatTokenName(root);
      if (!colorPaletteMap.has(name)) {
        colorPaletteMap.set(name, /* @__PURE__ */ new Map());
      }
      const virtualPath = replaceRootWithColorPalette(
        [...token.path],
        [...root]
      );
      const virtualName = formatTokenName(virtualPath);
      const virtualToken = getByName(virtualName);
      if (!virtualToken || !virtualToken.extensions.cssVar) return;
      const { var: virtualVar } = virtualToken.extensions.cssVar;
      colorPaletteMap.get(name).set(virtualVar, token.extensions.cssVar.ref);
      if (isDefault && root.length === 1) {
        const colorPaletteName = formatTokenName(["colors", "colorPalette"]);
        const colorPaletteToken = getByName(colorPaletteName);
        if (!colorPaletteToken) return;
        const name2 = formatTokenName(token.path);
        const virtualToken2 = getByName(name2);
        if (!virtualToken2) return;
        const keyPath = colorPalette.keys[0]?.filter(Boolean);
        if (!keyPath.length) return;
        const computedName = formatTokenName(root.concat(keyPath));
        if (!colorPaletteMap.has(computedName)) {
          colorPaletteMap.set(computedName, /* @__PURE__ */ new Map());
        }
        colorPaletteMap.get(computedName).set(
          colorPaletteToken.extensions.cssVar.var,
          virtualToken2.extensions.cssVar.ref
        );
      }
    });
  }
  let byCategoryJson = {};
  function setupViews() {
    allTokens.forEach((token) => {
      buildConditionMap(token);
      buildCategoryMap(token);
      buildCssVars(token);
      buildFlatMap(token);
      buildColorPalette(token);
    });
    byCategoryJson = (0,_map_to_json_js__WEBPACK_IMPORTED_MODULE_4__.mapToJson)(byCategory);
  }
  const colorMix = (value, tokenFn) => {
    if (!value || typeof value !== "string") return { invalid: true, value };
    const [colorPath, rawOpacity] = value.split("/");
    if (!colorPath || !rawOpacity) {
      return { invalid: true, value: colorPath };
    }
    const colorToken = tokenFn(colorPath);
    const opacityToken = getByName(`opacity.${rawOpacity}`)?.value;
    if (!opacityToken && isNaN(Number(rawOpacity))) {
      return { invalid: true, value: colorPath };
    }
    const percent = opacityToken ? Number(opacityToken) * 100 + "%" : `${rawOpacity}%`;
    const color = colorToken ?? colorPath;
    return {
      invalid: false,
      color,
      value: `color-mix(in srgb, ${color} ${percent}, transparent)`
    };
  };
  const getVar = (0,_utils_memo_js__WEBPACK_IMPORTED_MODULE_5__.memo)((value, fallback) => {
    return flatMap.get(value) ?? fallback;
  });
  const getCategoryValues = (0,_utils_memo_js__WEBPACK_IMPORTED_MODULE_5__.memo)((category) => {
    return byCategoryJson[category] || null;
  });
  const expandReferenceInValue = (0,_utils_memo_js__WEBPACK_IMPORTED_MODULE_5__.memo)((value) => {
    return (0,_expand_reference_js__WEBPACK_IMPORTED_MODULE_6__.expandTokenReferences)(value, (path) => {
      if (!path) return;
      if (path.includes("/")) {
        const mix = colorMix(path, (v) => getVar(v));
        if (mix.invalid) {
          throw new Error("Invalid color mix at " + path + ": " + mix.value);
        }
        return mix.value;
      }
      const resolved = getVar(path);
      if (resolved) return resolved;
      return _references_js__WEBPACK_IMPORTED_MODULE_7__.TOKEN_PATH_REGEX.test(path) ? (0,_esc_js__WEBPACK_IMPORTED_MODULE_8__.esc)(path) : path;
    });
  });
  const dictionary = {
    prefix,
    allTokens,
    tokenMap: tokenNameMap,
    registerToken,
    getByName,
    formatTokenName,
    formatCssVar,
    flatMap,
    cssVarMap,
    categoryMap,
    colorPaletteMap,
    getVar,
    getCategoryValues,
    expandReferenceInValue
  };
  function registerTransform(...fns) {
    fns.forEach((fn) => {
      transforms.set(fn.name, fn);
    });
  }
  function registerMiddleware(...fns) {
    middlewares.push(...fns);
  }
  function transformToken(transform, token) {
    if (token.extensions.references) return;
    if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(transform.match) && !transform.match(token)) return;
    const fn = (v) => transform.transform(v, dictionary);
    const transformed = fn(token);
    switch (true) {
      case transform.type === "extensions":
        Object.assign(token.extensions, transformed);
        break;
      case transform.type === "value":
        token.value = transformed;
        break;
      default:
        token[transform.type] = transformed;
        break;
    }
  }
  function applyMiddlewares(enforce) {
    middlewares.forEach((middleware) => {
      if (middleware.enforce === enforce) {
        middleware.transform(dictionary);
      }
    });
  }
  function applyTransforms(enforce) {
    transforms.forEach((transform) => {
      if (transform.enforce === enforce) {
        allTokens.forEach((token) => {
          transformToken(transform, token);
        });
      }
    });
  }
  function addConditionalTokens() {
    allTokens.forEach((token) => {
      const tokens2 = getConditionalTokens(token);
      if (!tokens2 || tokens2.length === 0) return;
      tokens2.forEach((token2) => {
        registerToken(token2);
      });
    });
  }
  function getTokenReferences(value) {
    const refs = (0,_references_js__WEBPACK_IMPORTED_MODULE_7__.getReferences)(value);
    return refs.map((ref) => getByName(ref)).filter(Boolean);
  }
  function addReferences() {
    allTokens.forEach((token) => {
      if (!(0,_references_js__WEBPACK_IMPORTED_MODULE_7__.hasReference)(token.value)) return;
      const references = getTokenReferences(token.value);
      token.extensions.references = references.reduce((acc, ref) => {
        acc[ref.name] = ref;
        return acc;
      }, {});
    });
  }
  function expandTokenReferences$1() {
    allTokens.forEach((token) => {
      (0,_references_js__WEBPACK_IMPORTED_MODULE_7__.expandReferences)(token);
    });
  }
  function build() {
    applyMiddlewares("pre");
    applyTransforms("pre");
    addConditionalTokens();
    addReferences();
    expandTokenReferences$1();
    applyMiddlewares("post");
    applyTransforms("post");
    setupViews();
  }
  registerTokens();
  registerTransform(..._token_transforms_js__WEBPACK_IMPORTED_MODULE_9__.tokenTransforms);
  registerMiddleware(..._token_middleware_js__WEBPACK_IMPORTED_MODULE_10__.tokenMiddlewares);
  build();
  return dictionary;
}
function filterDefault(path) {
  if (path[0] === "DEFAULT") return path;
  return path.filter((item) => item !== "DEFAULT");
}
function filterBaseCondition(path) {
  return path.filter((item) => item !== "base");
}
function getConditionalTokens(token) {
  if (!token.extensions.conditions) return;
  const { conditions } = token.extensions;
  const tokens = [];
  (0,_utils_walk_object_js__WEBPACK_IMPORTED_MODULE_1__.walkObject)(conditions, (value, path) => {
    const nextPath = filterBaseCondition(path);
    if (!nextPath.length) return;
    const nextToken = structuredClone(token);
    nextToken.value = value;
    nextToken.extensions.condition = nextPath.join(":");
    tokens.push(nextToken);
  });
  return tokens;
}
function replaceRootWithColorPalette(path, roots) {
  const startIndex = path.findIndex(
    (_, index) => roots.every(
      (rootElement, rootIndex) => path[index + rootIndex] === rootElement
    )
  );
  if (startIndex === -1) {
    return path;
  }
  path.splice(startIndex, roots.length);
  path.splice(startIndex, 0, "colorPalette");
  return path;
}
const tokenCategories = (0,_utils_create_props_js__WEBPACK_IMPORTED_MODULE_11__.createProps)()([
  "aspectRatios",
  "zIndex",
  "opacity",
  "colors",
  "fonts",
  "fontSizes",
  "fontWeights",
  "lineHeights",
  "letterSpacings",
  "sizes",
  "shadows",
  "spacing",
  "radii",
  "cursor",
  "borders",
  "borderWidths",
  "borderStyles",
  "durations",
  "easings",
  "animations",
  "blurs",
  "gradients",
  "breakpoints",
  "assets"
]);




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/token-middleware.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/token-middleware.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addNegativeTokens: () => (/* binding */ addNegativeTokens),
/* harmony export */   addPixelUnit: () => (/* binding */ addPixelUnit),
/* harmony export */   addVirtualPalette: () => (/* binding */ addVirtualPalette),
/* harmony export */   removeEmptyTokens: () => (/* binding */ removeEmptyTokens),
/* harmony export */   tokenMiddlewares: () => (/* binding */ tokenMiddlewares)
/* harmony export */ });
/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/is.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/is.js");
/* harmony import */ var _calc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./calc.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/calc.js");
/* harmony import */ var _unit_conversion_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unit-conversion.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/unit-conversion.js");





const addNegativeTokens = {
  enforce: "pre",
  transform(dictionary) {
    const { prefix, allTokens, formatCssVar, formatTokenName, registerToken } = dictionary;
    const tokens = allTokens.filter(
      ({ extensions }) => extensions.category === "spacing"
    );
    tokens.forEach((token) => {
      const originalPath = token.path.slice();
      const originalVar = formatCssVar(originalPath, prefix);
      if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_0__.isString)(token.value) && token.value === "0rem") {
        return;
      }
      const nextToken = structuredClone(token);
      Object.assign(nextToken.extensions, {
        negative: true,
        prop: `-${token.extensions.prop}`,
        originalPath
      });
      nextToken.value = _calc_js__WEBPACK_IMPORTED_MODULE_1__.calc.negate(originalVar.ref);
      const lastPath = nextToken.path[nextToken.path.length - 1];
      if (lastPath != null) {
        nextToken.path[nextToken.path.length - 1] = `-${lastPath}`;
      }
      if (nextToken.path) {
        nextToken.name = formatTokenName(nextToken.path);
      }
      registerToken(nextToken);
    });
  }
};
const units = /* @__PURE__ */ new Set([
  "spacing",
  "sizes",
  "borderWidths",
  "fontSizes",
  "radii"
]);
const addPixelUnit = {
  enforce: "post",
  transform(dictionary) {
    const tokens = dictionary.allTokens.filter((token) => {
      return units.has(token.extensions.category) && !token.extensions.negative;
    });
    tokens.forEach((token) => {
      Object.assign(token.extensions, {
        pixelValue: (0,_unit_conversion_js__WEBPACK_IMPORTED_MODULE_2__.toPx)(token.value)
      });
    });
  }
};
const addVirtualPalette = {
  enforce: "post",
  transform(dictionary) {
    const { allTokens, registerToken, formatTokenName } = dictionary;
    const tokens = allTokens.filter(
      ({ extensions }) => extensions.category === "colors"
    );
    const keys = /* @__PURE__ */ new Map();
    const colorPalettes = /* @__PURE__ */ new Map();
    tokens.forEach((token) => {
      const { colorPalette } = token.extensions;
      if (!colorPalette) return;
      colorPalette.keys.forEach((keyPath) => {
        keys.set(formatTokenName(keyPath), keyPath);
      });
      colorPalette.roots.forEach((colorPaletteRoot) => {
        const name = formatTokenName(colorPaletteRoot);
        const colorPaletteList = colorPalettes.get(name) || [];
        colorPaletteList.push(token);
        colorPalettes.set(name, colorPaletteList);
        if (token.extensions.default && colorPaletteRoot.length === 1) {
          const keyPath = colorPalette.keys[0]?.filter(Boolean);
          if (!keyPath.length) return;
          const path = colorPaletteRoot.concat(keyPath);
          keys.set(formatTokenName(path), []);
        }
      });
    });
    keys.forEach((segments) => {
      const path = ["colors", "colorPalette", ...segments].filter(Boolean);
      const name = formatTokenName(path);
      const prop = formatTokenName(path.slice(1));
      const token = {
        name,
        value: name,
        originalValue: name,
        path,
        extensions: {
          condition: "base",
          originalPath: path,
          category: "colors",
          prop,
          virtual: true
        }
      };
      registerToken(token, "pre");
    });
  }
};
const removeEmptyTokens = {
  enforce: "post",
  transform(dictionary) {
    dictionary.allTokens = dictionary.allTokens.filter(
      (token) => token.value !== ""
    );
  }
};
const tokenMiddlewares = [
  addNegativeTokens,
  addVirtualPalette,
  addPixelUnit,
  removeEmptyTokens
];




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/token-transforms.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/token-transforms.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addColorPalette: () => (/* binding */ addColorPalette),
/* harmony export */   addConditionalCssVariables: () => (/* binding */ addConditionalCssVariables),
/* harmony export */   addCssVariables: () => (/* binding */ addCssVariables),
/* harmony export */   tokenTransforms: () => (/* binding */ tokenTransforms)
/* harmony export */ });
/* harmony import */ var _references_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./references.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/references.js");



const addCssVariables = {
  type: "extensions",
  enforce: "pre",
  name: "tokens/css-var",
  transform(token, dictionary) {
    const { prefix, formatCssVar } = dictionary;
    const { negative, originalPath } = token.extensions;
    const path = negative ? originalPath : token.path;
    return {
      cssVar: formatCssVar(path.filter(Boolean), prefix)
    };
  }
};
const addConditionalCssVariables = {
  enforce: "post",
  type: "value",
  name: "tokens/conditionals",
  transform(token, dictionary) {
    const { prefix, formatCssVar } = dictionary;
    const refs = (0,_references_js__WEBPACK_IMPORTED_MODULE_0__.getReferences)(token.value);
    if (!refs.length) return token.value;
    refs.forEach((ref) => {
      const variable = formatCssVar(ref.split("."), prefix);
      token.value = token.value.replace(`{${variable.ref}}`, variable);
    });
    return token.value;
  }
};
const addColorPalette = {
  type: "extensions",
  enforce: "pre",
  name: "tokens/colors/colorPalette",
  match(token) {
    return token.extensions.category === "colors" && !token.extensions.virtual;
  },
  transform(token, dict) {
    let path = token.path.slice();
    path.pop();
    path.shift();
    if (path.length === 0) {
      const newPath = [...token.path];
      newPath.shift();
      path = newPath;
    }
    if (path.length === 0) {
      return {};
    }
    const roots = path.reduce((acc, _, i, arr) => {
      const next = arr.slice(0, i + 1);
      acc.push(next);
      return acc;
    }, []);
    const root = path[0];
    const value = dict.formatTokenName(path);
    const keys = token.path.slice(token.path.indexOf(root) + 1).reduce((acc, _, i, arr) => {
      acc.push(arr.slice(i));
      return acc;
    }, []);
    if (keys.length === 0) {
      keys.push([""]);
    }
    return {
      colorPalette: { value, roots, keys }
    };
  }
};
const tokenTransforms = [
  addCssVariables,
  addConditionalCssVariables,
  addColorPalette
];




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/unit-conversion.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/unit-conversion.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getUnit: () => (/* binding */ getUnit),
/* harmony export */   toEm: () => (/* binding */ toEm),
/* harmony export */   toPx: () => (/* binding */ toPx),
/* harmony export */   toRem: () => (/* binding */ toRem)
/* harmony export */ });

const BASE_FONT_SIZE = 16;
const UNIT_PX = "px";
const UNIT_EM = "em";
const UNIT_REM = "rem";
function getUnit(value = "") {
  const DIGIT_REGEX = new RegExp(String.raw`-?\d+(?:\.\d+|\d*)`);
  const UNIT_REGEX = new RegExp(`${UNIT_PX}|${UNIT_EM}|${UNIT_REM}`);
  const unit = value.match(
    new RegExp(`${DIGIT_REGEX.source}(${UNIT_REGEX.source})`)
  );
  return unit?.[1];
}
function toPx(value = "") {
  if (typeof value === "number") {
    return `${value}px`;
  }
  const unit = getUnit(value);
  if (!unit) return value;
  if (unit === UNIT_PX) {
    return value;
  }
  if (unit === UNIT_EM || unit === UNIT_REM) {
    return `${parseFloat(value) * BASE_FONT_SIZE}${UNIT_PX}`;
  }
}
function toEm(value = "", fontSize = BASE_FONT_SIZE) {
  const unit = getUnit(value);
  if (!unit) return value;
  if (unit === UNIT_EM) {
    return value;
  }
  if (unit === UNIT_PX) {
    return `${parseFloat(value) / fontSize}${UNIT_EM}`;
  }
  if (unit === UNIT_REM) {
    return `${parseFloat(value) * BASE_FONT_SIZE / fontSize}${UNIT_EM}`;
  }
}
function toRem(value = "") {
  const unit = getUnit(value);
  if (!unit) return value;
  if (unit === UNIT_REM) {
    return value;
  }
  if (unit === UNIT_EM) {
    return `${parseFloat(value)}${UNIT_REM}`;
  }
  if (unit === UNIT_PX) {
    return `${parseFloat(value) / BASE_FONT_SIZE}${UNIT_REM}`;
  }
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/use-recipe.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/use-recipe.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useRecipe: () => (/* binding */ useRecipe)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/provider.js");

"use client";



function useRecipe(options) {
  const { key, recipe: recipeProp } = options;
  const sys = (0,_provider_js__WEBPACK_IMPORTED_MODULE_1__.useChakraContext)();
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    const recipe = recipeProp || (key != null ? sys.getRecipe(key) : {});
    return sys.cva(structuredClone(recipe));
  }, [key, recipeProp, sys]);
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/use-resolved-props.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/use-resolved-props.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isHtmlProp: () => (/* binding */ isHtmlProp),
/* harmony export */   useResolvedProps: () => (/* binding */ useResolvedProps)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _utils_split_props_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/split-props.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/split-props.js");
/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/provider.js");





const htmlProps = /* @__PURE__ */ new Set([
  "htmlWidth",
  "htmlHeight",
  "htmlSize",
  "htmlTranslate"
]);
function isHtmlProp(prop) {
  return typeof prop === "string" && htmlProps.has(prop);
}
function useResolvedProps(inProps, cvaRecipe, shouldForwardProps) {
  const { css, isValidProperty } = (0,_provider_js__WEBPACK_IMPORTED_MODULE_1__.useChakraContext)();
  const { children, ...props } = inProps;
  const result = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    const [forwardedProps, restProps_B] = (0,_utils_split_props_js__WEBPACK_IMPORTED_MODULE_2__.splitProps)(
      props,
      (key) => shouldForwardProps(key, cvaRecipe.variantKeys)
    );
    const [variantProps, restProps_C] = (0,_utils_split_props_js__WEBPACK_IMPORTED_MODULE_2__.splitProps)(
      restProps_B,
      cvaRecipe.variantKeys
    );
    const [styleProps, elementProps] = (0,_utils_split_props_js__WEBPACK_IMPORTED_MODULE_2__.splitProps)(restProps_C, isValidProperty);
    return {
      forwardedProps,
      variantProps,
      styleProps,
      elementProps
    };
  }, [cvaRecipe.variantKeys, shouldForwardProps, props, isValidProperty]);
  const { css: cssStyles, ...propStyles } = result.styleProps;
  const cvaStyles = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    const variantProps = { ...result.variantProps };
    if (!cvaRecipe.variantKeys.includes("colorPalette")) {
      variantProps.colorPalette = props.colorPalette;
    }
    if (!cvaRecipe.variantKeys.includes("orientation")) {
      variantProps.orientation = props.orientation;
    }
    return cvaRecipe(variantProps);
  }, [cvaRecipe, result.variantProps, props.colorPalette, props.orientation]);
  const styles = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return css(cvaStyles, ...toArray(cssStyles), propStyles);
  }, [css, cvaStyles, cssStyles, propStyles]);
  return {
    styles,
    props: {
      ...result.forwardedProps,
      ...result.elementProps,
      children
    }
  };
}
const toArray = (val) => {
  const res = Array.isArray(val) ? val : [val];
  return res.filter(Boolean).flat();
};




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/use-slot-recipe.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/use-slot-recipe.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useSlotRecipe: () => (/* binding */ useSlotRecipe)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/provider.js");

"use client";



function useSlotRecipe(options) {
  const { key, recipe: recipeProp } = options;
  const sys = (0,_provider_js__WEBPACK_IMPORTED_MODULE_1__.useChakraContext)();
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    const recipe = recipeProp || (key != null ? sys.getSlotRecipe(key) : {});
    return sys.sva(structuredClone(recipe));
  }, [key, recipeProp, sys]);
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/styled-system/utility.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/styled-system/utility.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createUtility: () => (/* binding */ createUtility)
/* harmony export */ });
/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/is.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/is.js");
/* harmony import */ var _utils_memo_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/memo.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/memo.js");
/* harmony import */ var _color_mix_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./color-mix.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/color-mix.js");
/* harmony import */ var _map_to_json_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map-to-json.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/map-to-json.js");






function normalize(config) {
  return config;
}
function normalizeConfig(config) {
  return Object.fromEntries(
    Object.entries(config).map(([property, propertyConfig]) => {
      return [property, normalize(propertyConfig)];
    })
  );
}
function createUtility(options) {
  const configs = normalizeConfig(options.config);
  const tokens = options.tokens;
  const shorthands = /* @__PURE__ */ new Map();
  const propValues = /* @__PURE__ */ new Map();
  function register(property, config) {
    configs[property] = normalize(config);
    assignProperty(property, config);
  }
  const assignProperty = (property, config) => {
    const values = getPropertyValues(config);
    if (!values) return;
    propValues.set(property, values);
    assignPropertyType(property, config);
  };
  const assignProperties = () => {
    for (const [prop, config] of Object.entries(configs)) {
      if (!config) continue;
      assignProperty(prop, config);
    }
  };
  const assignShorthands = () => {
    for (const [property, config] of Object.entries(configs)) {
      const { shorthand } = config ?? {};
      if (!shorthand) continue;
      const values = Array.isArray(shorthand) ? shorthand : [shorthand];
      values.forEach((name) => shorthands.set(name, property));
    }
  };
  const assignColorPaletteProperty = () => {
    const values = (0,_map_to_json_js__WEBPACK_IMPORTED_MODULE_0__.mapToJson)(tokens.colorPaletteMap);
    register("colorPalette", {
      values: Object.keys(values),
      transform: (0,_utils_memo_js__WEBPACK_IMPORTED_MODULE_1__.memo)((value) => values[value])
    });
  };
  const propTypes = /* @__PURE__ */ new Map();
  const assignPropertyType = (property, config) => {
    if (!config) return;
    const values = getPropertyValues(config, (key) => `type:Tokens["${key}"]`);
    if (typeof values === "object" && values.type) {
      propTypes.set(property, /* @__PURE__ */ new Set([`type:${values.type}`]));
      return;
    }
    if (values) {
      const keys2 = new Set(Object.keys(values));
      propTypes.set(property, keys2);
    }
    const set = propTypes.get(property) ?? /* @__PURE__ */ new Set();
    if (config.property) {
      propTypes.set(property, set.add(`CssProperties["${config.property}"]`));
    }
  };
  const assignPropertyTypes = () => {
    for (const [property, propertyConfig] of Object.entries(configs)) {
      if (!propertyConfig) continue;
      assignPropertyType(property, propertyConfig);
    }
  };
  const addPropertyType = (property, type) => {
    const set = propTypes.get(property) ?? /* @__PURE__ */ new Set();
    propTypes.set(property, /* @__PURE__ */ new Set([...set, ...type]));
  };
  const getTypes = () => {
    const map = /* @__PURE__ */ new Map();
    for (const [prop, values] of propTypes.entries()) {
      if (values.size === 0) {
        map.set(prop, ["string"]);
        continue;
      }
      const typeValues = Array.from(values).map((key) => {
        if (key.startsWith("CssProperties")) return key;
        if (key.startsWith("type:")) return key.replace("type:", "");
        return JSON.stringify(key);
      });
      map.set(prop, typeValues);
    }
    return map;
  };
  const getPropertyValues = (config, resolveFn) => {
    const { values } = config;
    const fn = (key) => {
      const value = resolveFn?.(key);
      return value ? { [value]: value } : void 0;
    };
    if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_2__.isString)(values)) {
      return fn?.(values) ?? tokens.getCategoryValues(values) ?? {};
    }
    if (Array.isArray(values)) {
      return values.reduce((result, value) => {
        result[value] = value;
        return result;
      }, {});
    }
    if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_2__.isFunction)(values)) {
      return values(resolveFn ? fn : tokens.getCategoryValues);
    }
    return values;
  };
  const defaultTransform = (0,_utils_memo_js__WEBPACK_IMPORTED_MODULE_1__.memo)((prop, value) => {
    return {
      [prop]: prop.startsWith("--") ? tokens.getVar(value, value) : value
    };
  });
  const tokenFn = Object.assign(tokens.getVar, {
    raw: (path) => tokens.getByName(path)
  });
  const transform = (0,_utils_memo_js__WEBPACK_IMPORTED_MODULE_1__.memo)((prop, raw) => {
    const key = resolveShorthand(prop);
    if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_2__.isString)(raw) && !raw.includes("_EMO_")) {
      raw = tokens.expandReferenceInValue(raw);
    }
    const config = configs[key];
    if (!config) {
      return defaultTransform(key, raw);
    }
    const value = propValues.get(key)?.[raw];
    if (!config.transform) {
      return defaultTransform(prop, value ?? raw);
    }
    const _colorMix = (value2) => (0,_color_mix_js__WEBPACK_IMPORTED_MODULE_3__.colorMix)(value2, tokenFn);
    return config.transform(value ?? raw, {
      raw,
      token: tokenFn,
      utils: { colorMix: _colorMix }
    });
  });
  function build() {
    assignShorthands();
    assignColorPaletteProperty();
    assignProperties();
    assignPropertyTypes();
  }
  build();
  const hasShorthand = shorthands.size > 0;
  const resolveShorthand = (0,_utils_memo_js__WEBPACK_IMPORTED_MODULE_1__.memo)((prop) => {
    return shorthands.get(prop) ?? prop;
  });
  const keys = () => {
    return [...Array.from(shorthands.keys()), ...Object.keys(configs)];
  };
  const instance = {
    keys,
    hasShorthand,
    transform,
    shorthands,
    resolveShorthand,
    register,
    getTypes,
    addPropertyType
  };
  return instance;
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/breakpoints.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/breakpoints.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   breakpoints: () => (/* binding */ breakpoints)
/* harmony export */ });

const breakpoints = {
  sm: "480px",
  md: "768px",
  lg: "1024px",
  xl: "1280px",
  "2xl": "1536px"
};




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/global-css.js":
/*!********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/global-css.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   globalCss: () => (/* binding */ globalCss)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const empty = "var(--chakra-empty,/*!*/ /*!*/)";
const globalCss = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineGlobalStyles)({
  "*": {
    fontFeatureSettings: '"cv11"',
    "--ring-inset": empty,
    "--ring-offset-width": "0px",
    "--ring-offset-color": "#fff",
    "--ring-color": "rgba(66, 153, 225, 0.6)",
    "--ring-offset-shadow": "0 0 #0000",
    "--ring-shadow": "0 0 #0000",
    ...Object.fromEntries(
      [
        "brightness",
        "contrast",
        "grayscale",
        "hue-rotate",
        "invert",
        "saturate",
        "sepia",
        "drop-shadow"
      ].map((prop) => [`--${prop}`, empty])
    ),
    ...Object.fromEntries(
      [
        "blur",
        "brightness",
        "contrast",
        "grayscale",
        "hue-rotate",
        "invert",
        "opacity",
        "saturate",
        "sepia"
      ].map((prop) => [`--backdrop-${prop}`, empty])
    ),
    "--global-font-mono": "fonts.mono",
    "--global-font-body": "fonts.body",
    "--global-color-border": "colors.border"
  },
  html: {
    color: "fg",
    bg: "bg",
    lineHeight: "1.5",
    colorPalette: "gray"
  },
  "*::placeholder, *[data-placeholder]": {
    color: "fg.muted/80"
  },
  "*::selection": {
    bg: "colorPalette.emphasized/80"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultThemeConfig: () => (/* binding */ defaultThemeConfig)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _breakpoints_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./breakpoints.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/breakpoints.js");
/* harmony import */ var _global_css_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global-css.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/global-css.js");
/* harmony import */ var _layer_styles_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./layer-styles.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/layer-styles.js");
/* harmony import */ var _motion_styles_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./motion-styles.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/motion-styles.js");
/* harmony import */ var _recipes_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./recipes.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes.js");
/* harmony import */ var _semantic_tokens_colors_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./semantic-tokens/colors.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/colors.js");
/* harmony import */ var _semantic_tokens_radii_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./semantic-tokens/radii.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/radii.js");
/* harmony import */ var _semantic_tokens_shadows_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./semantic-tokens/shadows.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/shadows.js");
/* harmony import */ var _slot_recipes_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./slot-recipes.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/slot-recipes.js");
/* harmony import */ var _text_styles_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./text-styles.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/text-styles.js");
/* harmony import */ var _tokens_animations_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tokens/animations.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/animations.js");
/* harmony import */ var _tokens_aspect_ratios_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tokens/aspect-ratios.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/aspect-ratios.js");
/* harmony import */ var _tokens_blurs_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tokens/blurs.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/blurs.js");
/* harmony import */ var _tokens_borders_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tokens/borders.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/borders.js");
/* harmony import */ var _tokens_colors_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tokens/colors.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/colors.js");
/* harmony import */ var _tokens_cursor_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./tokens/cursor.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/cursor.js");
/* harmony import */ var _tokens_durations_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./tokens/durations.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/durations.js");
/* harmony import */ var _tokens_easings_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./tokens/easings.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/easings.js");
/* harmony import */ var _tokens_font_sizes_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./tokens/font-sizes.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/font-sizes.js");
/* harmony import */ var _tokens_font_weights_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./tokens/font-weights.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/font-weights.js");
/* harmony import */ var _tokens_fonts_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./tokens/fonts.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/fonts.js");
/* harmony import */ var _tokens_keyframes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tokens/keyframes.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/keyframes.js");
/* harmony import */ var _tokens_letter_spacing_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./tokens/letter-spacing.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/letter-spacing.js");
/* harmony import */ var _tokens_line_heights_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./tokens/line-heights.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/line-heights.js");
/* harmony import */ var _tokens_radius_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./tokens/radius.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/radius.js");
/* harmony import */ var _tokens_sizes_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./tokens/sizes.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/sizes.js");
/* harmony import */ var _tokens_spacing_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./tokens/spacing.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/spacing.js");
/* harmony import */ var _tokens_z_indices_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./tokens/z-indices.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/z-indices.js");































const defaultThemeConfig = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineConfig)({
  preflight: true,
  cssVarsPrefix: "chakra",
  cssVarsRoot: ":where(html, .chakra-theme)",
  globalCss: _global_css_js__WEBPACK_IMPORTED_MODULE_1__.globalCss,
  theme: {
    breakpoints: _breakpoints_js__WEBPACK_IMPORTED_MODULE_2__.breakpoints,
    keyframes: _tokens_keyframes_js__WEBPACK_IMPORTED_MODULE_3__.keyframes,
    tokens: {
      aspectRatios: _tokens_aspect_ratios_js__WEBPACK_IMPORTED_MODULE_4__.aspectRatios,
      animations: _tokens_animations_js__WEBPACK_IMPORTED_MODULE_5__.animations,
      blurs: _tokens_blurs_js__WEBPACK_IMPORTED_MODULE_6__.blurs,
      borders: _tokens_borders_js__WEBPACK_IMPORTED_MODULE_7__.borders,
      colors: _tokens_colors_js__WEBPACK_IMPORTED_MODULE_8__.colors,
      durations: _tokens_durations_js__WEBPACK_IMPORTED_MODULE_9__.durations,
      easings: _tokens_easings_js__WEBPACK_IMPORTED_MODULE_10__.easings,
      fonts: _tokens_fonts_js__WEBPACK_IMPORTED_MODULE_11__.fonts,
      fontSizes: _tokens_font_sizes_js__WEBPACK_IMPORTED_MODULE_12__.fontSizes,
      fontWeights: _tokens_font_weights_js__WEBPACK_IMPORTED_MODULE_13__.fontWeights,
      letterSpacings: _tokens_letter_spacing_js__WEBPACK_IMPORTED_MODULE_14__.letterSpacings,
      lineHeights: _tokens_line_heights_js__WEBPACK_IMPORTED_MODULE_15__.lineHeights,
      radii: _tokens_radius_js__WEBPACK_IMPORTED_MODULE_16__.radii,
      spacing: _tokens_spacing_js__WEBPACK_IMPORTED_MODULE_17__.spacing,
      sizes: _tokens_sizes_js__WEBPACK_IMPORTED_MODULE_18__.sizes,
      zIndex: _tokens_z_indices_js__WEBPACK_IMPORTED_MODULE_19__.zIndices,
      cursor: _tokens_cursor_js__WEBPACK_IMPORTED_MODULE_20__.cursor
    },
    semanticTokens: {
      colors: _semantic_tokens_colors_js__WEBPACK_IMPORTED_MODULE_21__.semanticColors,
      shadows: _semantic_tokens_shadows_js__WEBPACK_IMPORTED_MODULE_22__.semanticShadows,
      radii: _semantic_tokens_radii_js__WEBPACK_IMPORTED_MODULE_23__.semanticRadii
    },
    recipes: _recipes_js__WEBPACK_IMPORTED_MODULE_24__.recipes,
    slotRecipes: _slot_recipes_js__WEBPACK_IMPORTED_MODULE_25__.slotRecipes,
    textStyles: _text_styles_js__WEBPACK_IMPORTED_MODULE_26__.textStyles,
    layerStyles: _layer_styles_js__WEBPACK_IMPORTED_MODULE_27__.layerStyles,
    animationStyles: _motion_styles_js__WEBPACK_IMPORTED_MODULE_28__.animationStyles
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/layer-styles.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/layer-styles.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   layerStyles: () => (/* binding */ layerStyles)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const layerStyles = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineLayerStyles)({
  // fill: some background color + color combination
  "fill.muted": {
    value: {
      background: "colorPalette.muted",
      color: "colorPalette.fg"
    }
  },
  "fill.subtle": {
    value: {
      background: "colorPalette.subtle",
      color: "colorPalette.fg"
    }
  },
  "fill.surface": {
    value: {
      background: "colorPalette.subtle",
      color: "colorPalette.fg",
      boxShadow: "0 0 0px 1px var(--shadow-color)",
      boxShadowColor: "colorPalette.muted"
    }
  },
  "fill.solid": {
    value: {
      background: "colorPalette.solid",
      color: "colorPalette.contrast"
    }
  },
  // outline: some border color + color combination
  "outline.subtle": {
    value: {
      color: "colorPalette.fg",
      boxShadow: "inset 0 0 0px 1px var(--shadow-color)",
      boxShadowColor: "colorPalette.subtle"
    }
  },
  "outline.solid": {
    value: {
      borderWidth: "1px",
      borderColor: "colorPalette.solid",
      color: "colorPalette.fg"
    }
  },
  // indicator: floating border color or left/bottom border
  "indicator.bottom": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        bottom: "var(--indicator-offset-y, 0)",
        insetInline: "var(--indicator-offset-x, 0)",
        height: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.top": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        top: "var(--indicator-offset-y, 0)",
        insetInline: "var(--indicator-offset-x, 0)",
        height: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.start": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        insetInlineStart: "var(--indicator-offset-x, 0)",
        insetBlock: "var(--indicator-offset-y, 0)",
        width: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.end": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        insetInlineEnd: "var(--indicator-offset-x, 0)",
        insetBlock: "var(--indicator-offset-y, 0)",
        width: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  disabled: {
    value: {
      opacity: "0.5",
      cursor: "not-allowed"
    }
  },
  none: {
    value: {}
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/motion-styles.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/motion-styles.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   animationStyles: () => (/* binding */ animationStyles)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const animationStyles = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineAnimationStyles)({
  "slide-fade-in": {
    value: {
      transformOrigin: "var(--transform-origin)",
      "&[data-placement^=top]": {
        animationName: "slide-from-bottom, fade-in"
      },
      "&[data-placement^=bottom]": {
        animationName: "slide-from-top, fade-in"
      },
      "&[data-placement^=left]": {
        animationName: "slide-from-right, fade-in"
      },
      "&[data-placement^=right]": {
        animationName: "slide-from-left, fade-in"
      }
    }
  },
  "slide-fade-out": {
    value: {
      transformOrigin: "var(--transform-origin)",
      "&[data-placement^=top]": {
        animationName: "slide-to-bottom, fade-out"
      },
      "&[data-placement^=bottom]": {
        animationName: "slide-to-top, fade-out"
      },
      "&[data-placement^=left]": {
        animationName: "slide-to-right, fade-out"
      },
      "&[data-placement^=right]": {
        animationName: "slide-to-left, fade-out"
      }
    }
  },
  "scale-fade-in": {
    value: {
      transformOrigin: "var(--transform-origin)",
      animationName: "scale-in, fade-in"
    }
  },
  "scale-fade-out": {
    value: {
      transformOrigin: "var(--transform-origin)",
      animationName: "scale-out, fade-out"
    }
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   recipes: () => (/* binding */ recipes)
/* harmony export */ });
/* harmony import */ var _recipes_badge_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./recipes/badge.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/badge.js");
/* harmony import */ var _recipes_button_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./recipes/button.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/button.js");
/* harmony import */ var _recipes_checkmark_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./recipes/checkmark.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkmark.js");
/* harmony import */ var _recipes_code_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./recipes/code.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/code.js");
/* harmony import */ var _recipes_color_swatch_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./recipes/color-swatch.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/color-swatch.js");
/* harmony import */ var _recipes_container_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./recipes/container.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/container.js");
/* harmony import */ var _recipes_heading_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./recipes/heading.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/heading.js");
/* harmony import */ var _recipes_icon_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./recipes/icon.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/icon.js");
/* harmony import */ var _recipes_input_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./recipes/input.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/input.js");
/* harmony import */ var _recipes_input_addon_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./recipes/input-addon.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/input-addon.js");
/* harmony import */ var _recipes_kbd_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./recipes/kbd.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/kbd.js");
/* harmony import */ var _recipes_link_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./recipes/link.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/link.js");
/* harmony import */ var _recipes_mark_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./recipes/mark.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/mark.js");
/* harmony import */ var _recipes_radiomark_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./recipes/radiomark.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/radiomark.js");
/* harmony import */ var _recipes_separator_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./recipes/separator.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/separator.js");
/* harmony import */ var _recipes_skeleton_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./recipes/skeleton.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/skeleton.js");
/* harmony import */ var _recipes_skip_nav_link_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./recipes/skip-nav-link.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/skip-nav-link.js");
/* harmony import */ var _recipes_spinner_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./recipes/spinner.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/spinner.js");
/* harmony import */ var _recipes_textarea_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./recipes/textarea.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/textarea.js");





















const recipes = {
  badge: _recipes_badge_js__WEBPACK_IMPORTED_MODULE_0__.badgeRecipe,
  button: _recipes_button_js__WEBPACK_IMPORTED_MODULE_1__.buttonRecipe,
  code: _recipes_code_js__WEBPACK_IMPORTED_MODULE_2__.codeRecipe,
  container: _recipes_container_js__WEBPACK_IMPORTED_MODULE_3__.containerRecipe,
  heading: _recipes_heading_js__WEBPACK_IMPORTED_MODULE_4__.headingRecipe,
  input: _recipes_input_js__WEBPACK_IMPORTED_MODULE_5__.inputRecipe,
  inputAddon: _recipes_input_addon_js__WEBPACK_IMPORTED_MODULE_6__.inputAddonRecipe,
  kbd: _recipes_kbd_js__WEBPACK_IMPORTED_MODULE_7__.kbdRecipe,
  link: _recipes_link_js__WEBPACK_IMPORTED_MODULE_8__.linkRecipe,
  mark: _recipes_mark_js__WEBPACK_IMPORTED_MODULE_9__.markRecipe,
  separator: _recipes_separator_js__WEBPACK_IMPORTED_MODULE_10__.separatorRecipe,
  skeleton: _recipes_skeleton_js__WEBPACK_IMPORTED_MODULE_11__.skeletonRecipe,
  skipNavLink: _recipes_skip_nav_link_js__WEBPACK_IMPORTED_MODULE_12__.skipNavLinkRecipe,
  spinner: _recipes_spinner_js__WEBPACK_IMPORTED_MODULE_13__.spinnerRecipe,
  textarea: _recipes_textarea_js__WEBPACK_IMPORTED_MODULE_14__.textareaRecipe,
  icon: _recipes_icon_js__WEBPACK_IMPORTED_MODULE_15__.iconRecipe,
  checkmark: _recipes_checkmark_js__WEBPACK_IMPORTED_MODULE_16__.checkmarkRecipe,
  radiomark: _recipes_radiomark_js__WEBPACK_IMPORTED_MODULE_17__.radiomarkRecipe,
  colorSwatch: _recipes_color_swatch_js__WEBPACK_IMPORTED_MODULE_18__.colorSwatchRecipe
};




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/accordion.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/accordion.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   accordionSlotRecipe: () => (/* binding */ accordionSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const accordionSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-accordion",
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.accordionAnatomy.keys(),
  base: {
    root: {
      width: "full",
      "--accordion-radius": "radii.l2"
    },
    item: {
      overflowAnchor: "none"
    },
    itemTrigger: {
      display: "flex",
      alignItems: "center",
      textAlign: "start",
      width: "full",
      outline: "0",
      gap: "3",
      fontWeight: "medium",
      borderRadius: "var(--accordion-radius)",
      _focusVisible: {
        outline: "2px solid",
        outlineColor: "colorPalette.focusRing"
      },
      _disabled: {
        layerStyle: "disabled"
      }
    },
    itemBody: {
      pt: "var(--accordion-padding-y)",
      pb: "calc(var(--accordion-padding-y) * 2)"
    },
    itemContent: {
      overflow: "hidden",
      borderRadius: "var(--accordion-radius)",
      _open: {
        animationName: "expand-height, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "collapse-height, fade-out",
        animationDuration: "moderate"
      }
    },
    itemIndicator: {
      transition: "rotate 0.2s",
      transformOrigin: "center",
      color: "fg.subtle",
      _open: {
        rotate: "180deg"
      },
      _icon: {
        width: "1.2em",
        height: "1.2em"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        item: {
          borderBottomWidth: "1px"
        }
      },
      subtle: {
        itemTrigger: {
          px: "var(--accordion-padding-x)"
        },
        itemContent: {
          px: "var(--accordion-padding-x)"
        },
        item: {
          borderRadius: "var(--accordion-radius)",
          _open: {
            bg: "colorPalette.subtle"
          }
        }
      },
      enclosed: {
        root: {
          borderWidth: "1px",
          borderRadius: "var(--accordion-radius)",
          divideY: "1px",
          overflow: "hidden"
        },
        itemTrigger: {
          px: "var(--accordion-padding-x)"
        },
        itemContent: {
          px: "var(--accordion-padding-x)"
        },
        item: {
          _open: {
            bg: "bg.subtle"
          }
        }
      },
      plain: {}
    },
    size: {
      sm: {
        root: {
          "--accordion-padding-x": "spacing.3",
          "--accordion-padding-y": "spacing.2"
        },
        itemTrigger: {
          textStyle: "sm",
          py: "var(--accordion-padding-y)"
        }
      },
      md: {
        root: {
          "--accordion-padding-x": "spacing.4",
          "--accordion-padding-y": "spacing.2"
        },
        itemTrigger: {
          textStyle: "md",
          py: "var(--accordion-padding-y)"
        }
      },
      lg: {
        root: {
          "--accordion-padding-x": "spacing.4.5",
          "--accordion-padding-y": "spacing.2.5"
        },
        itemTrigger: {
          textStyle: "lg",
          py: "var(--accordion-padding-y)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/action-bar.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/action-bar.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   actionBarSlotRecipe: () => (/* binding */ actionBarSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const actionBarSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-action-bar",
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.actionBarAnatomy.keys(),
  base: {
    positioner: {
      position: "fixed",
      display: "flex",
      justifyContent: "center",
      pointerEvents: "none",
      insetInline: "0",
      top: "unset",
      bottom: "calc(env(safe-area-inset-bottom) + 20px)"
    },
    content: {
      bg: "bg.panel",
      shadow: "md",
      display: "flex",
      alignItems: "center",
      gap: "3",
      borderRadius: "l3",
      py: "2.5",
      px: "3",
      pointerEvents: "auto",
      // Stabilize the position of the action bar when the scrollbar is hidden
      // by using the scrollbar width to offset the position.
      translate: "calc(-1 * var(--scrollbar-width) / 2) 0px",
      _open: {
        animationName: "slide-from-bottom, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "slide-to-bottom, fade-out",
        animationDuration: "faster"
      }
    },
    separator: {
      width: "1px",
      height: "5",
      bg: "border"
    },
    selectionTrigger: {
      display: "inline-flex",
      alignItems: "center",
      gap: "2",
      alignSelf: "stretch",
      textStyle: "sm",
      px: "4",
      py: "1",
      borderRadius: "l2",
      borderWidth: "1px",
      borderStyle: "dashed"
    }
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/alert.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/alert.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   alertSlotRecipe: () => (/* binding */ alertSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const alertSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.alertAnatomy.keys(),
  className: "chakra-alert",
  base: {
    root: {
      width: "full",
      display: "flex",
      alignItems: "flex-start",
      position: "relative",
      borderRadius: "l3"
    },
    title: {
      fontWeight: "medium"
    },
    description: {
      display: "inline"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0",
      width: "1em",
      height: "1em",
      _icon: { boxSize: "full" }
    },
    content: {
      display: "flex",
      flex: "1",
      gap: "1"
    }
  },
  variants: {
    status: {
      info: {
        root: { colorPalette: "blue" }
      },
      warning: {
        root: { colorPalette: "orange" }
      },
      success: {
        root: { colorPalette: "green" }
      },
      error: {
        root: { colorPalette: "red" }
      },
      neutral: {
        root: { colorPalette: "gray" }
      }
    },
    inline: {
      true: {
        content: {
          display: "inline-flex",
          flexDirection: "row",
          alignItems: "center"
        }
      },
      false: {
        content: {
          display: "flex",
          flexDirection: "column"
        }
      }
    },
    variant: {
      subtle: {
        root: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg"
        }
      },
      surface: {
        root: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg",
          shadow: "inset 0 0 0px 1px var(--shadow-color)",
          shadowColor: "colorPalette.muted"
        },
        indicator: {
          color: "colorPalette.fg"
        }
      },
      outline: {
        root: {
          color: "colorPalette.fg",
          shadow: "inset 0 0 0px 1px var(--shadow-color)",
          shadowColor: "colorPalette.muted"
        },
        indicator: {
          color: "colorPalette.fg"
        }
      },
      solid: {
        root: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        },
        indicator: {
          color: "colorPalette.contrast"
        }
      }
    },
    size: {
      sm: {
        root: {
          gap: "2",
          px: "3",
          py: "3",
          textStyle: "xs"
        },
        indicator: {
          textStyle: "lg"
        }
      },
      md: {
        root: {
          gap: "3",
          px: "4",
          py: "4",
          textStyle: "sm"
        },
        indicator: {
          textStyle: "xl"
        }
      },
      lg: {
        root: {
          gap: "3",
          px: "4",
          py: "4",
          textStyle: "md"
        },
        indicator: {
          textStyle: "2xl"
        }
      }
    }
  },
  defaultVariants: {
    status: "info",
    variant: "subtle",
    size: "md",
    inline: false
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/avatar.js":
/*!************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/avatar.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   avatarSlotRecipe: () => (/* binding */ avatarSlotRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _ark_ui_react_avatar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ark-ui/react/avatar */ "./node_modules/@zag-js/avatar/dist/index.mjs");




const avatarSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  slots: _ark_ui_react_avatar__WEBPACK_IMPORTED_MODULE_1__.anatomy.keys(),
  className: "chakra-avatar",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      fontWeight: "medium",
      position: "relative",
      verticalAlign: "top",
      flexShrink: "0",
      userSelect: "none",
      width: "var(--avatar-size)",
      height: "var(--avatar-size)",
      fontSize: "var(--avatar-font-size)",
      borderRadius: "var(--avatar-radius)",
      "&[data-group-item]": {
        borderWidth: "2px",
        borderColor: "bg"
      }
    },
    image: {
      width: "100%",
      height: "100%",
      objectFit: "cover",
      borderRadius: "var(--avatar-radius)"
    },
    fallback: {
      lineHeight: "1",
      textTransform: "uppercase",
      fontWeight: "medium",
      fontSize: "var(--avatar-font-size)",
      borderRadius: "var(--avatar-radius)"
    }
  },
  variants: {
    size: {
      full: {
        root: {
          "--avatar-size": "100%",
          "--avatar-font-size": "100%"
        }
      },
      "2xs": {
        root: {
          "--avatar-font-size": "fontSizes.2xs",
          "--avatar-size": "sizes.6"
        }
      },
      xs: {
        root: {
          "--avatar-font-size": "fontSizes.xs",
          "--avatar-size": "sizes.8"
        }
      },
      sm: {
        root: {
          "--avatar-font-size": "fontSizes.sm",
          "--avatar-size": "sizes.9"
        }
      },
      md: {
        root: {
          "--avatar-font-size": "fontSizes.md",
          "--avatar-size": "sizes.10"
        }
      },
      lg: {
        root: {
          "--avatar-font-size": "fontSizes.md",
          "--avatar-size": "sizes.11"
        }
      },
      xl: {
        root: {
          "--avatar-font-size": "fontSizes.lg",
          "--avatar-size": "sizes.12"
        }
      },
      "2xl": {
        root: {
          "--avatar-font-size": "fontSizes.xl",
          "--avatar-size": "sizes.16"
        }
      }
    },
    variant: {
      solid: {
        root: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        }
      },
      subtle: {
        root: {
          bg: "colorPalette.muted",
          color: "colorPalette.fg"
        }
      },
      outline: {
        root: {
          color: "colorPalette.fg",
          borderWidth: "1px",
          borderColor: "colorPalette.muted"
        }
      }
    },
    shape: {
      square: {},
      rounded: {
        root: { "--avatar-radius": "radii.l3" }
      },
      full: {
        root: { "--avatar-radius": "radii.full" }
      }
    },
    borderless: {
      true: {
        root: {
          "&[data-group-item]": {
            borderWidth: "0px"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    shape: "full",
    variant: "subtle"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/badge.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/badge.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   badgeRecipe: () => (/* binding */ badgeRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const badgeRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineRecipe)({
  className: "chakra-badge",
  base: {
    display: "inline-flex",
    alignItems: "center",
    borderRadius: "l2",
    gap: "1",
    fontWeight: "medium",
    fontVariantNumeric: "tabular-nums",
    whiteSpace: "nowrap",
    userSelect: "none"
  },
  variants: {
    variant: {
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast"
      },
      subtle: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg"
      },
      outline: {
        color: "colorPalette.fg",
        shadow: "inset 0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted"
      },
      surface: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        shadow: "inset 0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted"
      },
      plain: {
        color: "colorPalette.fg"
      }
    },
    size: {
      xs: {
        textStyle: "2xs",
        px: "1",
        minH: "4"
      },
      sm: {
        textStyle: "xs",
        px: "1.5",
        minH: "5"
      },
      md: {
        textStyle: "sm",
        px: "2",
        minH: "6"
      },
      lg: {
        textStyle: "sm",
        px: "2.5",
        minH: "7"
      }
    }
  },
  defaultVariants: {
    variant: "subtle",
    size: "sm"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/blockquote.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/blockquote.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   blockquoteSlotRecipe: () => (/* binding */ blockquoteSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const blockquoteSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-blockquote",
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.blockquoteAnatomy.keys(),
  base: {
    root: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      gap: "2"
    },
    caption: {
      textStyle: "sm",
      color: "fg.muted"
    },
    icon: {
      boxSize: "5"
    }
  },
  variants: {
    justify: {
      start: {
        root: {
          alignItems: "flex-start",
          textAlign: "start"
        }
      },
      center: {
        root: {
          alignItems: "center",
          textAlign: "center"
        }
      },
      end: {
        root: {
          alignItems: "flex-end",
          textAlign: "end"
        }
      }
    },
    variant: {
      subtle: {
        root: {
          paddingX: "5",
          borderStartWidth: "4px",
          borderStartColor: "colorPalette.muted"
        },
        icon: {
          color: "colorPalette.fg"
        }
      },
      solid: {
        root: {
          paddingX: "5",
          borderStartWidth: "4px",
          borderStartColor: "colorPalette.solid"
        },
        icon: {
          color: "colorPalette.solid"
        }
      },
      plain: {
        root: {
          paddingX: "5"
        },
        icon: {
          color: "colorPalette.solid"
        }
      }
    }
  },
  defaultVariants: {
    variant: "subtle",
    justify: "start"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/breadcrumb.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/breadcrumb.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   breadcrumbSlotRecipe: () => (/* binding */ breadcrumbSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const breadcrumbSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-breadcrumb",
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.breadcrumbAnatomy.keys(),
  base: {
    list: {
      display: "flex",
      alignItems: "center",
      wordBreak: "break-word",
      color: "fg.muted",
      listStyle: "none"
    },
    link: {
      outline: "0",
      textDecoration: "none",
      borderRadius: "l1",
      focusRing: "outside",
      display: "inline-flex",
      alignItems: "center",
      gap: "2"
    },
    item: {
      display: "inline-flex",
      alignItems: "center"
    },
    separator: {
      color: "fg.muted",
      opacity: "0.8",
      _icon: {
        boxSize: "1em"
      },
      _rtl: {
        rotate: "180deg"
      }
    },
    ellipsis: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      _icon: {
        boxSize: "1em"
      }
    }
  },
  variants: {
    variant: {
      underline: {
        link: {
          color: "colorPalette.fg",
          textDecoration: "underline",
          textUnderlineOffset: "0.2em",
          textDecorationColor: "colorPalette.muted"
        },
        currentLink: {
          color: "colorPalette.fg"
        }
      },
      plain: {
        link: {
          color: "fg.muted",
          _hover: { color: "fg" }
        },
        currentLink: {
          color: "fg"
        }
      }
    },
    size: {
      sm: {
        list: {
          gap: "1",
          textStyle: "xs"
        }
      },
      md: {
        list: {
          gap: "1.5",
          textStyle: "sm"
        }
      },
      lg: {
        list: {
          gap: "2",
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    variant: "plain",
    size: "md"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/button.js":
/*!************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/button.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buttonRecipe: () => (/* binding */ buttonRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const buttonRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineRecipe)({
  className: "chakra-button",
  base: {
    display: "inline-flex",
    appearance: "none",
    alignItems: "center",
    justifyContent: "center",
    userSelect: "none",
    position: "relative",
    borderRadius: "l2",
    whiteSpace: "nowrap",
    verticalAlign: "middle",
    borderWidth: "1px",
    borderColor: "transparent",
    cursor: "button",
    flexShrink: "0",
    outline: "0",
    lineHeight: "1.2",
    isolation: "isolate",
    fontWeight: "medium",
    transitionProperty: "common",
    transitionDuration: "moderate",
    focusVisibleRing: "outside",
    _disabled: {
      layerStyle: "disabled"
    },
    _icon: {
      flexShrink: "0"
    }
  },
  variants: {
    size: {
      "2xs": {
        h: "6",
        minW: "6",
        textStyle: "xs",
        px: "2",
        gap: "1",
        _icon: {
          width: "3.5",
          height: "3.5"
        }
      },
      xs: {
        h: "8",
        minW: "8",
        textStyle: "xs",
        px: "2.5",
        gap: "1",
        _icon: {
          width: "4",
          height: "4"
        }
      },
      sm: {
        h: "9",
        minW: "9",
        px: "3.5",
        textStyle: "sm",
        gap: "2",
        _icon: {
          width: "4",
          height: "4"
        }
      },
      md: {
        h: "10",
        minW: "10",
        textStyle: "sm",
        px: "4",
        gap: "2",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      lg: {
        h: "11",
        minW: "11",
        textStyle: "md",
        px: "5",
        gap: "3",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      xl: {
        h: "12",
        minW: "12",
        textStyle: "md",
        px: "5",
        gap: "2.5",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      "2xl": {
        h: "16",
        minW: "16",
        textStyle: "lg",
        px: "7",
        gap: "3",
        _icon: {
          width: "6",
          height: "6"
        }
      }
    },
    variant: {
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast",
        borderColor: "transparent",
        _hover: {
          bg: "colorPalette.solid/90"
        },
        _expanded: {
          bg: "colorPalette.solid/90"
        }
      },
      subtle: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        borderColor: "transparent",
        _hover: {
          bg: "colorPalette.muted"
        },
        _expanded: {
          bg: "colorPalette.muted"
        }
      },
      surface: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        shadow: "0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted",
        _hover: {
          bg: "colorPalette.muted"
        },
        _expanded: {
          bg: "colorPalette.muted"
        }
      },
      outline: {
        borderWidth: "1px",
        borderColor: "colorPalette.muted",
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.subtle"
        },
        _expanded: {
          bg: "colorPalette.subtle"
        }
      },
      ghost: {
        bg: "transparent",
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.subtle"
        },
        _expanded: {
          bg: "colorPalette.subtle"
        }
      },
      plain: {
        color: "colorPalette.fg"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/card.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/card.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cardSlotRecipe: () => (/* binding */ cardSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const cardSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-card",
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.cardAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      minWidth: "0",
      wordWrap: "break-word",
      borderRadius: "l3",
      color: "fg",
      textAlign: "start"
    },
    title: {
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted",
      fontSize: "sm"
    },
    header: {
      paddingInline: "var(--card-padding)",
      paddingTop: "var(--card-padding)",
      display: "flex",
      flexDirection: "column",
      gap: "1.5"
    },
    body: {
      padding: "var(--card-padding)",
      flex: "1",
      display: "flex",
      flexDirection: "column"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      gap: "2",
      paddingInline: "var(--card-padding)",
      paddingBottom: "var(--card-padding)"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          "--card-padding": "spacing.4"
        },
        title: {
          textStyle: "md"
        }
      },
      md: {
        root: {
          "--card-padding": "spacing.6"
        },
        title: {
          textStyle: "lg"
        }
      },
      lg: {
        root: {
          "--card-padding": "spacing.7"
        },
        title: {
          textStyle: "xl"
        }
      }
    },
    variant: {
      elevated: {
        root: {
          bg: "bg.panel",
          boxShadow: "md"
        }
      },
      outline: {
        root: {
          bg: "bg.panel",
          borderWidth: "1px",
          borderColor: "border"
        }
      },
      subtle: {
        root: {
          bg: "bg.muted"
        }
      }
    }
  },
  defaultVariants: {
    variant: "outline",
    size: "md"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkbox-card.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkbox-card.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkboxCardSlotRecipe: () => (/* binding */ checkboxCardSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _checkmark_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./checkmark.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkmark.js");





const checkboxCardSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.checkboxCardAnatomy.keys(),
  className: "chakra-checkbox-card",
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      userSelect: "none",
      position: "relative",
      borderRadius: "l2",
      flex: "1",
      focusVisibleRing: "outside",
      _disabled: {
        opacity: "0.8"
      },
      _invalid: {
        outline: "2px solid",
        outlineColor: "border.error"
      }
    },
    control: {
      display: "inline-flex",
      flex: "1",
      position: "relative",
      borderRadius: "inherit",
      justifyContent: "var(--checkbox-card-justify)",
      alignItems: "var(--checkbox-card-align)"
    },
    label: {
      fontWeight: "medium",
      display: "flex",
      alignItems: "center",
      gap: "2",
      flex: "1",
      _disabled: {
        opacity: "0.5"
      }
    },
    description: {
      opacity: "0.64",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    },
    addon: {
      _disabled: {
        opacity: "0.5"
      }
    },
    indicator: _checkmark_js__WEBPACK_IMPORTED_MODULE_2__.checkmarkRecipe.base,
    content: {
      display: "flex",
      flexDirection: "column",
      flex: "1",
      gap: "1",
      justifyContent: "var(--checkbox-card-justify)",
      alignItems: "var(--checkbox-card-align)"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        control: {
          padding: "3",
          gap: "1.5"
        },
        addon: {
          px: "3",
          py: "1.5",
          borderTopWidth: "1px"
        },
        indicator: _checkmark_js__WEBPACK_IMPORTED_MODULE_2__.checkmarkRecipe.variants?.size.sm
      },
      md: {
        root: {
          textStyle: "sm"
        },
        control: {
          padding: "4",
          gap: "2.5"
        },
        addon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        indicator: _checkmark_js__WEBPACK_IMPORTED_MODULE_2__.checkmarkRecipe.variants?.size.md
      },
      lg: {
        root: {
          textStyle: "md"
        },
        control: {
          padding: "4",
          gap: "3.5"
        },
        addon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        indicator: _checkmark_js__WEBPACK_IMPORTED_MODULE_2__.checkmarkRecipe.variants?.size.lg
      }
    },
    variant: {
      surface: {
        root: {
          borderWidth: "1px",
          borderColor: "border",
          _checked: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg",
            borderColor: "colorPalette.muted"
          },
          _disabled: {
            bg: "bg.muted"
          }
        },
        indicator: _checkmark_js__WEBPACK_IMPORTED_MODULE_2__.checkmarkRecipe.variants?.variant.solid
      },
      subtle: {
        root: {
          bg: "bg.muted"
        },
        control: {
          _checked: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          }
        },
        indicator: _checkmark_js__WEBPACK_IMPORTED_MODULE_2__.checkmarkRecipe.variants?.variant.plain
      },
      outline: {
        root: {
          borderWidth: "1px",
          borderColor: "border",
          _checked: {
            boxShadow: "0 0 0 1px var(--shadow-color)",
            boxShadowColor: "colorPalette.solid",
            borderColor: "colorPalette.solid"
          }
        },
        indicator: _checkmark_js__WEBPACK_IMPORTED_MODULE_2__.checkmarkRecipe.variants?.variant.solid
      },
      solid: {
        root: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast",
            borderColor: "colorPalette.solid"
          }
        },
        indicator: _checkmark_js__WEBPACK_IMPORTED_MODULE_2__.checkmarkRecipe.variants?.variant.inverted
      }
    },
    justify: {
      start: {
        root: { "--checkbox-card-justify": "flex-start" }
      },
      end: {
        root: { "--checkbox-card-justify": "flex-end" }
      },
      center: {
        root: { "--checkbox-card-justify": "center" }
      }
    },
    align: {
      start: {
        root: { "--checkbox-card-align": "flex-start" },
        content: { textAlign: "start" }
      },
      end: {
        root: { "--checkbox-card-align": "flex-end" },
        content: { textAlign: "end" }
      },
      center: {
        root: { "--checkbox-card-align": "center" },
        content: { textAlign: "center" }
      }
    },
    orientation: {
      vertical: {
        control: { flexDirection: "column" }
      },
      horizontal: {
        control: { flexDirection: "row" }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    align: "start",
    orientation: "horizontal"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkbox.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkbox.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkboxSlotRecipe: () => (/* binding */ checkboxSlotRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _checkmark_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./checkmark.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkmark.js");
/* harmony import */ var _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ark-ui/react/checkbox */ "./node_modules/@ark-ui/react/dist/components/checkbox/checkbox.anatomy.js");





const checkboxSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  slots: _ark_ui_react_checkbox__WEBPACK_IMPORTED_MODULE_1__.checkboxAnatomy.keys(),
  className: "chakra-checkbox",
  base: {
    root: {
      display: "inline-flex",
      gap: "2",
      alignItems: "center",
      verticalAlign: "top",
      position: "relative"
    },
    control: _checkmark_js__WEBPACK_IMPORTED_MODULE_2__.checkmarkRecipe.base,
    label: {
      fontWeight: "medium",
      userSelect: "none",
      _disabled: {
        opacity: "0.5"
      }
    }
  },
  variants: {
    size: {
      xs: {
        root: { gap: "1.5" },
        label: { textStyle: "xs" },
        control: _checkmark_js__WEBPACK_IMPORTED_MODULE_2__.checkmarkRecipe.variants?.size?.xs
      },
      sm: {
        root: { gap: "2" },
        label: { textStyle: "sm" },
        control: _checkmark_js__WEBPACK_IMPORTED_MODULE_2__.checkmarkRecipe.variants?.size?.sm
      },
      md: {
        root: { gap: "2.5" },
        label: { textStyle: "sm" },
        control: _checkmark_js__WEBPACK_IMPORTED_MODULE_2__.checkmarkRecipe.variants?.size?.md
      },
      lg: {
        root: { gap: "3" },
        label: { textStyle: "md" },
        control: _checkmark_js__WEBPACK_IMPORTED_MODULE_2__.checkmarkRecipe.variants?.size?.lg
      }
    },
    variant: {
      outline: {
        control: _checkmark_js__WEBPACK_IMPORTED_MODULE_2__.checkmarkRecipe.variants?.variant?.outline
      },
      solid: {
        control: _checkmark_js__WEBPACK_IMPORTED_MODULE_2__.checkmarkRecipe.variants?.variant?.solid
      },
      subtle: {
        control: _checkmark_js__WEBPACK_IMPORTED_MODULE_2__.checkmarkRecipe.variants?.variant?.subtle
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkmark.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkmark.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkmarkRecipe: () => (/* binding */ checkmarkRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const checkmarkRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineRecipe)({
  className: "chakra-checkmark",
  base: {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: "0",
    color: "white",
    borderWidth: "1px",
    borderColor: "transparent",
    borderRadius: "l1",
    focusVisibleRing: "outside",
    _icon: {
      boxSize: "full"
    },
    _invalid: {
      colorPalette: "red",
      borderColor: "border.error"
    },
    _disabled: {
      opacity: "0.5"
    }
  },
  variants: {
    size: {
      xs: {
        boxSize: "3"
      },
      sm: {
        boxSize: "4"
      },
      md: {
        boxSize: "5",
        p: "0.5"
      },
      lg: {
        boxSize: "6",
        p: "0.5"
      }
    },
    variant: {
      solid: {
        borderColor: "border",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast",
          borderColor: "colorPalette.solid"
        }
      },
      outline: {
        borderColor: "border",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg",
          borderColor: "colorPalette.solid"
        }
      },
      subtle: {
        bg: "colorPalette.muted",
        borderColor: "colorPalette.muted",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg"
        }
      },
      plain: {
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg"
        }
      },
      inverted: {
        borderColor: "border",
        color: "colorPalette.fg",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          borderColor: "colorPalette.solid"
        }
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/code.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/code.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   codeRecipe: () => (/* binding */ codeRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _badge_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./badge.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/badge.js");




const { variants, defaultVariants } = _badge_js__WEBPACK_IMPORTED_MODULE_0__.badgeRecipe;
const codeRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_1__.defineRecipe)({
  className: "chakra-code",
  base: {
    fontFamily: "mono",
    alignItems: "center",
    display: "inline-flex",
    borderRadius: "l2"
  },
  variants,
  defaultVariants
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/collapsible.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/collapsible.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   collapsibleSlotRecipe: () => (/* binding */ collapsibleSlotRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _ark_ui_react_collapsible__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ark-ui/react/collapsible */ "./node_modules/@zag-js/collapsible/dist/index.mjs");




const collapsibleSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  slots: _ark_ui_react_collapsible__WEBPACK_IMPORTED_MODULE_1__.anatomy.keys(),
  className: "chakra-collapsible",
  base: {
    content: {
      overflow: "hidden",
      _open: {
        animationName: "expand-height, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "collapse-height, fade-out",
        animationDuration: "moderate"
      }
    }
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/color-picker.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/color-picker.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   colorPickerSlotRecipe: () => (/* binding */ colorPickerSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _color_swatch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./color-swatch.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/color-swatch.js");
/* harmony import */ var _input_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./input.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/input.js");






const colorPickerSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "colorPicker",
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.colorPickerAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5"
    },
    label: {
      color: "fg",
      fontWeight: "medium",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    },
    valueText: {
      textAlign: "start"
    },
    control: {
      display: "flex",
      alignItems: "center",
      flexDirection: "row",
      gap: "2",
      position: "relative"
    },
    swatchTrigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexDirection: "row",
      flexShrink: "0",
      gap: "2",
      textStyle: "sm",
      minH: "var(--input-height)",
      minW: "var(--input-height)",
      px: "1",
      rounded: "l2",
      _disabled: { opacity: "0.5" },
      "--focus-color": "colors.colorPalette.focusRing",
      "&:focus-visible": {
        borderColor: "var(--focus-color)",
        outline: "1px solid var(--focus-color)"
      },
      "&[data-fit-content]": {
        "--input-height": "unset",
        px: "0",
        border: "0"
      }
    },
    content: {
      display: "flex",
      flexDirection: "column",
      bg: "bg.panel",
      borderRadius: "l3",
      boxShadow: "lg",
      width: "64",
      p: "4",
      gap: "3",
      zIndex: "dropdown",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    area: {
      height: "180px",
      borderRadius: "l2",
      overflow: "hidden"
    },
    areaThumb: {
      borderRadius: "full",
      height: "var(--thumb-size)",
      width: "var(--thumb-size)",
      borderWidth: "2px",
      borderColor: "white",
      shadow: "sm",
      focusVisibleRing: "mixed",
      focusRingColor: "white"
    },
    areaBackground: {
      height: "full"
    },
    channelSlider: {
      borderRadius: "l2",
      flex: "1"
    },
    channelSliderTrack: {
      height: "var(--slider-height)",
      borderRadius: "inherit",
      boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.1)"
    },
    channelText: {
      textStyle: "xs",
      color: "fg.muted",
      fontWeight: "medium",
      textTransform: "capitalize"
    },
    swatchGroup: {
      display: "flex",
      flexDirection: "row",
      flexWrap: "wrap",
      gap: "2"
    },
    swatch: {
      ..._color_swatch_js__WEBPACK_IMPORTED_MODULE_2__.colorSwatchRecipe.base,
      borderRadius: "l1"
    },
    swatchIndicator: {
      color: "white",
      rounded: "full"
    },
    channelSliderThumb: {
      borderRadius: "full",
      height: "var(--thumb-size)",
      width: "var(--thumb-size)",
      borderWidth: "2px",
      borderColor: "white",
      shadow: "sm",
      transform: "translate(-50%, -50%)",
      focusVisibleRing: "outside",
      focusRingOffset: "1px"
    },
    channelInput: {
      ..._input_js__WEBPACK_IMPORTED_MODULE_3__.inputRecipe.base,
      "&::-webkit-inner-spin-button, &::-webkit-outer-spin-button": {
        WebkitAppearance: "none",
        margin: 0
      }
    },
    formatSelect: {
      textStyle: "xs",
      textTransform: "uppercase",
      borderWidth: "1px",
      minH: "6",
      focusRing: "inside",
      rounded: "l2"
    },
    transparencyGrid: {
      borderRadius: "l2"
    },
    view: {
      display: "flex",
      flexDirection: "column",
      gap: "2"
    }
  },
  variants: {
    size: {
      "2xs": {
        channelInput: _input_js__WEBPACK_IMPORTED_MODULE_3__.inputRecipe.variants?.size?.["2xs"],
        swatch: { "--swatch-size": "sizes.4.5" },
        trigger: { "--input-height": "sizes.7" },
        area: { "--thumb-size": "sizes.3" },
        channelSlider: {
          "--slider-height": "sizes.3",
          "--thumb-size": "sizes.3"
        }
      },
      xs: {
        channelInput: _input_js__WEBPACK_IMPORTED_MODULE_3__.inputRecipe.variants?.size?.xs,
        swatch: { "--swatch-size": "sizes.5" },
        trigger: { "--input-height": "sizes.8" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      sm: {
        channelInput: _input_js__WEBPACK_IMPORTED_MODULE_3__.inputRecipe.variants?.size?.sm,
        swatch: { "--swatch-size": "sizes.6" },
        trigger: { "--input-height": "sizes.9" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      md: {
        channelInput: _input_js__WEBPACK_IMPORTED_MODULE_3__.inputRecipe.variants?.size?.md,
        swatch: { "--swatch-size": "sizes.7" },
        trigger: { "--input-height": "sizes.10" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      lg: {
        channelInput: _input_js__WEBPACK_IMPORTED_MODULE_3__.inputRecipe.variants?.size?.lg,
        swatch: { "--swatch-size": "sizes.7" },
        trigger: { "--input-height": "sizes.11" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      xl: {
        channelInput: _input_js__WEBPACK_IMPORTED_MODULE_3__.inputRecipe.variants?.size?.xl,
        swatch: { "--swatch-size": "sizes.8" },
        trigger: { "--input-height": "sizes.12" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      "2xl": {
        channelInput: _input_js__WEBPACK_IMPORTED_MODULE_3__.inputRecipe.variants?.size?.["2xl"],
        swatch: { "--swatch-size": "sizes.10" },
        trigger: { "--input-height": "sizes.16" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      }
    },
    variant: {
      outline: {
        channelInput: _input_js__WEBPACK_IMPORTED_MODULE_3__.inputRecipe.variants?.variant?.outline,
        trigger: {
          borderWidth: "1px"
        }
      },
      subtle: {
        channelInput: _input_js__WEBPACK_IMPORTED_MODULE_3__.inputRecipe.variants?.variant?.subtle,
        trigger: {
          borderWidth: "1px",
          borderColor: "transparent",
          bg: "bg.muted"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/color-swatch.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/color-swatch.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   colorSwatchRecipe: () => (/* binding */ colorSwatchRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const colorSwatchRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineRecipe)({
  className: "color-swatch",
  base: {
    boxSize: "var(--swatch-size)",
    shadow: "inset 0 0 0 1px rgba(0, 0, 0, 0.1)",
    "--checker-size": "8px",
    "--checker-bg": "colors.bg",
    "--checker-fg": "colors.bg.emphasized",
    background: "linear-gradient(var(--color), var(--color)), repeating-conic-gradient(var(--checker-fg) 0%, var(--checker-fg) 25%, var(--checker-bg) 0%, var(--checker-bg) 50%) 0% 50% / var(--checker-size) var(--checker-size) !important",
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: "0"
  },
  variants: {
    size: {
      "2xs": { "--swatch-size": "sizes.3.5" },
      xs: { "--swatch-size": "sizes.4" },
      sm: { "--swatch-size": "sizes.4.5" },
      md: { "--swatch-size": "sizes.5" },
      lg: { "--swatch-size": "sizes.6" },
      xl: { "--swatch-size": "sizes.7" },
      "2xl": { "--swatch-size": "sizes.8" },
      inherit: { "--swatch-size": "inherit" },
      full: { "--swatch-size": "100%" }
    },
    shape: {
      square: { borderRadius: "none" },
      circle: { borderRadius: "full" },
      rounded: { borderRadius: "l1" }
    }
  },
  defaultVariants: {
    size: "md",
    shape: "rounded"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/container.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/container.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   containerRecipe: () => (/* binding */ containerRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const containerRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineRecipe)({
  className: "chakra-container",
  base: {
    position: "relative",
    maxWidth: "8xl",
    w: "100%",
    mx: "auto",
    px: { base: "4", md: "6", lg: "8" }
  },
  variants: {
    centerContent: {
      true: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center"
      }
    },
    fluid: {
      true: {
        maxWidth: "full"
      }
    }
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/data-list.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/data-list.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dataListSlotRecipe: () => (/* binding */ dataListSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const dataListSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.dataListAnatomy.keys(),
  className: "chakra-data-list",
  base: {
    itemLabel: {
      display: "flex",
      alignItems: "center",
      gap: "1"
    },
    itemValue: {
      display: "flex",
      minWidth: "0",
      flex: "1"
    }
  },
  variants: {
    orientation: {
      horizontal: {
        root: {
          display: "flex",
          flexDirection: "column"
        },
        item: {
          display: "inline-flex",
          alignItems: "center",
          gap: "4"
        },
        itemLabel: {
          minWidth: "120px"
        }
      },
      vertical: {
        root: {
          display: "flex",
          flexDirection: "column"
        },
        item: {
          display: "flex",
          flexDirection: "column",
          gap: "1"
        }
      }
    },
    size: {
      sm: {
        root: {
          gap: "3"
        },
        item: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          gap: "4"
        },
        item: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          gap: "5"
        },
        item: {
          textStyle: "md"
        }
      }
    },
    variant: {
      subtle: {
        itemLabel: {
          color: "fg.muted"
        }
      },
      bold: {
        itemLabel: {
          fontWeight: "medium"
        },
        itemValue: {
          color: "fg.muted"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    orientation: "vertical",
    variant: "subtle"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/dialog.js":
/*!************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/dialog.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dialogSlotRecipe: () => (/* binding */ dialogSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const dialogSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.dialogAnatomy.keys(),
  className: "chakra-dialog",
  base: {
    backdrop: {
      bg: "blackAlpha.500",
      pos: "fixed",
      left: 0,
      top: 0,
      w: "100vw",
      h: "100dvh",
      zIndex: "overlay",
      _open: {
        animationName: "fade-in",
        animationDuration: "slow"
      },
      _closed: {
        animationName: "fade-out",
        animationDuration: "moderate"
      }
    },
    positioner: {
      display: "flex",
      width: "100vw",
      height: "100dvh",
      position: "fixed",
      left: 0,
      top: 0,
      "--dialog-z-index": "zIndex.modal",
      zIndex: "calc(var(--dialog-z-index) + var(--layer-index, 0))",
      justifyContent: "center",
      overscrollBehaviorY: "none"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      borderRadius: "l3",
      textStyle: "sm",
      my: "var(--dialog-margin, var(--dialog-base-margin))",
      "--dialog-z-index": "zIndex.modal",
      zIndex: "calc(var(--dialog-z-index) + var(--layer-index, 0))",
      bg: "bg.panel",
      boxShadow: "lg",
      _open: {
        animationDuration: "moderate"
      },
      _closed: {
        animationDuration: "faster"
      }
    },
    header: {
      display: "flex",
      gap: "2",
      flex: 0,
      px: "6",
      pt: "6",
      pb: "4"
    },
    body: {
      flex: "1",
      px: "6",
      pt: "2",
      pb: "6"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      gap: "3",
      px: "6",
      pt: "2",
      pb: "4"
    },
    title: {
      textStyle: "lg",
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted"
    },
    closeTrigger: {
      pos: "absolute",
      top: "2",
      insetEnd: "2"
    }
  },
  variants: {
    placement: {
      center: {
        positioner: {
          alignItems: "center"
        },
        content: {
          "--dialog-base-margin": "auto",
          mx: "auto"
        }
      },
      top: {
        positioner: {
          alignItems: "flex-start"
        },
        content: {
          "--dialog-base-margin": "spacing.16",
          mx: "auto"
        }
      },
      bottom: {
        positioner: {
          alignItems: "flex-end"
        },
        content: {
          "--dialog-base-margin": "spacing.16",
          mx: "auto"
        }
      }
    },
    scrollBehavior: {
      inside: {
        positioner: {
          overflow: "hidden"
        },
        content: {
          maxH: "calc(100% - 7.5rem)"
        },
        body: {
          overflow: "auto"
        }
      },
      outside: {
        positioner: {
          overflow: "auto",
          pointerEvents: "auto"
        }
      }
    },
    size: {
      xs: {
        content: {
          maxW: "sm"
        }
      },
      sm: {
        content: {
          maxW: "md"
        }
      },
      md: {
        content: {
          maxW: "lg"
        }
      },
      lg: {
        content: {
          maxW: "2xl"
        }
      },
      xl: {
        content: {
          maxW: "4xl"
        }
      },
      cover: {
        positioner: {
          padding: "10"
        },
        content: {
          width: "100%",
          height: "100%",
          "--dialog-margin": "0"
        }
      },
      full: {
        content: {
          maxW: "100vw",
          minH: "100vh",
          "--dialog-margin": "0",
          borderRadius: "0"
        }
      }
    },
    motionPreset: {
      scale: {
        content: {
          _open: { animationName: "scale-in, fade-in" },
          _closed: { animationName: "scale-out, fade-out" }
        }
      },
      "slide-in-bottom": {
        content: {
          _open: { animationName: "slide-from-bottom, fade-in" },
          _closed: { animationName: "slide-to-bottom, fade-out" }
        }
      },
      "slide-in-top": {
        content: {
          _open: { animationName: "slide-from-top, fade-in" },
          _closed: { animationName: "slide-to-top, fade-out" }
        }
      },
      "slide-in-left": {
        content: {
          _open: { animationName: "slide-from-left, fade-in" },
          _closed: { animationName: "slide-to-left, fade-out" }
        }
      },
      "slide-in-right": {
        content: {
          _open: { animationName: "slide-from-right, fade-in" },
          _closed: { animationName: "slide-to-right, fade-out" }
        }
      },
      none: {}
    }
  },
  defaultVariants: {
    size: "md",
    scrollBehavior: "outside",
    placement: "top",
    motionPreset: "scale"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/drawer.js":
/*!************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/drawer.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   drawerSlotRecipe: () => (/* binding */ drawerSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const drawerSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.drawerAnatomy.keys(),
  className: "chakra-drawer",
  base: {
    backdrop: {
      bg: "blackAlpha.500",
      pos: "fixed",
      insetInlineStart: 0,
      top: 0,
      w: "100vw",
      h: "100dvh",
      zIndex: "overlay",
      _open: {
        animationName: "fade-in",
        animationDuration: "slow"
      },
      _closed: {
        animationName: "fade-out",
        animationDuration: "moderate"
      }
    },
    positioner: {
      display: "flex",
      width: "100vw",
      height: "100dvh",
      position: "fixed",
      insetInlineStart: 0,
      top: 0,
      zIndex: "modal",
      overscrollBehaviorY: "none"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      zIndex: "modal",
      textStyle: "sm",
      maxH: "100dvh",
      color: "inherit",
      bg: "bg.panel",
      boxShadow: "lg",
      _open: {
        animationDuration: "slowest",
        animationTimingFunction: "ease-in-smooth"
      },
      _closed: {
        animationDuration: "slower",
        animationTimingFunction: "ease-in-smooth"
      }
    },
    header: {
      display: "flex",
      alignItems: "center",
      gap: "2",
      flex: 0,
      px: "6",
      pt: "6",
      pb: "4"
    },
    body: {
      px: "6",
      py: "2",
      flex: "1",
      overflow: "auto"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      gap: "3",
      px: "6",
      pt: "2",
      pb: "4"
    },
    title: {
      flex: "1",
      textStyle: "lg",
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted"
    },
    closeTrigger: {
      pos: "absolute",
      top: "3",
      insetEnd: "2"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          maxW: "xs"
        }
      },
      sm: {
        content: {
          maxW: "md"
        }
      },
      md: {
        content: {
          maxW: "lg"
        }
      },
      lg: {
        content: {
          maxW: "2xl"
        }
      },
      xl: {
        content: {
          maxW: "4xl"
        }
      },
      full: {
        content: {
          maxW: "100vw",
          h: "100dvh"
        }
      }
    },
    placement: {
      start: {
        positioner: {
          justifyContent: "flex-start"
        },
        content: {
          _open: {
            animationName: {
              base: "slide-from-left-full, fade-in",
              _rtl: "slide-from-right-full, fade-in"
            }
          },
          _closed: {
            animationName: {
              base: "slide-to-left-full, fade-out",
              _rtl: "slide-to-right-full, fade-out"
            }
          }
        }
      },
      end: {
        positioner: {
          justifyContent: "flex-end"
        },
        content: {
          _open: {
            animationName: {
              base: "slide-from-right-full, fade-in",
              _rtl: "slide-from-left-full, fade-in"
            }
          },
          _closed: {
            animationName: {
              base: "slide-to-right-full, fade-out",
              _rtl: "slide-to-right-full, fade-out"
            }
          }
        }
      },
      top: {
        positioner: {
          alignItems: "flex-start"
        },
        content: {
          maxW: "100%",
          _open: { animationName: "slide-from-top-full, fade-in" },
          _closed: { animationName: "slide-to-top-full, fade-out" }
        }
      },
      bottom: {
        positioner: {
          alignItems: "flex-end"
        },
        content: {
          maxW: "100%",
          _open: { animationName: "slide-from-bottom-full, fade-in" },
          _closed: { animationName: "slide-to-bottom-full, fade-out" }
        }
      }
    },
    contained: {
      true: {
        positioner: {
          padding: "4"
        },
        content: {
          borderRadius: "l3"
        }
      }
    }
  },
  defaultVariants: {
    size: "xs",
    placement: "end"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/editable.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/editable.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   editableSlotRecipe: () => (/* binding */ editableSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const sharedStyles = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineStyle)({
  fontSize: "inherit",
  fontWeight: "inherit",
  textAlign: "inherit",
  bg: "transparent",
  borderRadius: "l2"
});
const editableSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.editableAnatomy.keys(),
  className: "chakra-editable",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative",
      gap: "1.5",
      width: "full"
    },
    preview: {
      ...sharedStyles,
      py: "1",
      px: "1",
      display: "inline-flex",
      alignItems: "center",
      transitionProperty: "common",
      transitionDuration: "normal",
      cursor: "text",
      _hover: {
        bg: "bg.muted"
      },
      _disabled: {
        userSelect: "none"
      }
    },
    input: {
      ...sharedStyles,
      outline: "0",
      py: "1",
      px: "1",
      transitionProperty: "common",
      transitionDuration: "normal",
      width: "full",
      focusVisibleRing: "inside",
      focusRingWidth: "2px",
      _placeholder: { opacity: 0.6 }
    },
    control: {
      display: "inline-flex",
      alignItems: "center",
      gap: "1.5"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        preview: { minH: "8" },
        input: { minH: "8" }
      },
      md: {
        root: {
          textStyle: "sm"
        },
        preview: { minH: "9" },
        input: { minH: "9" }
      },
      lg: {
        root: {
          textStyle: "md"
        },
        preview: { minH: "10" },
        input: { minH: "10" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/empty-state.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/empty-state.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   emptyStateSlotRecipe: () => (/* binding */ emptyStateSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const emptyStateSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.emptyStateAnatomy.keys(),
  className: "chakra-empty-state",
  base: {
    root: {
      width: "full"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center"
    },
    indicator: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: "fg.subtle",
      _icon: {
        boxSize: "1em"
      }
    },
    title: {
      fontWeight: "semibold"
    },
    description: {
      textStyle: "sm",
      color: "fg.muted"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          px: "4",
          py: "6"
        },
        title: {
          textStyle: "md"
        },
        content: {
          gap: "4"
        },
        indicator: {
          textStyle: "2xl"
        }
      },
      md: {
        root: {
          px: "8",
          py: "12"
        },
        title: {
          textStyle: "lg"
        },
        content: {
          gap: "6"
        },
        indicator: {
          textStyle: "4xl"
        }
      },
      lg: {
        root: {
          px: "12",
          py: "16"
        },
        title: {
          textStyle: "xl"
        },
        content: {
          gap: "8"
        },
        indicator: {
          textStyle: "6xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/field.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/field.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fieldSlotRecipe: () => (/* binding */ fieldSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const fieldSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-field",
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.fieldAnatomy.keys(),
  base: {
    requiredIndicator: {
      color: "fg.error",
      lineHeight: "1"
    },
    root: {
      display: "flex",
      width: "100%",
      position: "relative",
      gap: "1.5"
    },
    label: {
      display: "flex",
      alignItems: "center",
      textAlign: "start",
      textStyle: "sm",
      fontWeight: "medium",
      gap: "1",
      userSelect: "none",
      _disabled: {
        opacity: "0.5"
      }
    },
    errorText: {
      display: "inline-flex",
      alignItems: "center",
      fontWeight: "medium",
      gap: "1",
      color: "fg.error",
      textStyle: "xs"
    },
    helperText: {
      color: "fg.muted",
      textStyle: "xs"
    }
  },
  variants: {
    orientation: {
      vertical: {
        root: {
          flexDirection: "column",
          alignItems: "flex-start"
        }
      },
      horizontal: {
        root: {
          flexDirection: "row",
          alignItems: "center",
          justifyContent: "space-between"
        },
        label: {
          flex: "0 0 var(--field-label-width, 80px)"
        }
      }
    }
  },
  defaultVariants: {
    orientation: "vertical"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/fieldset.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/fieldset.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fieldsetSlotRecipe: () => (/* binding */ fieldsetSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const fieldsetSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "fieldset",
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.fieldsetAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      width: "full"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      width: "full"
    },
    legend: {
      color: "fg",
      fontWeight: "medium",
      _disabled: {
        opacity: "0.5"
      }
    },
    helperText: {
      color: "fg.muted",
      textStyle: "sm"
    },
    errorText: {
      display: "inline-flex",
      alignItems: "center",
      color: "fg.error",
      gap: "2",
      fontWeight: "medium",
      textStyle: "sm"
    }
  },
  variants: {
    size: {
      sm: {
        root: { spaceY: "2" },
        content: { gap: "1.5" },
        legend: { textStyle: "sm" }
      },
      md: {
        root: { spaceY: "4" },
        content: { gap: "4" },
        legend: { textStyle: "sm" }
      },
      lg: {
        root: { spaceY: "6" },
        content: { gap: "4" },
        legend: { textStyle: "md" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/file-upload.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/file-upload.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fileUploadSlotRecipe: () => (/* binding */ fileUploadSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const fileUploadSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-file-upload",
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.fileUploadAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "4",
      width: "100%",
      alignItems: "flex-start"
    },
    label: {
      fontWeight: "medium",
      textStyle: "sm"
    },
    dropzone: {
      background: "bg",
      borderRadius: "l3",
      borderWidth: "2px",
      borderStyle: "dashed",
      display: "flex",
      alignItems: "center",
      flexDirection: "column",
      gap: "4",
      justifyContent: "center",
      minHeight: "2xs",
      px: "3",
      py: "2",
      transition: "backgrounds",
      focusVisibleRing: "outside",
      _hover: {
        bg: "bg.subtle"
      },
      _dragging: {
        bg: "colorPalette.subtle",
        borderStyle: "solid",
        borderColor: "colorPalette.solid"
      }
    },
    dropzoneContent: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      textAlign: "center",
      gap: "1",
      textStyle: "sm"
    },
    item: {
      pos: "relative",
      textStyle: "sm",
      animationName: "fade-in",
      animationDuration: "moderate",
      background: "bg",
      borderRadius: "l2",
      borderWidth: "1px",
      width: "100%",
      display: "flex",
      alignItems: "center",
      gap: "3",
      p: "4"
    },
    itemGroup: {
      width: "100%",
      display: "flex",
      flexDirection: "column",
      gap: "3",
      _empty: {
        display: "none"
      }
    },
    itemName: {
      color: "fg",
      fontWeight: "medium",
      lineClamp: "1"
    },
    itemContent: {
      display: "flex",
      flexDirection: "column",
      gap: "0.5",
      flex: "1"
    },
    itemSizeText: {
      color: "fg.muted",
      textStyle: "xs"
    },
    itemDeleteTrigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      alignSelf: "flex-start",
      boxSize: "5",
      p: "2px",
      color: "fg.muted",
      cursor: "button"
    },
    itemPreview: {
      color: "fg.muted",
      _icon: {
        boxSize: "4.5"
      }
    }
  },
  defaultVariants: {}
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/heading.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/heading.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   headingRecipe: () => (/* binding */ headingRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const headingRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineRecipe)({
  className: "chakra-heading",
  base: {
    fontFamily: "heading",
    fontWeight: "semibold"
  },
  variants: {
    size: {
      xs: { textStyle: "xs" },
      sm: { textStyle: "sm" },
      md: { textStyle: "md" },
      lg: { textStyle: "lg" },
      xl: { textStyle: "xl" },
      "2xl": { textStyle: "2xl" },
      "3xl": { textStyle: "3xl" },
      "4xl": { textStyle: "4xl" },
      "5xl": { textStyle: "5xl" },
      "6xl": { textStyle: "6xl" },
      "7xl": { textStyle: "7xl" }
    }
  },
  defaultVariants: {
    size: "xl"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/hover-card.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/hover-card.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hoverCardSlotRecipe: () => (/* binding */ hoverCardSlotRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _ark_ui_react_hover_card__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ark-ui/react/hover-card */ "./node_modules/@zag-js/hover-card/dist/index.mjs");




const hoverCardSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-hover-card",
  slots: _ark_ui_react_hover_card__WEBPACK_IMPORTED_MODULE_1__.anatomy.keys(),
  base: {
    content: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      textStyle: "sm",
      "--hovercard-bg": "colors.bg.panel",
      bg: "var(--hovercard-bg)",
      boxShadow: "lg",
      maxWidth: "80",
      borderRadius: "l3",
      zIndex: "popover",
      transformOrigin: "var(--transform-origin)",
      outline: "0",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    arrow: {
      "--arrow-size": "sizes.3",
      "--arrow-background": "var(--hovercard-bg)"
    },
    arrowTip: {
      borderTopWidth: "0.5px",
      borderInlineStartWidth: "0.5px"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          padding: "3"
        }
      },
      sm: {
        content: {
          padding: "4"
        }
      },
      md: {
        content: {
          padding: "5"
        }
      },
      lg: {
        content: {
          padding: "6"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/icon.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/icon.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   iconRecipe: () => (/* binding */ iconRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const iconRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineRecipe)({
  className: "chakra-icon",
  base: {
    display: "inline-block",
    lineHeight: "1em",
    flexShrink: "0",
    color: "currentcolor",
    verticalAlign: "middle"
  },
  variants: {
    size: {
      inherit: {},
      xs: { boxSize: "3" },
      sm: { boxSize: "4" },
      md: { boxSize: "5" },
      lg: { boxSize: "6" },
      xl: { boxSize: "7" },
      "2xl": { boxSize: "8" }
    }
  },
  defaultVariants: {
    size: "inherit"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/input-addon.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/input-addon.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   inputAddonRecipe: () => (/* binding */ inputAddonRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _input_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./input.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/input.js");




const inputAddonRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineRecipe)({
  className: "chakra-input-addon",
  base: {
    flex: "0 0 auto",
    width: "auto",
    display: "flex",
    alignItems: "center",
    whiteSpace: "nowrap",
    alignSelf: "stretch",
    borderRadius: "l2"
  },
  variants: {
    size: _input_js__WEBPACK_IMPORTED_MODULE_1__.inputRecipe.variants.size,
    variant: {
      outline: {
        borderWidth: "1px",
        borderColor: "border",
        bg: "bg.muted"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.emphasized"
      },
      flushed: {
        borderBottom: "1px solid",
        borderColor: "inherit",
        borderRadius: "0",
        px: "0",
        bg: "transparent"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/input.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/input.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   inputRecipe: () => (/* binding */ inputRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const inputRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineRecipe)({
  className: "chakra-input",
  base: {
    width: "100%",
    minWidth: "0",
    outline: "0",
    position: "relative",
    appearance: "none",
    textAlign: "start",
    borderRadius: "l2",
    _disabled: {
      layerStyle: "disabled"
    },
    height: "var(--input-height)",
    minW: "var(--input-height)",
    "--focus-color": "colors.colorPalette.focusRing",
    "--error-color": "colors.border.error",
    _invalid: {
      focusRingColor: "var(--error-color)",
      borderColor: "var(--error-color)"
    }
  },
  variants: {
    size: {
      "2xs": {
        textStyle: "xs",
        px: "2",
        "--input-height": "sizes.7"
      },
      xs: {
        textStyle: "xs",
        px: "2",
        "--input-height": "sizes.8"
      },
      sm: {
        textStyle: "sm",
        px: "2.5",
        "--input-height": "sizes.9"
      },
      md: {
        textStyle: "sm",
        px: "3",
        "--input-height": "sizes.10"
      },
      lg: {
        textStyle: "md",
        px: "4",
        "--input-height": "sizes.11"
      },
      xl: {
        textStyle: "md",
        px: "4.5",
        "--input-height": "sizes.12"
      },
      "2xl": {
        textStyle: "lg",
        px: "5",
        "--input-height": "sizes.16"
      }
    },
    variant: {
      outline: {
        bg: "transparent",
        borderWidth: "1px",
        borderColor: "border",
        focusVisibleRing: "inside",
        focusRingColor: "var(--focus-color)"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.muted",
        focusVisibleRing: "inside",
        focusRingColor: "var(--focus-color)"
      },
      flushed: {
        bg: "transparent",
        borderBottomWidth: "1px",
        borderBottomColor: "border",
        borderRadius: "0",
        px: "0",
        _focusVisible: {
          borderColor: "var(--focus-color)",
          boxShadow: "0px 1px 0px 0px var(--focus-color)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/kbd.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/kbd.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   kbdRecipe: () => (/* binding */ kbdRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const kbdRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineRecipe)({
  className: "chakra-kbd",
  base: {
    display: "inline-flex",
    alignItems: "center",
    fontWeight: "medium",
    fontFamily: "mono",
    flexShrink: "0",
    whiteSpace: "nowrap",
    wordSpacing: "-0.5em",
    userSelect: "none",
    px: "1",
    borderRadius: "l2"
  },
  variants: {
    variant: {
      raised: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        borderWidth: "1px",
        borderBottomWidth: "2px",
        borderColor: "colorPalette.muted"
      },
      outline: {
        borderWidth: "1px",
        color: "colorPalette.fg"
      },
      subtle: {
        bg: "colorPalette.muted",
        color: "colorPalette.fg"
      },
      plain: {
        color: "colorPalette.fg"
      }
    },
    size: {
      sm: {
        textStyle: "xs",
        height: "4.5"
      },
      md: {
        textStyle: "sm",
        height: "5"
      },
      lg: {
        textStyle: "md",
        height: "6"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "raised"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/link.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/link.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   linkRecipe: () => (/* binding */ linkRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const linkRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineRecipe)({
  className: "chakra-link",
  base: {
    display: "inline-flex",
    alignItems: "center",
    outline: "none",
    gap: "1.5",
    cursor: "pointer",
    borderRadius: "l1",
    focusRing: "outside"
  },
  variants: {
    variant: {
      underline: {
        color: "colorPalette.fg",
        textDecoration: "underline",
        textUnderlineOffset: "3px",
        textDecorationColor: "currentColor/20"
      },
      plain: {
        color: "colorPalette.fg",
        _hover: {
          textDecoration: "underline",
          textUnderlineOffset: "3px",
          textDecorationColor: "currentColor/20"
        }
      }
    }
  },
  defaultVariants: {
    variant: "plain"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/list.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/list.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   listSlotRecipe: () => (/* binding */ listSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const listSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-list",
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.listAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "var(--list-gap)",
      "& :where(ul, ol)": {
        marginTop: "var(--list-gap)"
      }
    },
    item: {
      whiteSpace: "normal",
      display: "list-item"
    },
    indicator: {
      marginEnd: "2",
      minHeight: "1lh",
      flexShrink: 0,
      display: "inline-block",
      verticalAlign: "middle"
    }
  },
  variants: {
    variant: {
      marker: {
        root: {
          listStyle: "revert"
        },
        item: {
          _marker: {
            color: "fg.subtle"
          }
        }
      },
      plain: {
        item: {
          alignItems: "flex-start",
          display: "inline-flex"
        }
      }
    },
    align: {
      center: {
        item: { alignItems: "center" }
      },
      start: {
        item: { alignItems: "flex-start" }
      },
      end: {
        item: { alignItems: "flex-end" }
      }
    }
  },
  defaultVariants: {
    variant: "marker"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/mark.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/mark.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   markRecipe: () => (/* binding */ markRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const markRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineRecipe)({
  className: "chakra-mark",
  base: {
    bg: "transparent",
    color: "inherit",
    whiteSpace: "nowrap"
  },
  variants: {
    variant: {
      subtle: {
        bg: "colorPalette.subtle",
        color: "inherit"
      },
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast"
      },
      text: {
        fontWeight: "medium"
      },
      plain: {}
    }
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/menu.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/menu.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   menuSlotRecipe: () => (/* binding */ menuSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const menuSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-menu",
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.menuAnatomy.keys(),
  base: {
    content: {
      outline: 0,
      bg: "bg.panel",
      boxShadow: "lg",
      color: "fg",
      maxHeight: "var(--available-height)",
      "--menu-z-index": "zIndex.dropdown",
      zIndex: "calc(var(--menu-z-index) + var(--layer-index, 0))",
      borderRadius: "l2",
      overflow: "hidden",
      overflowY: "auto",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    item: {
      textDecoration: "none",
      color: "fg",
      userSelect: "none",
      borderRadius: "l1",
      width: "100%",
      display: "flex",
      cursor: "menuitem",
      alignItems: "center",
      textAlign: "start",
      position: "relative",
      flex: "0 0 auto",
      outline: 0,
      _disabled: {
        layerStyle: "disabled"
      },
      "&[data-type]": {
        ps: "8"
      }
    },
    itemText: {
      flex: "1"
    },
    itemIndicator: {
      position: "absolute",
      insetStart: "2",
      transform: "translateY(-50%)",
      top: "50%"
    },
    itemGroupLabel: {
      px: "2",
      py: "1.5",
      fontWeight: "semibold",
      textStyle: "sm"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0"
    },
    itemCommand: {
      opacity: "0.6",
      textStyle: "xs",
      ms: "auto",
      ps: "4",
      letterSpacing: "widest",
      fontFamily: "inherit"
    },
    separator: {
      height: "1px",
      bg: "bg.muted",
      my: "1",
      mx: "-1"
    }
  },
  variants: {
    variant: {
      subtle: {
        item: {
          _highlighted: {
            bg: "bg.emphasized/60"
          }
        }
      },
      solid: {
        item: {
          _highlighted: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast"
          }
        }
      }
    },
    size: {
      sm: {
        content: {
          minW: "8rem",
          padding: "1"
        },
        item: {
          gap: "1",
          textStyle: "xs",
          py: "1",
          px: "1.5"
        }
      },
      md: {
        content: {
          minW: "8rem",
          padding: "1.5"
        },
        item: {
          gap: "2",
          textStyle: "sm",
          py: "1.5",
          px: "2"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "subtle"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/native-select.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/native-select.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   nativeSelectSlotRecipe: () => (/* binding */ nativeSelectSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./select.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/select.js");





const nativeSelectSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-native-select",
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.nativeSelectAnatomy.keys(),
  base: {
    root: {
      height: "fit-content",
      display: "flex",
      width: "100%",
      position: "relative"
    },
    field: {
      width: "100%",
      minWidth: "0",
      outline: "0",
      appearance: "none",
      borderRadius: "l2",
      "--error-color": "colors.border.error",
      _disabled: {
        layerStyle: "disabled"
      },
      _invalid: {
        focusRingColor: "var(--error-color)",
        borderColor: "var(--error-color)"
      },
      focusVisibleRing: "inside",
      lineHeight: "normal",
      "& > option, & > optgroup": {
        bg: "bg"
      }
    },
    indicator: {
      position: "absolute",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      pointerEvents: "none",
      top: "50%",
      transform: "translateY(-50%)",
      height: "100%",
      color: "fg.muted",
      _disabled: {
        opacity: "0.5"
      },
      _invalid: {
        color: "fg.error"
      },
      _icon: {
        width: "1em",
        height: "1em"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        field: _select_js__WEBPACK_IMPORTED_MODULE_2__.selectSlotRecipe.variants?.variant.outline.trigger
      },
      subtle: {
        field: _select_js__WEBPACK_IMPORTED_MODULE_2__.selectSlotRecipe.variants?.variant.subtle.trigger
      },
      plain: {
        field: {
          bg: "transparent",
          color: "fg",
          focusRingWidth: "2px"
        }
      }
    },
    size: {
      xs: {
        field: {
          textStyle: "xs",
          ps: "2",
          pe: "6",
          height: "6"
        },
        indicator: {
          textStyle: "sm",
          insetEnd: "1.5"
        }
      },
      sm: {
        field: {
          textStyle: "sm",
          ps: "2.5",
          pe: "8",
          height: "8"
        },
        indicator: {
          textStyle: "md",
          insetEnd: "2"
        }
      },
      md: {
        field: {
          textStyle: "sm",
          ps: "3",
          pe: "8",
          height: "10"
        },
        indicator: {
          textStyle: "lg",
          insetEnd: "2"
        }
      },
      lg: {
        field: {
          textStyle: "md",
          ps: "4",
          pe: "8",
          height: "11"
        },
        indicator: {
          textStyle: "xl",
          insetEnd: "3"
        }
      },
      xl: {
        field: {
          textStyle: "md",
          ps: "4.5",
          pe: "10",
          height: "12"
        },
        indicator: {
          textStyle: "xl",
          insetEnd: "3"
        }
      }
    }
  },
  defaultVariants: _select_js__WEBPACK_IMPORTED_MODULE_2__.selectSlotRecipe.defaultVariants
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/number-input.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/number-input.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   numberInputSlotRecipe: () => (/* binding */ numberInputSlotRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _utils_entries_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/entries.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/entries.js");
/* harmony import */ var _input_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./input.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/input.js");
/* harmony import */ var _ark_ui_react_number_input__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ark-ui/react/number-input */ "./node_modules/@zag-js/number-input/dist/index.mjs");






const triggerStyle = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineStyle)({
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  flex: "1",
  userSelect: "none",
  cursor: "button",
  lineHeight: "1",
  color: "fg.muted",
  "--stepper-base-radius": "radii.l1",
  "--stepper-radius": "calc(var(--stepper-base-radius) + 1px)",
  _icon: {
    boxSize: "1em"
  },
  _disabled: {
    opacity: "0.5"
  },
  _hover: {
    bg: "bg.muted"
  },
  _active: {
    bg: "bg.emphasized"
  }
});
const numberInputSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-number-input",
  slots: _ark_ui_react_number_input__WEBPACK_IMPORTED_MODULE_1__.anatomy.keys(),
  base: {
    root: {
      position: "relative",
      zIndex: "0",
      isolation: "isolate"
    },
    input: {
      ..._input_js__WEBPACK_IMPORTED_MODULE_2__.inputRecipe.base,
      verticalAlign: "top",
      pe: "calc(var(--stepper-width) + 0.5rem)"
    },
    control: {
      display: "flex",
      flexDirection: "column",
      position: "absolute",
      top: "0",
      insetEnd: "0px",
      margin: "1px",
      width: "var(--stepper-width)",
      height: "calc(100% - 2px)",
      zIndex: "1",
      borderStartWidth: "1px",
      divideY: "1px"
    },
    incrementTrigger: {
      ...triggerStyle,
      borderTopEndRadius: "var(--stepper-radius)"
    },
    decrementTrigger: {
      ...triggerStyle,
      borderBottomEndRadius: "var(--stepper-radius)"
    },
    valueText: {
      fontWeight: "medium",
      fontFeatureSettings: "pnum",
      fontVariantNumeric: "proportional-nums"
    }
  },
  variants: {
    size: {
      xs: {
        input: _input_js__WEBPACK_IMPORTED_MODULE_2__.inputRecipe.variants.size.xs,
        control: {
          fontSize: "2xs",
          "--stepper-width": "sizes.4"
        }
      },
      sm: {
        input: _input_js__WEBPACK_IMPORTED_MODULE_2__.inputRecipe.variants.size.sm,
        control: {
          fontSize: "xs",
          "--stepper-width": "sizes.5"
        }
      },
      md: {
        input: _input_js__WEBPACK_IMPORTED_MODULE_2__.inputRecipe.variants.size.md,
        control: {
          fontSize: "sm",
          "--stepper-width": "sizes.6"
        }
      },
      lg: {
        input: _input_js__WEBPACK_IMPORTED_MODULE_2__.inputRecipe.variants.size.lg,
        control: {
          fontSize: "sm",
          "--stepper-width": "sizes.6"
        }
      }
    },
    variant: (0,_utils_entries_js__WEBPACK_IMPORTED_MODULE_3__.mapEntries)(_input_js__WEBPACK_IMPORTED_MODULE_2__.inputRecipe.variants.variant, (key, variantStyles) => [
      key,
      { input: variantStyles }
    ])
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/pin-input.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/pin-input.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pinInputSlotRecipe: () => (/* binding */ pinInputSlotRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _utils_entries_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/entries.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/entries.js");
/* harmony import */ var _input_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./input.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/input.js");
/* harmony import */ var _ark_ui_react_pin_input__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ark-ui/react/pin-input */ "./node_modules/@zag-js/pin-input/dist/index.mjs");






const { variants, defaultVariants } = _input_js__WEBPACK_IMPORTED_MODULE_0__.inputRecipe;
const pinInputSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_1__.defineSlotRecipe)({
  className: "chakra-pin-input",
  slots: _ark_ui_react_pin_input__WEBPACK_IMPORTED_MODULE_2__.anatomy.keys(),
  base: {
    input: {
      ..._input_js__WEBPACK_IMPORTED_MODULE_0__.inputRecipe.base,
      textAlign: "center",
      width: "var(--input-height)"
    },
    control: {
      display: "inline-flex",
      gap: "2",
      isolation: "isolate"
    }
  },
  variants: {
    size: (0,_utils_entries_js__WEBPACK_IMPORTED_MODULE_3__.mapEntries)(variants.size, (key, value) => [key, { input: value }]),
    variant: (0,_utils_entries_js__WEBPACK_IMPORTED_MODULE_3__.mapEntries)(variants.variant, (key, value) => [
      key,
      { input: value }
    ]),
    attached: {
      true: {
        control: {
          gap: "0",
          spaceX: "-1px"
        },
        input: {
          _notFirst: { borderStartRadius: "0" },
          _notLast: { borderEndRadius: "0" },
          _focusVisible: { zIndex: "1" }
        }
      }
    }
  },
  defaultVariants
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/popover.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/popover.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   popoverSlotRecipe: () => (/* binding */ popoverSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const popoverSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-popover",
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.popoverAnatomy.keys(),
  base: {
    content: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      textStyle: "sm",
      "--popover-bg": "colors.bg.panel",
      bg: "var(--popover-bg)",
      boxShadow: "lg",
      "--popover-size": "sizes.xs",
      "--popover-mobile-size": "calc(100dvw - 1rem)",
      width: {
        base: "min(var(--popover-mobile-size), var(--popover-size))",
        sm: "var(--popover-size)"
      },
      borderRadius: "l3",
      "--popover-z-index": "zIndex.popover",
      zIndex: "calc(var(--popover-z-index) + var(--layer-index, 0))",
      outline: "0",
      transformOrigin: "var(--transform-origin)",
      maxHeight: "var(--available-height)",
      _open: {
        animationStyle: "scale-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "scale-fade-out",
        animationDuration: "faster"
      }
    },
    header: {
      paddingInline: "var(--popover-padding)",
      paddingTop: "var(--popover-padding)"
    },
    body: {
      padding: "var(--popover-padding)",
      flex: "1"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      paddingInline: "var(--popover-padding)",
      paddingBottom: "var(--popover-padding)"
    },
    arrow: {
      "--arrow-size": "sizes.3",
      "--arrow-background": "var(--popover-bg)"
    },
    arrowTip: {
      borderTopWidth: "1px",
      borderInlineStartWidth: "1px"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          "--popover-padding": "spacing.3"
        }
      },
      sm: {
        content: {
          "--popover-padding": "spacing.4"
        }
      },
      md: {
        content: {
          "--popover-padding": "spacing.5"
        }
      },
      lg: {
        content: {
          "--popover-padding": "spacing.6"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/progress-circle.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/progress-circle.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   progressCircleSlotRecipe: () => (/* binding */ progressCircleSlotRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _ark_ui_react_progress__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ark-ui/react/progress */ "./node_modules/@zag-js/progress/dist/index.mjs");




const progressCircleSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-progress-circle",
  slots: _ark_ui_react_progress__WEBPACK_IMPORTED_MODULE_1__.anatomy.keys(),
  base: {
    root: {
      display: "inline-flex",
      textStyle: "sm",
      position: "relative"
    },
    circle: {
      _indeterminate: {
        animation: "spin 2s linear infinite"
      }
    },
    circleTrack: {
      "--track-color": "colors.colorPalette.muted",
      stroke: "var(--track-color)"
    },
    circleRange: {
      stroke: "colorPalette.solid",
      transitionProperty: "stroke-dasharray",
      transitionDuration: "0.6s",
      _indeterminate: {
        animation: "circular-progress 1.5s linear infinite"
      }
    },
    label: {
      display: "inline-flex"
    },
    valueText: {
      lineHeight: "1",
      fontWeight: "medium",
      letterSpacing: "tight",
      fontVariantNumeric: "tabular-nums"
    }
  },
  variants: {
    size: {
      xs: {
        circle: {
          "--size": "24px",
          "--thickness": "4px"
        },
        valueText: {
          textStyle: "2xs"
        }
      },
      sm: {
        circle: {
          "--size": "32px",
          "--thickness": "5px"
        },
        valueText: {
          textStyle: "2xs"
        }
      },
      md: {
        circle: {
          "--size": "40px",
          "--thickness": "6px"
        },
        valueText: {
          textStyle: "xs"
        }
      },
      lg: {
        circle: {
          "--size": "48px",
          "--thickness": "7px"
        },
        valueText: {
          textStyle: "sm"
        }
      },
      xl: {
        circle: {
          "--size": "64px",
          "--thickness": "8px"
        },
        valueText: {
          textStyle: "sm"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/progress.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/progress.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   progressSlotRecipe: () => (/* binding */ progressSlotRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _ark_ui_react_progress__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ark-ui/react/progress */ "./node_modules/@zag-js/progress/dist/index.mjs");




const progressSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  slots: _ark_ui_react_progress__WEBPACK_IMPORTED_MODULE_1__.anatomy.keys(),
  className: "chakra-progress",
  base: {
    root: {
      textStyle: "sm",
      position: "relative"
    },
    track: {
      overflow: "hidden",
      position: "relative"
    },
    range: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transitionProperty: "width, height",
      transitionDuration: "slow",
      height: "100%",
      bgColor: "var(--track-color)",
      _indeterminate: {
        "--animate-from-x": "-40%",
        "--animate-to-x": "100%",
        position: "absolute",
        willChange: "left",
        minWidth: "50%",
        animation: "position 1s ease infinite normal none running",
        backgroundImage: `linear-gradient(to right, transparent 0%, var(--track-color) 50%, transparent 100%)`
      }
    },
    label: {
      display: "inline-flex",
      fontWeight: "medium",
      alignItems: "center",
      gap: "1"
    },
    valueText: {
      textStyle: "xs",
      lineHeight: "1",
      fontWeight: "medium"
    }
  },
  variants: {
    variant: {
      outline: {
        track: {
          shadow: "inset",
          bgColor: "bg.muted"
        },
        range: {
          bgColor: "colorPalette.solid"
        }
      },
      subtle: {
        track: {
          bgColor: "colorPalette.muted"
        },
        range: {
          bgColor: "colorPalette.solid/72"
        }
      }
    },
    shape: {
      square: {},
      rounded: {
        track: {
          borderRadius: "l1"
        }
      },
      full: {
        track: {
          borderRadius: "full"
        }
      }
    },
    striped: {
      true: {
        range: {
          backgroundImage: `linear-gradient(45deg, var(--stripe-color) 25%, transparent 25%, transparent 50%, var(--stripe-color) 50%, var(--stripe-color) 75%, transparent 75%, transparent)`,
          backgroundSize: `var(--stripe-size) var(--stripe-size)`,
          "--stripe-size": "1rem",
          "--stripe-color": {
            _light: "rgba(255, 255, 255, 0.3)",
            _dark: "rgba(0, 0, 0, 0.3)"
          }
        }
      }
    },
    animated: {
      true: {
        range: {
          "--animate-from": "var(--stripe-size)",
          animation: "bg-position 1s linear infinite"
        }
      }
    },
    size: {
      xs: {
        track: { h: "1.5" }
      },
      sm: {
        track: { h: "2" }
      },
      md: {
        track: { h: "2.5" }
      },
      lg: {
        track: { h: "3" }
      },
      xl: {
        track: { h: "4" }
      }
    }
  },
  defaultVariants: {
    variant: "outline",
    size: "md",
    shape: "rounded"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/qr-code.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/qr-code.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   qrCodeSlotRecipe: () => (/* binding */ qrCodeSlotRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _ark_ui_react_qr_code__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ark-ui/react/qr-code */ "./node_modules/@zag-js/qr-code/dist/index.mjs");




const qrCodeSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  slots: _ark_ui_react_qr_code__WEBPACK_IMPORTED_MODULE_1__.anatomy.keys(),
  className: "chakra-qr-code",
  base: {
    root: {
      position: "relative",
      width: "fit-content",
      "--qr-code-overlay-size": "calc(var(--qr-code-size) / 3)"
    },
    frame: {
      width: "var(--qr-code-size)",
      height: "var(--qr-code-size)",
      fill: "currentColor"
    },
    overlay: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: "var(--qr-code-overlay-size)",
      height: "var(--qr-code-overlay-size)",
      padding: "1",
      bg: "bg",
      rounded: "l1"
    }
  },
  variants: {
    size: {
      "2xs": {
        root: { "--qr-code-size": "40px" }
      },
      xs: {
        root: { "--qr-code-size": "64px" }
      },
      sm: {
        root: { "--qr-code-size": "80px" }
      },
      md: {
        root: { "--qr-code-size": "120px" }
      },
      lg: {
        root: { "--qr-code-size": "160px" }
      },
      xl: {
        root: { "--qr-code-size": "200px" }
      },
      "2xl": {
        root: { "--qr-code-size": "240px" }
      },
      full: {
        root: { "--qr-code-size": "100%" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/radio-card.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/radio-card.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   radioCardSlotRecipe: () => (/* binding */ radioCardSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _radiomark_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./radiomark.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/radiomark.js");





const radioCardSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-radio-card",
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.radioCardAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5",
      isolation: "isolate"
    },
    item: {
      flex: "1",
      display: "flex",
      flexDirection: "column",
      userSelect: "none",
      position: "relative",
      borderRadius: "l2",
      _focus: {
        bg: "colorPalette.muted/20"
      },
      _disabled: {
        opacity: "0.8",
        borderColor: "border.disabled"
      },
      _checked: {
        zIndex: "1"
      }
    },
    label: {
      display: "inline-flex",
      fontWeight: "medium",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    },
    itemText: {
      fontWeight: "medium",
      flex: "1"
    },
    itemDescription: {
      opacity: "0.64",
      textStyle: "sm"
    },
    itemControl: {
      display: "inline-flex",
      flex: "1",
      pos: "relative",
      rounded: "inherit",
      justifyContent: "var(--radio-card-justify)",
      alignItems: "var(--radio-card-align)",
      _disabled: {
        bg: "bg.muted"
      }
    },
    itemIndicator: _radiomark_js__WEBPACK_IMPORTED_MODULE_2__.radiomarkRecipe.base,
    itemAddon: {
      roundedBottom: "inherit",
      _disabled: {
        color: "fg.muted"
      }
    },
    itemContent: {
      display: "flex",
      flexDirection: "column",
      flex: "1",
      gap: "1",
      justifyContent: "var(--radio-card-justify)",
      alignItems: "var(--radio-card-align)"
    }
  },
  variants: {
    size: {
      sm: {
        item: {
          textStyle: "sm"
        },
        itemControl: {
          padding: "3",
          gap: "1.5"
        },
        itemAddon: {
          px: "3",
          py: "1.5",
          borderTopWidth: "1px"
        },
        itemIndicator: _radiomark_js__WEBPACK_IMPORTED_MODULE_2__.radiomarkRecipe.variants?.size.sm
      },
      md: {
        item: {
          textStyle: "sm"
        },
        itemControl: {
          padding: "4",
          gap: "2.5"
        },
        itemAddon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        itemIndicator: _radiomark_js__WEBPACK_IMPORTED_MODULE_2__.radiomarkRecipe.variants?.size.md
      },
      lg: {
        item: {
          textStyle: "md"
        },
        itemControl: {
          padding: "4",
          gap: "3.5"
        },
        itemAddon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        itemIndicator: _radiomark_js__WEBPACK_IMPORTED_MODULE_2__.radiomarkRecipe.variants?.size.lg
      }
    },
    variant: {
      surface: {
        item: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg",
            borderColor: "colorPalette.muted"
          }
        },
        itemIndicator: _radiomark_js__WEBPACK_IMPORTED_MODULE_2__.radiomarkRecipe.variants?.variant.solid
      },
      subtle: {
        item: {
          bg: "bg.muted"
        },
        itemControl: {
          _checked: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          }
        },
        itemIndicator: _radiomark_js__WEBPACK_IMPORTED_MODULE_2__.radiomarkRecipe.variants?.variant.outline
      },
      outline: {
        item: {
          borderWidth: "1px",
          _checked: {
            boxShadow: "0 0 0 1px var(--shadow-color)",
            boxShadowColor: "colorPalette.solid",
            borderColor: "colorPalette.solid"
          }
        },
        itemIndicator: _radiomark_js__WEBPACK_IMPORTED_MODULE_2__.radiomarkRecipe.variants?.variant.solid
      },
      solid: {
        item: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast",
            borderColor: "colorPalette.solid"
          }
        },
        itemIndicator: _radiomark_js__WEBPACK_IMPORTED_MODULE_2__.radiomarkRecipe.variants?.variant.inverted
      }
    },
    justify: {
      start: {
        item: { "--radio-card-justify": "flex-start" }
      },
      end: {
        item: { "--radio-card-justify": "flex-end" }
      },
      center: {
        item: { "--radio-card-justify": "center" }
      }
    },
    align: {
      start: {
        item: { "--radio-card-align": "flex-start" },
        itemControl: { textAlign: "start" }
      },
      end: {
        item: { "--radio-card-align": "flex-end" },
        itemControl: { textAlign: "end" }
      },
      center: {
        item: { "--radio-card-align": "center" },
        itemControl: { textAlign: "center" }
      }
    },
    orientation: {
      vertical: {
        itemControl: { flexDirection: "column" }
      },
      horizontal: {
        itemControl: { flexDirection: "row" }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    align: "start",
    orientation: "horizontal"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/radio-group.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/radio-group.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   radioGroupSlotRecipe: () => (/* binding */ radioGroupSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _radiomark_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./radiomark.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/radiomark.js");





const radioGroupSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-radio-group",
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.radioGroupAnatomy.keys(),
  base: {
    item: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative",
      fontWeight: "medium",
      _disabled: {
        cursor: "disabled"
      }
    },
    itemControl: _radiomark_js__WEBPACK_IMPORTED_MODULE_2__.radiomarkRecipe.base,
    label: {
      userSelect: "none",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        itemControl: _radiomark_js__WEBPACK_IMPORTED_MODULE_2__.radiomarkRecipe.variants?.variant?.outline
      },
      subtle: {
        itemControl: _radiomark_js__WEBPACK_IMPORTED_MODULE_2__.radiomarkRecipe.variants?.variant?.subtle
      },
      solid: {
        itemControl: _radiomark_js__WEBPACK_IMPORTED_MODULE_2__.radiomarkRecipe.variants?.variant?.solid
      }
    },
    size: {
      xs: {
        item: { textStyle: "xs", gap: "1.5" },
        itemControl: _radiomark_js__WEBPACK_IMPORTED_MODULE_2__.radiomarkRecipe.variants?.size?.xs
      },
      sm: {
        item: { textStyle: "sm", gap: "2" },
        itemControl: _radiomark_js__WEBPACK_IMPORTED_MODULE_2__.radiomarkRecipe.variants?.size?.sm
      },
      md: {
        item: { textStyle: "sm", gap: "2.5" },
        itemControl: _radiomark_js__WEBPACK_IMPORTED_MODULE_2__.radiomarkRecipe.variants?.size?.md
      },
      lg: {
        item: { textStyle: "md", gap: "3" },
        itemControl: _radiomark_js__WEBPACK_IMPORTED_MODULE_2__.radiomarkRecipe.variants?.size?.lg
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/radiomark.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/radiomark.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   radiomarkRecipe: () => (/* binding */ radiomarkRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const radiomarkRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineRecipe)({
  className: "chakra-radiomark",
  base: {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    verticalAlign: "top",
    color: "white",
    borderWidth: "1px",
    borderColor: "transparent",
    borderRadius: "full",
    cursor: "radio",
    _focusVisible: {
      outline: "2px solid",
      outlineColor: "colorPalette.focusRing",
      outlineOffset: "2px"
    },
    _invalid: {
      colorPalette: "red",
      borderColor: "red.500"
    },
    _disabled: {
      opacity: "0.5",
      cursor: "disabled"
    },
    "& .dot": {
      height: "100%",
      width: "100%",
      borderRadius: "full",
      bg: "currentColor",
      scale: "0.4"
    }
  },
  variants: {
    variant: {
      solid: {
        borderWidth: "1px",
        borderColor: "border",
        _checked: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast",
          borderColor: "colorPalette.solid"
        }
      },
      subtle: {
        borderWidth: "1px",
        bg: "colorPalette.muted",
        borderColor: "colorPalette.muted",
        color: "transparent",
        _checked: {
          color: "colorPalette.fg"
        }
      },
      outline: {
        borderWidth: "1px",
        borderColor: "inherit",
        _checked: {
          color: "colorPalette.fg",
          borderColor: "colorPalette.solid"
        },
        "& .dot": {
          scale: "0.6"
        }
      },
      inverted: {
        bg: "bg",
        borderWidth: "1px",
        borderColor: "inherit",
        _checked: {
          color: "colorPalette.solid",
          borderColor: "currentcolor"
        }
      }
    },
    size: {
      xs: {
        boxSize: "3"
      },
      sm: {
        boxSize: "4"
      },
      md: {
        boxSize: "5"
      },
      lg: {
        boxSize: "6"
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/rating-group.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/rating-group.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ratingGroupSlotRecipe: () => (/* binding */ ratingGroupSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const ratingGroupSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-rating-group",
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.ratingGroupAnatomy.keys(),
  base: {
    root: {
      display: "inline-flex"
    },
    control: {
      display: "inline-flex",
      alignItems: "center"
    },
    item: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      userSelect: "none"
    },
    itemIndicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      width: "1em",
      height: "1em",
      position: "relative",
      "--clip-path": { base: "inset(0 50% 0 0)", _rtl: "inset(0 0 0 50%)" },
      _icon: {
        stroke: "currentColor",
        width: "100%",
        height: "100%",
        display: "inline-block",
        flexShrink: 0,
        position: "absolute",
        left: 0,
        top: 0
      },
      "& [data-bg]": {
        color: "bg.emphasized"
      },
      "& [data-fg]": {
        color: "transparent"
      },
      "&[data-highlighted]:not([data-half])": {
        "& [data-fg]": {
          color: "colorPalette.solid"
        }
      },
      "&[data-half]": {
        "& [data-fg]": {
          color: "colorPalette.solid",
          clipPath: "var(--clip-path)"
        }
      }
    }
  },
  variants: {
    size: {
      xs: {
        item: {
          textStyle: "sm"
        }
      },
      sm: {
        item: {
          textStyle: "md"
        }
      },
      md: {
        item: {
          textStyle: "xl"
        }
      },
      lg: {
        item: {
          textStyle: "2xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/segment-group.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/segment-group.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   segmentGroupSlotRecipe: () => (/* binding */ segmentGroupSlotRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _ark_ui_react_segment_group__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ark-ui/react/segment-group */ "./node_modules/@ark-ui/react/dist/components/segment-group/segment-group.anatomy.js");




const segmentGroupSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-segment-group",
  slots: _ark_ui_react_segment_group__WEBPACK_IMPORTED_MODULE_1__.segmentGroupAnatomy.keys(),
  base: {
    root: {
      "--segment-radius": "radii.l2",
      borderRadius: "l2",
      display: "inline-flex",
      boxShadow: "inset",
      minW: "max-content",
      textAlign: "center",
      position: "relative",
      isolation: "isolate",
      bg: "bg.muted",
      _vertical: {
        flexDirection: "column"
      }
    },
    item: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      userSelect: "none",
      fontSize: "sm",
      position: "relative",
      color: "fg",
      borderRadius: "var(--segment-radius)",
      _disabled: {
        opacity: "0.5"
      },
      "&:has(input:focus-visible)": {
        focusRing: "outside"
      },
      _before: {
        content: '""',
        position: "absolute",
        bg: "border",
        transition: "opacity 0.2s"
      },
      _horizontal: {
        _before: {
          insetInlineStart: 0,
          insetBlock: "1.5",
          width: "1px"
        }
      },
      _vertical: {
        _before: {
          insetBlockStart: 0,
          insetInline: "1.5",
          height: "1px"
        }
      },
      "& + &[data-state=checked], &[data-state=checked] + &, &:first-of-type": {
        _before: {
          opacity: "0"
        }
      },
      "&[data-state=checked][data-ssr]": {
        shadow: "sm",
        bg: "bg",
        borderRadius: "var(--segment-radius)"
      }
    },
    indicator: {
      shadow: "sm",
      pos: "absolute",
      bg: { _light: "bg", _dark: "bg.emphasized" },
      width: "var(--width)",
      height: "var(--height)",
      top: "var(--top)",
      left: "var(--left)",
      zIndex: -1,
      borderRadius: "var(--segment-radius)"
    }
  },
  variants: {
    size: {
      xs: {
        item: {
          textStyle: "xs",
          px: "3",
          gap: "1",
          height: "6"
        }
      },
      sm: {
        item: {
          textStyle: "sm",
          px: "4",
          gap: "2",
          height: "8"
        }
      },
      md: {
        item: {
          textStyle: "sm",
          px: "4",
          gap: "2",
          height: "10"
        }
      },
      lg: {
        item: {
          textStyle: "md",
          px: "4.5",
          gap: "3",
          height: "11"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/select.js":
/*!************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/select.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   selectSlotRecipe: () => (/* binding */ selectSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const selectSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-select",
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.selectAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5",
      width: "full"
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      width: "full",
      minH: "var(--select-trigger-height)",
      "--input-height": "var(--select-trigger-height)",
      px: "var(--select-trigger-padding-x)",
      borderRadius: "l2",
      userSelect: "none",
      textAlign: "start",
      focusVisibleRing: "inside",
      _placeholderShown: {
        color: "fg.muted/80"
      },
      _disabled: {
        layerStyle: "disabled"
      },
      _invalid: {
        borderColor: "border.error"
      }
    },
    indicatorGroup: {
      display: "flex",
      alignItems: "center",
      gap: "1",
      pos: "absolute",
      right: "0",
      top: "0",
      bottom: "0",
      px: "var(--select-trigger-padding-x)",
      pointerEvents: "none"
    },
    indicator: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: { base: "fg.muted", _disabled: "fg.subtle", _invalid: "fg.error" }
    },
    content: {
      background: "bg.panel",
      display: "flex",
      flexDirection: "column",
      zIndex: "dropdown",
      borderRadius: "l2",
      outline: 0,
      maxH: "96",
      overflowY: "auto",
      boxShadow: "md",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "fastest"
      }
    },
    item: {
      position: "relative",
      userSelect: "none",
      display: "flex",
      alignItems: "center",
      gap: "2",
      cursor: "option",
      justifyContent: "space-between",
      flex: "1",
      textAlign: "start",
      borderRadius: "l1",
      _highlighted: {
        bg: "bg.emphasized/60"
      },
      _disabled: {
        pointerEvents: "none",
        opacity: "0.5"
      },
      _icon: {
        width: "4",
        height: "4"
      }
    },
    control: {
      pos: "relative"
    },
    itemText: {
      flex: "1"
    },
    itemGroup: {
      _first: { mt: "0" }
    },
    itemGroupLabel: {
      py: "1",
      fontWeight: "medium"
    },
    label: {
      fontWeight: "medium",
      userSelect: "none",
      textStyle: "sm",
      _disabled: {
        layerStyle: "disabled"
      }
    },
    valueText: {
      lineClamp: "1",
      maxW: "80%"
    },
    clearTrigger: {
      color: "fg.muted",
      pointerEvents: "auto",
      focusVisibleRing: "inside",
      focusRingWidth: "2px",
      rounded: "l1"
    }
  },
  variants: {
    variant: {
      outline: {
        trigger: {
          bg: "transparent",
          borderWidth: "1px",
          borderColor: "border",
          _expanded: {
            borderColor: "border.emphasized"
          }
        }
      },
      subtle: {
        trigger: {
          borderWidth: "1px",
          borderColor: "transparent",
          bg: "bg.muted"
        }
      }
    },
    size: {
      xs: {
        root: {
          "--select-trigger-height": "sizes.8",
          "--select-trigger-padding-x": "spacing.2"
        },
        content: {
          p: "1",
          gap: "1",
          textStyle: "xs"
        },
        trigger: {
          textStyle: "xs",
          gap: "1"
        },
        item: {
          py: "1",
          px: "2"
        },
        itemGroupLabel: {
          py: "1",
          px: "2"
        },
        indicator: {
          _icon: {
            width: "3.5",
            height: "3.5"
          }
        }
      },
      sm: {
        root: {
          "--select-trigger-height": "sizes.9",
          "--select-trigger-padding-x": "spacing.2.5"
        },
        content: {
          p: "1",
          textStyle: "sm"
        },
        trigger: {
          textStyle: "sm",
          gap: "1"
        },
        indicator: {
          _icon: {
            width: "4",
            height: "4"
          }
        },
        item: {
          py: "1",
          px: "1.5"
        },
        itemGroup: {
          mt: "1"
        },
        itemGroupLabel: {
          py: "1",
          px: "1.5"
        }
      },
      md: {
        root: {
          "--select-trigger-height": "sizes.10",
          "--select-trigger-padding-x": "spacing.3"
        },
        content: {
          p: "1",
          textStyle: "sm"
        },
        itemGroup: {
          mt: "1.5"
        },
        item: {
          py: "1.5",
          px: "2"
        },
        itemIndicator: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center"
        },
        itemGroupLabel: {
          py: "1.5",
          px: "2"
        },
        trigger: {
          textStyle: "sm",
          gap: "2"
        },
        indicator: {
          _icon: {
            width: "4",
            height: "4"
          }
        }
      },
      lg: {
        root: {
          "--select-trigger-height": "sizes.12",
          "--select-trigger-padding-x": "spacing.4"
        },
        content: {
          p: "1.5",
          textStyle: "md"
        },
        itemGroup: {
          mt: "2"
        },
        item: {
          py: "2",
          px: "3"
        },
        itemGroupLabel: {
          py: "2",
          px: "3"
        },
        trigger: {
          textStyle: "md",
          py: "3",
          gap: "2"
        },
        indicator: {
          _icon: {
            width: "5",
            height: "5"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/separator.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/separator.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   separatorRecipe: () => (/* binding */ separatorRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const separatorRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineRecipe)({
  className: "chakra-separator",
  base: {
    display: "block",
    borderColor: "border"
  },
  variants: {
    variant: {
      solid: {
        borderStyle: "solid"
      },
      dashed: {
        borderStyle: "dashed"
      },
      dotted: {
        borderStyle: "dotted"
      }
    },
    orientation: {
      vertical: {
        borderInlineStartWidth: "var(--separator-thickness)"
      },
      horizontal: {
        borderTopWidth: "var(--separator-thickness)"
      }
    },
    size: {
      xs: {
        "--separator-thickness": "0.5px"
      },
      sm: {
        "--separator-thickness": "1px"
      },
      md: {
        "--separator-thickness": "2px"
      },
      lg: {
        "--separator-thickness": "3px"
      }
    }
  },
  defaultVariants: {
    size: "sm",
    variant: "solid",
    orientation: "horizontal"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/skeleton.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/skeleton.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   skeletonRecipe: () => (/* binding */ skeletonRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const skeletonRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineRecipe)({
  className: "chakra-skeleton",
  base: {},
  variants: {
    loading: {
      true: {
        borderRadius: "l2",
        boxShadow: "none",
        backgroundClip: "padding-box",
        cursor: "default",
        color: "transparent",
        pointerEvents: "none",
        userSelect: "none",
        flexShrink: "0",
        "&::before, &::after, *": {
          visibility: "hidden"
        }
      },
      false: {
        background: "unset",
        animation: "fade-in var(--fade-duration, 0.1s) ease-out !important"
      }
    },
    variant: {
      pulse: {
        background: "bg.emphasized",
        animation: "pulse",
        animationDuration: "var(--duration, 1.2s)"
      },
      shine: {
        "--animate-from": "200%",
        "--animate-to": "-200%",
        "--start-color": "colors.bg.muted",
        "--end-color": "colors.bg.emphasized",
        backgroundImage: "linear-gradient(270deg,var(--start-color),var(--end-color),var(--end-color),var(--start-color))",
        backgroundSize: "400% 100%",
        animation: "bg-position var(--duration, 5s) ease-in-out infinite"
      },
      none: {
        animation: "none"
      }
    }
  },
  defaultVariants: {
    variant: "pulse",
    loading: true
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/skip-nav-link.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/skip-nav-link.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   skipNavLinkRecipe: () => (/* binding */ skipNavLinkRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const skipNavLinkRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineRecipe)({
  className: "chakra-skip-nav",
  base: {
    display: "inline-flex",
    bg: "bg.panel",
    padding: "2.5",
    borderRadius: "l2",
    fontWeight: "semibold",
    focusVisibleRing: "outside",
    textStyle: "sm",
    // visually hidden
    userSelect: "none",
    border: "0",
    height: "1px",
    width: "1px",
    margin: "-1px",
    outline: "0",
    overflow: "hidden",
    position: "absolute",
    clip: "rect(0 0 0 0)",
    _focusVisible: {
      clip: "auto",
      width: "auto",
      height: "auto",
      position: "fixed",
      top: "6",
      insetStart: "6"
    }
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/slider.js":
/*!************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/slider.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sliderSlotRecipe: () => (/* binding */ sliderSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const sliderSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-slider",
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.sliderAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1",
      textStyle: "sm",
      position: "relative",
      isolation: "isolate",
      touchAction: "none"
    },
    label: {
      fontWeight: "medium",
      textStyle: "sm"
    },
    control: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative"
    },
    track: {
      overflow: "hidden",
      borderRadius: "full",
      flex: "1"
    },
    range: {
      width: "inherit",
      height: "inherit",
      _disabled: { bg: "border.emphasized!" }
    },
    markerGroup: {
      position: "absolute!",
      zIndex: "1"
    },
    marker: {
      "--marker-bg": { base: "white", _underValue: "colors.bg" },
      display: "flex",
      alignItems: "center",
      gap: "calc(var(--slider-thumb-size) / 2)",
      color: "fg.muted",
      textStyle: "xs"
    },
    markerIndicator: {
      width: "var(--slider-marker-size)",
      height: "var(--slider-marker-size)",
      borderRadius: "full",
      bg: "var(--marker-bg)"
    },
    thumb: {
      width: "var(--slider-thumb-size)",
      height: "var(--slider-thumb-size)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      outline: 0,
      zIndex: "2",
      borderRadius: "full",
      _focusVisible: {
        ring: "2px",
        ringColor: "colorPalette.focusRing",
        ringOffset: "2px",
        ringOffsetColor: "bg"
      }
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          "--slider-thumb-size": "sizes.4",
          "--slider-track-size": "sizes.1.5",
          "--slider-marker-center": "6px",
          "--slider-marker-size": "sizes.1",
          "--slider-marker-inset": "3px"
        }
      },
      md: {
        root: {
          "--slider-thumb-size": "sizes.5",
          "--slider-track-size": "sizes.2",
          "--slider-marker-center": "8px",
          "--slider-marker-size": "sizes.1",
          "--slider-marker-inset": "4px"
        }
      },
      lg: {
        root: {
          "--slider-thumb-size": "sizes.6",
          "--slider-track-size": "sizes.2.5",
          "--slider-marker-center": "9px",
          "--slider-marker-size": "sizes.1.5",
          "--slider-marker-inset": "5px"
        }
      }
    },
    variant: {
      outline: {
        track: {
          shadow: "inset",
          bg: "bg.emphasized/72"
        },
        range: {
          bg: "colorPalette.solid"
        },
        thumb: {
          borderWidth: "2px",
          borderColor: "colorPalette.solid",
          bg: "bg",
          _disabled: {
            bg: "border.emphasized",
            borderColor: "border.emphasized"
          }
        }
      },
      solid: {
        track: {
          bg: "colorPalette.subtle",
          _disabled: {
            bg: "bg.muted"
          }
        },
        range: {
          bg: "colorPalette.solid"
        },
        thumb: {
          bg: "colorPalette.solid",
          _disabled: {
            bg: "border.emphasized"
          }
        }
      }
    },
    orientation: {
      vertical: {
        root: {
          display: "inline-flex"
        },
        control: {
          flexDirection: "column",
          height: "100%",
          minWidth: "var(--slider-thumb-size)",
          "&[data-has-mark-label], &:has(.chakra-slider__marker-label)": {
            marginEnd: "4"
          }
        },
        track: {
          width: "var(--slider-track-size)"
        },
        thumb: {
          left: "50%",
          translate: "-50% 0"
        },
        markerGroup: {
          insetStart: "var(--slider-marker-center)",
          insetBlock: "var(--slider-marker-inset)"
        },
        marker: {
          flexDirection: "row"
        }
      },
      horizontal: {
        control: {
          flexDirection: "row",
          width: "100%",
          minHeight: "var(--slider-thumb-size)",
          "&[data-has-mark-label], &:has(.chakra-slider__marker-label)": {
            marginBottom: "4"
          }
        },
        track: {
          height: "var(--slider-track-size)"
        },
        thumb: {
          top: "50%",
          translate: "0 -50%"
        },
        markerGroup: {
          top: "var(--slider-marker-center)",
          insetInline: "var(--slider-marker-inset)"
        },
        marker: {
          flexDirection: "column"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    orientation: "horizontal"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/spinner.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/spinner.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   spinnerRecipe: () => (/* binding */ spinnerRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const spinnerRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineRecipe)({
  className: "chakra-spinner",
  base: {
    display: "inline-block",
    borderColor: "currentColor",
    borderStyle: "solid",
    borderWidth: "2px",
    borderRadius: "full",
    width: "var(--spinner-size)",
    height: "var(--spinner-size)",
    animation: "spin",
    animationDuration: "slowest",
    "--spinner-track-color": "transparent",
    borderBottomColor: "var(--spinner-track-color)",
    borderInlineStartColor: "var(--spinner-track-color)"
  },
  variants: {
    size: {
      inherit: { "--spinner-size": "1em" },
      xs: { "--spinner-size": "sizes.3" },
      sm: { "--spinner-size": "sizes.4" },
      md: { "--spinner-size": "sizes.5" },
      lg: { "--spinner-size": "sizes.8" },
      xl: { "--spinner-size": "sizes.10" }
    }
  },
  defaultVariants: {
    size: "md"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/stat.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/stat.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   statSlotRecipe: () => (/* binding */ statSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const statSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-stat",
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.statAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1",
      position: "relative",
      flex: "1"
    },
    label: {
      display: "inline-flex",
      gap: "1.5",
      alignItems: "center",
      color: "fg.muted",
      textStyle: "sm"
    },
    helpText: {
      color: "fg.muted",
      textStyle: "xs"
    },
    valueUnit: {
      color: "fg.muted",
      textStyle: "xs",
      fontWeight: "initial",
      letterSpacing: "initial"
    },
    valueText: {
      verticalAlign: "baseline",
      fontWeight: "semibold",
      letterSpacing: "tight",
      fontFeatureSettings: "pnum",
      fontVariantNumeric: "proportional-nums",
      display: "inline-flex",
      gap: "1"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      marginEnd: 1,
      "& :where(svg)": {
        w: "1em",
        h: "1em"
      },
      "&[data-type=up]": {
        color: "fg.success"
      },
      "&[data-type=down]": {
        color: "fg.error"
      }
    }
  },
  variants: {
    size: {
      sm: {
        valueText: {
          textStyle: "xl"
        }
      },
      md: {
        valueText: {
          textStyle: "2xl"
        }
      },
      lg: {
        valueText: {
          textStyle: "3xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/status.js":
/*!************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/status.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   statusSlotRecipe: () => (/* binding */ statusSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const statusSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-status",
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.statusAnatomy.keys(),
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      gap: "2"
    },
    indicator: {
      width: "0.64em",
      height: "0.64em",
      flexShrink: 0,
      borderRadius: "full",
      forcedColorAdjust: "none",
      bg: "colorPalette.solid"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/steps.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/steps.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   stepsSlotRecipe: () => (/* binding */ stepsSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const stepsSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-steps",
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.stepsAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      width: "full"
    },
    list: {
      display: "flex",
      justifyContent: "space-between",
      "--steps-gutter": "spacing.3",
      "--steps-thickness": "2px"
    },
    title: {
      fontWeight: "medium",
      color: "fg"
    },
    description: {
      color: "fg.muted"
    },
    separator: {
      bg: "border",
      flex: "1"
    },
    indicator: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      flexShrink: "0",
      borderRadius: "full",
      fontWeight: "medium",
      width: "var(--steps-size)",
      height: "var(--steps-size)",
      _icon: {
        flexShrink: "0",
        width: "var(--steps-icon-size)",
        height: "var(--steps-icon-size)"
      }
    },
    item: {
      position: "relative",
      display: "flex",
      gap: "3",
      flex: "1 0 0",
      "&:last-of-type": {
        flex: "initial",
        "& [data-part=separator]": {
          display: "none"
        }
      }
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      gap: "3",
      textAlign: "start",
      focusVisibleRing: "outside",
      borderRadius: "l2"
    },
    content: {
      focusVisibleRing: "outside"
    }
  },
  variants: {
    orientation: {
      vertical: {
        root: {
          flexDirection: "row",
          height: "100%"
        },
        list: {
          flexDirection: "column",
          alignItems: "flex-start"
        },
        separator: {
          position: "absolute",
          width: "var(--steps-thickness)",
          height: "100%",
          maxHeight: "calc(100% - var(--steps-size) - var(--steps-gutter) * 2)",
          top: "calc(var(--steps-size) + var(--steps-gutter))",
          insetStart: "calc(var(--steps-size) / 2 - 1px)"
        },
        item: {
          alignItems: "flex-start"
        }
      },
      horizontal: {
        root: {
          flexDirection: "column",
          width: "100%"
        },
        list: {
          flexDirection: "row",
          alignItems: "center"
        },
        separator: {
          width: "100%",
          height: "var(--steps-thickness)",
          marginX: "var(--steps-gutter)"
        },
        item: {
          alignItems: "center"
        }
      }
    },
    variant: {
      solid: {
        indicator: {
          _incomplete: {
            borderWidth: "var(--steps-thickness)"
          },
          _current: {
            bg: "colorPalette.muted",
            borderWidth: "var(--steps-thickness)",
            borderColor: "colorPalette.solid",
            color: "colorPalette.fg"
          },
          _complete: {
            bg: "colorPalette.solid",
            borderColor: "colorPalette.solid",
            color: "colorPalette.contrast"
          }
        },
        separator: {
          _complete: {
            bg: "colorPalette.solid"
          }
        }
      },
      subtle: {
        indicator: {
          _incomplete: {
            bg: "bg.muted"
          },
          _current: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          },
          _complete: {
            bg: "colorPalette.emphasized",
            color: "colorPalette.fg"
          }
        },
        separator: {
          _complete: {
            bg: "colorPalette.emphasized"
          }
        }
      }
    },
    size: {
      xs: {
        root: {
          gap: "2.5"
        },
        list: {
          "--steps-size": "sizes.6",
          "--steps-icon-size": "sizes.3.5",
          textStyle: "xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      sm: {
        root: {
          gap: "3"
        },
        list: {
          "--steps-size": "sizes.8",
          "--steps-icon-size": "sizes.4",
          textStyle: "xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      md: {
        root: {
          gap: "4"
        },
        list: {
          "--steps-size": "sizes.10",
          "--steps-icon-size": "sizes.4",
          textStyle: "sm"
        },
        title: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          gap: "6"
        },
        list: {
          "--steps-size": "sizes.11",
          "--steps-icon-size": "sizes.5",
          textStyle: "md"
        },
        title: {
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid",
    orientation: "horizontal"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/switch.js":
/*!************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/switch.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   switchSlotRecipe: () => (/* binding */ switchSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const switchSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.switchAnatomy.keys(),
  className: "chakra-switch",
  base: {
    root: {
      display: "inline-flex",
      gap: "2.5",
      alignItems: "center",
      position: "relative",
      verticalAlign: "middle",
      "--switch-diff": "calc(var(--switch-width) - var(--switch-height))",
      "--switch-x": {
        base: "var(--switch-diff)",
        _rtl: "calc(var(--switch-diff) * -1)"
      }
    },
    label: {
      lineHeight: "1",
      userSelect: "none",
      fontSize: "sm",
      fontWeight: "medium",
      _disabled: {
        opacity: "0.5"
      }
    },
    indicator: {
      position: "absolute",
      height: "var(--switch-height)",
      width: "var(--switch-height)",
      fontSize: "var(--switch-indicator-font-size)",
      fontWeight: "medium",
      flexShrink: 0,
      userSelect: "none",
      display: "grid",
      placeContent: "center",
      transition: "inset-inline-start 0.12s ease",
      insetInlineStart: "calc(var(--switch-x) - 2px)",
      _checked: {
        insetInlineStart: "2px"
      }
    },
    control: {
      display: "inline-flex",
      gap: "0.5rem",
      flexShrink: 0,
      justifyContent: "flex-start",
      cursor: "switch",
      borderRadius: "full",
      position: "relative",
      width: "var(--switch-width)",
      height: "var(--switch-height)",
      transition: "backgrounds",
      _disabled: {
        opacity: "0.5",
        cursor: "not-allowed"
      },
      _invalid: {
        outline: "2px solid",
        outlineColor: "border.error",
        outlineOffset: "2px"
      }
    },
    thumb: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: 0,
      transitionProperty: "translate",
      transitionDuration: "fast",
      borderRadius: "inherit",
      _checked: {
        translate: "var(--switch-x) 0"
      }
    }
  },
  variants: {
    variant: {
      solid: {
        control: {
          borderRadius: "full",
          bg: "bg.emphasized",
          focusVisibleRing: "outside",
          _checked: {
            bg: "colorPalette.solid"
          }
        },
        thumb: {
          bg: "white",
          width: "var(--switch-height)",
          height: "var(--switch-height)",
          scale: "0.8",
          boxShadow: "sm",
          _checked: {
            bg: "colorPalette.contrast"
          }
        }
      },
      raised: {
        control: {
          borderRadius: "full",
          height: "calc(var(--switch-height) / 2)",
          bg: "bg.muted",
          boxShadow: "inset",
          _checked: {
            bg: "colorPalette.solid/60"
          }
        },
        thumb: {
          width: "var(--switch-height)",
          height: "var(--switch-height)",
          position: "relative",
          top: "calc(var(--switch-height) * -0.25)",
          bg: "white",
          boxShadow: "xs",
          focusVisibleRing: "outside",
          _checked: {
            bg: "colorPalette.solid"
          }
        }
      }
    },
    size: {
      xs: {
        root: {
          "--switch-width": "sizes.6",
          "--switch-height": "sizes.3",
          "--switch-indicator-font-size": "fontSizes.xs"
        }
      },
      sm: {
        root: {
          "--switch-width": "sizes.8",
          "--switch-height": "sizes.4",
          "--switch-indicator-font-size": "fontSizes.xs"
        }
      },
      md: {
        root: {
          "--switch-width": "sizes.10",
          "--switch-height": "sizes.5",
          "--switch-indicator-font-size": "fontSizes.sm"
        }
      },
      lg: {
        root: {
          "--switch-width": "sizes.12",
          "--switch-height": "sizes.6",
          "--switch-indicator-font-size": "fontSizes.md"
        }
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/table.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/table.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tableSlotRecipe: () => (/* binding */ tableSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const tableSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  className: "chakra-table",
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.tableAnatomy.keys(),
  base: {
    root: {
      fontVariantNumeric: "lining-nums tabular-nums",
      borderCollapse: "collapse",
      width: "full",
      textAlign: "start",
      verticalAlign: "top"
    },
    row: {
      _selected: {
        bg: "colorPalette.subtle"
      }
    },
    cell: {
      textAlign: "start",
      alignItems: "center"
    },
    columnHeader: {
      fontWeight: "medium",
      textAlign: "start",
      color: "fg"
    },
    caption: {
      fontWeight: "medium",
      textStyle: "xs"
    },
    footer: {
      fontWeight: "medium"
    }
  },
  variants: {
    interactive: {
      true: {
        body: {
          "& tr": {
            _hover: {
              bg: "colorPalette.subtle"
            }
          }
        }
      }
    },
    stickyHeader: {
      true: {
        header: {
          "& :where(tr)": {
            top: "var(--table-sticky-offset, 0)",
            position: "sticky",
            zIndex: 1
          }
        }
      }
    },
    striped: {
      true: {
        row: {
          "&:nth-of-type(odd) td": {
            bg: "bg.muted"
          }
        }
      }
    },
    showColumnBorder: {
      true: {
        columnHeader: {
          "&:not(:last-of-type)": {
            borderInlineEndWidth: "1px"
          }
        },
        cell: {
          "&:not(:last-of-type)": {
            borderInlineEndWidth: "1px"
          }
        }
      }
    },
    variant: {
      line: {
        columnHeader: {
          borderBottomWidth: "1px"
        },
        cell: {
          borderBottomWidth: "1px"
        },
        row: {
          bg: "bg"
        }
      },
      outline: {
        root: {
          boxShadow: "0 0 0 1px {colors.border}",
          overflow: "hidden"
        },
        columnHeader: {
          borderBottomWidth: "1px"
        },
        header: {
          bg: "bg.muted"
        },
        row: {
          "&:not(:last-of-type)": {
            borderBottomWidth: "1px"
          }
        },
        footer: {
          borderTopWidth: "1px"
        }
      }
    },
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        columnHeader: {
          px: "2",
          py: "2"
        },
        cell: {
          px: "2",
          py: "2"
        }
      },
      md: {
        root: {
          textStyle: "sm"
        },
        columnHeader: {
          px: "3",
          py: "3"
        },
        cell: {
          px: "3",
          py: "3"
        }
      },
      lg: {
        root: {
          textStyle: "md"
        },
        columnHeader: {
          px: "4",
          py: "3"
        },
        cell: {
          px: "4",
          py: "3"
        }
      }
    }
  },
  defaultVariants: {
    variant: "line",
    size: "md"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/tabs.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/tabs.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tabsSlotRecipe: () => (/* binding */ tabsSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const tabsSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.tabsAnatomy.keys(),
  className: "chakra-tabs",
  base: {
    root: {
      "--tabs-trigger-radius": "radii.l2",
      position: "relative",
      _horizontal: {
        display: "block"
      },
      _vertical: {
        display: "flex"
      }
    },
    list: {
      display: "inline-flex",
      position: "relative",
      isolation: "isolate",
      "--tabs-indicator-shadow": "shadows.xs",
      "--tabs-indicator-bg": "colors.bg",
      minH: "var(--tabs-height)",
      _horizontal: {
        flexDirection: "row"
      },
      _vertical: {
        flexDirection: "column"
      }
    },
    trigger: {
      outline: "0",
      minW: "var(--tabs-height)",
      height: "var(--tabs-height)",
      display: "flex",
      alignItems: "center",
      fontWeight: "medium",
      position: "relative",
      cursor: "button",
      gap: "2",
      _focusVisible: {
        zIndex: 1,
        outline: "2px solid",
        outlineColor: "colorPalette.focusRing"
      },
      _disabled: {
        cursor: "not-allowed",
        opacity: 0.5
      }
    },
    content: {
      focusVisibleRing: "inside",
      _horizontal: {
        width: "100%",
        pt: "var(--tabs-content-padding)"
      },
      _vertical: {
        height: "100%",
        ps: "var(--tabs-content-padding)"
      }
    },
    indicator: {
      width: "var(--width)",
      height: "var(--height)",
      borderRadius: "var(--tabs-indicator-radius)",
      bg: "var(--tabs-indicator-bg)",
      shadow: "var(--tabs-indicator-shadow)",
      zIndex: -1
    }
  },
  variants: {
    fitted: {
      true: {
        list: {
          display: "flex"
        },
        trigger: {
          flex: 1,
          textAlign: "center",
          justifyContent: "center"
        }
      }
    },
    justify: {
      start: {
        list: {
          justifyContent: "flex-start"
        }
      },
      center: {
        list: {
          justifyContent: "center"
        }
      },
      end: {
        list: {
          justifyContent: "flex-end"
        }
      }
    },
    size: {
      sm: {
        root: {
          "--tabs-height": "sizes.9",
          "--tabs-content-padding": "spacing.3"
        },
        trigger: {
          py: "1",
          px: "3",
          textStyle: "sm"
        }
      },
      md: {
        root: {
          "--tabs-height": "sizes.10",
          "--tabs-content-padding": "spacing.4"
        },
        trigger: {
          py: "2",
          px: "4",
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          "--tabs-height": "sizes.11",
          "--tabs-content-padding": "spacing.4.5"
        },
        trigger: {
          py: "2",
          px: "4.5",
          textStyle: "md"
        }
      }
    },
    variant: {
      line: {
        list: {
          display: "flex",
          borderColor: "border",
          _horizontal: {
            borderBottomWidth: "1px"
          },
          _vertical: {
            borderEndWidth: "1px"
          }
        },
        trigger: {
          color: "fg.muted",
          _disabled: {
            _active: { bg: "initial" }
          },
          _selected: {
            color: "fg",
            _horizontal: {
              layerStyle: "indicator.bottom",
              "--indicator-offset-y": "-1px",
              "--indicator-color": "colors.colorPalette.solid"
            },
            _vertical: {
              layerStyle: "indicator.end",
              "--indicator-offset-x": "-1px"
            }
          }
        }
      },
      subtle: {
        trigger: {
          borderRadius: "var(--tabs-trigger-radius)",
          color: "fg.muted",
          _selected: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg"
          }
        }
      },
      enclosed: {
        list: {
          bg: "bg.muted",
          padding: "1",
          borderRadius: "l3",
          minH: "calc(var(--tabs-height) - 4px)"
        },
        trigger: {
          justifyContent: "center",
          color: "fg.muted",
          borderRadius: "var(--tabs-trigger-radius)",
          _selected: {
            bg: "bg",
            color: "colorPalette.fg",
            shadow: "xs"
          }
        }
      },
      outline: {
        list: {
          "--line-thickness": "1px",
          "--line-offset": "calc(var(--line-thickness) * -1)",
          borderColor: "border",
          display: "flex",
          _horizontal: {
            _before: {
              content: '""',
              position: "absolute",
              bottom: "0px",
              width: "100%",
              borderBottomWidth: "var(--line-thickness)",
              borderBottomColor: "border"
            }
          },
          _vertical: {
            _before: {
              content: '""',
              position: "absolute",
              insetInline: "var(--line-offset)",
              height: "calc(100% - calc(var(--line-thickness) * 2))",
              borderEndWidth: "var(--line-thickness)",
              borderEndColor: "border"
            }
          }
        },
        trigger: {
          color: "fg.muted",
          borderWidth: "1px",
          borderColor: "transparent",
          _selected: {
            bg: "currentBg",
            color: "colorPalette.fg"
          },
          _horizontal: {
            borderTopRadius: "var(--tabs-trigger-radius)",
            marginBottom: "var(--line-offset)",
            marginEnd: { _notLast: "var(--line-offset)" },
            _selected: {
              borderColor: "border",
              borderBottomColor: "transparent"
            }
          },
          _vertical: {
            borderStartRadius: "var(--tabs-trigger-radius)",
            marginEnd: "var(--line-offset)",
            marginBottom: { _notLast: "var(--line-offset)" },
            _selected: {
              borderColor: "border",
              borderEndColor: "transparent"
            }
          }
        }
      },
      plain: {
        trigger: {
          color: "fg.muted",
          _selected: {
            color: "colorPalette.fg"
          },
          borderRadius: "var(--tabs-trigger-radius)",
          "&[data-selected][data-ssr]": {
            bg: "var(--tabs-indicator-bg)",
            shadow: "var(--tabs-indicator-shadow)",
            borderRadius: "var(--tabs-indicator-radius)"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "line"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/tag.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/tag.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tagSlotRecipe: () => (/* binding */ tagSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _badge_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./badge.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/badge.js");





const badgeVariant = _badge_js__WEBPACK_IMPORTED_MODULE_0__.badgeRecipe.variants?.variant;
const tagSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_1__.defineSlotRecipe)({
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_2__.tagAnatomy.keys(),
  className: "chakra-tag",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      verticalAlign: "top",
      maxWidth: "100%",
      userSelect: "none",
      borderRadius: "l2",
      focusVisibleRing: "outside"
    },
    label: {
      lineClamp: "1"
    },
    closeTrigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      outline: "0",
      borderRadius: "l1",
      color: "currentColor",
      focusVisibleRing: "inside",
      focusRingWidth: "2px"
    },
    startElement: {
      flexShrink: 0,
      boxSize: "var(--tag-element-size)",
      ms: "var(--tag-element-offset)",
      "&:has([data-scope=avatar])": {
        boxSize: "var(--tag-avatar-size)",
        ms: "calc(var(--tag-element-offset) * 1.5)"
      },
      _icon: { boxSize: "100%" }
    },
    endElement: {
      flexShrink: 0,
      boxSize: "var(--tag-element-size)",
      me: "var(--tag-element-offset)",
      _icon: { boxSize: "100%" },
      "&:has(button)": {
        ms: "calc(var(--tag-element-offset) * -1)"
      }
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          px: "1.5",
          minH: "4.5",
          gap: "1",
          "--tag-avatar-size": "spacing.3",
          "--tag-element-size": "spacing.3",
          "--tag-element-offset": "-2px"
        },
        label: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          px: "1.5",
          minH: "5",
          gap: "1",
          "--tag-avatar-size": "spacing.3.5",
          "--tag-element-size": "spacing.3.5",
          "--tag-element-offset": "-2px"
        },
        label: {
          textStyle: "xs"
        }
      },
      lg: {
        root: {
          px: "2",
          minH: "6",
          gap: "1.5",
          "--tag-avatar-size": "spacing.4.5",
          "--tag-element-size": "spacing.4",
          "--tag-element-offset": "-3px"
        },
        label: {
          textStyle: "sm"
        }
      },
      xl: {
        root: {
          px: "2.5",
          minH: "8",
          gap: "1.5",
          "--tag-avatar-size": "spacing.6",
          "--tag-element-size": "spacing.4.5",
          "--tag-element-offset": "-4px"
        },
        label: {
          textStyle: "sm"
        }
      }
    },
    variant: {
      subtle: {
        root: badgeVariant?.subtle
      },
      solid: {
        root: badgeVariant?.solid
      },
      outline: {
        root: badgeVariant?.outline
      },
      surface: {
        root: badgeVariant?.surface
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "surface"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/textarea.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/textarea.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   textareaRecipe: () => (/* binding */ textareaRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const textareaRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineRecipe)({
  className: "chakra-textarea",
  base: {
    width: "100%",
    minWidth: "0",
    outline: "0",
    position: "relative",
    appearance: "none",
    textAlign: "start",
    borderRadius: "l2",
    _disabled: {
      layerStyle: "disabled"
    },
    "--focus-color": "colors.colorPalette.focusRing",
    "--error-color": "colors.border.error",
    _invalid: {
      focusRingColor: "var(--error-color)",
      borderColor: "var(--error-color)"
    }
  },
  variants: {
    size: {
      xs: {
        textStyle: "xs",
        px: "2",
        py: "1.5",
        scrollPaddingBottom: "1.5"
      },
      sm: {
        textStyle: "sm",
        px: "2.5",
        py: "2",
        scrollPaddingBottom: "2"
      },
      md: {
        textStyle: "sm",
        px: "3",
        py: "2",
        scrollPaddingBottom: "2"
      },
      lg: {
        textStyle: "md",
        px: "4",
        py: "3",
        scrollPaddingBottom: "3"
      },
      xl: {
        textStyle: "md",
        px: "4.5",
        py: "3.5",
        scrollPaddingBottom: "3.5"
      }
    },
    variant: {
      outline: {
        bg: "transparent",
        borderWidth: "1px",
        borderColor: "border",
        focusVisibleRing: "inside"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.muted",
        focusVisibleRing: "inside"
      },
      flushed: {
        bg: "transparent",
        borderBottomWidth: "1px",
        borderBottomColor: "border",
        borderRadius: "0",
        px: "0",
        _focusVisible: {
          borderColor: "var(--focus-color)",
          boxShadow: "0px 1px 0px 0px var(--focus-color)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/timeline.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/timeline.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   timelineSlotRecipe: () => (/* binding */ timelineSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const timelineSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.timelineAnatomy.keys(),
  className: "chakra-timeline",
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      width: "full",
      "--timeline-thickness": "1px",
      "--timeline-gutter": "4px"
    },
    item: {
      display: "flex",
      position: "relative",
      alignItems: "flex-start",
      flexShrink: 0,
      gap: "4",
      _last: {
        "& :where(.chakra-timeline__separator)": { display: "none" }
      }
    },
    separator: {
      position: "absolute",
      borderStartWidth: "var(--timeline-thickness)",
      ms: "calc(-1 * var(--timeline-thickness) / 2)",
      insetInlineStart: "calc(var(--timeline-indicator-size) / 2)",
      insetBlock: "0",
      borderColor: "border"
    },
    indicator: {
      outline: "2px solid {colors.bg}",
      position: "relative",
      flexShrink: "0",
      boxSize: "var(--timeline-indicator-size)",
      fontSize: "var(--timeline-font-size)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      borderRadius: "full",
      fontWeight: "medium"
    },
    connector: {
      alignSelf: "stretch",
      position: "relative"
    },
    content: {
      pb: "6",
      display: "flex",
      flexDirection: "column",
      width: "full",
      gap: "2"
    },
    title: {
      display: "flex",
      fontWeight: "medium",
      flexWrap: "wrap",
      gap: "1.5",
      alignItems: "center",
      mt: "var(--timeline-margin)"
    },
    description: {
      color: "fg.muted",
      textStyle: "xs"
    }
  },
  variants: {
    variant: {
      subtle: {
        indicator: {
          bg: "colorPalette.muted"
        }
      },
      solid: {
        indicator: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        }
      },
      outline: {
        indicator: {
          bg: "currentBg",
          borderWidth: "1px",
          borderColor: "colorPalette.muted"
        }
      },
      plain: {}
    },
    size: {
      sm: {
        root: {
          "--timeline-indicator-size": "sizes.4",
          "--timeline-font-size": "fontSizes.2xs"
        },
        title: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          "--timeline-indicator-size": "sizes.5",
          "--timeline-font-size": "fontSizes.xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          "--timeline-indicator-size": "sizes.6",
          "--timeline-font-size": "fontSizes.xs"
        },
        title: {
          mt: "0.5",
          textStyle: "sm"
        }
      },
      xl: {
        root: {
          "--timeline-indicator-size": "sizes.8",
          "--timeline-font-size": "fontSizes.sm"
        },
        title: {
          mt: "1.5",
          textStyle: "sm"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/toast.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/toast.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   toastSlotRecipe: () => (/* binding */ toastSlotRecipe)
/* harmony export */ });
/* harmony import */ var _anatomy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../anatomy.js */ "./node_modules/@chakra-ui/react/dist/esm/anatomy.js");
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");




const toastSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  slots: _anatomy_js__WEBPACK_IMPORTED_MODULE_1__.toastAnatomy.keys(),
  className: "chakra-toast",
  base: {
    root: {
      width: "full",
      display: "flex",
      alignItems: "flex-start",
      position: "relative",
      gap: "3",
      py: "4",
      ps: "4",
      pe: "6",
      borderRadius: "l2",
      translate: "var(--x) var(--y)",
      scale: "var(--scale)",
      zIndex: "var(--z-index)",
      height: "var(--height)",
      opacity: "var(--opacity)",
      willChange: "translate, opacity, scale",
      transition: "translate 400ms, scale 400ms, opacity 400ms, height 400ms, box-shadow 200ms",
      transitionTimingFunction: "cubic-bezier(0.21, 1.02, 0.73, 1)",
      _closed: {
        transition: "translate 400ms, scale 400ms, opacity 200ms",
        transitionTimingFunction: "cubic-bezier(0.06, 0.71, 0.55, 1)"
      },
      bg: "bg.panel",
      color: "fg",
      boxShadow: "xl",
      "--toast-trigger-bg": "colors.bg.muted",
      "&[data-type=warning]": {
        bg: "orange.solid",
        color: "orange.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      },
      "&[data-type=success]": {
        bg: "green.solid",
        color: "green.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      },
      "&[data-type=error]": {
        bg: "red.solid",
        color: "red.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      }
    },
    title: {
      fontWeight: "medium",
      textStyle: "sm",
      marginEnd: "2"
    },
    description: {
      display: "inline",
      textStyle: "sm",
      opacity: "0.8"
    },
    indicator: {
      flexShrink: "0",
      boxSize: "5"
    },
    actionTrigger: {
      textStyle: "sm",
      fontWeight: "medium",
      height: "8",
      px: "3",
      borderRadius: "l2",
      alignSelf: "center",
      borderWidth: "1px",
      borderColor: "var(--toast-border-color, inherit)",
      transition: "background 200ms",
      _hover: {
        bg: "var(--toast-trigger-bg)"
      }
    },
    closeTrigger: {
      position: "absolute",
      top: "1",
      insetEnd: "1",
      padding: "1",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      color: "{currentColor/60}",
      borderRadius: "l2",
      textStyle: "md",
      transition: "background 200ms",
      _icon: {
        boxSize: "1em"
      }
    }
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/tooltip.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/recipes/tooltip.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tooltipSlotRecipe: () => (/* binding */ tooltipSlotRecipe)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _ark_ui_react_tooltip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ark-ui/react/tooltip */ "./node_modules/@zag-js/tooltip/dist/index.mjs");




const tooltipSlotRecipe = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSlotRecipe)({
  slots: _ark_ui_react_tooltip__WEBPACK_IMPORTED_MODULE_1__.anatomy.keys(),
  className: "chakra-tooltip",
  base: {
    content: {
      "--tooltip-bg": "colors.bg.inverted",
      bg: "var(--tooltip-bg)",
      color: "fg.inverted",
      px: "2.5",
      py: "1",
      borderRadius: "l2",
      fontWeight: "medium",
      textStyle: "xs",
      boxShadow: "md",
      maxW: "xs",
      zIndex: "tooltip",
      transformOrigin: "var(--transform-origin)",
      _open: {
        animationStyle: "scale-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "scale-fade-out",
        animationDuration: "fast"
      }
    },
    arrow: {
      "--arrow-size": "sizes.2",
      "--arrow-background": "var(--tooltip-bg)"
    },
    arrowTip: {
      borderTopWidth: "1px",
      borderInlineStartWidth: "1px",
      borderColor: "var(--tooltip-bg)"
    }
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/colors.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/colors.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   semanticColors: () => (/* binding */ semanticColors)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const semanticColors = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSemanticTokens.colors({
  bg: {
    DEFAULT: {
      value: { _light: "{colors.white}", _dark: "{colors.black}" }
    },
    subtle: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.gray.950}" }
    },
    muted: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    inverted: {
      value: { _light: "{colors.black}", _dark: "{colors.white}" }
    },
    panel: {
      value: { _light: "{colors.white}", _dark: "{colors.gray.950}" }
    },
    error: {
      value: { _light: "{colors.red.50}", _dark: "{colors.red.950}" }
    },
    warning: {
      value: { _light: "{colors.orange.50}", _dark: "{colors.orange.950}" }
    },
    success: {
      value: { _light: "{colors.green.50}", _dark: "{colors.green.950}" }
    },
    info: {
      value: { _light: "{colors.blue.50}", _dark: "{colors.blue.950}" }
    }
  },
  fg: {
    DEFAULT: {
      value: { _light: "{colors.black}", _dark: "{colors.gray.50}" }
    },
    muted: {
      value: { _light: "{colors.gray.600}", _dark: "{colors.gray.400}" }
    },
    subtle: {
      value: { _light: "{colors.gray.400}", _dark: "{colors.gray.500}" }
    },
    inverted: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.black}" }
    },
    error: {
      value: { _light: "{colors.red.500}", _dark: "{colors.red.400}" }
    },
    warning: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.300}" }
    },
    success: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.300}" }
    },
    info: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.300}" }
    }
  },
  border: {
    DEFAULT: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    muted: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    subtle: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.gray.950}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.300}", _dark: "{colors.gray.700}" }
    },
    inverted: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    },
    error: {
      value: { _light: "{colors.red.500}", _dark: "{colors.red.400}" }
    },
    warning: {
      value: { _light: "{colors.orange.500}", _dark: "{colors.orange.400}" }
    },
    success: {
      value: { _light: "{colors.green.500}", _dark: "{colors.green.400}" }
    },
    info: {
      value: { _light: "{colors.blue.500}", _dark: "{colors.blue.400}" }
    }
  },
  gray: {
    contrast: {
      value: { _light: "{colors.white}", _dark: "{colors.black}" }
    },
    fg: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    },
    subtle: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    muted: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.300}", _dark: "{colors.gray.700}" }
    },
    solid: {
      value: { _light: "{colors.gray.900}", _dark: "{colors.white}" }
    },
    focusRing: {
      value: { _light: "{colors.gray.400}", _dark: "{colors.gray.400}" }
    }
  },
  red: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.red.700}", _dark: "{colors.red.300}" }
    },
    subtle: {
      value: { _light: "{colors.red.100}", _dark: "{colors.red.900}" }
    },
    muted: {
      value: { _light: "{colors.red.200}", _dark: "{colors.red.800}" }
    },
    emphasized: {
      value: { _light: "{colors.red.300}", _dark: "{colors.red.700}" }
    },
    solid: {
      value: { _light: "{colors.red.600}", _dark: "{colors.red.600}" }
    },
    focusRing: {
      value: { _light: "{colors.red.400}", _dark: "{colors.red.400}" }
    }
  },
  orange: {
    contrast: {
      value: { _light: "white", _dark: "black" }
    },
    fg: {
      value: { _light: "{colors.orange.700}", _dark: "{colors.orange.300}" }
    },
    subtle: {
      value: { _light: "{colors.orange.100}", _dark: "{colors.orange.900}" }
    },
    muted: {
      value: { _light: "{colors.orange.200}", _dark: "{colors.orange.800}" }
    },
    emphasized: {
      value: { _light: "{colors.orange.300}", _dark: "{colors.orange.700}" }
    },
    solid: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.500}" }
    },
    focusRing: {
      value: { _light: "{colors.orange.400}", _dark: "{colors.orange.400}" }
    }
  },
  green: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.green.700}", _dark: "{colors.green.300}" }
    },
    subtle: {
      value: { _light: "{colors.green.100}", _dark: "{colors.green.900}" }
    },
    muted: {
      value: { _light: "{colors.green.200}", _dark: "{colors.green.800}" }
    },
    emphasized: {
      value: { _light: "{colors.green.300}", _dark: "{colors.green.700}" }
    },
    solid: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.600}" }
    },
    focusRing: {
      value: { _light: "{colors.green.400}", _dark: "{colors.green.400}" }
    }
  },
  blue: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.blue.700}", _dark: "{colors.blue.300}" }
    },
    subtle: {
      value: { _light: "{colors.blue.100}", _dark: "{colors.blue.900}" }
    },
    muted: {
      value: { _light: "{colors.blue.200}", _dark: "{colors.blue.800}" }
    },
    emphasized: {
      value: { _light: "{colors.blue.300}", _dark: "{colors.blue.700}" }
    },
    solid: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.600}" }
    },
    focusRing: {
      value: { _light: "{colors.blue.400}", _dark: "{colors.blue.400}" }
    }
  },
  yellow: {
    contrast: {
      value: { _light: "black", _dark: "black" }
    },
    fg: {
      value: { _light: "{colors.yellow.800}", _dark: "{colors.yellow.300}" }
    },
    subtle: {
      value: { _light: "{colors.yellow.100}", _dark: "{colors.yellow.900}" }
    },
    muted: {
      value: { _light: "{colors.yellow.200}", _dark: "{colors.yellow.800}" }
    },
    emphasized: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.700}" }
    },
    solid: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.300}" }
    },
    focusRing: {
      value: { _light: "{colors.yellow.400}", _dark: "{colors.yellow.400}" }
    }
  },
  teal: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.teal.700}", _dark: "{colors.teal.300}" }
    },
    subtle: {
      value: { _light: "{colors.teal.100}", _dark: "{colors.teal.900}" }
    },
    muted: {
      value: { _light: "{colors.teal.200}", _dark: "{colors.teal.800}" }
    },
    emphasized: {
      value: { _light: "{colors.teal.300}", _dark: "{colors.teal.700}" }
    },
    solid: {
      value: { _light: "{colors.teal.600}", _dark: "{colors.teal.600}" }
    },
    focusRing: {
      value: { _light: "{colors.teal.400}", _dark: "{colors.teal.400}" }
    }
  },
  purple: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.purple.700}", _dark: "{colors.purple.300}" }
    },
    subtle: {
      value: { _light: "{colors.purple.100}", _dark: "{colors.purple.900}" }
    },
    muted: {
      value: { _light: "{colors.purple.200}", _dark: "{colors.purple.800}" }
    },
    emphasized: {
      value: { _light: "{colors.purple.300}", _dark: "{colors.purple.700}" }
    },
    solid: {
      value: { _light: "{colors.purple.600}", _dark: "{colors.purple.600}" }
    },
    focusRing: {
      value: { _light: "{colors.purple.400}", _dark: "{colors.purple.400}" }
    }
  },
  pink: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.pink.700}", _dark: "{colors.pink.300}" }
    },
    subtle: {
      value: { _light: "{colors.pink.100}", _dark: "{colors.pink.900}" }
    },
    muted: {
      value: { _light: "{colors.pink.200}", _dark: "{colors.pink.800}" }
    },
    emphasized: {
      value: { _light: "{colors.pink.300}", _dark: "{colors.pink.700}" }
    },
    solid: {
      value: { _light: "{colors.pink.600}", _dark: "{colors.pink.600}" }
    },
    focusRing: {
      value: { _light: "{colors.pink.400}", _dark: "{colors.pink.400}" }
    }
  },
  cyan: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.cyan.700}", _dark: "{colors.cyan.300}" }
    },
    subtle: {
      value: { _light: "{colors.cyan.100}", _dark: "{colors.cyan.900}" }
    },
    muted: {
      value: { _light: "{colors.cyan.200}", _dark: "{colors.cyan.800}" }
    },
    emphasized: {
      value: { _light: "{colors.cyan.300}", _dark: "{colors.cyan.700}" }
    },
    solid: {
      value: { _light: "{colors.cyan.600}", _dark: "{colors.cyan.600}" }
    },
    focusRing: {
      value: { _light: "{colors.cyan.400}", _dark: "{colors.cyan.400}" }
    }
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/radii.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/radii.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   semanticRadii: () => (/* binding */ semanticRadii)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const semanticRadii = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSemanticTokens.radii({
  l1: { value: "{radii.xs}" },
  l2: { value: "{radii.sm}" },
  l3: { value: "{radii.md}" }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/shadows.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/shadows.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   semanticShadows: () => (/* binding */ semanticShadows)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const semanticShadows = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineSemanticTokens.shadows({
  xs: {
    value: {
      _light: "0px 1px 2px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/20}",
      _dark: "0px 1px 1px {black/64}, 0px 0px 1px inset {colors.gray.300/20}"
    }
  },
  sm: {
    value: {
      _light: "0px 2px 4px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 2px 4px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  md: {
    value: {
      _light: "0px 4px 8px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 4px 8px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  lg: {
    value: {
      _light: "0px 8px 16px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 8px 16px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  xl: {
    value: {
      _light: "0px 16px 24px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 16px 24px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  "2xl": {
    value: {
      _light: "0px 24px 40px {colors.gray.900/16}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 24px 40px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  inner: {
    value: {
      _light: "inset 0 2px 4px 0 {black/5}",
      _dark: "inset 0 2px 4px 0 black"
    }
  },
  inset: {
    value: {
      _light: "inset 0 0 0 1px {black/5}",
      _dark: "inset 0 0 0 1px {colors.gray.300/5}"
    }
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/slot-recipes.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/slot-recipes.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   slotRecipes: () => (/* binding */ slotRecipes)
/* harmony export */ });
/* harmony import */ var _recipes_accordion_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./recipes/accordion.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/accordion.js");
/* harmony import */ var _recipes_action_bar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./recipes/action-bar.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/action-bar.js");
/* harmony import */ var _recipes_alert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./recipes/alert.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/alert.js");
/* harmony import */ var _recipes_avatar_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./recipes/avatar.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/avatar.js");
/* harmony import */ var _recipes_blockquote_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./recipes/blockquote.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/blockquote.js");
/* harmony import */ var _recipes_breadcrumb_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./recipes/breadcrumb.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/breadcrumb.js");
/* harmony import */ var _recipes_card_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./recipes/card.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/card.js");
/* harmony import */ var _recipes_checkbox_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./recipes/checkbox.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkbox.js");
/* harmony import */ var _recipes_checkbox_card_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./recipes/checkbox-card.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkbox-card.js");
/* harmony import */ var _recipes_collapsible_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./recipes/collapsible.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/collapsible.js");
/* harmony import */ var _recipes_color_picker_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./recipes/color-picker.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/color-picker.js");
/* harmony import */ var _recipes_data_list_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./recipes/data-list.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/data-list.js");
/* harmony import */ var _recipes_dialog_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./recipes/dialog.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/dialog.js");
/* harmony import */ var _recipes_drawer_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./recipes/drawer.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/drawer.js");
/* harmony import */ var _recipes_editable_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./recipes/editable.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/editable.js");
/* harmony import */ var _recipes_empty_state_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./recipes/empty-state.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/empty-state.js");
/* harmony import */ var _recipes_field_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./recipes/field.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/field.js");
/* harmony import */ var _recipes_fieldset_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./recipes/fieldset.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/fieldset.js");
/* harmony import */ var _recipes_file_upload_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./recipes/file-upload.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/file-upload.js");
/* harmony import */ var _recipes_hover_card_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./recipes/hover-card.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/hover-card.js");
/* harmony import */ var _recipes_list_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./recipes/list.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/list.js");
/* harmony import */ var _recipes_menu_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./recipes/menu.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/menu.js");
/* harmony import */ var _recipes_native_select_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./recipes/native-select.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/native-select.js");
/* harmony import */ var _recipes_number_input_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./recipes/number-input.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/number-input.js");
/* harmony import */ var _recipes_pin_input_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./recipes/pin-input.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/pin-input.js");
/* harmony import */ var _recipes_popover_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./recipes/popover.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/popover.js");
/* harmony import */ var _recipes_progress_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./recipes/progress.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/progress.js");
/* harmony import */ var _recipes_progress_circle_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./recipes/progress-circle.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/progress-circle.js");
/* harmony import */ var _recipes_qr_code_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./recipes/qr-code.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/qr-code.js");
/* harmony import */ var _recipes_radio_card_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./recipes/radio-card.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/radio-card.js");
/* harmony import */ var _recipes_radio_group_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./recipes/radio-group.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/radio-group.js");
/* harmony import */ var _recipes_rating_group_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./recipes/rating-group.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/rating-group.js");
/* harmony import */ var _recipes_segment_group_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./recipes/segment-group.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/segment-group.js");
/* harmony import */ var _recipes_select_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./recipes/select.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/select.js");
/* harmony import */ var _recipes_slider_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./recipes/slider.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/slider.js");
/* harmony import */ var _recipes_stat_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./recipes/stat.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/stat.js");
/* harmony import */ var _recipes_status_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./recipes/status.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/status.js");
/* harmony import */ var _recipes_steps_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./recipes/steps.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/steps.js");
/* harmony import */ var _recipes_switch_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./recipes/switch.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/switch.js");
/* harmony import */ var _recipes_table_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./recipes/table.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/table.js");
/* harmony import */ var _recipes_tabs_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./recipes/tabs.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/tabs.js");
/* harmony import */ var _recipes_tag_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./recipes/tag.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/tag.js");
/* harmony import */ var _recipes_timeline_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./recipes/timeline.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/timeline.js");
/* harmony import */ var _recipes_toast_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./recipes/toast.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/toast.js");
/* harmony import */ var _recipes_tooltip_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./recipes/tooltip.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/recipes/tooltip.js");















































const slotRecipes = {
  accordion: _recipes_accordion_js__WEBPACK_IMPORTED_MODULE_0__.accordionSlotRecipe,
  actionBar: _recipes_action_bar_js__WEBPACK_IMPORTED_MODULE_1__.actionBarSlotRecipe,
  alert: _recipes_alert_js__WEBPACK_IMPORTED_MODULE_2__.alertSlotRecipe,
  avatar: _recipes_avatar_js__WEBPACK_IMPORTED_MODULE_3__.avatarSlotRecipe,
  blockquote: _recipes_blockquote_js__WEBPACK_IMPORTED_MODULE_4__.blockquoteSlotRecipe,
  breadcrumb: _recipes_breadcrumb_js__WEBPACK_IMPORTED_MODULE_5__.breadcrumbSlotRecipe,
  card: _recipes_card_js__WEBPACK_IMPORTED_MODULE_6__.cardSlotRecipe,
  checkbox: _recipes_checkbox_js__WEBPACK_IMPORTED_MODULE_7__.checkboxSlotRecipe,
  checkboxCard: _recipes_checkbox_card_js__WEBPACK_IMPORTED_MODULE_8__.checkboxCardSlotRecipe,
  collapsible: _recipes_collapsible_js__WEBPACK_IMPORTED_MODULE_9__.collapsibleSlotRecipe,
  dataList: _recipes_data_list_js__WEBPACK_IMPORTED_MODULE_10__.dataListSlotRecipe,
  dialog: _recipes_dialog_js__WEBPACK_IMPORTED_MODULE_11__.dialogSlotRecipe,
  drawer: _recipes_drawer_js__WEBPACK_IMPORTED_MODULE_12__.drawerSlotRecipe,
  editable: _recipes_editable_js__WEBPACK_IMPORTED_MODULE_13__.editableSlotRecipe,
  emptyState: _recipes_empty_state_js__WEBPACK_IMPORTED_MODULE_14__.emptyStateSlotRecipe,
  field: _recipes_field_js__WEBPACK_IMPORTED_MODULE_15__.fieldSlotRecipe,
  fieldset: _recipes_fieldset_js__WEBPACK_IMPORTED_MODULE_16__.fieldsetSlotRecipe,
  fileUpload: _recipes_file_upload_js__WEBPACK_IMPORTED_MODULE_17__.fileUploadSlotRecipe,
  hoverCard: _recipes_hover_card_js__WEBPACK_IMPORTED_MODULE_18__.hoverCardSlotRecipe,
  list: _recipes_list_js__WEBPACK_IMPORTED_MODULE_19__.listSlotRecipe,
  menu: _recipes_menu_js__WEBPACK_IMPORTED_MODULE_20__.menuSlotRecipe,
  nativeSelect: _recipes_native_select_js__WEBPACK_IMPORTED_MODULE_21__.nativeSelectSlotRecipe,
  numberInput: _recipes_number_input_js__WEBPACK_IMPORTED_MODULE_22__.numberInputSlotRecipe,
  pinInput: _recipes_pin_input_js__WEBPACK_IMPORTED_MODULE_23__.pinInputSlotRecipe,
  popover: _recipes_popover_js__WEBPACK_IMPORTED_MODULE_24__.popoverSlotRecipe,
  progress: _recipes_progress_js__WEBPACK_IMPORTED_MODULE_25__.progressSlotRecipe,
  progressCircle: _recipes_progress_circle_js__WEBPACK_IMPORTED_MODULE_26__.progressCircleSlotRecipe,
  radioCard: _recipes_radio_card_js__WEBPACK_IMPORTED_MODULE_27__.radioCardSlotRecipe,
  radioGroup: _recipes_radio_group_js__WEBPACK_IMPORTED_MODULE_28__.radioGroupSlotRecipe,
  ratingGroup: _recipes_rating_group_js__WEBPACK_IMPORTED_MODULE_29__.ratingGroupSlotRecipe,
  segmentGroup: _recipes_segment_group_js__WEBPACK_IMPORTED_MODULE_30__.segmentGroupSlotRecipe,
  select: _recipes_select_js__WEBPACK_IMPORTED_MODULE_31__.selectSlotRecipe,
  slider: _recipes_slider_js__WEBPACK_IMPORTED_MODULE_32__.sliderSlotRecipe,
  stat: _recipes_stat_js__WEBPACK_IMPORTED_MODULE_33__.statSlotRecipe,
  steps: _recipes_steps_js__WEBPACK_IMPORTED_MODULE_34__.stepsSlotRecipe,
  switch: _recipes_switch_js__WEBPACK_IMPORTED_MODULE_35__.switchSlotRecipe,
  table: _recipes_table_js__WEBPACK_IMPORTED_MODULE_36__.tableSlotRecipe,
  tabs: _recipes_tabs_js__WEBPACK_IMPORTED_MODULE_37__.tabsSlotRecipe,
  tag: _recipes_tag_js__WEBPACK_IMPORTED_MODULE_38__.tagSlotRecipe,
  toast: _recipes_toast_js__WEBPACK_IMPORTED_MODULE_39__.toastSlotRecipe,
  tooltip: _recipes_tooltip_js__WEBPACK_IMPORTED_MODULE_40__.tooltipSlotRecipe,
  status: _recipes_status_js__WEBPACK_IMPORTED_MODULE_41__.statusSlotRecipe,
  timeline: _recipes_timeline_js__WEBPACK_IMPORTED_MODULE_42__.timelineSlotRecipe,
  colorPicker: _recipes_color_picker_js__WEBPACK_IMPORTED_MODULE_43__.colorPickerSlotRecipe,
  qrCode: _recipes_qr_code_js__WEBPACK_IMPORTED_MODULE_44__.qrCodeSlotRecipe
};




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/text-styles.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/text-styles.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   textStyles: () => (/* binding */ textStyles)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const textStyles = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineTextStyles)({
  "2xs": { value: { fontSize: "2xs", lineHeight: "0.75rem" } },
  xs: { value: { fontSize: "xs", lineHeight: "1rem" } },
  sm: { value: { fontSize: "sm", lineHeight: "1.25rem" } },
  md: { value: { fontSize: "md", lineHeight: "1.5rem" } },
  lg: { value: { fontSize: "lg", lineHeight: "1.75rem" } },
  xl: { value: { fontSize: "xl", lineHeight: "1.875rem" } },
  "2xl": { value: { fontSize: "2xl", lineHeight: "2rem" } },
  "3xl": { value: { fontSize: "3xl", lineHeight: "2.375rem" } },
  "4xl": {
    value: {
      fontSize: "4xl",
      lineHeight: "2.75rem",
      letterSpacing: "-0.025em"
    }
  },
  "5xl": {
    value: {
      fontSize: "5xl",
      lineHeight: "3.75rem",
      letterSpacing: "-0.025em"
    }
  },
  "6xl": {
    value: { fontSize: "6xl", lineHeight: "4.5rem", letterSpacing: "-0.025em" }
  },
  "7xl": {
    value: {
      fontSize: "7xl",
      lineHeight: "5.75rem",
      letterSpacing: "-0.025em"
    }
  },
  none: {
    value: {}
  },
  label: {
    value: {
      fontSize: "sm",
      lineHeight: "1.25rem",
      fontWeight: "medium"
    }
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/animations.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/tokens/animations.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   animations: () => (/* binding */ animations)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const animations = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineTokens.animations({
  spin: { value: "spin 1s linear infinite" },
  ping: { value: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite" },
  pulse: { value: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite" },
  bounce: { value: "bounce 1s infinite" }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/aspect-ratios.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/tokens/aspect-ratios.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   aspectRatios: () => (/* binding */ aspectRatios)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const aspectRatios = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineTokens.aspectRatios({
  square: { value: "1 / 1" },
  landscape: { value: "4 / 3" },
  portrait: { value: "3 / 4" },
  wide: { value: "16 / 9" },
  ultrawide: { value: "18 / 5" },
  golden: { value: "1.618 / 1" }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/blurs.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/tokens/blurs.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   blurs: () => (/* binding */ blurs)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const blurs = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineTokens.blurs({
  none: { value: " " },
  sm: { value: "4px" },
  md: { value: "8px" },
  lg: { value: "12px" },
  xl: { value: "16px" },
  "2xl": { value: "24px" },
  "3xl": { value: "40px" },
  "4xl": { value: "64px" }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/borders.js":
/*!************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/tokens/borders.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   borders: () => (/* binding */ borders)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const borders = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineTokens.borders({
  xs: { value: "0.5px solid" },
  sm: { value: "1px solid" },
  md: { value: "2px solid" },
  lg: { value: "4px solid" },
  xl: { value: "8px solid" }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/colors.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/tokens/colors.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   colors: () => (/* binding */ colors)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const colors = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineTokens.colors({
  transparent: { value: "transparent" },
  current: { value: "currentColor" },
  black: { value: "#09090B" },
  white: { value: "#FFFFFF" },
  whiteAlpha: {
    50: { value: "rgba(255, 255, 255, 0.04)" },
    100: { value: "rgba(255, 255, 255, 0.06)" },
    200: { value: "rgba(255, 255, 255, 0.08)" },
    300: { value: "rgba(255, 255, 255, 0.16)" },
    400: { value: "rgba(255, 255, 255, 0.24)" },
    500: { value: "rgba(255, 255, 255, 0.36)" },
    600: { value: "rgba(255, 255, 255, 0.48)" },
    700: { value: "rgba(255, 255, 255, 0.64)" },
    800: { value: "rgba(255, 255, 255, 0.80)" },
    900: { value: "rgba(255, 255, 255, 0.92)" },
    950: { value: "rgba(255, 255, 255, 0.95)" }
  },
  blackAlpha: {
    50: { value: "rgba(0, 0, 0, 0.04)" },
    100: { value: "rgba(0, 0, 0, 0.06)" },
    200: { value: "rgba(0, 0, 0, 0.08)" },
    300: { value: "rgba(0, 0, 0, 0.16)" },
    400: { value: "rgba(0, 0, 0, 0.24)" },
    500: { value: "rgba(0, 0, 0, 0.36)" },
    600: { value: "rgba(0, 0, 0, 0.48)" },
    700: { value: "rgba(0, 0, 0, 0.64)" },
    800: { value: "rgba(0, 0, 0, 0.80)" },
    900: { value: "rgba(0, 0, 0, 0.92)" },
    950: { value: "rgba(0, 0, 0, 0.95)" }
  },
  gray: {
    50: { value: "#fafafa" },
    100: { value: "#f4f4f5" },
    200: { value: "#e4e4e7" },
    300: { value: "#d4d4d8" },
    400: { value: "#a1a1aa" },
    500: { value: "#71717a" },
    600: { value: "#52525b" },
    700: { value: "#3f3f46" },
    800: { value: "#27272a" },
    900: { value: "#18181b" },
    950: { value: "#111111" }
  },
  red: {
    50: { value: "#fef2f2" },
    100: { value: "#fee2e2" },
    200: { value: "#fecaca" },
    300: { value: "#fca5a5" },
    400: { value: "#f87171" },
    500: { value: "#ef4444" },
    600: { value: "#dc2626" },
    700: { value: "#991919" },
    800: { value: "#511111" },
    900: { value: "#300c0c" },
    950: { value: "#1f0808" }
  },
  orange: {
    50: { value: "#fff7ed" },
    100: { value: "#ffedd5" },
    200: { value: "#fed7aa" },
    300: { value: "#fdba74" },
    400: { value: "#fb923c" },
    500: { value: "#f97316" },
    600: { value: "#ea580c" },
    700: { value: "#92310a" },
    800: { value: "#6c2710" },
    900: { value: "#3b1106" },
    950: { value: "#220a04" }
  },
  yellow: {
    50: { value: "#fefce8" },
    100: { value: "#fef9c3" },
    200: { value: "#fef08a" },
    300: { value: "#fde047" },
    400: { value: "#facc15" },
    500: { value: "#eab308" },
    600: { value: "#ca8a04" },
    700: { value: "#845209" },
    800: { value: "#713f12" },
    900: { value: "#422006" },
    950: { value: "#281304" }
  },
  green: {
    50: { value: "#f0fdf4" },
    100: { value: "#dcfce7" },
    200: { value: "#bbf7d0" },
    300: { value: "#86efac" },
    400: { value: "#4ade80" },
    500: { value: "#22c55e" },
    600: { value: "#16a34a" },
    700: { value: "#116932" },
    800: { value: "#124a28" },
    900: { value: "#042713" },
    950: { value: "#03190c" }
  },
  teal: {
    50: { value: "#f0fdfa" },
    100: { value: "#ccfbf1" },
    200: { value: "#99f6e4" },
    300: { value: "#5eead4" },
    400: { value: "#2dd4bf" },
    500: { value: "#14b8a6" },
    600: { value: "#0d9488" },
    700: { value: "#0c5d56" },
    800: { value: "#114240" },
    900: { value: "#032726" },
    950: { value: "#021716" }
  },
  blue: {
    50: { value: "#eff6ff" },
    100: { value: "#dbeafe" },
    200: { value: "#bfdbfe" },
    300: { value: "#a3cfff" },
    400: { value: "#60a5fa" },
    500: { value: "#3b82f6" },
    600: { value: "#2563eb" },
    700: { value: "#173da6" },
    800: { value: "#1a3478" },
    900: { value: "#14204a" },
    950: { value: "#0c142e" }
  },
  cyan: {
    50: { value: "#ecfeff" },
    100: { value: "#cffafe" },
    200: { value: "#a5f3fc" },
    300: { value: "#67e8f9" },
    400: { value: "#22d3ee" },
    500: { value: "#06b6d4" },
    600: { value: "#0891b2" },
    700: { value: "#0c5c72" },
    800: { value: "#134152" },
    900: { value: "#072a38" },
    950: { value: "#051b24" }
  },
  purple: {
    50: { value: "#faf5ff" },
    100: { value: "#f3e8ff" },
    200: { value: "#e9d5ff" },
    300: { value: "#d8b4fe" },
    400: { value: "#c084fc" },
    500: { value: "#a855f7" },
    600: { value: "#9333ea" },
    700: { value: "#641ba3" },
    800: { value: "#4a1772" },
    900: { value: "#2f0553" },
    950: { value: "#1a032e" }
  },
  pink: {
    50: { value: "#fdf2f8" },
    100: { value: "#fce7f3" },
    200: { value: "#fbcfe8" },
    300: { value: "#f9a8d4" },
    400: { value: "#f472b6" },
    500: { value: "#ec4899" },
    600: { value: "#db2777" },
    700: { value: "#a41752" },
    800: { value: "#6d0e34" },
    900: { value: "#45061f" },
    950: { value: "#2c0514" }
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/cursor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/tokens/cursor.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cursor: () => (/* binding */ cursor)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const cursor = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineTokens.cursor({
  button: { value: "pointer" },
  checkbox: { value: "default" },
  disabled: { value: "not-allowed" },
  menuitem: { value: "default" },
  option: { value: "default" },
  radio: { value: "default" },
  slider: { value: "default" },
  switch: { value: "pointer" }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/durations.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/tokens/durations.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   durations: () => (/* binding */ durations)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const durations = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineTokens.durations({
  fastest: { value: "50ms" },
  faster: { value: "100ms" },
  fast: { value: "150ms" },
  moderate: { value: "200ms" },
  slow: { value: "300ms" },
  slower: { value: "400ms" },
  slowest: { value: "500ms" }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/easings.js":
/*!************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/tokens/easings.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   easings: () => (/* binding */ easings)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const easings = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineTokens.easings({
  "ease-in": { value: "cubic-bezier(0.42, 0, 1, 1)" },
  "ease-out": { value: "cubic-bezier(0, 0, 0.58, 1)" },
  "ease-in-out": { value: "cubic-bezier(0.42, 0, 0.58, 1)" },
  "ease-in-smooth": { value: "cubic-bezier(0.32, 0.72, 0, 1)" }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/font-sizes.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/tokens/font-sizes.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fontSizes: () => (/* binding */ fontSizes)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const fontSizes = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineTokens.fontSizes({
  "2xs": { value: "0.625rem" },
  xs: { value: "0.75rem" },
  sm: { value: "0.875rem" },
  md: { value: "1rem" },
  lg: { value: "1.125rem" },
  xl: { value: "1.25rem" },
  "2xl": { value: "1.5rem" },
  "3xl": { value: "1.875rem" },
  "4xl": { value: "2.25rem" },
  "5xl": { value: "3rem" },
  "6xl": { value: "3.75rem" },
  "7xl": { value: "4.5rem" },
  "8xl": { value: "6rem" },
  "9xl": { value: "8rem" }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/font-weights.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/tokens/font-weights.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fontWeights: () => (/* binding */ fontWeights)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const fontWeights = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineTokens.fontWeights({
  thin: { value: "100" },
  extralight: { value: "200" },
  light: { value: "300" },
  normal: { value: "400" },
  medium: { value: "500" },
  semibold: { value: "600" },
  bold: { value: "700" },
  extrabold: { value: "800" },
  black: { value: "900" }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/fonts.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/tokens/fonts.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fonts: () => (/* binding */ fonts)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const fallback = `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
const fonts = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineTokens.fonts({
  heading: {
    value: `Inter, ${fallback}`
  },
  body: {
    value: `Inter, ${fallback}`
  },
  mono: {
    value: `SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace`
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/keyframes.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/tokens/keyframes.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   keyframes: () => (/* binding */ keyframes)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const keyframes = (0,_styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineKeyframes)({
  spin: {
    "0%": { transform: "rotate(0deg)" },
    "100%": { transform: "rotate(360deg)" }
  },
  pulse: {
    "50%": { opacity: "0.5" }
  },
  ping: {
    "75%, 100%": {
      transform: "scale(2)",
      opacity: "0"
    }
  },
  bounce: {
    "0%, 100%": {
      transform: "translateY(-25%)",
      animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
    },
    "50%": {
      transform: "none",
      animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
    }
  },
  "bg-position": {
    from: { backgroundPosition: "var(--animate-from, 1rem) 0" },
    to: { backgroundPosition: "var(--animate-to, 0) 0" }
  },
  position: {
    from: {
      insetInlineStart: "var(--animate-from-x)",
      insetBlockStart: "var(--animate-from-y)"
    },
    to: {
      insetInlineStart: "var(--animate-to-x)",
      insetBlockStart: "var(--animate-to-y)"
    }
  },
  "circular-progress": {
    "0%": {
      strokeDasharray: "1, 400",
      strokeDashoffset: "0"
    },
    "50%": {
      strokeDasharray: "400, 400",
      strokeDashoffset: "-100%"
    },
    "100%": {
      strokeDasharray: "400, 400",
      strokeDashoffset: "-260%"
    }
  },
  // collapse
  "expand-height": {
    from: { height: "0" },
    to: { height: "var(--height)" }
  },
  "collapse-height": {
    from: { height: "var(--height)" },
    to: { height: "0" }
  },
  "expand-width": {
    from: { width: "0" },
    to: { width: "var(--width)" }
  },
  "collapse-width": {
    from: { height: "var(--width)" },
    to: { height: "0" }
  },
  // fade
  "fade-in": {
    from: { opacity: 0 },
    to: { opacity: 1 }
  },
  "fade-out": {
    from: { opacity: 1 },
    to: { opacity: 0 }
  },
  // slide from (full)
  "slide-from-left-full": {
    from: { translate: "-100% 0" },
    to: { translate: "0 0" }
  },
  "slide-from-right-full": {
    from: { translate: "100% 0" },
    to: { translate: "0 0" }
  },
  "slide-from-top-full": {
    from: { translate: "0 -100%" },
    to: { translate: "0 0" }
  },
  "slide-from-bottom-full": {
    from: { translate: "0 100%" },
    to: { translate: "0 0" }
  },
  // slide to (full)
  "slide-to-left-full": {
    from: { translate: "0 0" },
    to: { translate: "-100% 0" }
  },
  "slide-to-right-full": {
    from: { translate: "0 0" },
    to: { translate: "100% 0" }
  },
  "slide-to-top-full": {
    from: { translate: "0 0" },
    to: { translate: "0 -100%" }
  },
  "slide-to-bottom-full": {
    from: { translate: "0 0" },
    to: { translate: "0 100%" }
  },
  // slide from
  "slide-from-top": {
    "0%": { translate: "0 -0.5rem" },
    to: { translate: "0" }
  },
  "slide-from-bottom": {
    "0%": { translate: "0 0.5rem" },
    to: { translate: "0" }
  },
  "slide-from-left": {
    "0%": { translate: "-0.5rem 0" },
    to: { translate: "0" }
  },
  "slide-from-right": {
    "0%": { translate: "0.5rem 0" },
    to: { translate: "0" }
  },
  // slide to
  "slide-to-top": {
    "0%": { translate: "0" },
    to: { translate: "0 -0.5rem" }
  },
  "slide-to-bottom": {
    "0%": { translate: "0" },
    to: { translate: "0 0.5rem" }
  },
  "slide-to-left": {
    "0%": { translate: "0" },
    to: { translate: "-0.5rem 0" }
  },
  "slide-to-right": {
    "0%": { translate: "0" },
    to: { translate: "0.5rem 0" }
  },
  // scale
  "scale-in": {
    from: { scale: "0.95" },
    to: { scale: "1" }
  },
  "scale-out": {
    from: { scale: "1" },
    to: { scale: "0.95" }
  }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/letter-spacing.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/tokens/letter-spacing.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   letterSpacings: () => (/* binding */ letterSpacings)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const letterSpacings = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineTokens.letterSpacings({
  tighter: { value: "-0.05em" },
  tight: { value: "-0.025em" },
  wide: { value: "0.025em" },
  wider: { value: "0.05em" },
  widest: { value: "0.1em" }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/line-heights.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/tokens/line-heights.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   lineHeights: () => (/* binding */ lineHeights)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const lineHeights = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineTokens.lineHeights({
  shorter: { value: 1.25 },
  short: { value: 1.375 },
  moderate: { value: 1.5 },
  tall: { value: 1.625 },
  taller: { value: 2 }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/radius.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/tokens/radius.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   radii: () => (/* binding */ radii)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const radii = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineTokens.radii({
  none: { value: "0" },
  "2xs": { value: "0.0625rem" },
  xs: { value: "0.125rem" },
  sm: { value: "0.25rem" },
  md: { value: "0.375rem" },
  lg: { value: "0.5rem" },
  xl: { value: "0.75rem" },
  "2xl": { value: "1rem" },
  "3xl": { value: "1.5rem" },
  "4xl": { value: "2rem" },
  full: { value: "9999px" }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/sizes.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/tokens/sizes.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sizes: () => (/* binding */ sizes)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _spacing_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./spacing.js */ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/spacing.js");




const largeSizes = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineTokens.sizes({
  "3xs": { value: "14rem" },
  "2xs": { value: "16rem" },
  xs: { value: "20rem" },
  sm: { value: "24rem" },
  md: { value: "28rem" },
  lg: { value: "32rem" },
  xl: { value: "36rem" },
  "2xl": { value: "42rem" },
  "3xl": { value: "48rem" },
  "4xl": { value: "56rem" },
  "5xl": { value: "64rem" },
  "6xl": { value: "72rem" },
  "7xl": { value: "80rem" },
  "8xl": { value: "90rem" }
});
const namedSizes = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineTokens.sizes({
  max: { value: "max-content" },
  min: { value: "min-content" },
  fit: { value: "fit-content" },
  prose: { value: "60ch" },
  full: { value: "100%" },
  dvh: { value: "100dvh" },
  svh: { value: "100svh" },
  lvh: { value: "100lvh" },
  dvw: { value: "100dvw" },
  svw: { value: "100svw" },
  lvw: { value: "100lvw" },
  vw: { value: "100vw" },
  vh: { value: "100vh" }
});
const fractionalSizes = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineTokens.sizes({
  "1/2": { value: "50%" },
  "1/3": { value: "33.333333%" },
  "2/3": { value: "66.666667%" },
  "1/4": { value: "25%" },
  "3/4": { value: "75%" },
  "1/5": { value: "20%" },
  "2/5": { value: "40%" },
  "3/5": { value: "60%" },
  "4/5": { value: "80%" },
  "1/6": { value: "16.666667%" },
  "2/6": { value: "33.333333%" },
  "3/6": { value: "50%" },
  "4/6": { value: "66.666667%" },
  "5/6": { value: "83.333333%" },
  "1/12": { value: "8.333333%" },
  "2/12": { value: "16.666667%" },
  "3/12": { value: "25%" },
  "4/12": { value: "33.333333%" },
  "5/12": { value: "41.666667%" },
  "6/12": { value: "50%" },
  "7/12": { value: "58.333333%" },
  "8/12": { value: "66.666667%" },
  "9/12": { value: "75%" },
  "10/12": { value: "83.333333%" },
  "11/12": { value: "91.666667%" }
});
const sizes = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineTokens.sizes({
  ...largeSizes,
  ..._spacing_js__WEBPACK_IMPORTED_MODULE_1__.spacing,
  ...fractionalSizes,
  ...namedSizes
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/spacing.js":
/*!************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/tokens/spacing.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   spacing: () => (/* binding */ spacing)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const spacing = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineTokens.spacing({
  0.5: { value: "0.125rem" },
  1: { value: "0.25rem" },
  1.5: { value: "0.375rem" },
  2: { value: "0.5rem" },
  2.5: { value: "0.625rem" },
  3: { value: "0.75rem" },
  3.5: { value: "0.875rem" },
  4: { value: "1rem" },
  4.5: { value: "1.125rem" },
  5: { value: "1.25rem" },
  6: { value: "1.5rem" },
  7: { value: "1.75rem" },
  8: { value: "2rem" },
  9: { value: "2.25rem" },
  10: { value: "2.5rem" },
  11: { value: "2.75rem" },
  12: { value: "3rem" },
  14: { value: "3.5rem" },
  16: { value: "4rem" },
  20: { value: "5rem" },
  24: { value: "6rem" },
  28: { value: "7rem" },
  32: { value: "8rem" },
  36: { value: "9rem" },
  40: { value: "10rem" },
  44: { value: "11rem" },
  48: { value: "12rem" },
  52: { value: "13rem" },
  56: { value: "14rem" },
  60: { value: "15rem" },
  64: { value: "16rem" },
  72: { value: "18rem" },
  80: { value: "20rem" },
  96: { value: "24rem" }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/theme/tokens/z-indices.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/theme/tokens/z-indices.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   zIndices: () => (/* binding */ zIndices)
/* harmony export */ });
/* harmony import */ var _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styled-system/config.js */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");



const zIndices = _styled_system_config_js__WEBPACK_IMPORTED_MODULE_0__.defineTokens.zIndex({
  hide: { value: -1 },
  base: { value: 0 },
  docked: { value: 10 },
  dropdown: { value: 1e3 },
  sticky: { value: 1100 },
  banner: { value: 1200 },
  overlay: { value: 1300 },
  modal: { value: 1400 },
  popover: { value: 1500 },
  skipNav: { value: 1600 },
  toast: { value: 1700 },
  tooltip: { value: 1800 },
  max: { value: 2147483647 }
});




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/utils/attr.js":
/*!**************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/utils/attr.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dataAttr: () => (/* binding */ dataAttr)
/* harmony export */ });

const dataAttr = (condition) => condition ? "" : void 0;




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/utils/call-all.js":
/*!******************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/utils/call-all.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   callAll: () => (/* binding */ callAll)
/* harmony export */ });

function callAll(...fns) {
  return function mergedFn(...args) {
    fns.forEach((fn) => fn?.(...args));
  };
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/utils/clone.js":
/*!***************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/utils/clone.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clone: () => (/* binding */ clone)
/* harmony export */ });

function clone(obj) {
  if (obj === null || typeof obj !== "object") return obj;
  if (Array.isArray(obj)) return obj.map((prop) => clone(prop));
  const _clone = Object.create(Object.getPrototypeOf(obj));
  for (const key of Object.keys(obj)) {
    _clone[key] = clone(obj[key]);
  }
  return _clone;
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/utils/compact.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/utils/compact.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compact: () => (/* binding */ compact)
/* harmony export */ });

function compact(object) {
  const clone = Object.assign({}, object);
  for (let key in clone) {
    if (clone[key] === void 0) delete clone[key];
  }
  return clone;
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/utils/create-props.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/utils/create-props.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createProps: () => (/* binding */ createProps)
/* harmony export */ });

const createProps = () => (props) => Array.from(new Set(props));




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/utils/cx.js":
/*!************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/utils/cx.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cx: () => (/* binding */ cx)
/* harmony export */ });

const cx = (...classNames) => classNames.filter(Boolean).map((r) => r.trim()).join(" ");




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/utils/entries.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/utils/entries.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapEntries: () => (/* binding */ mapEntries)
/* harmony export */ });

function mapEntries(obj, f) {
  const result = {};
  for (const key in obj) {
    const kv = f(key, obj[key]);
    result[kv[0]] = kv[1];
  }
  return result;
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/utils/flatten.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/utils/flatten.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   flatten: () => (/* binding */ flatten)
/* harmony export */ });
/* harmony import */ var _walk_object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./walk-object.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/walk-object.js");



function flatten(values, stop) {
  const result = {};
  (0,_walk_object_js__WEBPACK_IMPORTED_MODULE_0__.walkObject)(
    values,
    (token, paths) => {
      if (token) {
        result[paths.join(".")] = token.value;
      }
    },
    { stop }
  );
  return result;
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/utils/interop.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/utils/interop.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   interopDefault: () => (/* binding */ interopDefault)
/* harmony export */ });

function interopDefault(mod) {
  return mod.default || mod;
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/utils/is.js":
/*!************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/utils/is.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isCssVar: () => (/* binding */ isCssVar),
/* harmony export */   isFunction: () => (/* binding */ isFunction),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   isString: () => (/* binding */ isString)
/* harmony export */ });

const isObject = (v) => v != null && typeof v === "object" && !Array.isArray(v);
const isCssVar = (v) => /^var\(--.+\)$/.test(v);
const isString = (v) => typeof v === "string";
const isFunction = (v) => typeof v === "function";




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/utils/memo.js":
/*!**************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/utils/memo.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   memo: () => (/* binding */ memo)
/* harmony export */ });
/* harmony import */ var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fast-safe-stringify */ "./node_modules/fast-safe-stringify/index.js");



const memo = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  function get(...args) {
    const key = args.map((v) => fast_safe_stringify__WEBPACK_IMPORTED_MODULE_0__(v)).join("|");
    if (cache[key] === void 0) cache[key] = fn(...args);
    return cache[key];
  }
  return get;
};




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/utils/merge.js":
/*!***************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/utils/merge.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mergeWith: () => (/* binding */ mergeWith)
/* harmony export */ });
/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/is.js");



function merge(target, source) {
  if (source == null) return target;
  for (const key of Object.keys(source)) {
    if (source[key] === void 0 || key === "__proto__") continue;
    if (!(0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(target[key]) && (0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(source[key])) {
      Object.assign(target, { [key]: source[key] });
    } else if (target[key] && (0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(source[key])) {
      merge(target[key], source[key]);
    } else if (Array.isArray(source[key]) && Array.isArray(target[key])) {
      let i = 0;
      for (; i < source[key].length; i++) {
        if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(target[key][i]) && (0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(source[key][i])) {
          merge(target[key][i], source[key][i]);
        } else {
          target[key][i] = source[key][i];
        }
      }
    } else {
      Object.assign(target, { [key]: source[key] });
    }
  }
  return target;
}
function mergeWith(target, ...sources) {
  for (const source of sources) {
    merge(target, source);
  }
  return target;
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/utils/omit.js":
/*!**************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/utils/omit.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   omit: () => (/* binding */ omit)
/* harmony export */ });

function omit(object, keysToOmit = []) {
  const clone = Object.assign({}, object);
  for (const key of keysToOmit) {
    if (key in clone) {
      delete clone[key];
    }
  }
  return clone;
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/utils/ref.js":
/*!*************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/utils/ref.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getElementRef: () => (/* binding */ getElementRef)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/is.js");




function getElementRef(el) {
  const version = react__WEBPACK_IMPORTED_MODULE_0__.version;
  if (!(0,_is_js__WEBPACK_IMPORTED_MODULE_1__.isString)(version)) return el?.ref;
  if (version.startsWith("18.")) return el?.ref;
  return el?.props?.ref;
}




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/utils/split-props.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/utils/split-props.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSplitProps: () => (/* binding */ createSplitProps),
/* harmony export */   splitProps: () => (/* binding */ splitProps)
/* harmony export */ });
/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/is.js");



const splitPropFn = (props, predicate) => {
  const rest = {};
  const result = {};
  const allKeys = Object.keys(props);
  for (const key of allKeys) {
    if (predicate(key)) {
      result[key] = props[key];
    } else {
      rest[key] = props[key];
    }
  }
  return [result, rest];
};
const splitProps = (props, keys) => {
  const predicate = (0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(keys) ? keys : (key) => keys.includes(key);
  return splitPropFn(props, predicate);
};
const createSplitProps = (keys) => {
  return function split(props) {
    return splitProps(props, keys);
  };
};




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/utils/uniq.js":
/*!**************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/utils/uniq.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   uniq: () => (/* binding */ uniq)
/* harmony export */ });

const uniq = (...items) => {
  const _items = items.filter(Boolean);
  return Array.from(new Set(_items));
};




/***/ }),

/***/ "./node_modules/@chakra-ui/react/dist/esm/utils/walk-object.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@chakra-ui/react/dist/esm/utils/walk-object.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapObject: () => (/* binding */ mapObject),
/* harmony export */   walkObject: () => (/* binding */ walkObject)
/* harmony export */ });
/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is.js */ "./node_modules/@chakra-ui/react/dist/esm/utils/is.js");



const isNotNullish = (element) => element != null;
function walkObject(target, predicate, options = {}) {
  const { stop, getKey } = options;
  function inner(value, path = []) {
    if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) || Array.isArray(value)) {
      const result = {};
      for (const [prop, child] of Object.entries(value)) {
        const key = getKey?.(prop, child) ?? prop;
        const childPath = [...path, key];
        if (stop?.(value, childPath)) {
          return predicate(value, path);
        }
        const next = inner(child, childPath);
        if (isNotNullish(next)) {
          result[key] = next;
        }
      }
      return result;
    }
    return predicate(value, path);
  }
  return inner(target);
}
function mapObject(obj, fn) {
  if (Array.isArray(obj)) return obj.map((value) => fn(value));
  if (!(0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(obj)) {
    if (obj !== null && obj !== void 0) return fn(obj);
    else return obj;
  }
  return walkObject(obj, (value) => fn(value));
}




/***/ }),

/***/ "./node_modules/@emotion/cache/dist/emotion-cache.browser.development.esm.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@emotion/cache/dist/emotion-cache.browser.development.esm.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createCache)
/* harmony export */ });
/* harmony import */ var _emotion_sheet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @emotion/sheet */ "./node_modules/@emotion/sheet/dist/emotion-sheet.development.esm.js");
/* harmony import */ var stylis__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! stylis */ "./node_modules/stylis/src/Tokenizer.js");
/* harmony import */ var stylis__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! stylis */ "./node_modules/stylis/src/Utility.js");
/* harmony import */ var stylis__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! stylis */ "./node_modules/stylis/src/Enum.js");
/* harmony import */ var stylis__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! stylis */ "./node_modules/stylis/src/Serializer.js");
/* harmony import */ var stylis__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! stylis */ "./node_modules/stylis/src/Middleware.js");
/* harmony import */ var stylis__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! stylis */ "./node_modules/stylis/src/Parser.js");
/* harmony import */ var _emotion_weak_memoize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @emotion/weak-memoize */ "./node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js");
/* harmony import */ var _emotion_memoize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @emotion/memoize */ "./node_modules/@emotion/memoize/dist/emotion-memoize.esm.js");





var identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {
  var previous = 0;
  var character = 0;

  while (true) {
    previous = character;
    character = (0,stylis__WEBPACK_IMPORTED_MODULE_3__.peek)(); // &\f

    if (previous === 38 && character === 12) {
      points[index] = 1;
    }

    if ((0,stylis__WEBPACK_IMPORTED_MODULE_3__.token)(character)) {
      break;
    }

    (0,stylis__WEBPACK_IMPORTED_MODULE_3__.next)();
  }

  return (0,stylis__WEBPACK_IMPORTED_MODULE_3__.slice)(begin, stylis__WEBPACK_IMPORTED_MODULE_3__.position);
};

var toRules = function toRules(parsed, points) {
  // pretend we've started with a comma
  var index = -1;
  var character = 44;

  do {
    switch ((0,stylis__WEBPACK_IMPORTED_MODULE_3__.token)(character)) {
      case 0:
        // &\f
        if (character === 38 && (0,stylis__WEBPACK_IMPORTED_MODULE_3__.peek)() === 12) {
          // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
          // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
          // and when it should just concatenate the outer and inner selectors
          // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
          points[index] = 1;
        }

        parsed[index] += identifierWithPointTracking(stylis__WEBPACK_IMPORTED_MODULE_3__.position - 1, points, index);
        break;

      case 2:
        parsed[index] += (0,stylis__WEBPACK_IMPORTED_MODULE_3__.delimit)(character);
        break;

      case 4:
        // comma
        if (character === 44) {
          // colon
          parsed[++index] = (0,stylis__WEBPACK_IMPORTED_MODULE_3__.peek)() === 58 ? '&\f' : '';
          points[index] = parsed[index].length;
          break;
        }

      // fallthrough

      default:
        parsed[index] += (0,stylis__WEBPACK_IMPORTED_MODULE_4__.from)(character);
    }
  } while (character = (0,stylis__WEBPACK_IMPORTED_MODULE_3__.next)());

  return parsed;
};

var getRules = function getRules(value, points) {
  return (0,stylis__WEBPACK_IMPORTED_MODULE_3__.dealloc)(toRules((0,stylis__WEBPACK_IMPORTED_MODULE_3__.alloc)(value), points));
}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11


var fixedElements = /* #__PURE__ */new WeakMap();
var compat = function compat(element) {
  if (element.type !== 'rule' || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }

  var value = element.value;
  var parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;

  while (parent.type !== 'rule') {
    parent = parent.parent;
    if (!parent) return;
  } // short-circuit for the simplest case


  if (element.props.length === 1 && value.charCodeAt(0) !== 58
  /* colon */
  && !fixedElements.get(parent)) {
    return;
  } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
  // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"


  if (isImplicitRule) {
    return;
  }

  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;

  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel(element) {
  if (element.type === 'decl') {
    var value = element.value;

    if ( // charcode for l
    value.charCodeAt(0) === 108 && // charcode for b
    value.charCodeAt(2) === 98) {
      // this ignores label
      element["return"] = '';
      element.value = '';
    }
  }
};
var ignoreFlag = 'emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason';

var isIgnoringComment = function isIgnoringComment(element) {
  return element.type === 'comm' && element.children.indexOf(ignoreFlag) > -1;
};

var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm(cache) {
  return function (element, index, children) {
    if (element.type !== 'rule' || cache.compat) return;
    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);

    if (unsafePseudoClasses) {
      var isNested = !!element.parent; // in nested rules comments become children of the "auto-inserted" rule and that's always the `element.parent`
      //
      // considering this input:
      // .a {
      //   .b /* comm */ {}
      //   color: hotpink;
      // }
      // we get output corresponding to this:
      // .a {
      //   & {
      //     /* comm */
      //     color: hotpink;
      //   }
      //   .b {}
      // }

      var commentContainer = isNested ? element.parent.children : // global rule at the root level
      children;

      for (var i = commentContainer.length - 1; i >= 0; i--) {
        var node = commentContainer[i];

        if (node.line < element.line) {
          break;
        } // it is quite weird but comments are *usually* put at `column: element.column - 1`
        // so we seek *from the end* for the node that is earlier than the rule's `element` and check that
        // this will also match inputs like this:
        // .a {
        //   /* comm */
        //   .b {}
        // }
        //
        // but that is fine
        //
        // it would be the easiest to change the placement of the comment to be the first child of the rule:
        // .a {
        //   .b { /* comm */ }
        // }
        // with such inputs we wouldn't have to search for the comment at all
        // TODO: consider changing this comment placement in the next major version


        if (node.column < element.column) {
          if (isIgnoringComment(node)) {
            return;
          }

          break;
        }
      }

      unsafePseudoClasses.forEach(function (unsafePseudoClass) {
        console.error("The pseudo class \"" + unsafePseudoClass + "\" is potentially unsafe when doing server-side rendering. Try changing it to \"" + unsafePseudoClass.split('-child')[0] + "-of-type\".");
      });
    }
  };
};

var isImportRule = function isImportRule(element) {
  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};

var isPrependedWithRegularRules = function isPrependedWithRegularRules(index, children) {
  for (var i = index - 1; i >= 0; i--) {
    if (!isImportRule(children[i])) {
      return true;
    }
  }

  return false;
}; // use this to remove incorrect elements from further processing
// so they don't get handed to the `sheet` (or anything else)
// as that could potentially lead to additional logs which in turn could be overhelming to the user


var nullifyElement = function nullifyElement(element) {
  element.type = '';
  element.value = '';
  element["return"] = '';
  element.children = '';
  element.props = '';
};

var incorrectImportAlarm = function incorrectImportAlarm(element, index, children) {
  if (!isImportRule(element)) {
    return;
  }

  if (element.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element);
  } else if (isPrependedWithRegularRules(index, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element);
  }
};

/* eslint-disable no-fallthrough */

function prefix(value, length) {
  switch ((0,stylis__WEBPACK_IMPORTED_MODULE_4__.hash)(value, length)) {
    // color-adjust
    case 5103:
      return stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + 'print-' + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)

    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921: // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break

    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005: // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,

    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855: // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)

    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust

    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + value + stylis__WEBPACK_IMPORTED_MODULE_5__.MOZ + value + stylis__WEBPACK_IMPORTED_MODULE_5__.MS + value + value;
    // flex, flex-direction

    case 6828:
    case 4268:
      return stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + value + stylis__WEBPACK_IMPORTED_MODULE_5__.MS + value + value;
    // order

    case 6165:
      return stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + value + stylis__WEBPACK_IMPORTED_MODULE_5__.MS + 'flex-' + value + value;
    // align-items

    case 5187:
      return stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + value + (0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, /(\w+).+(:[^]+)/, stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + 'box-$1$2' + stylis__WEBPACK_IMPORTED_MODULE_5__.MS + 'flex-$1$2') + value;
    // align-self

    case 5443:
      return stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + value + stylis__WEBPACK_IMPORTED_MODULE_5__.MS + 'flex-item-' + (0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, /flex-|-self/, '') + value;
    // align-content

    case 4675:
      return stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + value + stylis__WEBPACK_IMPORTED_MODULE_5__.MS + 'flex-line-pack' + (0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, /align-content|flex-|-self/, '') + value;
    // flex-shrink

    case 5548:
      return stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + value + stylis__WEBPACK_IMPORTED_MODULE_5__.MS + (0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, 'shrink', 'negative') + value;
    // flex-basis

    case 5292:
      return stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + value + stylis__WEBPACK_IMPORTED_MODULE_5__.MS + (0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, 'basis', 'preferred-size') + value;
    // flex-grow

    case 6060:
      return stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + 'box-' + (0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, '-grow', '') + stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + value + stylis__WEBPACK_IMPORTED_MODULE_5__.MS + (0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, 'grow', 'positive') + value;
    // transition

    case 4554:
      return stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + (0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, /([^-])(transform)/g, '$1' + stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + '$2') + value;
    // cursor

    case 6187:
      return (0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)((0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)((0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, /(zoom-|grab)/, stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + '$1'), /(image-set)/, stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + '$1'), value, '') + value;
    // background, background-image

    case 5495:
    case 3959:
      return (0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, /(image-set\([^]*)/, stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + '$1' + '$`$1');
    // justify-content

    case 4968:
      return (0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)((0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, /(.+:)(flex-)?(.*)/, stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + 'box-pack:$3' + stylis__WEBPACK_IMPORTED_MODULE_5__.MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + value + value;
    // (margin|padding)-inline-(start|end)

    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return (0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, /(.+)-inline(.+)/, stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + '$1$2') + value;
    // (min|max)?(width|height|inline-size|block-size)

    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      // stretch, max-content, min-content, fill-available
      if ((0,stylis__WEBPACK_IMPORTED_MODULE_4__.strlen)(value) - 1 - length > 6) switch ((0,stylis__WEBPACK_IMPORTED_MODULE_4__.charat)(value, length + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          // -
          if ((0,stylis__WEBPACK_IMPORTED_MODULE_4__.charat)(value, length + 4) !== 45) break;
        // (f)ill-available, (f)it-content

        case 102:
          return (0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, /(.+:)(.+)-([^]+)/, '$1' + stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + '$2-$3' + '$1' + stylis__WEBPACK_IMPORTED_MODULE_5__.MOZ + ((0,stylis__WEBPACK_IMPORTED_MODULE_4__.charat)(value, length + 3) == 108 ? '$3' : '$2-$3')) + value;
        // (s)tretch

        case 115:
          return ~(0,stylis__WEBPACK_IMPORTED_MODULE_4__.indexof)(value, 'stretch') ? prefix((0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, 'stretch', 'fill-available'), length) + value : value;
      }
      break;
    // position: sticky

    case 4949:
      // (s)ticky?
      if ((0,stylis__WEBPACK_IMPORTED_MODULE_4__.charat)(value, length + 1) !== 115) break;
    // display: (flex|inline-flex)

    case 6444:
      switch ((0,stylis__WEBPACK_IMPORTED_MODULE_4__.charat)(value, (0,stylis__WEBPACK_IMPORTED_MODULE_4__.strlen)(value) - 3 - (~(0,stylis__WEBPACK_IMPORTED_MODULE_4__.indexof)(value, '!important') && 10))) {
        // stic(k)y
        case 107:
          return (0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, ':', ':' + stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT) + value;
        // (inline-)?fl(e)x

        case 101:
          return (0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + ((0,stylis__WEBPACK_IMPORTED_MODULE_4__.charat)(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + '$2$3' + '$1' + stylis__WEBPACK_IMPORTED_MODULE_5__.MS + '$2box$3') + value;
      }

      break;
    // writing-mode

    case 5936:
      switch ((0,stylis__WEBPACK_IMPORTED_MODULE_4__.charat)(value, length + 11)) {
        // vertical-l(r)
        case 114:
          return stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + value + stylis__WEBPACK_IMPORTED_MODULE_5__.MS + (0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, /[svh]\w+-[tblr]{2}/, 'tb') + value;
        // vertical-r(l)

        case 108:
          return stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + value + stylis__WEBPACK_IMPORTED_MODULE_5__.MS + (0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value;
        // horizontal(-)tb

        case 45:
          return stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + value + stylis__WEBPACK_IMPORTED_MODULE_5__.MS + (0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, /[svh]\w+-[tblr]{2}/, 'lr') + value;
      }

      return stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + value + stylis__WEBPACK_IMPORTED_MODULE_5__.MS + value + value;
  }

  return value;
}

var prefixer = function prefixer(element, index, children, callback) {
  if (element.length > -1) if (!element["return"]) switch (element.type) {
    case stylis__WEBPACK_IMPORTED_MODULE_5__.DECLARATION:
      element["return"] = prefix(element.value, element.length);
      break;

    case stylis__WEBPACK_IMPORTED_MODULE_5__.KEYFRAMES:
      return (0,stylis__WEBPACK_IMPORTED_MODULE_6__.serialize)([(0,stylis__WEBPACK_IMPORTED_MODULE_3__.copy)(element, {
        value: (0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(element.value, '@', '@' + stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT)
      })], callback);

    case stylis__WEBPACK_IMPORTED_MODULE_5__.RULESET:
      if (element.length) return (0,stylis__WEBPACK_IMPORTED_MODULE_4__.combine)(element.props, function (value) {
        switch ((0,stylis__WEBPACK_IMPORTED_MODULE_4__.match)(value, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ':read-only':
          case ':read-write':
            return (0,stylis__WEBPACK_IMPORTED_MODULE_6__.serialize)([(0,stylis__WEBPACK_IMPORTED_MODULE_3__.copy)(element, {
              props: [(0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, /:(read-\w+)/, ':' + stylis__WEBPACK_IMPORTED_MODULE_5__.MOZ + '$1')]
            })], callback);
          // :placeholder

          case '::placeholder':
            return (0,stylis__WEBPACK_IMPORTED_MODULE_6__.serialize)([(0,stylis__WEBPACK_IMPORTED_MODULE_3__.copy)(element, {
              props: [(0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, /:(plac\w+)/, ':' + stylis__WEBPACK_IMPORTED_MODULE_5__.WEBKIT + 'input-$1')]
            }), (0,stylis__WEBPACK_IMPORTED_MODULE_3__.copy)(element, {
              props: [(0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, /:(plac\w+)/, ':' + stylis__WEBPACK_IMPORTED_MODULE_5__.MOZ + '$1')]
            }), (0,stylis__WEBPACK_IMPORTED_MODULE_3__.copy)(element, {
              props: [(0,stylis__WEBPACK_IMPORTED_MODULE_4__.replace)(value, /:(plac\w+)/, stylis__WEBPACK_IMPORTED_MODULE_5__.MS + 'input-$1')]
            })], callback);
        }

        return '';
      });
  }
};

var defaultStylisPlugins = [prefixer];
var getSourceMap;

{
  var sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;

  getSourceMap = function getSourceMap(styles) {
    var matches = styles.match(sourceMapPattern);
    if (!matches) return;
    return matches[matches.length - 1];
  };
}

var createCache = function createCache(options) {
  var key = options.key;

  if (!key) {
    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\n" + "If multiple caches share the same key they might \"fight\" for each other's style elements.");
  }

  if (key === 'css') {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
    // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
    // note this very very intentionally targets all style elements regardless of the key to ensure
    // that creating a cache works inside of render of a React component

    Array.prototype.forEach.call(ssrStyles, function (node) {
      // we want to only move elements which have a space in the data-emotion attribute value
      // because that indicates that it is an Emotion 11 server-side rendered style elements
      // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
      // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
      // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
      // will not result in the Emotion 10 styles being destroyed
      var dataEmotionAttribute = node.getAttribute('data-emotion');

      if (dataEmotionAttribute.indexOf(' ') === -1) {
        return;
      }

      document.head.appendChild(node);
      node.setAttribute('data-s', '');
    });
  }

  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;

  {
    if (/[^a-z-]/.test(key)) {
      throw new Error("Emotion key must only contain lower case alphabetical characters and - but \"" + key + "\" was passed");
    }
  }

  var inserted = {};
  var container;
  var nodesToHydrate = [];

  {
    container = options.container || document.head;
    Array.prototype.forEach.call( // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function (node) {
      var attrib = node.getAttribute("data-emotion").split(' ');

      for (var i = 1; i < attrib.length; i++) {
        inserted[attrib[i]] = true;
      }

      nodesToHydrate.push(node);
    });
  }

  var _insert;

  var omnipresentPlugins = [compat, removeLabel];

  {
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
      get compat() {
        return cache.compat;
      }

    }), incorrectImportAlarm);
  }

  {
    var currentSheet;
    var finalizingPlugins = [stylis__WEBPACK_IMPORTED_MODULE_6__.stringify, function (element) {
      if (!element.root) {
        if (element["return"]) {
          currentSheet.insert(element["return"]);
        } else if (element.value && element.type !== stylis__WEBPACK_IMPORTED_MODULE_5__.COMMENT) {
          // insert empty rule in non-production environments
          // so @emotion/jest can grab `key` from the (JS)DOM for caches without any rules inserted yet
          currentSheet.insert(element.value + "{}");
        }
      }
    } ];
    var serializer = (0,stylis__WEBPACK_IMPORTED_MODULE_7__.middleware)(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));

    var stylis = function stylis(styles) {
      return (0,stylis__WEBPACK_IMPORTED_MODULE_6__.serialize)((0,stylis__WEBPACK_IMPORTED_MODULE_8__.compile)(styles), serializer);
    };

    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;

      if (getSourceMap) {
        var sourceMap = getSourceMap(serialized.styles);

        if (sourceMap) {
          currentSheet = {
            insert: function insert(rule) {
              sheet.insert(rule + sourceMap);
            }
          };
        }
      }

      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);

      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }

  var cache = {
    key: key,
    sheet: new _emotion_sheet__WEBPACK_IMPORTED_MODULE_0__.StyleSheet({
      key: key,
      container: container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted: inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};




/***/ }),

/***/ "./node_modules/@emotion/hash/dist/emotion-hash.esm.js":
/*!*************************************************************!*\
  !*** ./node_modules/@emotion/hash/dist/emotion-hash.esm.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ murmur2)
/* harmony export */ });
/* eslint-disable */
// Inspired by https://github.com/garycourt/murmurhash-js
// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
function murmur2(str) {
  // 'm' and 'r' are mixing constants generated offline.
  // They're not really 'magic', they just happen to work well.
  // const m = 0x5bd1e995;
  // const r = 24;
  // Initialize the hash
  var h = 0; // Mix 4 bytes at a time into the hash

  var k,
      i = 0,
      len = str.length;

  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
    k =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
    k ^=
    /* k >>> r: */
    k >>> 24;
    h =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^
    /* Math.imul(h, m): */
    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Handle the last few bytes of the input array


  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

    case 2:
      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

    case 1:
      h ^= str.charCodeAt(i) & 0xff;
      h =
      /* Math.imul(h, m): */
      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Do a few final mixes of the hash to ensure the last few
  // bytes are well-incorporated.


  h ^= h >>> 13;
  h =
  /* Math.imul(h, m): */
  (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}




/***/ }),

/***/ "./node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isPropValid)
/* harmony export */ });
/* harmony import */ var _emotion_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @emotion/memoize */ "./node_modules/@emotion/memoize/dist/emotion-memoize.esm.js");


// eslint-disable-next-line no-undef
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

var isPropValid = /* #__PURE__ */(0,_emotion_memoize__WEBPACK_IMPORTED_MODULE_0__["default"])(function (prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
  /* o */
  && prop.charCodeAt(1) === 110
  /* n */
  && prop.charCodeAt(2) < 91;
}
/* Z+1 */
);




/***/ }),

/***/ "./node_modules/@emotion/memoize/dist/emotion-memoize.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@emotion/memoize/dist/emotion-memoize.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ memoize)
/* harmony export */ });
function memoize(fn) {
  var cache = Object.create(null);
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}




/***/ }),

/***/ "./node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.esm.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.esm.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ hoistNonReactStatics)
/* harmony export */ });
/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hoist-non-react-statics */ "./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js");
/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_0__);


// this file isolates this package that is not tree-shakeable
// and if this module doesn't actually contain any logic of its own
// then Rollup just use 'hoist-non-react-statics' directly in other chunks

var hoistNonReactStatics = (function (targetComponent, sourceComponent) {
  return hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_0___default()(targetComponent, sourceComponent);
});




/***/ }),

/***/ "./node_modules/@emotion/react/dist/emotion-element-489459f2.browser.development.esm.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@emotion/react/dist/emotion-element-489459f2.browser.development.esm.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CacheProvider),
/* harmony export */   E: () => (/* binding */ Emotion$1),
/* harmony export */   T: () => (/* binding */ ThemeContext),
/* harmony export */   _: () => (/* binding */ __unsafe_useEmotionCache),
/* harmony export */   a: () => (/* binding */ ThemeProvider),
/* harmony export */   b: () => (/* binding */ withTheme),
/* harmony export */   c: () => (/* binding */ createEmotionProps),
/* harmony export */   h: () => (/* binding */ hasOwn),
/* harmony export */   u: () => (/* binding */ useTheme),
/* harmony export */   w: () => (/* binding */ withEmotionCache)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _emotion_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @emotion/cache */ "./node_modules/@emotion/cache/dist/emotion-cache.browser.development.esm.js");
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _emotion_weak_memoize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @emotion/weak-memoize */ "./node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js");
/* harmony import */ var _isolated_hnrs_dist_emotion_react_isolated_hnrs_browser_development_esm_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.esm.js */ "./node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.esm.js");
/* harmony import */ var _emotion_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @emotion/utils */ "./node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js");
/* harmony import */ var _emotion_serialize__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @emotion/serialize */ "./node_modules/@emotion/serialize/dist/emotion-serialize.development.esm.js");
/* harmony import */ var _emotion_use_insertion_effect_with_fallbacks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @emotion/use-insertion-effect-with-fallbacks */ "./node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js");










var EmotionCacheContext = /* #__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createContext( // we're doing this to avoid preconstruct's dead code elimination in this one case
// because this module is primarily intended for the browser and node
// but it's also required in react native and similar environments sometimes
// and we could have a special build just for that
// but this is much easier and the native packages
// might use a different theme context in the future anyway
typeof HTMLElement !== 'undefined' ? /* #__PURE__ */(0,_emotion_cache__WEBPACK_IMPORTED_MODULE_1__["default"])({
  key: 'css'
}) : null);

{
  EmotionCacheContext.displayName = 'EmotionCacheContext';
}

var CacheProvider = EmotionCacheContext.Provider;
var __unsafe_useEmotionCache = function useEmotionCache() {
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EmotionCacheContext);
};

var withEmotionCache = function withEmotionCache(func) {
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (props, ref) {
    // the cache will never be null in the browser
    var cache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EmotionCacheContext);
    return func(props, cache, ref);
  });
};

var ThemeContext = /* #__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createContext({});

{
  ThemeContext.displayName = 'EmotionThemeContext';
}

var useTheme = function useTheme() {
  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(ThemeContext);
};

var getTheme = function getTheme(outerTheme, theme) {
  if (typeof theme === 'function') {
    var mergedTheme = theme(outerTheme);

    if ((mergedTheme == null || typeof mergedTheme !== 'object' || Array.isArray(mergedTheme))) {
      throw new Error('[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!');
    }

    return mergedTheme;
  }

  if ((theme == null || typeof theme !== 'object' || Array.isArray(theme))) {
    throw new Error('[ThemeProvider] Please make your theme prop a plain object');
  }

  return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__["default"])({}, outerTheme, theme);
};

var createCacheWithTheme = /* #__PURE__ */(0,_emotion_weak_memoize__WEBPACK_IMPORTED_MODULE_3__["default"])(function (outerTheme) {
  return (0,_emotion_weak_memoize__WEBPACK_IMPORTED_MODULE_3__["default"])(function (theme) {
    return getTheme(outerTheme, theme);
  });
});
var ThemeProvider = function ThemeProvider(props) {
  var theme = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ThemeContext);

  if (props.theme !== theme) {
    theme = createCacheWithTheme(theme)(props.theme);
  }

  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ThemeContext.Provider, {
    value: theme
  }, props.children);
};
function withTheme(Component) {
  var componentName = Component.displayName || Component.name || 'Component';
  var WithTheme = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function render(props, ref) {
    var theme = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ThemeContext);
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__["default"])({
      theme: theme,
      ref: ref
    }, props));
  });
  WithTheme.displayName = "WithTheme(" + componentName + ")";
  return (0,_isolated_hnrs_dist_emotion_react_isolated_hnrs_browser_development_esm_js__WEBPACK_IMPORTED_MODULE_7__["default"])(WithTheme, Component);
}

var hasOwn = {}.hasOwnProperty;

var getLastPart = function getLastPart(functionName) {
  // The match may be something like 'Object.createEmotionProps' or
  // 'Loader.prototype.render'
  var parts = functionName.split('.');
  return parts[parts.length - 1];
};

var getFunctionNameFromStackTraceLine = function getFunctionNameFromStackTraceLine(line) {
  // V8
  var match = /^\s+at\s+([A-Za-z0-9$.]+)\s/.exec(line);
  if (match) return getLastPart(match[1]); // Safari / Firefox

  match = /^([A-Za-z0-9$.]+)@/.exec(line);
  if (match) return getLastPart(match[1]);
  return undefined;
};

var internalReactFunctionNames = /* #__PURE__ */new Set(['renderWithHooks', 'processChild', 'finishClassComponent', 'renderToString']); // These identifiers come from error stacks, so they have to be valid JS
// identifiers, thus we only need to replace what is a valid character for JS,
// but not for CSS.

var sanitizeIdentifier = function sanitizeIdentifier(identifier) {
  return identifier.replace(/\$/g, '-');
};

var getLabelFromStackTrace = function getLabelFromStackTrace(stackTrace) {
  if (!stackTrace) return undefined;
  var lines = stackTrace.split('\n');

  for (var i = 0; i < lines.length; i++) {
    var functionName = getFunctionNameFromStackTraceLine(lines[i]); // The first line of V8 stack traces is just "Error"

    if (!functionName) continue; // If we reach one of these, we have gone too far and should quit

    if (internalReactFunctionNames.has(functionName)) break; // The component name is the first function in the stack that starts with an
    // uppercase letter

    if (/^[A-Z]/.test(functionName)) return sanitizeIdentifier(functionName);
  }

  return undefined;
};

var typePropName = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__';
var labelPropName = '__EMOTION_LABEL_PLEASE_DO_NOT_USE__';
var createEmotionProps = function createEmotionProps(type, props) {
  if (typeof props.css === 'string' && // check if there is a css declaration
  props.css.indexOf(':') !== -1) {
    throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`" + props.css + "`");
  }

  var newProps = {};

  for (var _key in props) {
    if (hasOwn.call(props, _key)) {
      newProps[_key] = props[_key];
    }
  }

  newProps[typePropName] = type; // Runtime labeling is an opt-in feature because:
  // - It causes hydration warnings when using Safari and SSR
  // - It can degrade performance if there are a huge number of elements
  //
  // Even if the flag is set, we still don't compute the label if it has already
  // been determined by the Babel plugin.

  if (typeof globalThis !== 'undefined' && !!globalThis.EMOTION_RUNTIME_AUTO_LABEL && !!props.css && (typeof props.css !== 'object' || !('name' in props.css) || typeof props.css.name !== 'string' || props.css.name.indexOf('-') === -1)) {
    var label = getLabelFromStackTrace(new Error().stack);
    if (label) newProps[labelPropName] = label;
  }

  return newProps;
};

var Insertion = function Insertion(_ref) {
  var cache = _ref.cache,
      serialized = _ref.serialized,
      isStringTag = _ref.isStringTag;
  (0,_emotion_utils__WEBPACK_IMPORTED_MODULE_4__.registerStyles)(cache, serialized, isStringTag);
  (0,_emotion_use_insertion_effect_with_fallbacks__WEBPACK_IMPORTED_MODULE_6__.useInsertionEffectAlwaysWithSyncFallback)(function () {
    return (0,_emotion_utils__WEBPACK_IMPORTED_MODULE_4__.insertStyles)(cache, serialized, isStringTag);
  });

  return null;
};

var Emotion = /* #__PURE__ */withEmotionCache(function (props, cache, ref) {
  var cssProp = props.css; // so that using `css` from `emotion` and passing the result to the css prop works
  // not passing the registered cache to serializeStyles because it would
  // make certain babel optimisations not possible

  if (typeof cssProp === 'string' && cache.registered[cssProp] !== undefined) {
    cssProp = cache.registered[cssProp];
  }

  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = '';

  if (typeof props.className === 'string') {
    className = (0,_emotion_utils__WEBPACK_IMPORTED_MODULE_4__.getRegisteredStyles)(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }

  var serialized = (0,_emotion_serialize__WEBPACK_IMPORTED_MODULE_5__.serializeStyles)(registeredStyles, undefined, react__WEBPACK_IMPORTED_MODULE_0__.useContext(ThemeContext));

  if (serialized.name.indexOf('-') === -1) {
    var labelFromStack = props[labelPropName];

    if (labelFromStack) {
      serialized = (0,_emotion_serialize__WEBPACK_IMPORTED_MODULE_5__.serializeStyles)([serialized, 'label:' + labelFromStack + ';']);
    }
  }

  className += cache.key + "-" + serialized.name;
  var newProps = {};

  for (var _key2 in props) {
    if (hasOwn.call(props, _key2) && _key2 !== 'css' && _key2 !== typePropName && (_key2 !== labelPropName)) {
      newProps[_key2] = props[_key2];
    }
  }

  newProps.className = className;

  if (ref) {
    newProps.ref = ref;
  }

  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Insertion, {
    cache: cache,
    serialized: serialized,
    isStringTag: typeof WrappedComponent === 'string'
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(WrappedComponent, newProps));
});

{
  Emotion.displayName = 'EmotionCssPropInternal';
}

var Emotion$1 = Emotion;




/***/ }),

/***/ "./node_modules/@emotion/react/dist/emotion-react.browser.development.esm.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@emotion/react/dist/emotion-react.browser.development.esm.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CacheProvider: () => (/* reexport safe */ _emotion_element_489459f2_browser_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.C),
/* harmony export */   ClassNames: () => (/* binding */ ClassNames),
/* harmony export */   Global: () => (/* binding */ Global),
/* harmony export */   ThemeContext: () => (/* reexport safe */ _emotion_element_489459f2_browser_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.T),
/* harmony export */   ThemeProvider: () => (/* reexport safe */ _emotion_element_489459f2_browser_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.a),
/* harmony export */   __unsafe_useEmotionCache: () => (/* reexport safe */ _emotion_element_489459f2_browser_development_esm_js__WEBPACK_IMPORTED_MODULE_0__._),
/* harmony export */   createElement: () => (/* binding */ jsx),
/* harmony export */   css: () => (/* binding */ css),
/* harmony export */   jsx: () => (/* binding */ jsx),
/* harmony export */   keyframes: () => (/* binding */ keyframes),
/* harmony export */   useTheme: () => (/* reexport safe */ _emotion_element_489459f2_browser_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.u),
/* harmony export */   withEmotionCache: () => (/* reexport safe */ _emotion_element_489459f2_browser_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.w),
/* harmony export */   withTheme: () => (/* reexport safe */ _emotion_element_489459f2_browser_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)
/* harmony export */ });
/* harmony import */ var _emotion_element_489459f2_browser_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./emotion-element-489459f2.browser.development.esm.js */ "./node_modules/@emotion/react/dist/emotion-element-489459f2.browser.development.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _emotion_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @emotion/utils */ "./node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js");
/* harmony import */ var _emotion_use_insertion_effect_with_fallbacks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @emotion/use-insertion-effect-with-fallbacks */ "./node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js");
/* harmony import */ var _emotion_serialize__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @emotion/serialize */ "./node_modules/@emotion/serialize/dist/emotion-serialize.development.esm.js");
/* harmony import */ var _emotion_cache__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @emotion/cache */ "./node_modules/@emotion/cache/dist/emotion-cache.browser.development.esm.js");
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _emotion_weak_memoize__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @emotion/weak-memoize */ "./node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js");
/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! hoist-non-react-statics */ "./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js");
/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_8__);












var isDevelopment = true;

var pkg = {
	name: "@emotion/react",
	version: "11.14.0",
	main: "dist/emotion-react.cjs.js",
	module: "dist/emotion-react.esm.js",
	types: "dist/emotion-react.cjs.d.ts",
	exports: {
		".": {
			types: {
				"import": "./dist/emotion-react.cjs.mjs",
				"default": "./dist/emotion-react.cjs.js"
			},
			development: {
				"edge-light": {
					module: "./dist/emotion-react.development.edge-light.esm.js",
					"import": "./dist/emotion-react.development.edge-light.cjs.mjs",
					"default": "./dist/emotion-react.development.edge-light.cjs.js"
				},
				worker: {
					module: "./dist/emotion-react.development.edge-light.esm.js",
					"import": "./dist/emotion-react.development.edge-light.cjs.mjs",
					"default": "./dist/emotion-react.development.edge-light.cjs.js"
				},
				workerd: {
					module: "./dist/emotion-react.development.edge-light.esm.js",
					"import": "./dist/emotion-react.development.edge-light.cjs.mjs",
					"default": "./dist/emotion-react.development.edge-light.cjs.js"
				},
				browser: {
					module: "./dist/emotion-react.browser.development.esm.js",
					"import": "./dist/emotion-react.browser.development.cjs.mjs",
					"default": "./dist/emotion-react.browser.development.cjs.js"
				},
				module: "./dist/emotion-react.development.esm.js",
				"import": "./dist/emotion-react.development.cjs.mjs",
				"default": "./dist/emotion-react.development.cjs.js"
			},
			"edge-light": {
				module: "./dist/emotion-react.edge-light.esm.js",
				"import": "./dist/emotion-react.edge-light.cjs.mjs",
				"default": "./dist/emotion-react.edge-light.cjs.js"
			},
			worker: {
				module: "./dist/emotion-react.edge-light.esm.js",
				"import": "./dist/emotion-react.edge-light.cjs.mjs",
				"default": "./dist/emotion-react.edge-light.cjs.js"
			},
			workerd: {
				module: "./dist/emotion-react.edge-light.esm.js",
				"import": "./dist/emotion-react.edge-light.cjs.mjs",
				"default": "./dist/emotion-react.edge-light.cjs.js"
			},
			browser: {
				module: "./dist/emotion-react.browser.esm.js",
				"import": "./dist/emotion-react.browser.cjs.mjs",
				"default": "./dist/emotion-react.browser.cjs.js"
			},
			module: "./dist/emotion-react.esm.js",
			"import": "./dist/emotion-react.cjs.mjs",
			"default": "./dist/emotion-react.cjs.js"
		},
		"./jsx-runtime": {
			types: {
				"import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
				"default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
			},
			development: {
				"edge-light": {
					module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.esm.js",
					"import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.mjs",
					"default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.js"
				},
				worker: {
					module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.esm.js",
					"import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.mjs",
					"default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.js"
				},
				workerd: {
					module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.esm.js",
					"import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.mjs",
					"default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.js"
				},
				browser: {
					module: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.development.esm.js",
					"import": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.development.cjs.mjs",
					"default": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.development.cjs.js"
				},
				module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.esm.js",
				"import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.cjs.mjs",
				"default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.cjs.js"
			},
			"edge-light": {
				module: "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.esm.js",
				"import": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.mjs",
				"default": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.js"
			},
			worker: {
				module: "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.esm.js",
				"import": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.mjs",
				"default": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.js"
			},
			workerd: {
				module: "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.esm.js",
				"import": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.mjs",
				"default": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.js"
			},
			browser: {
				module: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
				"import": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.cjs.mjs",
				"default": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.cjs.js"
			},
			module: "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js",
			"import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
			"default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
		},
		"./_isolated-hnrs": {
			types: {
				"import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
				"default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
			},
			development: {
				"edge-light": {
					module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.esm.js",
					"import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.mjs",
					"default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.js"
				},
				worker: {
					module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.esm.js",
					"import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.mjs",
					"default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.js"
				},
				workerd: {
					module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.esm.js",
					"import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.mjs",
					"default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.js"
				},
				browser: {
					module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.esm.js",
					"import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.cjs.mjs",
					"default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.cjs.js"
				},
				module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.esm.js",
				"import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.cjs.mjs",
				"default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.cjs.js"
			},
			"edge-light": {
				module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.esm.js",
				"import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.mjs",
				"default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.js"
			},
			worker: {
				module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.esm.js",
				"import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.mjs",
				"default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.js"
			},
			workerd: {
				module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.esm.js",
				"import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.mjs",
				"default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.js"
			},
			browser: {
				module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
				"import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.cjs.mjs",
				"default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.cjs.js"
			},
			module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js",
			"import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
			"default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
		},
		"./jsx-dev-runtime": {
			types: {
				"import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
				"default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
			},
			development: {
				"edge-light": {
					module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.esm.js",
					"import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.mjs",
					"default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.js"
				},
				worker: {
					module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.esm.js",
					"import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.mjs",
					"default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.js"
				},
				workerd: {
					module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.esm.js",
					"import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.mjs",
					"default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.js"
				},
				browser: {
					module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.development.esm.js",
					"import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.development.cjs.mjs",
					"default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.development.cjs.js"
				},
				module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.esm.js",
				"import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.cjs.mjs",
				"default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.cjs.js"
			},
			"edge-light": {
				module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.esm.js",
				"import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.mjs",
				"default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.js"
			},
			worker: {
				module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.esm.js",
				"import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.mjs",
				"default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.js"
			},
			workerd: {
				module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.esm.js",
				"import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.mjs",
				"default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.js"
			},
			browser: {
				module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
				"import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.cjs.mjs",
				"default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.cjs.js"
			},
			module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js",
			"import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
			"default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
		},
		"./package.json": "./package.json",
		"./types/css-prop": "./types/css-prop.d.ts",
		"./macro": {
			types: {
				"import": "./macro.d.mts",
				"default": "./macro.d.ts"
			},
			"default": "./macro.js"
		}
	},
	imports: {
		"#is-development": {
			development: "./src/conditions/true.ts",
			"default": "./src/conditions/false.ts"
		},
		"#is-browser": {
			"edge-light": "./src/conditions/false.ts",
			workerd: "./src/conditions/false.ts",
			worker: "./src/conditions/false.ts",
			browser: "./src/conditions/true.ts",
			"default": "./src/conditions/is-browser.ts"
		}
	},
	files: [
		"src",
		"dist",
		"jsx-runtime",
		"jsx-dev-runtime",
		"_isolated-hnrs",
		"types/css-prop.d.ts",
		"macro.*"
	],
	sideEffects: false,
	author: "Emotion Contributors",
	license: "MIT",
	scripts: {
		"test:typescript": "dtslint types"
	},
	dependencies: {
		"@babel/runtime": "^7.18.3",
		"@emotion/babel-plugin": "^11.13.5",
		"@emotion/cache": "^11.14.0",
		"@emotion/serialize": "^1.3.3",
		"@emotion/use-insertion-effect-with-fallbacks": "^1.2.0",
		"@emotion/utils": "^1.4.2",
		"@emotion/weak-memoize": "^0.4.0",
		"hoist-non-react-statics": "^3.3.1"
	},
	peerDependencies: {
		react: ">=16.8.0"
	},
	peerDependenciesMeta: {
		"@types/react": {
			optional: true
		}
	},
	devDependencies: {
		"@definitelytyped/dtslint": "0.0.112",
		"@emotion/css": "11.13.5",
		"@emotion/css-prettifier": "1.2.0",
		"@emotion/server": "11.11.0",
		"@emotion/styled": "11.14.0",
		"@types/hoist-non-react-statics": "^3.3.5",
		"html-tag-names": "^1.1.2",
		react: "16.14.0",
		"svg-tag-names": "^1.1.1",
		typescript: "^5.4.5"
	},
	repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
	publishConfig: {
		access: "public"
	},
	"umd:main": "dist/emotion-react.umd.min.js",
	preconstruct: {
		entrypoints: [
			"./index.ts",
			"./jsx-runtime.ts",
			"./jsx-dev-runtime.ts",
			"./_isolated-hnrs.ts"
		],
		umdName: "emotionReact",
		exports: {
			extra: {
				"./types/css-prop": "./types/css-prop.d.ts",
				"./macro": {
					types: {
						"import": "./macro.d.mts",
						"default": "./macro.d.ts"
					},
					"default": "./macro.js"
				}
			}
		}
	}
};

var jsx = function jsx(type, props) {
  // eslint-disable-next-line prefer-rest-params
  var args = arguments;

  if (props == null || !_emotion_element_489459f2_browser_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.h.call(props, 'css')) {
    return react__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(undefined, args);
  }

  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = _emotion_element_489459f2_browser_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.E;
  createElementArgArray[1] = (0,_emotion_element_489459f2_browser_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(type, props);

  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  }

  return react__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(null, createElementArgArray);
};

(function (_jsx) {
  var JSX;

  (function (_JSX) {})(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
})(jsx || (jsx = {}));

var warnedAboutCssPropForGlobal = false; // maintain place over rerenders.
// initial render from browser, insertBefore context.sheet.tags[0] or if a style hasn't been inserted there yet, appendChild
// initial client-side render from SSR, use place of hydrating tag

var Global = /* #__PURE__ */(0,_emotion_element_489459f2_browser_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.w)(function (props, cache) {
  if (!warnedAboutCssPropForGlobal && ( // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // I don't really want to add it to the type since it shouldn't be used
  'className' in props && props.className || 'css' in props && props.css)) {
    console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
    warnedAboutCssPropForGlobal = true;
  }

  var styles = props.styles;
  var serialized = (0,_emotion_serialize__WEBPACK_IMPORTED_MODULE_4__.serializeStyles)([styles], undefined, react__WEBPACK_IMPORTED_MODULE_1__.useContext(_emotion_element_489459f2_browser_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.T));
  // but it is based on a constant that will never change at runtime
  // it's effectively like having two implementations and switching them out
  // so it's not actually breaking anything


  var sheetRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef();
  (0,_emotion_use_insertion_effect_with_fallbacks__WEBPACK_IMPORTED_MODULE_3__.useInsertionEffectWithLayoutFallback)(function () {
    var key = cache.key + "-global"; // use case of https://github.com/emotion-js/emotion/issues/2675

    var sheet = new cache.sheet.constructor({
      key: key,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false;
    var node = document.querySelector("style[data-emotion=\"" + key + " " + serialized.name + "\"]");

    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }

    if (node !== null) {
      rehydrating = true; // clear the hash so this node won't be recognizable as rehydratable by other <Global/>s

      node.setAttribute('data-emotion', key);
      sheet.hydrate([node]);
    }

    sheetRef.current = [sheet, rehydrating];
    return function () {
      sheet.flush();
    };
  }, [cache]);
  (0,_emotion_use_insertion_effect_with_fallbacks__WEBPACK_IMPORTED_MODULE_3__.useInsertionEffectWithLayoutFallback)(function () {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0],
        rehydrating = sheetRefCurrent[1];

    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }

    if (serialized.next !== undefined) {
      // insert keyframes
      (0,_emotion_utils__WEBPACK_IMPORTED_MODULE_2__.insertStyles)(cache, serialized.next, true);
    }

    if (sheet.tags.length) {
      // if this doesn't exist then it will be null so the style element will be appended
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }

    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});

{
  Global.displayName = 'EmotionGlobal';
}

function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (0,_emotion_serialize__WEBPACK_IMPORTED_MODULE_4__.serializeStyles)(args);
}

function keyframes() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name: name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}

var classnames = function classnames(args) {
  var len = args.length;
  var i = 0;
  var cls = '';

  for (; i < len; i++) {
    var arg = args[i];
    if (arg == null) continue;
    var toAdd = void 0;

    switch (typeof arg) {
      case 'boolean':
        break;

      case 'object':
        {
          if (Array.isArray(arg)) {
            toAdd = classnames(arg);
          } else {
            if (arg.styles !== undefined && arg.name !== undefined) {
              console.error('You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n' + '`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.');
            }

            toAdd = '';

            for (var k in arg) {
              if (arg[k] && k) {
                toAdd && (toAdd += ' ');
                toAdd += k;
              }
            }
          }

          break;
        }

      default:
        {
          toAdd = arg;
        }
    }

    if (toAdd) {
      cls && (cls += ' ');
      cls += toAdd;
    }
  }

  return cls;
};

function merge(registered, css, className) {
  var registeredStyles = [];
  var rawClassName = (0,_emotion_utils__WEBPACK_IMPORTED_MODULE_2__.getRegisteredStyles)(registered, registeredStyles, className);

  if (registeredStyles.length < 2) {
    return className;
  }

  return rawClassName + css(registeredStyles);
}

var Insertion = function Insertion(_ref) {
  var cache = _ref.cache,
      serializedArr = _ref.serializedArr;
  (0,_emotion_use_insertion_effect_with_fallbacks__WEBPACK_IMPORTED_MODULE_3__.useInsertionEffectAlwaysWithSyncFallback)(function () {

    for (var i = 0; i < serializedArr.length; i++) {
      (0,_emotion_utils__WEBPACK_IMPORTED_MODULE_2__.insertStyles)(cache, serializedArr[i], false);
    }
  });

  return null;
};

var ClassNames = /* #__PURE__ */(0,_emotion_element_489459f2_browser_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.w)(function (props, cache) {
  var hasRendered = false;
  var serializedArr = [];

  var css = function css() {
    if (hasRendered && isDevelopment) {
      throw new Error('css can only be used during render');
    }

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var serialized = (0,_emotion_serialize__WEBPACK_IMPORTED_MODULE_4__.serializeStyles)(args, cache.registered);
    serializedArr.push(serialized); // registration has to happen here as the result of this might get consumed by `cx`

    (0,_emotion_utils__WEBPACK_IMPORTED_MODULE_2__.registerStyles)(cache, serialized, false);
    return cache.key + "-" + serialized.name;
  };

  var cx = function cx() {
    if (hasRendered && isDevelopment) {
      throw new Error('cx can only be used during render');
    }

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return merge(cache.registered, css, classnames(args));
  };

  var content = {
    css: css,
    cx: cx,
    theme: react__WEBPACK_IMPORTED_MODULE_1__.useContext(_emotion_element_489459f2_browser_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.T)
  };
  var ele = props.children(content);
  hasRendered = true;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Insertion, {
    cache: cache,
    serializedArr: serializedArr
  }), ele);
});

{
  ClassNames.displayName = 'EmotionClassNames';
}

{
  var isBrowser = typeof document !== 'undefined'; // #1727, #2905 for some reason Jest and Vitest evaluate modules twice if some consuming module gets mocked

  var isTestEnv = typeof jest !== 'undefined' || typeof vi !== 'undefined';

  if (isBrowser && !isTestEnv) {
    // globalThis has wide browser support - https://caniuse.com/?search=globalThis, Node.js 12 and later
    var globalContext = typeof globalThis !== 'undefined' ? globalThis // eslint-disable-line no-undef
    : isBrowser ? window : __webpack_require__.g;
    var globalKey = "__EMOTION_REACT_" + pkg.version.split('.')[0] + "__";

    if (globalContext[globalKey]) {
      console.warn('You are loading @emotion/react when it is already loaded. Running ' + 'multiple instances may cause problems. This can happen if multiple ' + 'versions are used, or if multiple builds of the same version are ' + 'used.');
    }

    globalContext[globalKey] = true;
  }
}




/***/ }),

/***/ "./node_modules/@emotion/serialize/dist/emotion-serialize.development.esm.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@emotion/serialize/dist/emotion-serialize.development.esm.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   serializeStyles: () => (/* binding */ serializeStyles)
/* harmony export */ });
/* harmony import */ var _emotion_hash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @emotion/hash */ "./node_modules/@emotion/hash/dist/emotion-hash.esm.js");
/* harmony import */ var _emotion_unitless__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @emotion/unitless */ "./node_modules/@emotion/unitless/dist/emotion-unitless.esm.js");
/* harmony import */ var _emotion_memoize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @emotion/memoize */ "./node_modules/@emotion/memoize/dist/emotion-memoize.esm.js");




var isDevelopment = true;

var ILLEGAL_ESCAPE_SEQUENCE_ERROR = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;

var isCustomProperty = function isCustomProperty(property) {
  return property.charCodeAt(1) === 45;
};

var isProcessableValue = function isProcessableValue(value) {
  return value != null && typeof value !== 'boolean';
};

var processStyleName = /* #__PURE__ */(0,_emotion_memoize__WEBPACK_IMPORTED_MODULE_2__["default"])(function (styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
});

var processStyleValue = function processStyleValue(key, value) {
  switch (key) {
    case 'animation':
    case 'animationName':
      {
        if (typeof value === 'string') {
          return value.replace(animationRegex, function (match, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
  }

  if (_emotion_unitless__WEBPACK_IMPORTED_MODULE_1__["default"][key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
    return value + 'px';
  }

  return value;
};

{
  var contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
  var contentValues = ['normal', 'none', 'initial', 'inherit', 'unset'];
  var oldProcessStyleValue = processStyleValue;
  var msPattern = /^-ms-/;
  var hyphenPattern = /-(.)/g;
  var hyphenatedCache = {};

  processStyleValue = function processStyleValue(key, value) {
    if (key === 'content') {
      if (typeof value !== 'string' || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
      }
    }

    var processed = oldProcessStyleValue(key, value);

    if (processed !== '' && !isCustomProperty(key) && key.indexOf('-') !== -1 && hyphenatedCache[key] === undefined) {
      hyphenatedCache[key] = true;
      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, 'ms-').replace(hyphenPattern, function (str, _char) {
        return _char.toUpperCase();
      }) + "?");
    }

    return processed;
  };
}

var noComponentSelectorMessage = 'Component selectors can only be used in conjunction with ' + '@emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware ' + 'compiler transform.';

function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return '';
  }

  var componentSelector = interpolation;

  if (componentSelector.__emotion_styles !== undefined) {
    if (String(componentSelector) === 'NO_COMPONENT_SELECTOR') {
      throw new Error(noComponentSelectorMessage);
    }

    return componentSelector;
  }

  switch (typeof interpolation) {
    case 'boolean':
      {
        return '';
      }

    case 'object':
      {
        var keyframes = interpolation;

        if (keyframes.anim === 1) {
          cursor = {
            name: keyframes.name,
            styles: keyframes.styles,
            next: cursor
          };
          return keyframes.name;
        }

        var serializedStyles = interpolation;

        if (serializedStyles.styles !== undefined) {
          var next = serializedStyles.next;

          if (next !== undefined) {
            // not the most efficient thing ever but this is a pretty rare case
            // and there will be very few iterations of this generally
            while (next !== undefined) {
              cursor = {
                name: next.name,
                styles: next.styles,
                next: cursor
              };
              next = next.next;
            }
          }

          var styles = serializedStyles.styles + ";";
          return styles;
        }

        return createStringFromObject(mergedProps, registered, interpolation);
      }

    case 'function':
      {
        if (mergedProps !== undefined) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        } else {
          console.error('Functions that are interpolated in css calls will be stringified.\n' + 'If you want to have a css call based on props, create a function that returns a css call like this\n' + 'let dynamicStyle = (props) => css`color: ${props.color}`\n' + 'It can be called directly with props or interpolated in a styled call like this\n' + "let SomeComponent = styled('div')`${dynamicStyle}`");
        }

        break;
      }

    case 'string':
      {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function (_match, _p1, p2) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, '') + "`");
          return "${" + fakeVarName + "}";
        });

        if (matched.length) {
          console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join('\n') + "\n\nYou should wrap it with `css` like this:\n\ncss`" + replaced + "`");
        }
      }

      break;
  } // finalize string values (regular strings and functions interpolated into css calls)


  var asString = interpolation;

  if (registered == null) {
    return asString;
  }

  var cached = registered[asString];
  return cached !== undefined ? cached : asString;
}

function createStringFromObject(mergedProps, registered, obj) {
  var string = '';

  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var key in obj) {
      var value = obj[key];

      if (typeof value !== 'object') {
        var asString = value;

        if (registered != null && registered[asString] !== undefined) {
          string += key + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
        }
      } else {
        if (key === 'NO_COMPONENT_SELECTOR' && isDevelopment) {
          throw new Error(noComponentSelectorMessage);
        }

        if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);

          switch (key) {
            case 'animation':
            case 'animationName':
              {
                string += processStyleName(key) + ":" + interpolated + ";";
                break;
              }

            default:
              {
                if (key === 'undefined') {
                  console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
                }

                string += key + "{" + interpolated + "}";
              }
          }
        }
      }
    }
  }

  return string;
}

var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g; // this is the cursor for keyframes
// keyframes are stored on the SerializedStyles object as a linked list

var cursor;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
    return args[0];
  }

  var stringMode = true;
  var styles = '';
  cursor = undefined;
  var strings = args[0];

  if (strings == null || strings.raw === undefined) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;

    if (asTemplateStringsArr[0] === undefined) {
      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
    }

    styles += asTemplateStringsArr[0];
  } // we start at 1 since we've already handled the first arg


  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);

    if (stringMode) {
      var templateStringsArr = strings;

      if (templateStringsArr[i] === undefined) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }

      styles += templateStringsArr[i];
    }
  } // using a global regex with .exec is stateful so lastIndex has to be reset each time


  labelPattern.lastIndex = 0;
  var identifierName = '';
  var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

  while ((match = labelPattern.exec(styles)) !== null) {
    identifierName += '-' + match[1];
  }

  var name = (0,_emotion_hash__WEBPACK_IMPORTED_MODULE_0__["default"])(styles) + identifierName;

  {
    var devStyles = {
      name: name,
      styles: styles,
      next: cursor,
      toString: function toString() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    };
    return devStyles;
  }
}




/***/ }),

/***/ "./node_modules/@emotion/sheet/dist/emotion-sheet.development.esm.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@emotion/sheet/dist/emotion-sheet.development.esm.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StyleSheet: () => (/* binding */ StyleSheet)
/* harmony export */ });
var isDevelopment = true;

/*

Based off glamor's StyleSheet, thanks Sunil 

high performance StyleSheet for css-in-js systems

- uses multiple style tags behind the scenes for millions of rules
- uses `insertRule` for appending in production for *much* faster performance

// usage

import { StyleSheet } from '@emotion/sheet'

let styleSheet = new StyleSheet({ key: '', container: document.head })

styleSheet.insert('#box { border: 1px solid red; }')
- appends a css rule into the stylesheet

styleSheet.flush()
- empties the stylesheet of all its contents

*/

function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  } // this weirdness brought to you by firefox

  /* istanbul ignore next */


  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  } // this function should always return with a value
  // TS can't understand it though so we make it stop complaining here


  return undefined;
}

function createStyleElement(options) {
  var tag = document.createElement('style');
  tag.setAttribute('data-emotion', options.key);

  if (options.nonce !== undefined) {
    tag.setAttribute('nonce', options.nonce);
  }

  tag.appendChild(document.createTextNode(''));
  tag.setAttribute('data-s', '');
  return tag;
}

var StyleSheet = /*#__PURE__*/function () {
  // Using Node instead of HTMLElement since container may be a ShadowRoot
  function StyleSheet(options) {
    var _this = this;

    this._insertTag = function (tag) {
      var before;

      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }

      _this.container.insertBefore(tag, before);

      _this.tags.push(tag);
    };

    this.isSpeedy = options.speedy === undefined ? !isDevelopment : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }

  var _proto = StyleSheet.prototype;

  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };

  _proto.insert = function insert(rule) {
    // the max length is how many rules we have per style tag, it's 65000 in speedy mode
    // it's 1 in dev because we insert source maps that map a single rule to a location
    // and you can only have one source map per style tag
    if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }

    var tag = this.tags[this.tags.length - 1];

    {
      var isImportRule = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;

      if (isImportRule && this._alreadyInsertedOrderInsensitiveRule) {
        // this would only cause problem in speedy mode
        // but we don't want enabling speedy to affect the observable behavior
        // so we report this error at all times
        console.error("You're attempting to insert the following rule:\n" + rule + '\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.');
      }

      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule;
    }

    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);

      try {
        // this is the ultrafast version, works across browsers
        // the big drawback is that the css won't be editable in devtools
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
        if (!/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {
          console.error("There was a problem inserting the following rule: \"" + rule + "\"", e);
        }
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }

    this.ctr++;
  };

  _proto.flush = function flush() {
    this.tags.forEach(function (tag) {
      var _tag$parentNode;

      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;

    {
      this._alreadyInsertedOrderInsensitiveRule = false;
    }
  };

  return StyleSheet;
}();




/***/ }),

/***/ "./node_modules/@emotion/unitless/dist/emotion-unitless.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@emotion/unitless/dist/emotion-unitless.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ unitlessKeys)
/* harmony export */ });
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};




/***/ }),

/***/ "./node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useInsertionEffectAlwaysWithSyncFallback: () => (/* binding */ useInsertionEffectAlwaysWithSyncFallback),
/* harmony export */   useInsertionEffectWithLayoutFallback: () => (/* binding */ useInsertionEffectWithLayoutFallback)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);


var syncFallback = function syncFallback(create) {
  return create();
};

var useInsertionEffect = react__WEBPACK_IMPORTED_MODULE_0__['useInsertion' + 'Effect'] ? react__WEBPACK_IMPORTED_MODULE_0__['useInsertion' + 'Effect'] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;




/***/ }),

/***/ "./node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getRegisteredStyles: () => (/* binding */ getRegisteredStyles),
/* harmony export */   insertStyles: () => (/* binding */ insertStyles),
/* harmony export */   registerStyles: () => (/* binding */ registerStyles)
/* harmony export */ });
var isBrowser = true;

function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = '';
  classNames.split(' ').forEach(function (className) {
    if (registered[className] !== undefined) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;

  if ( // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (isStringTag === false || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  isBrowser === false ) && cache.registered[className] === undefined) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;

  if (cache.inserted[serialized.name] === undefined) {
    var current = serialized;

    do {
      cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);

      current = current.next;
    } while (current !== undefined);
  }
};




/***/ }),

/***/ "./node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ weakMemoize)
/* harmony export */ });
var weakMemoize = function weakMemoize(func) {
  var cache = new WeakMap();
  return function (arg) {
    if (cache.has(arg)) {
      // Use non-null assertion because we just checked that the cache `has` it
      // This allows us to remove `undefined` from the return value
      return cache.get(arg);
    }

    var ret = func(arg);
    cache.set(arg, ret);
    return ret;
  };
};




/***/ }),

/***/ "./node_modules/@floating-ui/core/dist/floating-ui.core.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@floating-ui/core/dist/floating-ui.core.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrow: () => (/* binding */ arrow),
/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),
/* harmony export */   computePosition: () => (/* binding */ computePosition),
/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),
/* harmony export */   flip: () => (/* binding */ flip),
/* harmony export */   hide: () => (/* binding */ hide),
/* harmony export */   inline: () => (/* binding */ inline),
/* harmony export */   limitShift: () => (/* binding */ limitShift),
/* harmony export */   offset: () => (/* binding */ offset),
/* harmony export */   rectToClientRect: () => (/* reexport safe */ _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect),
/* harmony export */   shift: () => (/* binding */ shift),
/* harmony export */   size: () => (/* binding */ size)
/* harmony export */ });
/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils */ "./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs");



function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);
  const alignmentAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);
  const alignLength = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(alignmentAxis);
  const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);
  const isVertical = sideAxis === 'y';
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case 'top':
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case 'bottom':
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case 'right':
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case 'left':
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement)) {
    case 'start':
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case 'end':
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */
const computePosition = async (reference, floating, config) => {
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === 'object') {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = 'clippingAncestors',
    rootBoundary = 'viewport',
    elementContext = 'floating',
    altBoundary = false,
    padding = 0
  } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);
  const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);
  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === 'floating' ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow = options => ({
  name: 'arrow',
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform,
      elements,
      middlewareData
    } = state;
    // Since `element` is required, we don't Partial<> the type.
    const {
      element,
      padding = 0
    } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);
    const coords = {
      x,
      y
    };
    const axis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);
    const length = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(axis);
    const arrowDimensions = await platform.getDimensions(element);
    const isYAxis = axis === 'y';
    const minProp = isYAxis ? 'top' : 'left';
    const maxProp = isYAxis ? 'bottom' : 'right';
    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;

    // DOM platform can return `window` as the `offsetParent`.
    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;

    // If the padding is large enough that it causes the arrow to no longer be
    // centered, modify the padding so that it is centered.
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[maxProp], largestPossiblePadding);

    // Make sure the arrow doesn't overflow the floating element if the center
    // point is outside the floating element's bounds.
    const min$1 = minPadding;
    const max = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min$1, center, max);

    // If the reference is small enough that the arrow's padding causes it to
    // to point to nothing for an aligned placement, adjust the offset of the
    // floating element itself. To ensure `shift()` continues to take action,
    // a single reset is performed when this is true.
    const shouldAddOffset = !middlewareData.arrow && (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset,
        centerOffset: center - offset - alignmentOffset,
        ...(shouldAddOffset && {
          alignmentOffset
        })
      },
      reset: shouldAddOffset
    };
  }
});

function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment), ...allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) !== alignment)] : allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter(placement => {
    if (alignment) {
      return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment || (autoAlignment ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAlignmentPlacement)(placement) !== placement : false);
    }
    return true;
  });
}
/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */
const autoPlacement = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'autoPlacement',
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform,
        elements
      } = state;
      const {
        crossAxis = false,
        alignment,
        allowedPlacements = _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);
      const placements$1 = alignment !== undefined || allowedPlacements === _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements$1[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const alignmentSides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));

      // Make `computeCoords` start from the right place.
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements$1[0]
          }
        };
      }
      const currentOverflows = [overflow[(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements$1[currentIndex + 1];

      // There are more placements to check.
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map(d => {
        const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d.placement);
        return [d.placement, alignment && crossAxis ?
        // Check along the mainAxis and main crossAxis side.
        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :
        // Check only the mainAxis.
        d.overflows[0], d.overflows];
      }).sort((a, b) => a[1] - b[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,
      // Aligned placements should not check their opposite crossAxis
      // side.
      (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d[0]) ? 2 : 3).every(v => v <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const flip = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'flip',
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = 'bestFit',
        fallbackAxisSideDirection = 'none',
        flipAlignment = true,
        ...detectOverflowOptions
      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);

      // If a reset by the arrow was caused due to an alignment offset being
      // added, we should skip any logic now since `flip()` has already done its
      // work.
      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);
      const initialSideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(initialPlacement);
      const isBasePlacement = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(initialPlacement) === initialPlacement;
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositePlacement)(initialPlacement)] : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getExpandedPlacements)(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxisPlacements)(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];

      // One or more sides is overflowing.
      if (!overflows.every(side => side <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          var _overflowsData$;
          const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(nextPlacement) : false;
          const hasInitialMainAxisOverflow = ((_overflowsData$ = overflowsData[0]) == null ? void 0 : _overflowsData$.overflows[0]) > 0;
          if (!ignoreCrossAxisOverflow || hasInitialMainAxisOverflow) {
            // Try next placement and re-run the lifecycle.
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }

        // First, find the candidates that fit on the mainAxis side of overflow,
        // then find the placement that fits the best on the main crossAxis side.
        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;

        // Otherwise fallback.
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case 'bestFit':
              {
                var _overflowsData$filter2;
                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(d.placement);
                    return currentSideAxis === initialSideAxis ||
                    // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === 'y';
                  }
                  return true;
                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement) {
                  resetPlacement = placement;
                }
                break;
              }
            case 'initialPlacement':
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};

function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.sides.some(side => overflow[side] >= 0);
}
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
const hide = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'hide',
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = 'referenceHidden',
        ...detectOverflowOptions
      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);
      switch (strategy) {
        case 'referenceHidden':
          {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              elementContext: 'reference'
            });
            const offsets = getSideOffsets(overflow, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets)
              }
            };
          }
        case 'escaped':
          {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              altBoundary: true
            });
            const offsets = getSideOffsets(overflow, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets)
              }
            };
          }
        default:
          {
            return {};
          }
      }
    }
  };
};

function getBoundingRect(rects) {
  const minX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map(rect => rect.left));
  const minY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map(rect => rect.top));
  const maxX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map(rect => rect.right));
  const maxY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map(rect => rect.bottom));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getRectsByLine(rects) {
  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);
  const groups = [];
  let prevRect = null;
  for (let i = 0; i < sortedRects.length; i++) {
    const rect = sortedRects[i];
    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
      groups.push([rect]);
    } else {
      groups[groups.length - 1].push(rect);
    }
    prevRect = rect;
  }
  return groups.map(rect => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(rect)));
}
/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */
const inline = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'inline',
    options,
    async fn(state) {
      const {
        placement,
        elements,
        rects,
        platform,
        strategy
      } = state;
      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a
      // ClientRect's bounds, despite the event listener being triggered. A
      // padding of 2 seems to handle this issue.
      const {
        padding = 2,
        x,
        y
      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);
      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);
      const clientRects = getRectsByLine(nativeClientRects);
      const fallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(nativeClientRects));
      const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);
      function getBoundingClientRect() {
        // There are two rects and they are disjoined.
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {
          // Find the first rect in which the point is fully inside.
          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
        }

        // There are 2 or more connected rects.
        if (clientRects.length >= 2) {
          if ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y') {
            const firstRect = clientRects[0];
            const lastRect = clientRects[clientRects.length - 1];
            const isTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === 'top';
            const top = firstRect.top;
            const bottom = lastRect.bottom;
            const left = isTop ? firstRect.left : lastRect.left;
            const right = isTop ? firstRect.right : lastRect.right;
            const width = right - left;
            const height = bottom - top;
            return {
              top,
              bottom,
              left,
              right,
              width,
              height,
              x: left,
              y: top
            };
          }
          const isLeftSide = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === 'left';
          const maxRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...clientRects.map(rect => rect.right));
          const minLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...clientRects.map(rect => rect.left));
          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
          const top = measureRects[0].top;
          const bottom = measureRects[measureRects.length - 1].bottom;
          const left = minLeft;
          const right = maxRight;
          const width = right - left;
          const height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform.getElementRects({
        reference: {
          getBoundingClientRect
        },
        floating: elements.floating,
        strategy
      });
      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
        return {
          reset: {
            rects: resetRects
          }
        };
      }
      return {};
    }
  };
};

// For type backwards-compatibility, the `OffsetOptions` type was also
// Derivable.

async function convertValueToCoords(state, options) {
  const {
    placement,
    platform,
    elements
  } = state;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
  const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);
  const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);
  const isVertical = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y';
  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);

  // eslint-disable-next-line prefer-const
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === 'number' ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === 'number') {
    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
const offset = function (options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: 'offset',
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);

      // If the placement is the same and the arrow caused an alignment offset
      // then we don't need to change the positioning coordinates.
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'shift',
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: _ref => {
            let {
              x,
              y
            } = _ref;
            return {
              x,
              y
            };
          }
        },
        ...detectOverflowOptions
      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));
      const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === 'y' ? 'top' : 'left';
        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
        const min = mainAxisCoord + overflow[minSide];
        const max = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, mainAxisCoord, max);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === 'y' ? 'top' : 'left';
        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
        const min = crossAxisCoord + overflow[minSide];
        const max = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, crossAxisCoord, max);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */
const limitShift = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);
      const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(offset, state);
      const computedOffset = typeof rawOffset === 'number' ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === 'y' ? 'height' : 'width';
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === 'y' ? 'width' : 'height';
        const isOriginSide = ['top', 'left'].includes((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};

/**
 * Provides data that allows you to change the size of the floating element 
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */
const size = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'size',
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform,
        elements
      } = state;
      const {
        apply = () => {},
        ...detectOverflowOptions
      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);
      const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);
      const isYAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y';
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === 'top' || side === 'bottom') {
        heightSide = side;
        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';
      } else {
        widthSide = side;
        heightSide = alignment === 'end' ? 'top' : 'bottom';
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, 0);
        const xMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.right, 0);
        const yMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, 0);
        const yMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};




/***/ }),

/***/ "./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrow: () => (/* binding */ arrow),
/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),
/* harmony export */   autoUpdate: () => (/* binding */ autoUpdate),
/* harmony export */   computePosition: () => (/* binding */ computePosition),
/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),
/* harmony export */   flip: () => (/* binding */ flip),
/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors),
/* harmony export */   hide: () => (/* binding */ hide),
/* harmony export */   inline: () => (/* binding */ inline),
/* harmony export */   limitShift: () => (/* binding */ limitShift),
/* harmony export */   offset: () => (/* binding */ offset),
/* harmony export */   platform: () => (/* binding */ platform),
/* harmony export */   shift: () => (/* binding */ shift),
/* harmony export */   size: () => (/* binding */ size)
/* harmony export */ });
/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/utils */ "./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs");
/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/core */ "./node_modules/@floating-ui/core/dist/floating-ui.core.mjs");
/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils/dom */ "./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs");





function getCssDimensions(element) {
  const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element);
  // In testing environments, the `width` and `height` properties are empty
  // strings for SVG elements, returning NaN. Fallback to `0` in this case.
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(width) !== offsetWidth || (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}

function unwrapElement(element) {
  return !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? element.contextElement : element;
}

function getScale(element) {
  const domElement = unwrapElement(element);
  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(domElement)) {
    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(rect.width) : rect.width) / width;
  let y = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(rect.height) : rect.height) / height;

  // 0, NaN, or Infinity should always fallback to 1.

  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}

const noOffsets = /*#__PURE__*/(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);
function getVisualOffsets(element) {
  const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);
  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isWebKit)() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element)) {
    return false;
  }
  return isFixed;
}

function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);
  if (includeScale) {
    if (offsetParent) {
      if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(domElement);
    const offsetWin = offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(offsetParent) ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getFrameElement)(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(currentIFrame);
      currentIFrame = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getFrameElement)(currentWin);
    }
  }
  return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.rectToClientRect)({
    width,
    height,
    x,
    y
  });
}

// If <html> has a CSS width greater than the viewport, then this will be
// incorrect for RTL.
function getWindowScrollBarX(element, rect) {
  const leftScroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}

function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :
  // RTL <body> scrollbar.
  getWindowScrollBarX(documentElement, htmlRect));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}

function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === 'fixed';
  const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(offsetParent);
  const topLayer = elements ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);
  const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);
  const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(offsetParent) !== 'body' || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(documentElement)) {
      scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(offsetParent);
    }
    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}

function getClientRects(element) {
  return Array.from(element.getClientRects());
}

// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable.
function getDocumentRect(element) {
  const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);
  const scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(element);
  const body = element.ownerDocument.body;
  const width = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(body).direction === 'rtl') {
    x += (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

function getViewportRect(element, strategy) {
  const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);
  const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isWebKit)();
    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}

// Returns the inner client rect, subtracting scrollbars if present.
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) ? getScale(element) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === 'viewport') {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === 'document') {
    rect = getDocumentRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element));
  } else if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.rectToClientRect)(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element);
  if (parentNode === stopNode || !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(parentNode) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(parentNode)) {
    return false;
  }
  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);
}

// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(element, [], false).filter(el => (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(el) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(el) !== 'body');
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === 'fixed';
  let currentNode = elementIsFixed ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element) : element;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  while ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(currentNode) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(currentNode)) {
    const computedStyle = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(currentNode);
    const currentNodeIsContaining = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isContainingBlock)(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      // Drop non-containing blocks.
      result = result.filter(ancestor => ancestor !== currentNode);
    } else {
      // Record last containing block for next iteration.
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(currentNode);
  }
  cache.set(element, result);
  return result;
}

// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors.
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === 'clippingAncestors' ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(rect.top, accRect.top);
    accRect.right = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(rect.right, accRect.right);
    accRect.bottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(rect.bottom, accRect.bottom);
    accRect.left = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}

function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}

function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent);
  const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(offsetParent);
  const isFixed = strategy === 'fixed';
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(offsetParent) !== 'body' || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(documentElement)) {
      scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      // If the <body> scrollbar appears on the left (e.g. RTL systems). Use
      // Firefox with layout.scrollbar.side = 3 in about:config to test this.
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}

function isStaticPositioned(element) {
  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === 'static';
}

function getTrueOffsetParent(element, polyfill) {
  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === 'fixed') {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;

  // Firefox returns the <html> element as the offsetParent if it's non-static,
  // while Chrome and Safari return the <body> element. The <body> element must
  // be used to perform the correct calculations even if the <html> element is
  // non-static.
  if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}

// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element, polyfill) {
  const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);
  if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(element)) {
    return win;
  }
  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {
    let svgOffsetParent = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element);
    while (svgOffsetParent && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(svgOffsetParent)) {
      if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTableElement)(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(offsetParent) && isStaticPositioned(offsetParent) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isContainingBlock)(offsetParent)) {
    return win;
  }
  return offsetParent || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getContainingBlock)(element) || win;
}

const getElementRects = async function (data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};

function isRTL(element) {
  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).direction === 'rtl';
}

const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement,
  isRTL
};

function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}

// https://samthor.au/2021/observing-dom/
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(top);
    const insetRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(root.clientWidth - (left + width));
    const insetBottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(root.clientHeight - (top + height));
    const insetLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(0, (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          // If the reference is clipped, the ratio is 0. Throttle the refresh
          // to prevent an infinite loop of updates.
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1000);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        // It's possible that even though the ratio is reported as 1, the
        // element is not actually fully within the IntersectionObserver's root
        // area anymore. This can happen under performance constraints. This may
        // be a bug in the browser's IntersectionObserver implementation. To
        // work around this, we compare the element's bounding rect now with
        // what it was at the time we created the IntersectionObserver. If they
        // are not equal then the element moved, so we refresh.
        refresh();
      }
      isFirstUpdate = false;
    }

    // Older browsers don't support a `document` as the root and will throw an
    // error.
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}

/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === 'function',
    layoutShift = typeof IntersectionObserver === 'function',
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(referenceEl) : []), ...(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(floating)] : [];
  ancestors.forEach(ancestor => {
    ancestorScroll && ancestor.addEventListener('scroll', update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener('resize', update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver(_ref => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        // Prevent update loops when using the `size` middleware.
        // https://github.com/floating-ui/floating-ui/issues/1740
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach(ancestor => {
      ancestorScroll && ancestor.removeEventListener('scroll', update);
      ancestorResize && ancestor.removeEventListener('resize', update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
const detectOverflow = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.detectOverflow;

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
const offset = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.offset;

/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */
const autoPlacement = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.autoPlacement;

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.shift;

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const flip = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.flip;

/**
 * Provides data that allows you to change the size of the floating element 
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */
const size = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.size;

/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
const hide = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.hide;

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.arrow;

/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */
const inline = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.inline;

/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */
const limitShift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.limitShift;

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 */
const computePosition = (reference, floating, options) => {
  // This caches the expensive `getClippingElementAncestors` function so that
  // multiple lifecycle resets re-use the same result. It only lives for a
  // single call. If other functions become expensive, we can add them as well.
  const cache = new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.computePosition)(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};




/***/ }),

/***/ "./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getComputedStyle: () => (/* binding */ getComputedStyle),
/* harmony export */   getContainingBlock: () => (/* binding */ getContainingBlock),
/* harmony export */   getDocumentElement: () => (/* binding */ getDocumentElement),
/* harmony export */   getFrameElement: () => (/* binding */ getFrameElement),
/* harmony export */   getNearestOverflowAncestor: () => (/* binding */ getNearestOverflowAncestor),
/* harmony export */   getNodeName: () => (/* binding */ getNodeName),
/* harmony export */   getNodeScroll: () => (/* binding */ getNodeScroll),
/* harmony export */   getOverflowAncestors: () => (/* binding */ getOverflowAncestors),
/* harmony export */   getParentNode: () => (/* binding */ getParentNode),
/* harmony export */   getWindow: () => (/* binding */ getWindow),
/* harmony export */   isContainingBlock: () => (/* binding */ isContainingBlock),
/* harmony export */   isElement: () => (/* binding */ isElement),
/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),
/* harmony export */   isLastTraversableNode: () => (/* binding */ isLastTraversableNode),
/* harmony export */   isNode: () => (/* binding */ isNode),
/* harmony export */   isOverflowElement: () => (/* binding */ isOverflowElement),
/* harmony export */   isShadowRoot: () => (/* binding */ isShadowRoot),
/* harmony export */   isTableElement: () => (/* binding */ isTableElement),
/* harmony export */   isTopLayer: () => (/* binding */ isTopLayer),
/* harmony export */   isWebKit: () => (/* binding */ isWebKit)
/* harmony export */ });
function hasWindow() {
  return typeof window !== 'undefined';
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || '').toLowerCase();
  }
  // Mocked nodes in testing environments may not be instances of Node. By
  // returning `#document` an infinite loop won't occur.
  // https://github.com/floating-ui/floating-ui/issues/2317
  return '#document';
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === 'undefined') {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
}
function isTableElement(element) {
  return ['table', 'td', 'th'].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [':popover-open', ':modal'].some(selector => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  // https://drafts.csswg.org/css-transforms-2/#individual-transforms
  return ['transform', 'translate', 'scale', 'rotate', 'perspective'].some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === 'undefined' || !CSS.supports) return false;
  return CSS.supports('-webkit-backdrop-filter', 'none');
}
function isLastTraversableNode(node) {
  return ['html', 'body', '#document'].includes(getNodeName(node));
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }
  const result =
  // Step into the shadow DOM of the parent of a slotted node.
  node.assignedSlot ||
  // DOM Element detected.
  node.parentNode ||
  // ShadowRoot detected.
  isShadowRoot(node) && node.host ||
  // Fallback.
  getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}




/***/ }),

/***/ "./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   alignments: () => (/* binding */ alignments),
/* harmony export */   clamp: () => (/* binding */ clamp),
/* harmony export */   createCoords: () => (/* binding */ createCoords),
/* harmony export */   evaluate: () => (/* binding */ evaluate),
/* harmony export */   expandPaddingObject: () => (/* binding */ expandPaddingObject),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   getAlignment: () => (/* binding */ getAlignment),
/* harmony export */   getAlignmentAxis: () => (/* binding */ getAlignmentAxis),
/* harmony export */   getAlignmentSides: () => (/* binding */ getAlignmentSides),
/* harmony export */   getAxisLength: () => (/* binding */ getAxisLength),
/* harmony export */   getExpandedPlacements: () => (/* binding */ getExpandedPlacements),
/* harmony export */   getOppositeAlignmentPlacement: () => (/* binding */ getOppositeAlignmentPlacement),
/* harmony export */   getOppositeAxis: () => (/* binding */ getOppositeAxis),
/* harmony export */   getOppositeAxisPlacements: () => (/* binding */ getOppositeAxisPlacements),
/* harmony export */   getOppositePlacement: () => (/* binding */ getOppositePlacement),
/* harmony export */   getPaddingObject: () => (/* binding */ getPaddingObject),
/* harmony export */   getSide: () => (/* binding */ getSide),
/* harmony export */   getSideAxis: () => (/* binding */ getSideAxis),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   placements: () => (/* binding */ placements),
/* harmony export */   rectToClientRect: () => (/* binding */ rectToClientRect),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   sides: () => (/* binding */ sides)
/* harmony export */ });
/**
 * Custom positioning reference element.
 * @see https://floating-ui.com/docs/virtual-elements
 */

const sides = ['top', 'right', 'bottom', 'left'];
const alignments = ['start', 'end'];
const placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = v => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
const oppositeAlignmentMap = {
  start: 'end',
  end: 'start'
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === 'function' ? value(param) : value;
}
function getSide(placement) {
  return placement.split('-')[0];
}
function getAlignment(placement) {
  return placement.split('-')[1];
}
function getOppositeAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}
function getAxisLength(axis) {
  return axis === 'y' ? 'height' : 'width';
}
function getSideAxis(placement) {
  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ['left', 'right'];
  const rl = ['right', 'left'];
  const tb = ['top', 'bottom'];
  const bt = ['bottom', 'top'];
  switch (side) {
    case 'top':
    case 'bottom':
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case 'left':
    case 'right':
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === 'start', rtl);
  if (alignment) {
    list = list.map(side => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}




/***/ }),

/***/ "./node_modules/@internationalized/number/dist/NumberFormatter.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@internationalized/number/dist/NumberFormatter.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NumberFormatter: () => (/* binding */ $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5),
/* harmony export */   numberFormatSignDisplayPolyfill: () => (/* binding */ $488c6ddbf4ef74c2$export$711b50b3c525e0f2)
/* harmony export */ });
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ let $488c6ddbf4ef74c2$var$formatterCache = new Map();
let $488c6ddbf4ef74c2$var$supportsSignDisplay = false;
try {
    $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat('de-DE', {
        signDisplay: 'exceptZero'
    }).resolvedOptions().signDisplay === 'exceptZero';
// eslint-disable-next-line no-empty
} catch  {}
let $488c6ddbf4ef74c2$var$supportsUnit = false;
try {
    $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat('de-DE', {
        style: 'unit',
        unit: 'degree'
    }).resolvedOptions().style === 'unit';
// eslint-disable-next-line no-empty
} catch  {}
// Polyfill for units since Safari doesn't support them yet. See https://bugs.webkit.org/show_bug.cgi?id=215438.
// Currently only polyfilling the unit degree in narrow format for ColorSlider in our supported locales.
// Values were determined by switching to each locale manually in Chrome.
const $488c6ddbf4ef74c2$var$UNITS = {
    degree: {
        narrow: {
            default: "\xb0",
            'ja-JP': " \u5EA6",
            'zh-TW': "\u5EA6",
            'sl-SI': " \xb0"
        }
    }
};
class $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 {
    /** Formats a number value as a string, according to the locale and options provided to the constructor. */ format(value) {
        let res = '';
        if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);
        else res = this.numberFormatter.format(value);
        if (this.options.style === 'unit' && !$488c6ddbf4ef74c2$var$supportsUnit) {
            var _UNITS_unit;
            let { unit: unit, unitDisplay: unitDisplay = 'short', locale: locale } = this.resolvedOptions();
            if (!unit) return res;
            let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];
            res += values[locale] || values.default;
        }
        return res;
    }
    /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */ formatToParts(value) {
        // TODO: implement signDisplay for formatToParts
        return this.numberFormatter.formatToParts(value);
    }
    /** Formats a number range as a string. */ formatRange(start, end) {
        if (typeof this.numberFormatter.formatRange === 'function') return this.numberFormatter.formatRange(start, end);
        if (end < start) throw new RangeError('End date must be >= start date');
        // Very basic fallback for old browsers.
        return `${this.format(start)} \u{2013} ${this.format(end)}`;
    }
    /** Formats a number range as an array of parts. */ formatRangeToParts(start, end) {
        if (typeof this.numberFormatter.formatRangeToParts === 'function') return this.numberFormatter.formatRangeToParts(start, end);
        if (end < start) throw new RangeError('End date must be >= start date');
        let startParts = this.numberFormatter.formatToParts(start);
        let endParts = this.numberFormatter.formatToParts(end);
        return [
            ...startParts.map((p)=>({
                    ...p,
                    source: 'startRange'
                })),
            {
                type: 'literal',
                value: " \u2013 ",
                source: 'shared'
            },
            ...endParts.map((p)=>({
                    ...p,
                    source: 'endRange'
                }))
        ];
    }
    /** Returns the resolved formatting options based on the values passed to the constructor. */ resolvedOptions() {
        let options = this.numberFormatter.resolvedOptions();
        if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = {
            ...options,
            signDisplay: this.options.signDisplay
        };
        if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === 'unit') options = {
            ...options,
            style: 'unit',
            unit: this.options.unit,
            unitDisplay: this.options.unitDisplay
        };
        return options;
    }
    constructor(locale, options = {}){
        this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);
        this.options = options;
    }
}
function $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {
    let { numberingSystem: numberingSystem } = options;
    if (numberingSystem && locale.includes('-nu-')) {
        if (!locale.includes('-u-')) locale += '-u-';
        locale += `-nu-${numberingSystem}`;
    }
    if (options.style === 'unit' && !$488c6ddbf4ef74c2$var$supportsUnit) {
        var _UNITS_unit;
        let { unit: unit, unitDisplay: unitDisplay = 'short' } = options;
        if (!unit) throw new Error('unit option must be provided with style: "unit"');
        if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);
        options = {
            ...options,
            style: 'decimal'
        };
    }
    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : '');
    if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);
    let numberFormatter = new Intl.NumberFormat(locale, options);
    $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);
    return numberFormatter;
}
function $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {
    if (signDisplay === 'auto') return numberFormat.format(num);
    else if (signDisplay === 'never') return numberFormat.format(Math.abs(num));
    else {
        let needsPositiveSign = false;
        if (signDisplay === 'always') needsPositiveSign = num > 0 || Object.is(num, 0);
        else if (signDisplay === 'exceptZero') {
            if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);
            else needsPositiveSign = num > 0;
        }
        if (needsPositiveSign) {
            let negative = numberFormat.format(-num);
            let noSign = numberFormat.format(num);
            // ignore RTL/LTR marker character
            let minus = negative.replace(noSign, '').replace(/\u200e|\u061C/, '');
            if ([
                ...minus
            ].length !== 1) console.warn('@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case');
            let positive = negative.replace(noSign, '!!!').replace(minus, '+').replace('!!!', noSign);
            return positive;
        } else return numberFormat.format(num);
    }
}



//# sourceMappingURL=NumberFormatter.module.js.map


/***/ }),

/***/ "./node_modules/@internationalized/number/dist/NumberParser.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@internationalized/number/dist/NumberParser.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NumberParser: () => (/* binding */ $6c7bd7858deea686$export$cd11ab140839f11d)
/* harmony export */ });
/* harmony import */ var _NumberFormatter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NumberFormatter.mjs */ "./node_modules/@internationalized/number/dist/NumberFormatter.mjs");


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp('^.*\\(.*\\).*$');
const $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [
    'latn',
    'arab',
    'hanidec',
    'deva',
    'beng'
];
class $6c7bd7858deea686$export$cd11ab140839f11d {
    /**
   * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
   */ parse(value) {
        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);
    }
    /**
   * Returns whether the given string could potentially be a valid number. This should be used to
   * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
   * of the minus/plus sign characters can be checked.
   */ isValidPartialNumber(value, minValue, maxValue) {
        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);
    }
    /**
   * Returns a numbering system for which the given string is valid in the current locale.
   * If no numbering system could be detected, the default numbering system for the current
   * locale is returned.
   */ getNumberingSystem(value) {
        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;
    }
    constructor(locale, options = {}){
        this.locale = locale;
        this.options = options;
    }
}
const $6c7bd7858deea686$var$numberParserCache = new Map();
function $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {
    // First try the default numbering system for the provided locale
    let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);
    // If that doesn't match, and the locale doesn't include a hard coded numbering system,
    // try each of the other supported numbering systems until we find one that matches.
    if (!locale.includes('-nu-') && !defaultParser.isValidPartialNumber(value)) {
        for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS)if (numberingSystem !== defaultParser.options.numberingSystem) {
            let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes('-u-') ? '-nu-' : '-u-nu-') + numberingSystem, options);
            if (parser.isValidPartialNumber(value)) return parser;
        }
    }
    return defaultParser;
}
function $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {
    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : '');
    let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);
    if (!parser) {
        parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);
        $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);
    }
    return parser;
}
// The actual number parser implementation. Instances of this class are cached
// based on the locale, options, and detected numbering system.
class $6c7bd7858deea686$var$NumberParserImpl {
    parse(value) {
        // to parse the number, we need to remove anything that isn't actually part of the number, for example we want '-10.40' not '-10.40 USD'
        let fullySanitizedValue = this.sanitize(value);
        if (this.symbols.group) // Remove group characters, and replace decimal points and numerals with ASCII values.
        fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, '');
        if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, '.');
        if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, '-');
        fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);
        if (this.options.style === 'percent') {
            // javascript is bad at dividing by 100 and maintaining the same significant figures, so perform it on the string before parsing
            let isNegative = fullySanitizedValue.indexOf('-');
            fullySanitizedValue = fullySanitizedValue.replace('-', '');
            let index = fullySanitizedValue.indexOf('.');
            if (index === -1) index = fullySanitizedValue.length;
            fullySanitizedValue = fullySanitizedValue.replace('.', '');
            if (index - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;
            else if (index - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;
            else if (index - 2 === -2) fullySanitizedValue = '0.00';
            else fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;
            if (isNegative > -1) fullySanitizedValue = `-${fullySanitizedValue}`;
        }
        let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
        if (isNaN(newValue)) return NaN;
        if (this.options.style === 'percent') {
            var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
            // extra step for rounding percents to what our formatter would output
            let options = {
                ...this.options,
                style: 'decimal',
                minimumFractionDigits: Math.min(((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) + 2, 20),
                maximumFractionDigits: Math.min(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2, 20)
            };
            return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new (0, _NumberFormatter_mjs__WEBPACK_IMPORTED_MODULE_0__.NumberFormatter)(this.locale, options).format(newValue));
        }
        // accounting will always be stripped to a positive number, so if it's accounting and has a () around everything, then we need to make it negative again
        if (this.options.currencySign === 'accounting' && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;
        return newValue;
    }
    sanitize(value) {
        // Remove literals and whitespace, which are allowed anywhere in the string
        value = value.replace(this.symbols.literals, '');
        // Replace the ASCII minus sign with the minus sign used in the current locale
        // so that both are allowed in case the user's keyboard doesn't have the locale's minus sign.
        if (this.symbols.minusSign) value = value.replace('-', this.symbols.minusSign);
        // In arab numeral system, their decimal character is 1643, but most keyboards don't type that
        // instead they use the , (44) character or apparently the (1548) character.
        if (this.options.numberingSystem === 'arab') {
            if (this.symbols.decimal) {
                value = value.replace(',', this.symbols.decimal);
                value = value.replace(String.fromCharCode(1548), this.symbols.decimal);
            }
            if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, '.', this.symbols.group);
        }
        // fr-FR group character is narrow non-breaking space, char code 8239 (U+202F), but that's not a key on the french keyboard,
        // so allow space and non-breaking space as a group char as well
        if (this.options.locale === 'fr-FR' && this.symbols.group) {
            value = $6c7bd7858deea686$var$replaceAll(value, ' ', this.symbols.group);
            value = $6c7bd7858deea686$var$replaceAll(value, /\u00A0/g, this.symbols.group);
        }
        return value;
    }
    isValidPartialNumber(value, minValue = -Infinity, maxValue = Infinity) {
        value = this.sanitize(value);
        // Remove minus or plus sign, which must be at the start of the string.
        if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);
        else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) value = value.slice(this.symbols.plusSign.length);
        // Numbers cannot start with a group separator
        if (this.symbols.group && value.startsWith(this.symbols.group)) return false;
        // Numbers that can't have any decimal values fail if a decimal character is typed
        if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;
        // Remove numerals, groups, and decimals
        if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, '');
        value = value.replace(this.symbols.numeral, '');
        if (this.symbols.decimal) value = value.replace(this.symbols.decimal, '');
        // The number is valid if there are no remaining characters
        return value.length === 0;
    }
    constructor(locale, options = {}){
        this.locale = locale;
        this.formatter = new Intl.NumberFormat(locale, options);
        this.options = this.formatter.resolvedOptions();
        this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);
        var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
        if (this.options.style === 'percent' && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn('NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.');
    }
}
const $6c7bd7858deea686$var$nonLiteralParts = new Set([
    'decimal',
    'fraction',
    'integer',
    'minusSign',
    'plusSign',
    'group'
]);
// This list is derived from https://www.unicode.org/cldr/charts/43/supplemental/language_plural_rules.html#comparison and includes
// all unique numbers which we need to check in order to determine all the plural forms for a given locale.
// See: https://github.com/adobe/react-spectrum/pull/5134/files#r1337037855 for used script
const $6c7bd7858deea686$var$pluralNumbers = [
    0,
    4,
    2,
    1,
    11,
    20,
    3,
    7,
    100,
    21,
    0.1,
    1.1
];
function $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {
    var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;
    // formatter needs access to all decimal places in order to generate the correct literal strings for the plural set
    let symbolFormatter = new Intl.NumberFormat(locale, {
        ...intlOptions,
        // Resets so we get the full range of symbols
        minimumSignificantDigits: 1,
        maximumSignificantDigits: 21,
        roundingIncrement: 1,
        roundingPriority: 'auto',
        roundingMode: 'halfExpand'
    });
    // Note: some locale's don't add a group symbol until there is a ten thousands place
    let allParts = symbolFormatter.formatToParts(-10000.111);
    let posAllParts = symbolFormatter.formatToParts(10000.111);
    let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n)=>symbolFormatter.formatToParts(n));
    var _allParts_find_value;
    let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p)=>p.type === 'minusSign')) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : '-';
    let plusSign = (_posAllParts_find = posAllParts.find((p)=>p.type === 'plusSign')) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;
    // Safari does not support the signDisplay option, but our number parser polyfills it.
    // If no plus sign was returned, but the original options contained signDisplay, default to the '+' character.
    if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === 'exceptZero' || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === 'always')) plusSign = '+';
    // If maximumSignificantDigits is 1 (the minimum) then we won't get decimal characters out of the above formatters
    // Percent also defaults to 0 fractionDigits, so we need to make a new one that isn't percent to get an accurate decimal
    let decimalParts = new Intl.NumberFormat(locale, {
        ...intlOptions,
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    }).formatToParts(0.001);
    let decimal = (_decimalParts_find = decimalParts.find((p)=>p.type === 'decimal')) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;
    let group = (_allParts_find1 = allParts.find((p)=>p.type === 'group')) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;
    // this set is also for a regex, it's all literals that might be in the string we want to eventually parse that
    // don't contribute to the numerical value
    let allPartsLiterals = allParts.filter((p)=>!$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p)=>$6c7bd7858deea686$var$escapeRegex(p.value));
    let pluralPartsLiterals = pluralParts.flatMap((p)=>p.filter((p)=>!$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p)=>$6c7bd7858deea686$var$escapeRegex(p.value)));
    let sortedLiterals = [
        ...new Set([
            ...allPartsLiterals,
            ...pluralPartsLiterals
        ])
    ].sort((a, b)=>b.length - a.length);
    let literals = sortedLiterals.length === 0 ? new RegExp('[\\p{White_Space}]', 'gu') : new RegExp(`${sortedLiterals.join('|')}|[\\p{White_Space}]`, 'gu');
    // These are for replacing non-latn characters with the latn equivalent
    let numerals = [
        ...new Intl.NumberFormat(intlOptions.locale, {
            useGrouping: false
        }).format(9876543210)
    ].reverse();
    let indexes = new Map(numerals.map((d, i)=>[
            d,
            i
        ]));
    let numeral = new RegExp(`[${numerals.join('')}]`, 'g');
    let index = (d)=>String(indexes.get(d));
    return {
        minusSign: minusSign,
        plusSign: plusSign,
        decimal: decimal,
        group: group,
        literals: literals,
        numeral: numeral,
        index: index
    };
}
function $6c7bd7858deea686$var$replaceAll(str, find, replace) {
    if (str.replaceAll) return str.replaceAll(find, replace);
    return str.split(find).join(replace);
}
function $6c7bd7858deea686$var$escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}



//# sourceMappingURL=NumberParser.module.js.map


/***/ }),

/***/ "./node_modules/@pandacss/is-valid-prop/dist/index.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@pandacss/is-valid-prop/dist/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   allCssProperties: () => (/* binding */ allCssProperties),
/* harmony export */   isCssProperty: () => (/* binding */ isCssProperty)
/* harmony export */ });
// src/index.ts
var userGeneratedStr = "";
var userGenerated = userGeneratedStr.split(",");
var cssPropertiesStr = "WebkitAppearance,WebkitBorderBefore,WebkitBorderBeforeColor,WebkitBorderBeforeStyle,WebkitBorderBeforeWidth,WebkitBoxReflect,WebkitLineClamp,WebkitMask,WebkitMaskAttachment,WebkitMaskClip,WebkitMaskComposite,WebkitMaskImage,WebkitMaskOrigin,WebkitMaskPosition,WebkitMaskPositionX,WebkitMaskPositionY,WebkitMaskRepeat,WebkitMaskRepeatX,WebkitMaskRepeatY,WebkitMaskSize,WebkitOverflowScrolling,WebkitTapHighlightColor,WebkitTextFillColor,WebkitTextStroke,WebkitTextStrokeColor,WebkitTextStrokeWidth,WebkitTouchCallout,WebkitUserModify,WebkitUserSelect,accentColor,alignContent,alignItems,alignSelf,alignTracks,all,anchorName,anchorScope,animation,animationComposition,animationDelay,animationDirection,animationDuration,animationFillMode,animationIterationCount,animationName,animationPlayState,animationRange,animationRangeEnd,animationRangeStart,animationTimeline,animationTimingFunction,appearance,aspectRatio,backdropFilter,backfaceVisibility,background,backgroundAttachment,backgroundBlendMode,backgroundClip,backgroundColor,backgroundImage,backgroundOrigin,backgroundPosition,backgroundPositionX,backgroundPositionY,backgroundRepeat,backgroundSize,blockSize,border,borderBlock,borderBlockColor,borderBlockEnd,borderBlockEndColor,borderBlockEndStyle,borderBlockEndWidth,borderBlockStart,borderBlockStartColor,borderBlockStartStyle,borderBlockStartWidth,borderBlockStyle,borderBlockWidth,borderBottom,borderBottomColor,borderBottomLeftRadius,borderBottomRightRadius,borderBottomStyle,borderBottomWidth,borderCollapse,borderColor,borderEndEndRadius,borderEndStartRadius,borderImage,borderImageOutset,borderImageRepeat,borderImageSlice,borderImageSource,borderImageWidth,borderInline,borderInlineColor,borderInlineEnd,borderInlineEndColor,borderInlineEndStyle,borderInlineEndWidth,borderInlineStart,borderInlineStartColor,borderInlineStartStyle,borderInlineStartWidth,borderInlineStyle,borderInlineWidth,borderLeft,borderLeftColor,borderLeftStyle,borderLeftWidth,borderRadius,borderRight,borderRightColor,borderRightStyle,borderRightWidth,borderSpacing,borderStartEndRadius,borderStartStartRadius,borderStyle,borderTop,borderTopColor,borderTopLeftRadius,borderTopRightRadius,borderTopStyle,borderTopWidth,borderWidth,bottom,boxAlign,boxDecorationBreak,boxDirection,boxFlex,boxFlexGroup,boxLines,boxOrdinalGroup,boxOrient,boxPack,boxShadow,boxSizing,breakAfter,breakBefore,breakInside,captionSide,caret,caretColor,caretShape,clear,clip,clipPath,clipRule,color,colorInterpolationFilters,colorScheme,columnCount,columnFill,columnGap,columnRule,columnRuleColor,columnRuleStyle,columnRuleWidth,columnSpan,columnWidth,columns,contain,containIntrinsicBlockSize,containIntrinsicHeight,containIntrinsicInlineSize,containIntrinsicSize,containIntrinsicWidth,container,containerName,containerType,content,contentVisibility,counterIncrement,counterReset,counterSet,cursor,cx,cy,d,direction,display,dominantBaseline,emptyCells,fieldSizing,fill,fillOpacity,fillRule,filter,flex,flexBasis,flexDirection,flexFlow,flexGrow,flexShrink,flexWrap,float,floodColor,floodOpacity,font,fontFamily,fontFeatureSettings,fontKerning,fontLanguageOverride,fontOpticalSizing,fontPalette,fontSize,fontSizeAdjust,fontSmooth,fontStretch,fontStyle,fontSynthesis,fontSynthesisPosition,fontSynthesisSmallCaps,fontSynthesisStyle,fontSynthesisWeight,fontVariant,fontVariantAlternates,fontVariantCaps,fontVariantEastAsian,fontVariantEmoji,fontVariantLigatures,fontVariantNumeric,fontVariantPosition,fontVariationSettings,fontWeight,forcedColorAdjust,gap,grid,gridArea,gridAutoColumns,gridAutoFlow,gridAutoRows,gridColumn,gridColumnEnd,gridColumnGap,gridColumnStart,gridGap,gridRow,gridRowEnd,gridRowGap,gridRowStart,gridTemplate,gridTemplateAreas,gridTemplateColumns,gridTemplateRows,hangingPunctuation,height,hyphenateCharacter,hyphenateLimitChars,hyphens,imageOrientation,imageRendering,imageResolution,imeMode,initialLetter,initialLetterAlign,inlineSize,inset,insetBlock,insetBlockEnd,insetBlockStart,insetInline,insetInlineEnd,insetInlineStart,interpolateSize,isolation,justifyContent,justifyItems,justifySelf,justifyTracks,left,letterSpacing,lightingColor,lineBreak,lineClamp,lineHeight,lineHeightStep,listStyle,listStyleImage,listStylePosition,listStyleType,margin,marginBlock,marginBlockEnd,marginBlockStart,marginBottom,marginInline,marginInlineEnd,marginInlineStart,marginLeft,marginRight,marginTop,marginTrim,marker,markerEnd,markerMid,markerStart,mask,maskBorder,maskBorderMode,maskBorderOutset,maskBorderRepeat,maskBorderSlice,maskBorderSource,maskBorderWidth,maskClip,maskComposite,maskImage,maskMode,maskOrigin,maskPosition,maskRepeat,maskSize,maskType,masonryAutoFlow,mathDepth,mathShift,mathStyle,maxBlockSize,maxHeight,maxInlineSize,maxLines,maxWidth,minBlockSize,minHeight,minInlineSize,minWidth,mixBlendMode,objectFit,objectPosition,offset,offsetAnchor,offsetDistance,offsetPath,offsetPosition,offsetRotate,opacity,order,orphans,outline,outlineColor,outlineOffset,outlineStyle,outlineWidth,overflow,overflowAnchor,overflowBlock,overflowClipBox,overflowClipMargin,overflowInline,overflowWrap,overflowX,overflowY,overlay,overscrollBehavior,overscrollBehaviorBlock,overscrollBehaviorInline,overscrollBehaviorX,overscrollBehaviorY,padding,paddingBlock,paddingBlockEnd,paddingBlockStart,paddingBottom,paddingInline,paddingInlineEnd,paddingInlineStart,paddingLeft,paddingRight,paddingTop,page,pageBreakAfter,pageBreakBefore,pageBreakInside,paintOrder,perspective,perspectiveOrigin,placeContent,placeItems,placeSelf,pointerEvents,position,positionAnchor,positionArea,positionTry,positionTryFallbacks,positionTryOrder,positionVisibility,printColorAdjust,quotes,r,resize,right,rotate,rowGap,rubyAlign,rubyMerge,rubyPosition,rx,ry,scale,scrollBehavior,scrollMargin,scrollMarginBlock,scrollMarginBlockEnd,scrollMarginBlockStart,scrollMarginBottom,scrollMarginInline,scrollMarginInlineEnd,scrollMarginInlineStart,scrollMarginLeft,scrollMarginRight,scrollMarginTop,scrollPadding,scrollPaddingBlock,scrollPaddingBlockEnd,scrollPaddingBlockStart,scrollPaddingBottom,scrollPaddingInline,scrollPaddingInlineEnd,scrollPaddingInlineStart,scrollPaddingLeft,scrollPaddingRight,scrollPaddingTop,scrollSnapAlign,scrollSnapCoordinate,scrollSnapDestination,scrollSnapPointsX,scrollSnapPointsY,scrollSnapStop,scrollSnapType,scrollSnapTypeX,scrollSnapTypeY,scrollTimeline,scrollTimelineAxis,scrollTimelineName,scrollbarColor,scrollbarGutter,scrollbarWidth,shapeImageThreshold,shapeMargin,shapeOutside,shapeRendering,stopColor,stopOpacity,stroke,strokeDasharray,strokeDashoffset,strokeLinecap,strokeLinejoin,strokeMiterlimit,strokeOpacity,strokeWidth,tabSize,tableLayout,textAlign,textAlignLast,textAnchor,textBox,textBoxEdge,textBoxTrim,textCombineUpright,textDecoration,textDecorationColor,textDecorationLine,textDecorationSkip,textDecorationSkipInk,textDecorationStyle,textDecorationThickness,textEmphasis,textEmphasisColor,textEmphasisPosition,textEmphasisStyle,textIndent,textJustify,textOrientation,textOverflow,textRendering,textShadow,textSizeAdjust,textSpacingTrim,textTransform,textUnderlineOffset,textUnderlinePosition,textWrap,textWrapMode,textWrapStyle,timelineScope,top,touchAction,transform,transformBox,transformOrigin,transformStyle,transition,transitionBehavior,transitionDelay,transitionDuration,transitionProperty,transitionTimingFunction,translate,unicodeBidi,userSelect,vectorEffect,verticalAlign,viewTimeline,viewTimelineAxis,viewTimelineInset,viewTimelineName,viewTransitionName,visibility,whiteSpace,whiteSpaceCollapse,widows,width,willChange,wordBreak,wordSpacing,wordWrap,writingMode,x,y,zIndex,zoom,alignmentBaseline,baselineShift,colorInterpolation,colorRendering,glyphOrientationVertical";
var allCssProperties = cssPropertiesStr.split(",").concat(userGenerated);
var properties = new Map(allCssProperties.map((prop) => [prop, true]));
function memo(fn) {
  const cache = /* @__PURE__ */ Object.create(null);
  return (arg) => {
    if (cache[arg] === void 0)
      cache[arg] = fn(arg);
    return cache[arg];
  };
}
var cssPropertySelectorRegex = /&|@/;
var isCssProperty = /* @__PURE__ */ memo((prop) => {
  return properties.has(prop) || prop.startsWith("--") || cssPropertySelectorRegex.test(prop);
});



/***/ }),

/***/ "./node_modules/@zag-js/accordion/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@zag-js/accordion/dist/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anatomy: () => (/* binding */ anatomy),
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   itemProps: () => (/* binding */ itemProps),
/* harmony export */   machine: () => (/* binding */ machine),
/* harmony export */   props: () => (/* binding */ props),
/* harmony export */   splitItemProps: () => (/* binding */ splitItemProps),
/* harmony export */   splitProps: () => (/* binding */ splitProps)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");






// src/accordion.anatomy.ts
var anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("accordion").parts("root", "item", "itemTrigger", "itemContent", "itemIndicator");
var parts = anatomy.build();
var getRootId = (ctx) => ctx.ids?.root ?? `accordion:${ctx.id}`;
var getItemId = (ctx, value) => ctx.ids?.item?.(value) ?? `accordion:${ctx.id}:item:${value}`;
var getItemContentId = (ctx, value) => ctx.ids?.itemContent?.(value) ?? `accordion:${ctx.id}:content:${value}`;
var getItemTriggerId = (ctx, value) => ctx.ids?.itemTrigger?.(value) ?? `accordion:${ctx.id}:trigger:${value}`;
var getRootEl = (ctx) => ctx.getById(getRootId(ctx));
var getTriggerEls = (ctx) => {
  const ownerId = CSS.escape(getRootId(ctx));
  const selector = `[aria-controls][data-ownedby='${ownerId}']:not([disabled])`;
  return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.queryAll)(getRootEl(ctx), selector);
};
var getFirstTriggerEl = (ctx) => (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.first)(getTriggerEls(ctx));
var getLastTriggerEl = (ctx) => (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.last)(getTriggerEls(ctx));
var getNextTriggerEl = (ctx, id) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.nextById)(getTriggerEls(ctx), getItemTriggerId(ctx, id));
var getPrevTriggerEl = (ctx, id) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.prevById)(getTriggerEls(ctx), getItemTriggerId(ctx, id));

// src/accordion.connect.ts
function connect(service, normalize) {
  const { send, context, prop, scope, computed } = service;
  const focusedValue = context.get("focusedValue");
  const value = context.get("value");
  const multiple = prop("multiple");
  function setValue(value2) {
    let nextValue = value2;
    if (!multiple && nextValue.length > 1) {
      nextValue = [nextValue[0]];
    }
    send({ type: "VALUE.SET", value: nextValue });
  }
  function getItemState(props2) {
    return {
      expanded: value.includes(props2.value),
      focused: focusedValue === props2.value,
      disabled: Boolean(props2.disabled ?? prop("disabled"))
    };
  }
  return {
    focusedValue,
    value,
    setValue,
    getItemState,
    getRootProps() {
      return normalize.element({
        ...parts.root.attrs,
        dir: prop("dir"),
        id: getRootId(scope),
        "data-orientation": prop("orientation")
      });
    },
    getItemProps(props2) {
      const itemState = getItemState(props2);
      return normalize.element({
        ...parts.item.attrs,
        dir: prop("dir"),
        id: getItemId(scope, props2.value),
        "data-state": itemState.expanded ? "open" : "closed",
        "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(itemState.focused),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(itemState.disabled),
        "data-orientation": prop("orientation")
      });
    },
    getItemContentProps(props2) {
      const itemState = getItemState(props2);
      return normalize.element({
        ...parts.itemContent.attrs,
        dir: prop("dir"),
        role: "region",
        id: getItemContentId(scope, props2.value),
        "aria-labelledby": getItemTriggerId(scope, props2.value),
        hidden: !itemState.expanded,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(itemState.disabled),
        "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(itemState.focused),
        "data-orientation": prop("orientation")
      });
    },
    getItemIndicatorProps(props2) {
      const itemState = getItemState(props2);
      return normalize.element({
        ...parts.itemIndicator.attrs,
        dir: prop("dir"),
        "aria-hidden": true,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(itemState.disabled),
        "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(itemState.focused),
        "data-orientation": prop("orientation")
      });
    },
    getItemTriggerProps(props2) {
      const { value: value2 } = props2;
      const itemState = getItemState(props2);
      return normalize.button({
        ...parts.itemTrigger.attrs,
        type: "button",
        dir: prop("dir"),
        id: getItemTriggerId(scope, value2),
        "aria-controls": getItemContentId(scope, value2),
        "aria-expanded": itemState.expanded,
        disabled: itemState.disabled,
        "data-orientation": prop("orientation"),
        "aria-disabled": itemState.disabled,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-ownedby": getRootId(scope),
        onFocus() {
          if (itemState.disabled) return;
          send({ type: "TRIGGER.FOCUS", value: value2 });
        },
        onBlur() {
          if (itemState.disabled) return;
          send({ type: "TRIGGER.BLUR" });
        },
        onClick(event) {
          if (itemState.disabled) return;
          if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isSafari)()) {
            event.currentTarget.focus();
          }
          send({ type: "TRIGGER.CLICK", value: value2 });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (itemState.disabled) return;
          const keyMap = {
            ArrowDown() {
              if (computed("isHorizontal")) return;
              send({ type: "GOTO.NEXT", value: value2 });
            },
            ArrowUp() {
              if (computed("isHorizontal")) return;
              send({ type: "GOTO.PREV", value: value2 });
            },
            ArrowRight() {
              if (!computed("isHorizontal")) return;
              send({ type: "GOTO.NEXT", value: value2 });
            },
            ArrowLeft() {
              if (!computed("isHorizontal")) return;
              send({ type: "GOTO.PREV", value: value2 });
            },
            Home() {
              send({ type: "GOTO.FIRST", value: value2 });
            },
            End() {
              send({ type: "GOTO.LAST", value: value2 });
            }
          };
          const key = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventKey)(event, {
            dir: prop("dir"),
            orientation: prop("orientation")
          });
          const exec = keyMap[key];
          if (exec) {
            exec(event);
            event.preventDefault();
          }
        }
      });
    }
  };
}
var { and, not } = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_3__.createGuards)();
var machine = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_3__.createMachine)({
  props({ props: props2 }) {
    return {
      collapsible: false,
      multiple: false,
      orientation: "vertical",
      defaultValue: [],
      ...props2
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable }) {
    return {
      focusedValue: bindable(() => ({
        defaultValue: null,
        sync: true,
        onChange(value) {
          prop("onFocusChange")?.({ value });
        }
      })),
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          prop("onValueChange")?.({ value });
        }
      }))
    };
  },
  computed: {
    isHorizontal: ({ prop }) => prop("orientation") === "horizontal"
  },
  on: {
    "VALUE.SET": {
      actions: ["setValue"]
    }
  },
  states: {
    idle: {
      on: {
        "TRIGGER.FOCUS": {
          target: "focused",
          actions: ["setFocusedValue"]
        }
      }
    },
    focused: {
      on: {
        "GOTO.NEXT": {
          actions: ["focusNextTrigger"]
        },
        "GOTO.PREV": {
          actions: ["focusPrevTrigger"]
        },
        "TRIGGER.CLICK": [
          {
            guard: and("isExpanded", "canToggle"),
            actions: ["collapse"]
          },
          {
            guard: not("isExpanded"),
            actions: ["expand"]
          }
        ],
        "GOTO.FIRST": {
          actions: ["focusFirstTrigger"]
        },
        "GOTO.LAST": {
          actions: ["focusLastTrigger"]
        },
        "TRIGGER.BLUR": {
          target: "idle",
          actions: ["clearFocusedValue"]
        }
      }
    }
  },
  implementations: {
    guards: {
      canToggle: ({ prop }) => !!prop("collapsible") || !!prop("multiple"),
      isExpanded: ({ context, event }) => context.get("value").includes(event.value)
    },
    actions: {
      collapse({ context, prop, event }) {
        const next = prop("multiple") ? (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.remove)(context.get("value"), event.value) : [];
        context.set("value", next);
      },
      expand({ context, prop, event }) {
        const next = prop("multiple") ? (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.add)(context.get("value"), event.value) : [event.value];
        context.set("value", next);
      },
      focusFirstTrigger({ scope }) {
        getFirstTriggerEl(scope)?.focus();
      },
      focusLastTrigger({ scope }) {
        getLastTriggerEl(scope)?.focus();
      },
      focusNextTrigger({ context, scope }) {
        const focusedValue = context.get("focusedValue");
        if (!focusedValue) return;
        const triggerEl = getNextTriggerEl(scope, focusedValue);
        triggerEl?.focus();
      },
      focusPrevTrigger({ context, scope }) {
        const focusedValue = context.get("focusedValue");
        if (!focusedValue) return;
        const triggerEl = getPrevTriggerEl(scope, focusedValue);
        triggerEl?.focus();
      },
      setFocusedValue({ context, event }) {
        context.set("focusedValue", event.value);
      },
      clearFocusedValue({ context }) {
        context.set("focusedValue", null);
      },
      setValue({ context, event }) {
        context.set("value", event.value);
      },
      coarseValue({ context, prop }) {
        if (!prop("multiple") && context.get("value").length > 1) {
          (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(`The value of accordion should be a single value when multiple is false.`);
          context.set("value", [context.get("value")[0]]);
        }
      }
    }
  }
});
var props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_4__.createProps)()([
  "collapsible",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "multiple",
  "onFocusChange",
  "onValueChange",
  "orientation",
  "value",
  "defaultValue"
]);
var splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.createSplitProps)(props);
var itemProps = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_4__.createProps)()(["value", "disabled"]);
var splitItemProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.createSplitProps)(itemProps);




/***/ }),

/***/ "./node_modules/@zag-js/anatomy/dist/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@zag-js/anatomy/dist/index.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createAnatomy: () => (/* binding */ createAnatomy)
/* harmony export */ });
// src/create-anatomy.ts
var createAnatomy = (name, parts = []) => ({
  parts: (...values) => {
    if (isEmpty(parts)) {
      return createAnatomy(name, values);
    }
    throw new Error("createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?");
  },
  extendWith: (...values) => createAnatomy(name, [...parts, ...values]),
  rename: (newName) => createAnatomy(newName, parts),
  keys: () => parts,
  build: () => [...new Set(parts)].reduce(
    (prev, part) => Object.assign(prev, {
      [part]: {
        selector: [
          `&[data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`,
          `& [data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`
        ].join(", "),
        attrs: { "data-scope": toKebabCase(name), "data-part": toKebabCase(part) }
      }
    }),
    {}
  )
});
var toKebabCase = (value) => value.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
var isEmpty = (v) => v.length === 0;




/***/ }),

/***/ "./node_modules/@zag-js/aria-hidden/dist/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@zag-js/aria-hidden/dist/index.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ariaHidden: () => (/* binding */ ariaHidden)
/* harmony export */ });
// src/walk-tree-outside.ts
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = (node) => node && (node.host || unwrapHost(node.parentNode));
var correctTargets = (parent, targets) => targets.map((target) => {
  if (parent.contains(target)) return target;
  const correctedTarget = unwrapHost(target);
  if (correctedTarget && parent.contains(correctedTarget)) {
    return correctedTarget;
  }
  console.error("[zag-js > ariaHidden] target", target, "in not contained inside", parent, ". Doing nothing");
  return null;
}).filter((x) => Boolean(x));
var isIgnoredNode = (node) => {
  if (node.localName === "next-route-announcer") return true;
  if (node.localName === "script") return true;
  if (node.hasAttribute("aria-live")) return true;
  return node.matches("[data-live-announcer]");
};
var walkTreeOutside = (originalTarget, props) => {
  const { parentNode, markerName, controlAttribute} = props;
  const targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  markerMap[markerName] || (markerMap[markerName] = /* @__PURE__ */ new WeakMap());
  const markerCounter = markerMap[markerName];
  const hiddenNodes = [];
  const elementsToKeep = /* @__PURE__ */ new Set();
  const elementsToStop = new Set(targets);
  const keep = (el) => {
    if (!el || elementsToKeep.has(el)) return;
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  const deep = (parent) => {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, (node) => {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          if (isIgnoredNode(node)) return;
          const attr = node.getAttribute(controlAttribute);
          const alreadyHidden = attr === "true" ;
          const counterValue = (counterMap.get(node) || 0) + 1;
          const markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true" );
          }
        } catch (e) {
          console.error("[zag-js > ariaHidden] cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return () => {
    hiddenNodes.forEach((node) => {
      const counterValue = counterMap.get(node) - 1;
      const markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};

// src/aria-hidden.ts
var getParentNode = (originalTarget) => {
  const target = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return target.ownerDocument.body;
};
var hideOthers = (originalTarget, parentNode = getParentNode(originalTarget), markerName = "data-aria-hidden") => {
  if (!parentNode) return;
  return walkTreeOutside(originalTarget, {
    parentNode,
    markerName,
    controlAttribute: "aria-hidden"});
};

// src/index.ts
var raf = (fn) => {
  const frameId = requestAnimationFrame(() => fn());
  return () => cancelAnimationFrame(frameId);
};
function ariaHidden(targetsOrFn, options = {}) {
  const { defer = true } = options;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const targets = typeof targetsOrFn === "function" ? targetsOrFn() : targetsOrFn;
      const elements = targets.filter(Boolean);
      if (elements.length === 0) return;
      cleanups.push(hideOthers(elements));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}




/***/ }),

/***/ "./node_modules/@zag-js/avatar/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@zag-js/avatar/dist/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anatomy: () => (/* binding */ anatomy),
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   machine: () => (/* binding */ machine),
/* harmony export */   props: () => (/* binding */ props),
/* harmony export */   splitProps: () => (/* binding */ splitProps)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");






// src/avatar.anatomy.ts
var anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("avatar").parts("root", "image", "fallback");
var parts = anatomy.build();

// src/avatar.dom.ts
var getRootId = (ctx) => ctx.ids?.root ?? `avatar:${ctx.id}`;
var getImageId = (ctx) => ctx.ids?.image ?? `avatar:${ctx.id}:image`;
var getFallbackId = (ctx) => ctx.ids?.fallback ?? `avatar:${ctx.id}:fallback`;
var getRootEl = (ctx) => ctx.getById(getRootId(ctx));
var getImageEl = (ctx) => ctx.getById(getImageId(ctx));

// src/avatar.connect.ts
function connect(service, normalize) {
  const { state, send, prop, scope } = service;
  const loaded = state.matches("loaded");
  return {
    loaded,
    setSrc(src) {
      const img = getImageEl(scope);
      img?.setAttribute("src", src);
    },
    setLoaded() {
      send({ type: "img.loaded", src: "api" });
    },
    setError() {
      send({ type: "img.error", src: "api" });
    },
    getRootProps() {
      return normalize.element({
        ...parts.root.attrs,
        dir: prop("dir"),
        id: getRootId(scope)
      });
    },
    getImageProps() {
      return normalize.img({
        ...parts.image.attrs,
        hidden: !loaded,
        dir: prop("dir"),
        id: getImageId(scope),
        "data-state": loaded ? "visible" : "hidden",
        onLoad() {
          send({ type: "img.loaded", src: "element" });
        },
        onError() {
          send({ type: "img.error", src: "element" });
        }
      });
    },
    getFallbackProps() {
      return normalize.element({
        ...parts.fallback.attrs,
        dir: prop("dir"),
        id: getFallbackId(scope),
        hidden: loaded,
        "data-state": loaded ? "hidden" : "visible"
      });
    }
  };
}
var machine = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_1__.createMachine)({
  initialState() {
    return "loading";
  },
  effects: ["trackImageRemoval", "trackSrcChange"],
  on: {
    "src.change": {
      target: "loading"
    },
    "img.unmount": {
      target: "error"
    }
  },
  states: {
    loading: {
      entry: ["checkImageStatus"],
      on: {
        "img.loaded": {
          target: "loaded",
          actions: ["invokeOnLoad"]
        },
        "img.error": {
          target: "error",
          actions: ["invokeOnError"]
        }
      }
    },
    error: {
      on: {
        "img.loaded": {
          target: "loaded",
          actions: ["invokeOnLoad"]
        }
      }
    },
    loaded: {
      on: {
        "img.error": {
          target: "error",
          actions: ["invokeOnError"]
        }
      }
    }
  },
  implementations: {
    actions: {
      invokeOnLoad({ prop }) {
        prop("onStatusChange")?.({ status: "loaded" });
      },
      invokeOnError({ prop }) {
        prop("onStatusChange")?.({ status: "error" });
      },
      checkImageStatus({ send, scope }) {
        const imageEl = getImageEl(scope);
        if (!imageEl?.complete) return;
        const type = hasLoaded(imageEl) ? "img.loaded" : "img.error";
        send({ type, src: "ssr" });
      }
    },
    effects: {
      trackImageRemoval({ send, scope }) {
        const rootEl = getRootEl(scope);
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_2__.observeChildren)(rootEl, {
          callback(records) {
            const removedNodes = Array.from(records[0].removedNodes);
            const removed = removedNodes.find(
              (node) => node.nodeType === Node.ELEMENT_NODE && node.matches("[data-scope=avatar][data-part=image]")
            );
            if (removed) {
              send({ type: "img.unmount" });
            }
          }
        });
      },
      trackSrcChange({ send, scope }) {
        const imageEl = getImageEl(scope);
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_2__.observeAttributes)(imageEl, {
          attributes: ["src", "srcset"],
          callback() {
            send({ type: "src.change" });
          }
        });
      }
    }
  }
});
function hasLoaded(image) {
  return image.complete && image.naturalWidth !== 0 && image.naturalHeight !== 0;
}
var props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_3__.createProps)()(["dir", "id", "ids", "onStatusChange", "getRootNode"]);
var splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.createSplitProps)(props);




/***/ }),

/***/ "./node_modules/@zag-js/checkbox/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@zag-js/checkbox/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anatomy: () => (/* binding */ anatomy),
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   machine: () => (/* binding */ machine),
/* harmony export */   props: () => (/* binding */ props),
/* harmony export */   splitProps: () => (/* binding */ splitProps)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_focus_visible__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/focus-visible */ "./node_modules/@zag-js/focus-visible/dist/index.mjs");
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");







// src/checkbox.anatomy.ts
var anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("checkbox").parts("root", "label", "control", "indicator");
var parts = anatomy.build();

// src/checkbox.dom.ts
var getRootId = (ctx) => ctx.ids?.root ?? `checkbox:${ctx.id}`;
var getLabelId = (ctx) => ctx.ids?.label ?? `checkbox:${ctx.id}:label`;
var getControlId = (ctx) => ctx.ids?.control ?? `checkbox:${ctx.id}:control`;
var getHiddenInputId = (ctx) => ctx.ids?.hiddenInput ?? `checkbox:${ctx.id}:input`;
var getRootEl = (ctx) => ctx.getById(getRootId(ctx));
var getHiddenInputEl = (ctx) => ctx.getById(getHiddenInputId(ctx));

// src/checkbox.connect.ts
function connect(service, normalize) {
  const { send, context, prop, computed, scope } = service;
  const disabled = prop("disabled");
  const readOnly = prop("readOnly");
  const invalid = prop("invalid");
  const focused = !disabled && context.get("focused");
  const focusVisible = !disabled && context.get("focusVisible");
  const checked = computed("checked");
  const indeterminate = computed("indeterminate");
  const dataAttrs = {
    "data-active": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(context.get("active")),
    "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(focused),
    "data-focus-visible": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(focusVisible),
    "data-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(readOnly),
    "data-hover": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(context.get("hovered")),
    "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
    "data-state": indeterminate ? "indeterminate" : checked ? "checked" : "unchecked",
    "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(invalid)
  };
  return {
    checked,
    disabled,
    indeterminate,
    focused,
    checkedState: checked,
    setChecked(checked2) {
      send({ type: "CHECKED.SET", checked: checked2, isTrusted: false });
    },
    toggleChecked() {
      send({ type: "CHECKED.TOGGLE", checked, isTrusted: false });
    },
    getRootProps() {
      return normalize.label({
        ...parts.root.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        id: getRootId(scope),
        htmlFor: getHiddenInputId(scope),
        onPointerMove() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: true } });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: false } });
        },
        onClick(event) {
          const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventTarget)(event);
          if (target === getHiddenInputEl(scope)) {
            event.stopPropagation();
          }
        }
      });
    },
    getLabelProps() {
      return normalize.element({
        ...parts.label.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        id: getLabelId(scope)
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts.control.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        id: getControlId(scope),
        "aria-hidden": true
      });
    },
    getIndicatorProps() {
      return normalize.element({
        ...parts.indicator.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        hidden: !indeterminate && !checked
      });
    },
    getHiddenInputProps() {
      return normalize.input({
        id: getHiddenInputId(scope),
        type: "checkbox",
        required: prop("required"),
        defaultChecked: checked,
        disabled,
        "aria-labelledby": getLabelId(scope),
        "aria-invalid": invalid,
        name: prop("name"),
        form: prop("form"),
        value: prop("value"),
        style: _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.visuallyHiddenStyle,
        onFocus() {
          const focusVisible2 = (0,_zag_js_focus_visible__WEBPACK_IMPORTED_MODULE_2__.isFocusVisible)();
          send({ type: "CONTEXT.SET", context: { focused: true, focusVisible: focusVisible2 } });
        },
        onBlur() {
          send({ type: "CONTEXT.SET", context: { focused: false, focusVisible: false } });
        },
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          const checked2 = event.currentTarget.checked;
          send({ type: "CHECKED.SET", checked: checked2, isTrusted: true });
        }
      });
    }
  };
}
var { not } = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_3__.createGuards)();
var machine = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_3__.createMachine)({
  props({ props: props2 }) {
    return {
      value: "on",
      ...props2,
      defaultChecked: !!props2.defaultChecked
    };
  },
  initialState() {
    return "ready";
  },
  context({ prop, bindable }) {
    return {
      checked: bindable(() => ({
        defaultValue: prop("defaultChecked"),
        value: prop("checked"),
        onChange(checked) {
          prop("onCheckedChange")?.({ checked });
        }
      })),
      fieldsetDisabled: bindable(() => ({ defaultValue: false })),
      focusVisible: bindable(() => ({ defaultValue: false })),
      active: bindable(() => ({ defaultValue: false })),
      focused: bindable(() => ({ defaultValue: false })),
      hovered: bindable(() => ({ defaultValue: false }))
    };
  },
  watch({ track, context, prop, action }) {
    track([() => prop("disabled")], () => {
      action(["removeFocusIfNeeded"]);
    });
    track([() => context.get("checked")], () => {
      action(["syncInputElement"]);
    });
  },
  effects: ["trackFormControlState", "trackPressEvent", "trackFocusVisible"],
  on: {
    "CHECKED.TOGGLE": [
      {
        guard: not("isTrusted"),
        actions: ["toggleChecked", "dispatchChangeEvent"]
      },
      {
        actions: ["toggleChecked"]
      }
    ],
    "CHECKED.SET": [
      {
        guard: not("isTrusted"),
        actions: ["setChecked", "dispatchChangeEvent"]
      },
      {
        actions: ["setChecked"]
      }
    ],
    "CONTEXT.SET": {
      actions: ["setContext"]
    }
  },
  computed: {
    indeterminate: ({ context }) => isIndeterminate(context.get("checked")),
    checked: ({ context }) => isChecked(context.get("checked")),
    disabled: ({ context, prop }) => !!prop("disabled") || context.get("fieldsetDisabled")
  },
  states: {
    ready: {}
  },
  implementations: {
    guards: {
      isTrusted: ({ event }) => !!event.isTrusted
    },
    effects: {
      trackPressEvent({ context, computed, scope }) {
        if (computed("disabled")) return;
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.trackPress)({
          pointerNode: getRootEl(scope),
          keyboardNode: getHiddenInputEl(scope),
          isValidKey: (event) => event.key === " ",
          onPress: () => context.set("active", false),
          onPressStart: () => context.set("active", true),
          onPressEnd: () => context.set("active", false)
        });
      },
      trackFocusVisible({ computed, scope }) {
        if (computed("disabled")) return;
        return (0,_zag_js_focus_visible__WEBPACK_IMPORTED_MODULE_2__.trackFocusVisible)({ root: scope.getRootNode?.() });
      },
      trackFormControlState({ context, scope }) {
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.trackFormControl)(getHiddenInputEl(scope), {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            context.set("checked", context.initial("checked"));
          }
        });
      }
    },
    actions: {
      setContext({ context, event }) {
        for (const key in event.context) {
          context.set(key, event.context[key]);
        }
      },
      syncInputElement({ context, computed, scope }) {
        const inputEl = getHiddenInputEl(scope);
        if (!inputEl) return;
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.setElementChecked)(inputEl, computed("checked"));
        inputEl.indeterminate = isIndeterminate(context.get("checked"));
      },
      removeFocusIfNeeded({ context, prop }) {
        if (prop("disabled") && context.get("focused")) {
          context.set("focused", false);
          context.set("focusVisible", false);
        }
      },
      setChecked({ context, event }) {
        context.set("checked", event.checked);
      },
      toggleChecked({ context, computed }) {
        const checked = isIndeterminate(computed("checked")) ? true : !computed("checked");
        context.set("checked", checked);
      },
      dispatchChangeEvent({ computed, scope }) {
        queueMicrotask(() => {
          const inputEl = getHiddenInputEl(scope);
          (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dispatchInputCheckedEvent)(inputEl, { checked: computed("checked") });
        });
      }
    }
  }
});
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function isChecked(checked) {
  return isIndeterminate(checked) ? false : !!checked;
}
var props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_4__.createProps)()([
  "defaultChecked",
  "checked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
var splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_5__.createSplitProps)(props);




/***/ }),

/***/ "./node_modules/@zag-js/collapsible/dist/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@zag-js/collapsible/dist/index.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anatomy: () => (/* binding */ anatomy),
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   machine: () => (/* binding */ machine),
/* harmony export */   props: () => (/* binding */ props),
/* harmony export */   splitProps: () => (/* binding */ splitProps)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");






// src/collapsible.anatomy.ts
var anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("collapsible").parts("root", "trigger", "content", "indicator");
var parts = anatomy.build();

// src/collapsible.dom.ts
var getRootId = (ctx) => ctx.ids?.root ?? `collapsible:${ctx.id}`;
var getContentId = (ctx) => ctx.ids?.content ?? `collapsible:${ctx.id}:content`;
var getTriggerId = (ctx) => ctx.ids?.trigger ?? `collapsible:${ctx.id}:trigger`;
var getContentEl = (ctx) => ctx.getById(getContentId(ctx));

// src/collapsible.connect.ts
function connect(service, normalize) {
  const { state, send, context, scope, prop } = service;
  const visible = state.matches("open") || state.matches("closing");
  const open = state.matches("open");
  const { width, height } = context.get("size");
  const disabled = !!prop("disabled");
  const skip = !context.get("initial") && open;
  const dir = "ltr";
  return {
    disabled,
    visible,
    open,
    measureSize() {
      send({ type: "size.measure" });
    },
    setOpen(nextOpen) {
      const open2 = state.matches("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "open" : "close" });
    },
    getRootProps() {
      return normalize.element({
        ...parts.root.attrs,
        "data-state": open ? "open" : "closed",
        dir,
        id: getRootId(scope)
      });
    },
    getContentProps() {
      return normalize.element({
        ...parts.content.attrs,
        "data-collapsible": "",
        "data-state": skip ? void 0 : open ? "open" : "closed",
        id: getContentId(scope),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        hidden: !visible,
        style: {
          "--height": height != null ? `${height}px` : void 0,
          "--width": width != null ? `${width}px` : void 0
        }
      });
    },
    getTriggerProps() {
      return normalize.element({
        ...parts.trigger.attrs,
        id: getTriggerId(scope),
        dir,
        type: "button",
        "data-state": open ? "open" : "closed",
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "aria-controls": getContentId(scope),
        "aria-expanded": visible || false,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          send({ type: open ? "close" : "open" });
        }
      });
    },
    getIndicatorProps() {
      return normalize.element({
        ...parts.indicator.attrs,
        dir,
        "data-state": open ? "open" : "closed",
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled)
      });
    }
  };
}
var machine = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_2__.createMachine)({
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "closed";
  },
  context({ bindable }) {
    return {
      size: bindable(() => ({ defaultValue: { height: 0, width: 0 } })),
      initial: bindable(() => ({ defaultValue: false }))
    };
  },
  refs() {
    return {
      cleanup: void 0,
      stylesRef: void 0
    };
  },
  watch({ track, prop, action }) {
    track([() => prop("open")], () => {
      action(["setInitial", "computeSize", "toggleVisibility"]);
    });
  },
  exit: ["clearInitial", "cleanupNode"],
  states: {
    closed: {
      on: {
        "controlled.open": {
          target: "open"
        },
        open: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitial", "computeSize", "invokeOnOpen"]
          }
        ]
      }
    },
    closing: {
      effects: ["trackExitAnimation"],
      on: {
        "controlled.close": {
          target: "closed"
        },
        "controlled.open": {
          target: "open"
        },
        open: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitial", "invokeOnOpen"]
          }
        ],
        close: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnExitComplete"]
          },
          {
            target: "closed",
            actions: ["setInitial", "computeSize", "invokeOnExitComplete"]
          }
        ],
        "animation.end": {
          target: "closed",
          actions: ["invokeOnExitComplete", "clearInitial"]
        }
      }
    },
    open: {
      effects: ["trackEnterAnimation"],
      on: {
        "controlled.close": {
          target: "closing"
        },
        close: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closing",
            actions: ["setInitial", "computeSize", "invokeOnClose"]
          }
        ],
        "size.measure": {
          actions: ["measureSize"]
        },
        "animation.end": {
          actions: ["clearInitial"]
        }
      }
    }
  },
  implementations: {
    guards: {
      isOpenControlled: ({ prop }) => prop("open") != void 0
    },
    effects: {
      trackEnterAnimation: ({ send, scope }) => {
        let cleanup;
        const rafCleanup = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => {
          const contentEl = getContentEl(scope);
          if (!contentEl) return;
          const animationName = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(contentEl).animationName;
          const hasNoAnimation = !animationName || animationName === "none";
          if (hasNoAnimation) {
            send({ type: "animation.end" });
            return;
          }
          const onEnd = (event) => {
            const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventTarget)(event);
            if (target === contentEl) {
              send({ type: "animation.end" });
            }
          };
          contentEl.addEventListener("animationend", onEnd);
          cleanup = () => {
            contentEl.removeEventListener("animationend", onEnd);
          };
        });
        return () => {
          rafCleanup();
          cleanup?.();
        };
      },
      trackExitAnimation: ({ send, scope }) => {
        let cleanup;
        const rafCleanup = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => {
          const contentEl = getContentEl(scope);
          if (!contentEl) return;
          const animationName = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(contentEl).animationName;
          const hasNoAnimation = !animationName || animationName === "none";
          if (hasNoAnimation) {
            send({ type: "animation.end" });
            return;
          }
          const onEnd = (event) => {
            const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventTarget)(event);
            if (target === contentEl) {
              send({ type: "animation.end" });
            }
          };
          contentEl.addEventListener("animationend", onEnd);
          const restoreStyles = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.setStyle)(contentEl, {
            animationFillMode: "forwards"
          });
          cleanup = () => {
            contentEl.removeEventListener("animationend", onEnd);
            (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.nextTick)(() => restoreStyles());
          };
        });
        return () => {
          rafCleanup();
          cleanup?.();
        };
      }
    },
    actions: {
      setInitial: ({ context, flush }) => {
        flush(() => {
          context.set("initial", true);
        });
      },
      clearInitial: ({ context }) => {
        context.set("initial", false);
      },
      cleanupNode: ({ refs }) => {
        refs.set("stylesRef", null);
      },
      measureSize: ({ context, flush, scope }) => {
        const contentEl = getContentEl(scope);
        if (!contentEl) return;
        const { height, width } = contentEl.getBoundingClientRect();
        flush(() => {
          context.set("size", { height, width });
        });
      },
      computeSize: ({ refs, scope, flush, context }) => {
        refs.get("cleanup")?.();
        const rafCleanup = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => {
          const contentEl = getContentEl(scope);
          if (!contentEl) return;
          const hidden = contentEl.hidden;
          contentEl.style.animationName = "none";
          contentEl.style.animationDuration = "0s";
          contentEl.hidden = false;
          const rect = contentEl.getBoundingClientRect();
          flush(() => {
            context.set("size", { height: rect.height, width: rect.width });
          });
          if (context.get("initial")) {
            contentEl.style.animationName = "";
            contentEl.style.animationDuration = "";
          }
          contentEl.hidden = hidden;
        });
        refs.set("cleanup", rafCleanup);
      },
      invokeOnOpen: ({ prop }) => {
        prop("onOpenChange")?.({ open: true });
      },
      invokeOnClose: ({ prop }) => {
        prop("onOpenChange")?.({ open: false });
      },
      invokeOnExitComplete: ({ prop }) => {
        prop("onExitComplete")?.();
      },
      toggleVisibility: ({ prop, send }) => {
        send({ type: prop("open") ? "controlled.open" : "controlled.close" });
      }
    }
  }
});
var props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_3__.createProps)()([
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "onExitComplete",
  "onOpenChange",
  "defaultOpen",
  "open"
]);
var splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.createSplitProps)(props);




/***/ }),

/***/ "./node_modules/@zag-js/collection/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@zag-js/collection/dist/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GridCollection: () => (/* binding */ GridCollection),
/* harmony export */   ListCollection: () => (/* binding */ ListCollection),
/* harmony export */   Selection: () => (/* binding */ Selection),
/* harmony export */   TreeCollection: () => (/* binding */ TreeCollection),
/* harmony export */   filePathToTree: () => (/* binding */ filePathToTree),
/* harmony export */   flattenedToTree: () => (/* binding */ flattenedToTree),
/* harmony export */   isGridCollection: () => (/* binding */ isGridCollection),
/* harmony export */   isListCollection: () => (/* binding */ isListCollection)
/* harmony export */ });
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");


var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var fallback = {
  itemToValue(item) {
    if (typeof item === "string") return item;
    if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(item) && (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.hasProp)(item, "value")) return item.value;
    return "";
  },
  itemToString(item) {
    if (typeof item === "string") return item;
    if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(item) && (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.hasProp)(item, "label")) return item.label;
    return fallback.itemToValue(item);
  },
  isItemDisabled(item) {
    if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(item) && (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.hasProp)(item, "disabled")) return !!item.disabled;
    return false;
  }
};
var ListCollection = class _ListCollection {
  constructor(options) {
    this.options = options;
    /**
     * The items in the collection
     */
    __publicField(this, "items");
    __publicField(this, "copy", (items) => {
      return new _ListCollection({ ...this.options, items: items ?? [...this.items] });
    });
    __publicField(this, "isEqual", (other) => {
      return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isEqual)(this.items, other.items);
    });
    /**
     * Function to update the collection items
     */
    __publicField(this, "setItems", (items) => {
      return this.copy(items);
    });
    /**
     * Returns all the values in the collection
     */
    __publicField(this, "getValues", (items = this.items) => {
      return Array.from(items).map((item) => this.getItemValue(item)).filter(Boolean);
    });
    /**
     * Get the item based on its value
     */
    __publicField(this, "find", (value) => {
      if (value == null) return null;
      const index = this.items.findIndex((item) => this.getItemValue(item) === value);
      return index != null ? this.items[index] : null;
    });
    /**
     * Get the items based on its values
     */
    __publicField(this, "findMany", (values) => {
      return Array.from(values).map((value) => this.find(value)).filter((item) => item != null);
    });
    /**
     * Get the item based on its index
     */
    __publicField(this, "at", (index) => {
      return this.items[index] ?? null;
    });
    __publicField(this, "sortFn", (valueA, valueB) => {
      const indexA = this.indexOf(valueA);
      const indexB = this.indexOf(valueB);
      return (indexA ?? 0) - (indexB ?? 0);
    });
    /**
     * Sort the values based on their index
     */
    __publicField(this, "sort", (values) => {
      return [...values].sort(this.sortFn.bind(this));
    });
    /**
     * Convert an item to a value
     */
    __publicField(this, "getItemValue", (item) => {
      if (item == null) return null;
      return this.options.itemToValue?.(item) ?? fallback.itemToValue(item);
    });
    /**
     * Whether an item is disabled
     */
    __publicField(this, "getItemDisabled", (item) => {
      if (item == null) return false;
      return this.options.isItemDisabled?.(item) ?? fallback.isItemDisabled(item);
    });
    /**
     * Convert an item to a string
     */
    __publicField(this, "stringifyItem", (item) => {
      if (item == null) return null;
      return this.options.itemToString?.(item) ?? fallback.itemToString(item);
    });
    /**
     * Convert a value to a string
     */
    __publicField(this, "stringify", (value) => {
      if (value == null) return null;
      return this.stringifyItem(this.find(value));
    });
    /**
     * Convert an array of items to a string
     */
    __publicField(this, "stringifyItems", (items, separator = ", ") => {
      return Array.from(items).map((item) => this.stringifyItem(item)).filter(Boolean).join(separator);
    });
    /**
     * Convert an array of items to a string
     */
    __publicField(this, "stringifyMany", (value, separator) => {
      return this.stringifyItems(this.findMany(value), separator);
    });
    /**
     * Whether the collection has a value
     */
    __publicField(this, "has", (value) => {
      return this.indexOf(value) !== -1;
    });
    /**
     * Whether the collection has an item
     */
    __publicField(this, "hasItem", (item) => {
      if (item == null) return false;
      return this.has(this.getItemValue(item));
    });
    /**
     * Group items by the groupBy function provided in options
     * Returns an array of [groupKey, items] tuples
     */
    __publicField(this, "group", () => {
      const { groupBy, groupSort } = this.options;
      if (!groupBy) return [["", [...this.items]]];
      const groups = /* @__PURE__ */ new Map();
      this.items.forEach((item, index) => {
        const groupKey = groupBy(item, index);
        if (!groups.has(groupKey)) {
          groups.set(groupKey, []);
        }
        groups.get(groupKey).push(item);
      });
      let entries = Array.from(groups.entries());
      if (groupSort) {
        entries.sort(([a], [b]) => {
          if (typeof groupSort === "function") return groupSort(a, b);
          if (Array.isArray(groupSort)) {
            const indexA = groupSort.indexOf(a);
            const indexB = groupSort.indexOf(b);
            if (indexA === -1) return 1;
            if (indexB === -1) return -1;
            return indexA - indexB;
          }
          if (groupSort === "asc") return a.localeCompare(b);
          if (groupSort === "desc") return b.localeCompare(a);
          return 0;
        });
      }
      return entries;
    });
    /**
     * Returns the next value in the collection
     */
    __publicField(this, "getNextValue", (value, step = 1, clamp = false) => {
      let index = this.indexOf(value);
      if (index === -1) return null;
      index = clamp ? Math.min(index + step, this.size - 1) : index + step;
      while (index <= this.size && this.getItemDisabled(this.at(index))) index++;
      return this.getItemValue(this.at(index));
    });
    /**
     * Returns the previous value in the collection
     */
    __publicField(this, "getPreviousValue", (value, step = 1, clamp = false) => {
      let index = this.indexOf(value);
      if (index === -1) return null;
      index = clamp ? Math.max(index - step, 0) : index - step;
      while (index >= 0 && this.getItemDisabled(this.at(index))) index--;
      return this.getItemValue(this.at(index));
    });
    /**
     * Get the index of an item based on its key
     */
    __publicField(this, "indexOf", (value) => {
      if (value == null) return -1;
      return this.items.findIndex((item) => this.getItemValue(item) === value);
    });
    __publicField(this, "getByText", (text, current) => {
      let items = current != null ? wrap(this.items, this.indexOf(current)) : this.items;
      const isSingleKey = text.length === 1;
      if (isSingleKey) items = items.filter((item) => this.getItemValue(item) !== current);
      return items.find((item) => match(this.stringifyItem(item), text));
    });
    /**
     * Search for a value based on a query
     */
    __publicField(this, "search", (queryString, options) => {
      const { state, currentValue, timeout = 350 } = options;
      const search = state.keysSoFar + queryString;
      const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
      const query = isRepeated ? search[0] : search;
      const item = this.getByText(query, currentValue);
      const value = this.getItemValue(item);
      function cleanup() {
        clearTimeout(state.timer);
        state.timer = -1;
      }
      function update(value2) {
        state.keysSoFar = value2;
        cleanup();
        if (value2 !== "") {
          state.timer = +setTimeout(() => {
            update("");
            cleanup();
          }, timeout);
        }
      }
      update(search);
      return value;
    });
    __publicField(this, "update", (value, item) => {
      let index = this.items.findIndex((item2) => this.getItemValue(item2) === value);
      if (index === -1) return this;
      return this.copy([...this.items.slice(0, index), item, ...this.items.slice(index + 1)]);
    });
    __publicField(this, "insert", (index, ...items) => {
      return this.copy(insert(this.items, index, ...items));
    });
    __publicField(this, "insertBefore", (value, ...items) => {
      let toIndex = this.indexOf(value);
      if (toIndex === -1) {
        if (this.items.length === 0) toIndex = 0;
        else return this;
      }
      return this.copy(insert(this.items, toIndex, ...items));
    });
    __publicField(this, "insertAfter", (value, ...items) => {
      let toIndex = this.indexOf(value);
      if (toIndex === -1) {
        if (this.items.length === 0) toIndex = 0;
        else return this;
      }
      return this.copy(insert(this.items, toIndex + 1, ...items));
    });
    __publicField(this, "prepend", (...items) => {
      return this.copy(insert(this.items, 0, ...items));
    });
    __publicField(this, "append", (...items) => {
      return this.copy(insert(this.items, this.items.length, ...items));
    });
    __publicField(this, "filter", (fn) => {
      const filteredItems = this.items.filter((item, index) => fn(this.stringifyItem(item), index));
      return this.copy(filteredItems);
    });
    __publicField(this, "remove", (...itemsOrValues) => {
      const values = itemsOrValues.map(
        (itemOrValue) => typeof itemOrValue === "string" ? itemOrValue : this.getItemValue(itemOrValue)
      );
      return this.copy(
        this.items.filter((item) => {
          const value = this.getItemValue(item);
          if (value == null) return false;
          return !values.includes(value);
        })
      );
    });
    __publicField(this, "move", (value, toIndex) => {
      const fromIndex = this.indexOf(value);
      if (fromIndex === -1) return this;
      return this.copy(move(this.items, [fromIndex], toIndex));
    });
    __publicField(this, "reorder", (fromIndex, toIndex) => {
      return this.copy(move(this.items, [fromIndex], toIndex));
    });
    __publicField(this, "compareValue", (a, b) => {
      const indexA = this.indexOf(a);
      const indexB = this.indexOf(b);
      if (indexA < indexB) return -1;
      if (indexA > indexB) return 1;
      return 0;
    });
    __publicField(this, "range", (from, to) => {
      let keys = [];
      let key = from;
      while (key != null) {
        let item = this.find(key);
        if (item) keys.push(key);
        if (key === to) return keys;
        key = this.getNextValue(key);
      }
      return [];
    });
    __publicField(this, "getValueRange", (from, to) => {
      if (from && to) {
        if (this.compareValue(from, to) <= 0) {
          return this.range(from, to);
        }
        return this.range(to, from);
      }
      return [];
    });
    __publicField(this, "toString", () => {
      let result = "";
      for (const item of this.items) {
        const value = this.getItemValue(item);
        const label = this.stringifyItem(item);
        const disabled = this.getItemDisabled(item);
        const itemString = [value, label, disabled].filter(Boolean).join(":");
        result += itemString + ",";
      }
      return result;
    });
    __publicField(this, "toJSON", () => {
      return {
        size: this.size,
        first: this.firstValue,
        last: this.lastValue
      };
    });
    this.items = [...options.items];
  }
  /**
   * Returns the number of items in the collection
   */
  get size() {
    return this.items.length;
  }
  /**
   * Returns the first value in the collection
   */
  get firstValue() {
    let index = 0;
    while (this.getItemDisabled(this.at(index))) index++;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the last value in the collection
   */
  get lastValue() {
    let index = this.size - 1;
    while (this.getItemDisabled(this.at(index))) index--;
    return this.getItemValue(this.at(index));
  }
  *[Symbol.iterator]() {
    yield* this.items;
  }
};
var match = (label, query) => {
  return !!label?.toLowerCase().startsWith(query.toLowerCase());
};
var wrap = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function isListCollection(v) {
  return v instanceof ListCollection;
}
function insert(items, index, ...values) {
  return [...items.slice(0, index), ...values, ...items.slice(index)];
}
function move(items, indices, toIndex) {
  indices = [...indices].sort((a, b) => a - b);
  const itemsToMove = indices.map((i) => items[i]);
  for (let i = indices.length - 1; i >= 0; i--) {
    items = [...items.slice(0, indices[i]), ...items.slice(indices[i] + 1)];
  }
  toIndex = Math.max(0, toIndex - indices.filter((i) => i < toIndex).length);
  return [...items.slice(0, toIndex), ...itemsToMove, ...items.slice(toIndex)];
}

// src/grid-collection.ts
var GridCollection = class extends ListCollection {
  constructor(options) {
    const { columnCount } = options;
    super(options);
    __publicField(this, "columnCount");
    /**
     * Returns the row data in the grid
     */
    __publicField(this, "getRows", () => {
      return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.chunk)([...this.items], this.columnCount);
    });
    /**
     * Returns the number of rows in the grid
     */
    __publicField(this, "getRowCount", () => {
      return this.getRows().length;
    });
    /**
     * Returns the index of the specified row and column in the grid
     */
    __publicField(this, "getCellIndex", (row, column) => {
      return row * this.columnCount + column;
    });
    /**
     * Returns the item at the specified row and column in the grid
     */
    __publicField(this, "getCell", (row, column) => {
      return this.at(this.getCellIndex(row, column));
    });
    /**
     * Returns the row and column index for a given value
     */
    __publicField(this, "getValueCell", (value) => {
      const index = this.indexOf(value);
      if (index === -1) return null;
      const row = Math.floor(index / this.columnCount);
      const column = index % this.columnCount;
      return { row, column };
    });
    /**
     * Returns the value of the last enabled column in a row
     */
    __publicField(this, "getLastEnabledColumnIndex", (row) => {
      for (let col = this.columnCount - 1; col >= 0; col--) {
        const cell = this.getCell(row, col);
        if (cell && !this.getItemDisabled(cell)) {
          return col;
        }
      }
      return null;
    });
    /**
     * Returns the index of the first enabled column in a row
     */
    __publicField(this, "getFirstEnabledColumnIndex", (row) => {
      for (let col = 0; col < this.columnCount; col++) {
        const cell = this.getCell(row, col);
        if (cell && !this.getItemDisabled(cell)) {
          return col;
        }
      }
      return null;
    });
    /**
     * Returns the value of the previous row in the grid, based on the current value
     */
    __publicField(this, "getPreviousRowValue", (value, loop = false) => {
      const currentCell = this.getValueCell(value);
      if (currentCell === null) return null;
      const rows = this.getRows();
      const rowCount = this.getRowCount();
      let prevRowIndex = currentCell.row;
      let prevColumnIndex = currentCell.column;
      for (let i = 1; i <= rowCount; i++) {
        prevRowIndex = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.prevIndex)(rows, prevRowIndex, { loop });
        const prevRow = rows[prevRowIndex];
        if (!prevRow) continue;
        const prevCell = prevRow[prevColumnIndex];
        if (!prevCell) {
          const lastColumnIndex = this.getLastEnabledColumnIndex(prevRowIndex);
          if (lastColumnIndex != null) {
            prevColumnIndex = lastColumnIndex;
          }
        }
        const cell = this.getCell(prevRowIndex, prevColumnIndex);
        if (!this.getItemDisabled(cell)) {
          return this.getItemValue(cell);
        }
      }
      return this.firstValue;
    });
    /**
     * Returns the value of the next row in the grid, based on the current value
     */
    __publicField(this, "getNextRowValue", (value, loop = false) => {
      const currentCell = this.getValueCell(value);
      if (currentCell === null) return null;
      const rows = this.getRows();
      const rowCount = this.getRowCount();
      let nextRowIndex = currentCell.row;
      let nextColumnIndex = currentCell.column;
      for (let i = 1; i <= rowCount; i++) {
        nextRowIndex = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.nextIndex)(rows, nextRowIndex, { loop });
        const nextRow = rows[nextRowIndex];
        if (!nextRow) continue;
        const nextCell = nextRow[nextColumnIndex];
        if (!nextCell) {
          const lastColumnIndex = this.getLastEnabledColumnIndex(nextRowIndex);
          if (lastColumnIndex != null) {
            nextColumnIndex = lastColumnIndex;
          }
        }
        const cell = this.getCell(nextRowIndex, nextColumnIndex);
        if (!this.getItemDisabled(cell)) {
          return this.getItemValue(cell);
        }
      }
      return this.lastValue;
    });
    this.columnCount = columnCount;
  }
};
function isGridCollection(v) {
  return v instanceof GridCollection;
}

// src/tree-visit.ts
function access(node, indexPath, options) {
  for (let i = 0; i < indexPath.length; i++) node = options.getChildren(node, indexPath.slice(i + 1))[indexPath[i]];
  return node;
}
function ancestorIndexPaths(indexPaths) {
  const sortedPaths = sortIndexPaths(indexPaths);
  const result = [];
  const seen = /* @__PURE__ */ new Set();
  for (const indexPath of sortedPaths) {
    const key = indexPath.join();
    if (!seen.has(key)) {
      seen.add(key);
      result.push(indexPath);
    }
  }
  return result;
}
function compareIndexPaths(a, b) {
  for (let i = 0; i < Math.min(a.length, b.length); i++) {
    if (a[i] < b[i]) return -1;
    if (a[i] > b[i]) return 1;
  }
  return a.length - b.length;
}
function sortIndexPaths(indexPaths) {
  return indexPaths.sort(compareIndexPaths);
}
function find(node, options) {
  let found;
  visit(node, {
    ...options,
    onEnter: (child, indexPath) => {
      if (options.predicate(child, indexPath)) {
        found = child;
        return "stop";
      }
    }
  });
  return found;
}
function findIndexPath(node, options) {
  let found;
  visit(node, {
    onEnter: (child, indexPath) => {
      if (options.predicate(child, indexPath)) {
        found = [...indexPath];
        return "stop";
      }
    },
    getChildren: options.getChildren
  });
  return found;
}
function reduce(node, options) {
  let result = options.initialResult;
  visit(node, {
    ...options,
    onEnter: (child, indexPath) => {
      result = options.nextResult(result, child, indexPath);
    }
  });
  return result;
}
function flatMap(node, options) {
  return reduce(node, {
    ...options,
    initialResult: [],
    nextResult: (result, child, indexPath) => {
      result.push(...options.transform(child, indexPath));
      return result;
    }
  });
}
function insertOperation(index, nodes) {
  return { type: "insert", index, nodes };
}
function removeOperation(indexes) {
  return { type: "remove", indexes };
}
function replaceOperation() {
  return { type: "replace" };
}
function splitIndexPath(indexPath) {
  return [indexPath.slice(0, -1), indexPath[indexPath.length - 1]];
}
function getInsertionOperations(indexPath, nodes, operations = /* @__PURE__ */ new Map()) {
  const [parentIndexPath, index] = splitIndexPath(indexPath);
  for (let i = parentIndexPath.length - 1; i >= 0; i--) {
    const parentKey = parentIndexPath.slice(0, i).join();
    switch (operations.get(parentKey)?.type) {
      case "remove":
        continue;
    }
    operations.set(parentKey, replaceOperation());
  }
  const operation = operations.get(parentIndexPath.join());
  switch (operation?.type) {
    case "remove":
      operations.set(parentIndexPath.join(), {
        type: "removeThenInsert",
        removeIndexes: operation.indexes,
        insertIndex: index,
        insertNodes: nodes
      });
      break;
    default:
      operations.set(parentIndexPath.join(), insertOperation(index, nodes));
  }
  return operations;
}
function getRemovalOperations(indexPaths) {
  const operations = /* @__PURE__ */ new Map();
  const indexesToRemove = /* @__PURE__ */ new Map();
  for (const indexPath of indexPaths) {
    const parentKey = indexPath.slice(0, -1).join();
    const value = indexesToRemove.get(parentKey) ?? [];
    value.push(indexPath[indexPath.length - 1]);
    indexesToRemove.set(
      parentKey,
      value.sort((a, b) => a - b)
    );
  }
  for (const indexPath of indexPaths) {
    for (let i = indexPath.length - 2; i >= 0; i--) {
      const parentKey = indexPath.slice(0, i).join();
      if (!operations.has(parentKey)) {
        operations.set(parentKey, replaceOperation());
      }
    }
  }
  for (const [parentKey, indexes] of indexesToRemove) {
    operations.set(parentKey, removeOperation(indexes));
  }
  return operations;
}
function getReplaceOperations(indexPath, node) {
  const operations = /* @__PURE__ */ new Map();
  const [parentIndexPath, index] = splitIndexPath(indexPath);
  for (let i = parentIndexPath.length - 1; i >= 0; i--) {
    const parentKey = parentIndexPath.slice(0, i).join();
    operations.set(parentKey, replaceOperation());
  }
  operations.set(parentIndexPath.join(), {
    type: "removeThenInsert",
    removeIndexes: [index],
    insertIndex: index,
    insertNodes: [node]
  });
  return operations;
}
function mutate(node, operations, options) {
  return map(node, {
    ...options,
    getChildren: (node2, indexPath) => {
      const key = indexPath.join();
      const operation = operations.get(key);
      switch (operation?.type) {
        case "replace":
        case "remove":
        case "removeThenInsert":
        case "insert":
          return options.getChildren(node2, indexPath);
        default:
          return [];
      }
    },
    transform: (node2, children, indexPath) => {
      const key = indexPath.join();
      const operation = operations.get(key);
      switch (operation?.type) {
        case "remove":
          return options.create(
            node2,
            children.filter((_, index) => !operation.indexes.includes(index)),
            indexPath
          );
        case "removeThenInsert":
          const updatedChildren = children.filter((_, index) => !operation.removeIndexes.includes(index));
          const adjustedIndex = operation.removeIndexes.reduce(
            (index, removedIndex) => removedIndex < index ? index - 1 : index,
            operation.insertIndex
          );
          return options.create(node2, splice(updatedChildren, adjustedIndex, 0, ...operation.insertNodes), indexPath);
        case "insert":
          return options.create(node2, splice(children, operation.index, 0, ...operation.nodes), indexPath);
        case "replace":
          return options.create(node2, children, indexPath);
        default:
          return node2;
      }
    }
  });
}
function splice(array, start, deleteCount, ...items) {
  return [...array.slice(0, start), ...items, ...array.slice(start + deleteCount)];
}
function map(node, options) {
  const childrenMap = {};
  visit(node, {
    ...options,
    onLeave: (child, indexPath) => {
      const keyIndexPath = [0, ...indexPath];
      const key = keyIndexPath.join();
      const transformed = options.transform(child, childrenMap[key] ?? [], indexPath);
      const parentKey = keyIndexPath.slice(0, -1).join();
      const parentChildren = childrenMap[parentKey] ?? [];
      parentChildren.push(transformed);
      childrenMap[parentKey] = parentChildren;
    }
  });
  return childrenMap[""][0];
}
function insert2(node, options) {
  const { nodes, at } = options;
  if (at.length === 0) throw new Error(`Can't insert nodes at the root`);
  const state = getInsertionOperations(at, nodes);
  return mutate(node, state, options);
}
function replace(node, options) {
  if (options.at.length === 0) return options.node;
  const operations = getReplaceOperations(options.at, options.node);
  return mutate(node, operations, options);
}
function remove(node, options) {
  if (options.indexPaths.length === 0) return node;
  for (const indexPath of options.indexPaths) {
    if (indexPath.length === 0) throw new Error(`Can't remove the root node`);
  }
  const operations = getRemovalOperations(options.indexPaths);
  return mutate(node, operations, options);
}
function move2(node, options) {
  if (options.indexPaths.length === 0) return node;
  for (const indexPath of options.indexPaths) {
    if (indexPath.length === 0) throw new Error(`Can't move the root node`);
  }
  if (options.to.length === 0) throw new Error(`Can't move nodes to the root`);
  const _ancestorIndexPaths = ancestorIndexPaths(options.indexPaths);
  const nodesToInsert = _ancestorIndexPaths.map((indexPath) => access(node, indexPath, options));
  const operations = getInsertionOperations(options.to, nodesToInsert, getRemovalOperations(_ancestorIndexPaths));
  return mutate(node, operations, options);
}
function visit(node, options) {
  const { onEnter, onLeave, getChildren } = options;
  let indexPath = [];
  let stack = [{ node }];
  const getIndexPath = options.reuseIndexPath ? () => indexPath : () => indexPath.slice();
  while (stack.length > 0) {
    let wrapper = stack[stack.length - 1];
    if (wrapper.state === void 0) {
      const enterResult = onEnter?.(wrapper.node, getIndexPath());
      if (enterResult === "stop") return;
      wrapper.state = enterResult === "skip" ? -1 : 0;
    }
    const children = wrapper.children || getChildren(wrapper.node, getIndexPath());
    wrapper.children || (wrapper.children = children);
    if (wrapper.state !== -1) {
      if (wrapper.state < children.length) {
        let currentIndex = wrapper.state;
        indexPath.push(currentIndex);
        stack.push({ node: children[currentIndex] });
        wrapper.state = currentIndex + 1;
        continue;
      }
      const leaveResult = onLeave?.(wrapper.node, getIndexPath());
      if (leaveResult === "stop") return;
    }
    indexPath.pop();
    stack.pop();
  }
}

// src/tree-collection.ts
var TreeCollection = class {
  constructor(options) {
    this.options = options;
    __publicField(this, "rootNode");
    __publicField(this, "isEqual", (other) => {
      return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isEqual)(this.rootNode, other.rootNode);
    });
    __publicField(this, "getNodeChildren", (node) => {
      return this.options.nodeToChildren?.(node) ?? fallback2.nodeToChildren(node) ?? [];
    });
    __publicField(this, "getNodeValue", (node) => {
      return this.options.nodeToValue?.(node) ?? fallback2.nodeToValue(node);
    });
    __publicField(this, "getNodeDisabled", (node) => {
      return this.options.isNodeDisabled?.(node) ?? fallback2.isNodeDisabled(node);
    });
    __publicField(this, "stringify", (value) => {
      const node = this.findNode(value);
      if (!node) return null;
      return this.stringifyNode(node);
    });
    __publicField(this, "stringifyNode", (node) => {
      return this.options.nodeToString?.(node) ?? fallback2.nodeToString(node);
    });
    __publicField(this, "getFirstNode", (rootNode = this.rootNode) => {
      let firstChild;
      visit(rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          if (!firstChild && indexPath.length > 0 && !this.getNodeDisabled(node)) {
            firstChild = node;
            return "stop";
          }
        }
      });
      return firstChild;
    });
    __publicField(this, "getLastNode", (rootNode = this.rootNode, opts = {}) => {
      let lastChild;
      visit(rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          const nodeValue = this.getNodeValue(node);
          if (opts.skip?.({ value: nodeValue, node, indexPath })) return "skip";
          if (indexPath.length > 1) return "skip";
          if (!this.getNodeDisabled(node)) {
            lastChild = node;
          }
        }
      });
      return lastChild;
    });
    __publicField(this, "at", (indexPath) => {
      return access(this.rootNode, indexPath, {
        getChildren: this.getNodeChildren
      });
    });
    __publicField(this, "findNode", (value, rootNode = this.rootNode) => {
      return find(rootNode, {
        getChildren: this.getNodeChildren,
        predicate: (node) => this.getNodeValue(node) === value
      });
    });
    __publicField(this, "sort", (values) => {
      return values.reduce(
        (acc, value) => {
          const indexPath = this.getIndexPath(value);
          if (indexPath != null) acc.push({ value, indexPath });
          return acc;
        },
        []
      ).sort((a, b) => compareIndexPaths(a.indexPath, b.indexPath)).map(({ value }) => value);
    });
    __publicField(this, "getIndexPath", (value) => {
      return findIndexPath(this.rootNode, {
        getChildren: this.getNodeChildren,
        predicate: (node) => this.getNodeValue(node) === value
      });
    });
    __publicField(this, "getValue", (indexPath) => {
      const node = this.at(indexPath);
      return node ? this.getNodeValue(node) : void 0;
    });
    __publicField(this, "getValuePath", (indexPath) => {
      if (!indexPath) return [];
      const valuePath = [];
      let currentPath = [...indexPath];
      while (currentPath.length > 0) {
        const node = this.at(currentPath);
        if (node) valuePath.unshift(this.getNodeValue(node));
        currentPath.pop();
      }
      return valuePath;
    });
    __publicField(this, "getDepth", (value) => {
      const indexPath = findIndexPath(this.rootNode, {
        getChildren: this.getNodeChildren,
        predicate: (node) => this.getNodeValue(node) === value
      });
      return indexPath?.length ?? 0;
    });
    __publicField(this, "isRootNode", (node) => {
      return this.getNodeValue(node) === this.getNodeValue(this.rootNode);
    });
    __publicField(this, "contains", (parentIndexPath, valueIndexPath) => {
      if (!parentIndexPath || !valueIndexPath) return false;
      return valueIndexPath.slice(0, parentIndexPath.length).every((_, i) => parentIndexPath[i] === valueIndexPath[i]);
    });
    __publicField(this, "getNextNode", (value, opts = {}) => {
      let found = false;
      let nextNode;
      visit(this.rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          if (this.isRootNode(node)) return;
          const nodeValue = this.getNodeValue(node);
          if (opts.skip?.({ value: nodeValue, node, indexPath })) {
            if (nodeValue === value) {
              found = true;
            }
            return "skip";
          }
          if (found && !this.getNodeDisabled(node)) {
            nextNode = node;
            return "stop";
          }
          if (nodeValue === value) {
            found = true;
          }
        }
      });
      return nextNode;
    });
    __publicField(this, "getPreviousNode", (value, opts = {}) => {
      let previousNode;
      let found = false;
      visit(this.rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          if (this.isRootNode(node)) return;
          const nodeValue = this.getNodeValue(node);
          if (opts.skip?.({ value: nodeValue, node, indexPath })) {
            return "skip";
          }
          if (nodeValue === value) {
            found = true;
            return "stop";
          }
          if (!this.getNodeDisabled(node)) {
            previousNode = node;
          }
        }
      });
      return found ? previousNode : void 0;
    });
    __publicField(this, "getParentNodes", (values) => {
      const result = [];
      let indexPath = this.getIndexPath(values);
      while (indexPath && indexPath.length > 0) {
        indexPath.pop();
        const parentNode = this.at(indexPath);
        if (parentNode && !this.isRootNode(parentNode)) {
          result.unshift(parentNode);
        }
      }
      return result;
    });
    __publicField(this, "getParentIndexPath", (indexPath) => {
      return indexPath.slice(0, -1);
    });
    __publicField(this, "getParentNode", (valueOrIndexPath) => {
      const indexPath = typeof valueOrIndexPath === "string" ? this.getIndexPath(valueOrIndexPath) : valueOrIndexPath;
      return indexPath ? this.at(this.getParentIndexPath(indexPath)) : void 0;
    });
    __publicField(this, "visit", (opts) => {
      const { skip, ...rest } = opts;
      visit(this.rootNode, {
        ...rest,
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          if (this.isRootNode(node)) return;
          if (skip?.({ value: this.getNodeValue(node), node, indexPath })) return "skip";
          return rest.onEnter?.(node, indexPath);
        }
      });
    });
    __publicField(this, "getPreviousSibling", (indexPath) => {
      const parentNode = this.getParentNode(indexPath);
      if (!parentNode) return;
      const siblings = this.getNodeChildren(parentNode);
      let idx = siblings.findIndex((sibling) => this.getValue(indexPath) === this.getNodeValue(sibling));
      while (--idx >= 0) {
        const sibling = siblings[idx];
        if (!this.getNodeDisabled(sibling)) return sibling;
      }
      return;
    });
    __publicField(this, "getNextSibling", (indexPath) => {
      const parentNode = this.getParentNode(indexPath);
      if (!parentNode) return;
      const siblings = this.getNodeChildren(parentNode);
      let idx = siblings.findIndex((sibling) => this.getValue(indexPath) === this.getNodeValue(sibling));
      while (++idx < siblings.length) {
        const sibling = siblings[idx];
        if (!this.getNodeDisabled(sibling)) return sibling;
      }
      return;
    });
    __publicField(this, "getSiblingNodes", (indexPath) => {
      const parentNode = this.getParentNode(indexPath);
      return parentNode ? this.getNodeChildren(parentNode) : [];
    });
    __publicField(this, "getValues", (rootNode = this.rootNode) => {
      const values = flatMap(rootNode, {
        getChildren: this.getNodeChildren,
        transform: (node) => [this.getNodeValue(node)]
      });
      return values.slice(1);
    });
    __publicField(this, "isSameDepth", (indexPath, depth) => {
      if (depth == null) return true;
      return indexPath.length === depth;
    });
    __publicField(this, "isBranchNode", (node) => {
      return this.getNodeChildren(node).length > 0;
    });
    __publicField(this, "getBranchValues", (rootNode = this.rootNode, opts = {}) => {
      let values = [];
      visit(rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          const nodeValue = this.getNodeValue(node);
          if (opts.skip?.({ value: nodeValue, node, indexPath })) return "skip";
          if (this.getNodeChildren(node).length > 0 && this.isSameDepth(indexPath, opts.depth)) {
            values.push(this.getNodeValue(node));
          }
        }
      });
      return values.slice(1);
    });
    __publicField(this, "flatten", (rootNode = this.rootNode) => {
      const nodes = flatMap(rootNode, {
        getChildren: this.getNodeChildren,
        transform: (node, indexPath) => {
          const children = this.getNodeChildren(node).map((child) => this.getNodeValue(child));
          return [
            (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.compact)({
              label: this.stringifyNode(node),
              value: this.getNodeValue(node),
              indexPath,
              children: children.length > 0 ? children : void 0
            })
          ];
        }
      });
      return nodes.slice(1);
    });
    __publicField(this, "_create", (node, children) => {
      return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.compact)({ ...node, children });
    });
    __publicField(this, "_insert", (rootNode, indexPath, nodes) => {
      return insert2(rootNode, { at: indexPath, nodes, getChildren: this.getNodeChildren, create: this._create });
    });
    __publicField(this, "_replace", (rootNode, indexPath, node) => {
      return replace(rootNode, { at: indexPath, node, getChildren: this.getNodeChildren, create: this._create });
    });
    __publicField(this, "_move", (rootNode, indexPaths, to) => {
      return move2(rootNode, { indexPaths, to, getChildren: this.getNodeChildren, create: this._create });
    });
    __publicField(this, "_remove", (rootNode, indexPaths) => {
      return remove(rootNode, { indexPaths, getChildren: this.getNodeChildren, create: this._create });
    });
    __publicField(this, "replace", (indexPath, node) => {
      return this._replace(this.rootNode, indexPath, node);
    });
    __publicField(this, "remove", (indexPaths) => {
      return this._remove(this.rootNode, indexPaths);
    });
    __publicField(this, "insertBefore", (indexPath, nodes) => {
      const parentNode = this.getParentNode(indexPath);
      return parentNode ? this._insert(this.rootNode, indexPath, nodes) : void 0;
    });
    __publicField(this, "insertAfter", (indexPath, nodes) => {
      const parentNode = this.getParentNode(indexPath);
      if (!parentNode) return;
      const nextIndex2 = [...indexPath.slice(0, -1), indexPath[indexPath.length - 1] + 1];
      return this._insert(this.rootNode, nextIndex2, nodes);
    });
    __publicField(this, "move", (fromIndexPaths, toIndexPath) => {
      return this._move(this.rootNode, fromIndexPaths, toIndexPath);
    });
    __publicField(this, "toJSON", () => {
      return this.getValues(this.rootNode);
    });
    this.rootNode = options.rootNode;
  }
};
function flattenedToTree(nodes) {
  let rootNode = {
    value: "ROOT"
  };
  nodes.map((node) => {
    const { indexPath, label, value } = node;
    if (!indexPath.length) {
      Object.assign(rootNode, { label, value, children: [] });
      return;
    }
    rootNode = insert2(rootNode, {
      at: indexPath,
      nodes: [(0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.compact)({ label, value })],
      getChildren: (node2) => node2.children ?? [],
      create: (node2, children) => {
        return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.compact)({ ...node2, children });
      }
    });
  });
  return new TreeCollection({ rootNode });
}
function filePathToTree(paths) {
  const rootNode = {
    label: "",
    value: "ROOT",
    children: []
  };
  paths.forEach((path) => {
    const parts = path.split("/");
    let currentNode = rootNode;
    parts.forEach((part) => {
      let childNode = currentNode.children?.find((child) => child.label === part);
      if (!childNode) {
        childNode = {
          value: parts.slice(0, parts.indexOf(part) + 1).join("/"),
          label: part
        };
        currentNode.children || (currentNode.children = []);
        currentNode.children.push(childNode);
      }
      currentNode = childNode;
    });
  });
  return new TreeCollection({ rootNode });
}
var fallback2 = {
  nodeToValue(node) {
    if (typeof node === "string") return node;
    if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(node) && (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.hasProp)(node, "value")) return node.value;
    return "";
  },
  nodeToString(node) {
    if (typeof node === "string") return node;
    if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(node) && (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.hasProp)(node, "label")) return node.label;
    return fallback2.nodeToValue(node);
  },
  isNodeDisabled(node) {
    if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(node) && (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.hasProp)(node, "disabled")) return !!node.disabled;
    return false;
  },
  nodeToChildren(node) {
    return node.children;
  }
};
var Selection = class _Selection extends Set {
  constructor(values = []) {
    super(values);
    __publicField(this, "selectionMode", "single");
    __publicField(this, "deselectable", true);
    __publicField(this, "copy", () => {
      const clone = new _Selection([...this]);
      return this.sync(clone);
    });
    __publicField(this, "sync", (other) => {
      other.selectionMode = this.selectionMode;
      other.deselectable = this.deselectable;
      return other;
    });
    __publicField(this, "isEmpty", () => {
      return this.size === 0;
    });
    __publicField(this, "isSelected", (value) => {
      if (this.selectionMode === "none" || value == null) {
        return false;
      }
      return this.has(value);
    });
    __publicField(this, "canSelect", (collection, value) => {
      return this.selectionMode !== "none" || !collection.getItemDisabled(collection.find(value));
    });
    __publicField(this, "firstSelectedValue", (collection) => {
      let firstValue = null;
      for (let value of this) {
        if (!firstValue || collection.compareValue(value, firstValue) < 0) {
          firstValue = value;
        }
      }
      return firstValue;
    });
    __publicField(this, "lastSelectedValue", (collection) => {
      let lastValue = null;
      for (let value of this) {
        if (!lastValue || collection.compareValue(value, lastValue) > 0) {
          lastValue = value;
        }
      }
      return lastValue;
    });
    __publicField(this, "extendSelection", (collection, anchorValue, targetValue) => {
      if (this.selectionMode === "none") {
        return this;
      }
      if (this.selectionMode === "single") {
        return this.replaceSelection(collection, targetValue);
      }
      const selection = this.copy();
      const lastSelected = Array.from(this).pop();
      for (let key of collection.getValueRange(anchorValue, lastSelected ?? targetValue)) {
        selection.delete(key);
      }
      for (let key of collection.getValueRange(targetValue, anchorValue)) {
        if (this.canSelect(collection, key)) {
          selection.add(key);
        }
      }
      return selection;
    });
    __publicField(this, "toggleSelection", (collection, value) => {
      if (this.selectionMode === "none") {
        return this;
      }
      if (this.selectionMode === "single" && !this.isSelected(value)) {
        return this.replaceSelection(collection, value);
      }
      const selection = this.copy();
      if (selection.has(value)) {
        selection.delete(value);
      } else if (selection.canSelect(collection, value)) {
        selection.add(value);
      }
      return selection;
    });
    __publicField(this, "replaceSelection", (collection, value) => {
      if (this.selectionMode === "none") {
        return this;
      }
      if (value == null) {
        return this;
      }
      if (!this.canSelect(collection, value)) {
        return this;
      }
      const selection = new _Selection([value]);
      return this.sync(selection);
    });
    __publicField(this, "setSelection", (values) => {
      if (this.selectionMode === "none") {
        return this;
      }
      let selection = new _Selection();
      for (let value of values) {
        if (value != null) {
          selection.add(value);
          if (this.selectionMode === "single") {
            break;
          }
        }
      }
      return this.sync(selection);
    });
    __publicField(this, "clearSelection", () => {
      const selection = this.copy();
      if (selection.deselectable && selection.size > 0) {
        selection.clear();
      }
      return selection;
    });
    __publicField(this, "select", (collection, value, forceToggle) => {
      if (this.selectionMode === "none") {
        return this;
      }
      if (this.selectionMode === "single") {
        if (this.isSelected(value) && this.deselectable) {
          return this.toggleSelection(collection, value);
        } else {
          return this.replaceSelection(collection, value);
        }
      } else if (this.selectionMode === "multiple" || forceToggle) {
        return this.toggleSelection(collection, value);
      } else {
        return this.replaceSelection(collection, value);
      }
    });
    __publicField(this, "deselect", (value) => {
      const selection = this.copy();
      selection.delete(value);
      return selection;
    });
    __publicField(this, "isEqual", (other) => {
      return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isEqual)(Array.from(this), Array.from(other));
    });
  }
};




/***/ }),

/***/ "./node_modules/@zag-js/color-picker/dist/index.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@zag-js/color-picker/dist/index.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anatomy: () => (/* binding */ anatomy),
/* harmony export */   areaProps: () => (/* binding */ areaProps),
/* harmony export */   channelProps: () => (/* binding */ channelProps),
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   machine: () => (/* binding */ machine),
/* harmony export */   parse: () => (/* binding */ parse),
/* harmony export */   props: () => (/* binding */ props),
/* harmony export */   splitAreaProps: () => (/* binding */ splitAreaProps),
/* harmony export */   splitChannelProps: () => (/* binding */ splitChannelProps),
/* harmony export */   splitProps: () => (/* binding */ splitProps),
/* harmony export */   splitSwatchProps: () => (/* binding */ splitSwatchProps),
/* harmony export */   splitSwatchTriggerProps: () => (/* binding */ splitSwatchTriggerProps),
/* harmony export */   splitTransparencyGridProps: () => (/* binding */ splitTransparencyGridProps),
/* harmony export */   swatchProps: () => (/* binding */ swatchProps),
/* harmony export */   swatchTriggerProps: () => (/* binding */ swatchTriggerProps),
/* harmony export */   transparencyGridProps: () => (/* binding */ transparencyGridProps)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
/* harmony import */ var _zag_js_color_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/color-utils */ "./node_modules/@zag-js/color-utils/dist/index.mjs");
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_popper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/popper */ "./node_modules/@zag-js/popper/dist/index.mjs");
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _zag_js_dismissable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @zag-js/dismissable */ "./node_modules/@zag-js/dismissable/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");









// src/color-picker.anatomy.ts
var anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("color-picker", [
  "root",
  "label",
  "control",
  "trigger",
  "positioner",
  "content",
  "area",
  "areaThumb",
  "valueText",
  "areaBackground",
  "channelSlider",
  "channelSliderLabel",
  "channelSliderTrack",
  "channelSliderThumb",
  "channelSliderValueText",
  "channelInput",
  "transparencyGrid",
  "swatchGroup",
  "swatchTrigger",
  "swatchIndicator",
  "swatch",
  "eyeDropperTrigger",
  "formatTrigger",
  "formatSelect"
]);
var parts = anatomy.build();
var getRootId = (ctx) => ctx.ids?.root ?? `color-picker:${ctx.id}`;
var getLabelId = (ctx) => ctx.ids?.label ?? `color-picker:${ctx.id}:label`;
var getHiddenInputId = (ctx) => ctx.ids?.hiddenInput ?? `color-picker:${ctx.id}:hidden-input`;
var getControlId = (ctx) => ctx.ids?.control ?? `color-picker:${ctx.id}:control`;
var getTriggerId = (ctx) => ctx.ids?.trigger ?? `color-picker:${ctx.id}:trigger`;
var getContentId = (ctx) => ctx.ids?.content ?? `color-picker:${ctx.id}:content`;
var getPositionerId = (ctx) => ctx.ids?.positioner ?? `color-picker:${ctx.id}:positioner`;
var getFormatSelectId = (ctx) => ctx.ids?.formatSelect ?? `color-picker:${ctx.id}:format-select`;
var getAreaId = (ctx) => ctx.ids?.area ?? `color-picker:${ctx.id}:area`;
var getAreaGradientId = (ctx) => ctx.ids?.areaGradient ?? `color-picker:${ctx.id}:area-gradient`;
var getAreaThumbId = (ctx) => ctx.ids?.areaThumb ?? `color-picker:${ctx.id}:area-thumb`;
var getChannelSliderTrackId = (ctx, channel) => ctx.ids?.channelSliderTrack?.(channel) ?? `color-picker:${ctx.id}:slider-track:${channel}`;
var getChannelSliderThumbId = (ctx, channel) => ctx.ids?.channelSliderThumb?.(channel) ?? `color-picker:${ctx.id}:slider-thumb:${channel}`;
var getContentEl = (ctx) => ctx.getById(getContentId(ctx));
var getAreaThumbEl = (ctx) => ctx.getById(getAreaThumbId(ctx));
var getChannelSliderThumbEl = (ctx, channel) => ctx.getById(getChannelSliderThumbId(ctx, channel));
var getFormatSelectEl = (ctx) => ctx.getById(getFormatSelectId(ctx));
var getHiddenInputEl = (ctx) => ctx.getById(getHiddenInputId(ctx));
var getAreaEl = (ctx) => ctx.getById(getAreaId(ctx));
var getAreaValueFromPoint = (ctx, point) => {
  const areaEl = getAreaEl(ctx);
  if (!areaEl) return;
  const { percent } = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getRelativePoint)(point, areaEl);
  return percent;
};
var getControlEl = (ctx) => ctx.getById(getControlId(ctx));
var getTriggerEl = (ctx) => ctx.getById(getTriggerId(ctx));
var getPositionerEl = (ctx) => ctx.getById(getPositionerId(ctx));
var getChannelSliderTrackEl = (ctx, channel) => ctx.getById(getChannelSliderTrackId(ctx, channel));
var getChannelSliderValueFromPoint = (ctx, point, channel) => {
  const trackEl = getChannelSliderTrackEl(ctx, channel);
  if (!trackEl) return;
  const { percent } = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getRelativePoint)(point, trackEl);
  return percent;
};
var getChannelInputEls = (ctx) => {
  return [
    ...(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.queryAll)(getContentEl(ctx), "input[data-channel]"),
    ...(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.queryAll)(getControlEl(ctx), "input[data-channel]")
  ];
};
function getChannelDisplayColor(color, channel) {
  switch (channel) {
    case "hue":
      return (0,_zag_js_color_utils__WEBPACK_IMPORTED_MODULE_2__.parseColor)(`hsl(${color.getChannelValue("hue")}, 100%, 50%)`);
    case "lightness":
    case "brightness":
    case "saturation":
    case "red":
    case "green":
    case "blue":
      return color.withChannelValue("alpha", 1);
    case "alpha": {
      return color;
    }
    default:
      throw new Error("Unknown color channel: " + channel);
  }
}
function getChannelValue(color, channel) {
  if (channel == null) return "";
  if (channel === "hex") {
    return color.toString("hex");
  }
  if (channel === "css") {
    return color.toString("css");
  }
  if (channel in color) {
    return color.getChannelValue(channel).toString();
  }
  const isHSL = color.getFormat() === "hsla";
  switch (channel) {
    case "hue":
      return isHSL ? color.toFormat("hsla").getChannelValue("hue").toString() : color.toFormat("hsba").getChannelValue("hue").toString();
    case "saturation":
      return isHSL ? color.toFormat("hsla").getChannelValue("saturation").toString() : color.toFormat("hsba").getChannelValue("saturation").toString();
    case "lightness":
      return color.toFormat("hsla").getChannelValue("lightness").toString();
    case "brightness":
      return color.toFormat("hsba").getChannelValue("brightness").toString();
    case "red":
    case "green":
    case "blue":
      return color.toFormat("rgba").getChannelValue(channel).toString();
    default:
      return color.getChannelValue(channel).toString();
  }
}
function getChannelRange(color, channel) {
  switch (channel) {
    case "hex":
      const minColor = (0,_zag_js_color_utils__WEBPACK_IMPORTED_MODULE_2__.parseColor)("#000000");
      const maxColor = (0,_zag_js_color_utils__WEBPACK_IMPORTED_MODULE_2__.parseColor)("#FFFFFF");
      return {
        minValue: minColor.toHexInt(),
        maxValue: maxColor.toHexInt(),
        pageSize: 10,
        step: 1
      };
    case "css":
      return void 0;
    case "hue":
    case "saturation":
    case "lightness":
      return color.toFormat("hsla").getChannelRange(channel);
    case "brightness":
      return color.toFormat("hsba").getChannelRange(channel);
    case "red":
    case "green":
    case "blue":
      return color.toFormat("rgba").getChannelRange(channel);
    default:
      return color.getChannelRange(channel);
  }
}

// src/utils/get-slider-background.ts
function getSliderBackgroundDirection(orientation, dir) {
  if (orientation === "vertical") {
    return "top";
  } else if (dir === "ltr") {
    return "right";
  } else {
    return "left";
  }
}
var getSliderBackground = (props2) => {
  const { channel, value, dir, orientation } = props2;
  const bgDirection = getSliderBackgroundDirection(orientation, dir);
  const { minValue, maxValue } = value.getChannelRange(channel);
  switch (channel) {
    case "hue":
      return `linear-gradient(to ${bgDirection}, rgb(255, 0, 0) 0%, rgb(255, 255, 0) 17%, rgb(0, 255, 0) 33%, rgb(0, 255, 255) 50%, rgb(0, 0, 255) 67%, rgb(255, 0, 255) 83%, rgb(255, 0, 0) 100%)`;
    case "lightness": {
      let start = value.withChannelValue(channel, minValue).toString("css");
      let middle = value.withChannelValue(channel, (maxValue - minValue) / 2).toString("css");
      let end = value.withChannelValue(channel, maxValue).toString("css");
      return `linear-gradient(to ${bgDirection}, ${start}, ${middle}, ${end})`;
    }
    case "saturation":
    case "brightness":
    case "red":
    case "green":
    case "blue":
    case "alpha": {
      let start = value.withChannelValue(channel, minValue).toString("css");
      let end = value.withChannelValue(channel, maxValue).toString("css");
      return `linear-gradient(to ${bgDirection}, ${start}, ${end})`;
    }
    default:
      throw new Error("Unknown color channel: " + channel);
  }
};

// src/color-picker.connect.ts
function connect(service, normalize) {
  const { context, send, prop, computed, state, scope } = service;
  const value = context.get("value");
  const format = context.get("format");
  const areaValue = computed("areaValue");
  const valueAsString = computed("valueAsString");
  const disabled = computed("disabled");
  const interactive = computed("interactive");
  const dragging = state.hasTag("dragging");
  const open = state.hasTag("open");
  const focused = state.hasTag("focused");
  const getAreaChannels = (props2) => {
    const channels = areaValue.getChannels();
    return {
      xChannel: props2.xChannel ?? channels[1],
      yChannel: props2.yChannel ?? channels[2]
    };
  };
  const currentPlacement = context.get("currentPlacement");
  const popperStyles = (0,_zag_js_popper__WEBPACK_IMPORTED_MODULE_3__.getPlacementStyles)({
    ...prop("positioning"),
    placement: currentPlacement
  });
  function getSwatchTriggerState(props2) {
    const color = (0,_zag_js_color_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeColor)(props2.value).toFormat(context.get("format"));
    return {
      value: color,
      valueAsString: color.toString("hex"),
      checked: color.isEqual(value),
      disabled: props2.disabled || !interactive
    };
  }
  return {
    dragging,
    open,
    valueAsString,
    value,
    setOpen(nextOpen) {
      const open2 = state.hasTag("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    setValue(value2) {
      send({ type: "VALUE.SET", value: (0,_zag_js_color_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeColor)(value2), src: "set-color" });
    },
    getChannelValue(channel) {
      return getChannelValue(value, channel);
    },
    getChannelValueText(channel, locale) {
      return value.formatChannelValue(channel, locale);
    },
    setChannelValue(channel, channelValue) {
      const color = value.withChannelValue(channel, channelValue);
      send({ type: "VALUE.SET", value: color, src: "set-channel" });
    },
    format: context.get("format"),
    setFormat(format2) {
      const formatValue = value.toFormat(format2);
      send({ type: "VALUE.SET", value: formatValue, src: "set-format" });
    },
    alpha: value.getChannelValue("alpha"),
    setAlpha(alphaValue) {
      const color = value.withChannelValue("alpha", alphaValue);
      send({ type: "VALUE.SET", value: color, src: "set-alpha" });
    },
    getRootProps() {
      return normalize.element({
        ...parts.root.attrs,
        dir: prop("dir"),
        id: getRootId(scope),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("readOnly")),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("invalid")),
        style: {
          "--value": value.toString("css")
        }
      });
    },
    getLabelProps() {
      return normalize.element({
        ...parts.label.attrs,
        dir: prop("dir"),
        id: getLabelId(scope),
        htmlFor: getHiddenInputId(scope),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("readOnly")),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("invalid")),
        "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(focused),
        onClick(event) {
          event.preventDefault();
          const inputEl = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.query)(getControlEl(scope), "[data-channel=hex]");
          inputEl?.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts.control.attrs,
        id: getControlId(scope),
        dir: prop("dir"),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("readOnly")),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("invalid")),
        "data-state": open ? "open" : "closed",
        "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(focused)
      });
    },
    getTriggerProps() {
      return normalize.button({
        ...parts.trigger.attrs,
        id: getTriggerId(scope),
        dir: prop("dir"),
        disabled,
        "aria-label": `select color. current color is ${valueAsString}`,
        "aria-controls": getContentId(scope),
        "aria-labelledby": getLabelId(scope),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("readOnly")),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("invalid")),
        "data-placement": currentPlacement,
        "aria-expanded": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(open),
        "data-state": open ? "open" : "closed",
        "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(focused),
        type: "button",
        onClick() {
          if (!interactive) return;
          send({ type: "TRIGGER.CLICK" });
        },
        onBlur() {
          if (!interactive) return;
          send({ type: "TRIGGER.BLUR" });
        },
        style: {
          position: "relative"
        }
      });
    },
    getPositionerProps() {
      return normalize.element({
        ...parts.positioner.attrs,
        id: getPositionerId(scope),
        dir: prop("dir"),
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize.element({
        ...parts.content.attrs,
        id: getContentId(scope),
        dir: prop("dir"),
        tabIndex: -1,
        "data-placement": currentPlacement,
        "data-state": open ? "open" : "closed",
        hidden: !open
      });
    },
    getValueTextProps() {
      return normalize.element({
        ...parts.valueText.attrs,
        dir: prop("dir"),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(focused)
      });
    },
    getAreaProps(props2 = {}) {
      const { xChannel, yChannel } = getAreaChannels(props2);
      const { areaStyles } = (0,_zag_js_color_utils__WEBPACK_IMPORTED_MODULE_2__.getColorAreaGradient)(areaValue, {
        xChannel,
        yChannel,
        dir: prop("dir")
      });
      return normalize.element({
        ...parts.area.attrs,
        id: getAreaId(scope),
        role: "group",
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("invalid")),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("readOnly")),
        onPointerDown(event) {
          if (!interactive) return;
          if (!(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isLeftClick)(event)) return;
          if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isModifierKey)(event)) return;
          const point = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventPoint)(event);
          const channel = { xChannel, yChannel };
          send({ type: "AREA.POINTER_DOWN", point, channel, id: "area" });
          event.preventDefault();
        },
        style: {
          position: "relative",
          touchAction: "none",
          forcedColorAdjust: "none",
          ...areaStyles
        }
      });
    },
    getAreaBackgroundProps(props2 = {}) {
      const { xChannel, yChannel } = getAreaChannels(props2);
      const { areaGradientStyles } = (0,_zag_js_color_utils__WEBPACK_IMPORTED_MODULE_2__.getColorAreaGradient)(areaValue, {
        xChannel,
        yChannel,
        dir: prop("dir")
      });
      return normalize.element({
        ...parts.areaBackground.attrs,
        id: getAreaGradientId(scope),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("invalid")),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("readOnly")),
        style: {
          position: "relative",
          touchAction: "none",
          forcedColorAdjust: "none",
          ...areaGradientStyles
        }
      });
    },
    getAreaThumbProps(props2 = {}) {
      const { xChannel, yChannel } = getAreaChannels(props2);
      const channel = { xChannel, yChannel };
      const xPercent = areaValue.getChannelValuePercent(xChannel);
      const yPercent = 1 - areaValue.getChannelValuePercent(yChannel);
      const xValue = areaValue.getChannelValue(xChannel);
      const yValue = areaValue.getChannelValue(yChannel);
      const color = areaValue.withChannelValue("alpha", 1).toString("css");
      return normalize.element({
        ...parts.areaThumb.attrs,
        id: getAreaThumbId(scope),
        dir: prop("dir"),
        tabIndex: disabled ? void 0 : 0,
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("invalid")),
        "data-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("readOnly")),
        role: "slider",
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuenow": xValue,
        "aria-label": `${xChannel} and ${yChannel}`,
        "aria-roledescription": "2d slider",
        "aria-valuetext": `${xChannel} ${xValue}, ${yChannel} ${yValue}`,
        style: {
          position: "absolute",
          left: `${xPercent * 100}%`,
          top: `${yPercent * 100}%`,
          transform: "translate(-50%, -50%)",
          touchAction: "none",
          forcedColorAdjust: "none",
          "--color": color,
          background: color
        },
        onFocus() {
          if (!interactive) return;
          send({ type: "AREA.FOCUS", id: "area", channel });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const step = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventStep)(event);
          const keyMap = {
            ArrowUp() {
              send({ type: "AREA.ARROW_UP", channel, step });
            },
            ArrowDown() {
              send({ type: "AREA.ARROW_DOWN", channel, step });
            },
            ArrowLeft() {
              send({ type: "AREA.ARROW_LEFT", channel, step });
            },
            ArrowRight() {
              send({ type: "AREA.ARROW_RIGHT", channel, step });
            },
            PageUp() {
              send({ type: "AREA.PAGE_UP", channel, step });
            },
            PageDown() {
              send({ type: "AREA.PAGE_DOWN", channel, step });
            },
            Escape(event2) {
              event2.stopPropagation();
            }
          };
          const exec = keyMap[(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventKey)(event, {
            dir: prop("dir")
          })];
          if (exec) {
            exec(event);
            event.preventDefault();
          }
        }
      });
    },
    getTransparencyGridProps(props2 = {}) {
      const { size = "12px" } = props2;
      return normalize.element({
        ...parts.transparencyGrid.attrs,
        style: {
          "--size": size,
          width: "100%",
          height: "100%",
          position: "absolute",
          backgroundColor: "#fff",
          backgroundImage: "conic-gradient(#eeeeee 0 25%, transparent 0 50%, #eeeeee 0 75%, transparent 0)",
          backgroundSize: "var(--size) var(--size)",
          inset: "0px",
          zIndex: "auto",
          pointerEvents: "none"
        }
      });
    },
    getChannelSliderProps(props2) {
      const { orientation = "horizontal", channel, format: format2 } = props2;
      return normalize.element({
        ...parts.channelSlider.attrs,
        "data-channel": channel,
        "data-orientation": orientation,
        role: "presentation",
        onPointerDown(event) {
          if (!interactive) return;
          if (!(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isLeftClick)(event)) return;
          if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isModifierKey)(event)) return;
          const point = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventPoint)(event);
          send({ type: "CHANNEL_SLIDER.POINTER_DOWN", channel, format: format2, point, id: channel, orientation });
          event.preventDefault();
        },
        style: {
          position: "relative",
          touchAction: "none"
        }
      });
    },
    getChannelSliderTrackProps(props2) {
      const { orientation = "horizontal", channel, format: format2 } = props2;
      const normalizedValue = format2 ? value.toFormat(format2) : areaValue;
      return normalize.element({
        ...parts.channelSliderTrack.attrs,
        id: getChannelSliderTrackId(scope, channel),
        role: "group",
        "data-channel": channel,
        "data-orientation": orientation,
        style: {
          position: "relative",
          forcedColorAdjust: "none",
          backgroundImage: getSliderBackground({
            orientation,
            channel,
            dir: prop("dir"),
            value: normalizedValue
          })
        }
      });
    },
    getChannelSliderLabelProps(props2) {
      const { channel } = props2;
      return normalize.element({
        ...parts.channelSliderLabel.attrs,
        "data-channel": channel,
        onClick(event) {
          if (!interactive) return;
          event.preventDefault();
          const thumbId = getChannelSliderThumbId(scope, channel);
          scope.getById(thumbId)?.focus({ preventScroll: true });
        },
        style: {
          userSelect: "none",
          WebkitUserSelect: "none"
        }
      });
    },
    getChannelSliderValueTextProps(props2) {
      return normalize.element({
        ...parts.channelSliderValueText.attrs,
        "data-channel": props2.channel
      });
    },
    getChannelSliderThumbProps(props2) {
      const { orientation = "horizontal", channel, format: format2 } = props2;
      const normalizedValue = format2 ? value.toFormat(format2) : areaValue;
      const channelRange = normalizedValue.getChannelRange(channel);
      const channelValue = normalizedValue.getChannelValue(channel);
      const offset = (channelValue - channelRange.minValue) / (channelRange.maxValue - channelRange.minValue);
      const placementStyles = orientation === "horizontal" ? { left: `${offset * 100}%`, top: "50%" } : { top: `${offset * 100}%`, left: "50%" };
      return normalize.element({
        ...parts.channelSliderThumb.attrs,
        id: getChannelSliderThumbId(scope, channel),
        role: "slider",
        "aria-label": channel,
        tabIndex: disabled ? void 0 : 0,
        "data-channel": channel,
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-orientation": orientation,
        "aria-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "aria-orientation": orientation,
        "aria-valuemax": channelRange.maxValue,
        "aria-valuemin": channelRange.minValue,
        "aria-valuenow": channelValue,
        "aria-valuetext": `${channel} ${channelValue}`,
        style: {
          forcedColorAdjust: "none",
          position: "absolute",
          background: getChannelDisplayColor(areaValue, channel).toString("css"),
          ...placementStyles
        },
        onFocus() {
          if (!interactive) return;
          send({ type: "CHANNEL_SLIDER.FOCUS", channel });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const step = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventStep)(event) * channelRange.step;
          const keyMap = {
            ArrowUp() {
              send({ type: "CHANNEL_SLIDER.ARROW_UP", channel, step });
            },
            ArrowDown() {
              send({ type: "CHANNEL_SLIDER.ARROW_DOWN", channel, step });
            },
            ArrowLeft() {
              send({ type: "CHANNEL_SLIDER.ARROW_LEFT", channel, step });
            },
            ArrowRight() {
              send({ type: "CHANNEL_SLIDER.ARROW_RIGHT", channel, step });
            },
            PageUp() {
              send({ type: "CHANNEL_SLIDER.PAGE_UP", channel });
            },
            PageDown() {
              send({ type: "CHANNEL_SLIDER.PAGE_DOWN", channel });
            },
            Home() {
              send({ type: "CHANNEL_SLIDER.HOME", channel });
            },
            End() {
              send({ type: "CHANNEL_SLIDER.END", channel });
            },
            Escape(event2) {
              event2.stopPropagation();
            }
          };
          const exec = keyMap[(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventKey)(event, {
            dir: prop("dir")
          })];
          if (exec) {
            exec(event);
            event.preventDefault();
          }
        }
      });
    },
    getChannelInputProps(props2) {
      const { channel } = props2;
      const isTextField = channel === "hex" || channel === "css";
      const channelRange = getChannelRange(value, channel);
      return normalize.input({
        ...parts.channelInput.attrs,
        dir: prop("dir"),
        type: isTextField ? "text" : "number",
        "data-channel": channel,
        "aria-label": channel,
        spellCheck: false,
        autoComplete: "off",
        disabled,
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("invalid")),
        "data-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("readOnly")),
        readOnly: prop("readOnly"),
        defaultValue: getChannelValue(value, channel),
        min: channelRange?.minValue,
        max: channelRange?.maxValue,
        step: channelRange?.step,
        onBeforeInput(event) {
          if (isTextField || !interactive) return;
          const value2 = event.currentTarget.value;
          if (value2.match(/[^0-9.]/g)) {
            event.preventDefault();
          }
        },
        onFocus(event) {
          if (!interactive) return;
          send({ type: "CHANNEL_INPUT.FOCUS", channel });
          event.currentTarget.select();
        },
        onBlur(event) {
          if (!interactive) return;
          const value2 = isTextField ? event.currentTarget.value : event.currentTarget.valueAsNumber;
          send({ type: "CHANNEL_INPUT.BLUR", channel, value: value2, isTextField });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          if (event.key === "Enter") {
            const value2 = isTextField ? event.currentTarget.value : event.currentTarget.valueAsNumber;
            send({ type: "CHANNEL_INPUT.CHANGE", channel, value: value2, isTextField });
            event.preventDefault();
          }
        },
        style: {
          appearance: "none",
          WebkitAppearance: "none",
          MozAppearance: "textfield"
        }
      });
    },
    getHiddenInputProps() {
      return normalize.input({
        type: "text",
        disabled,
        name: prop("name"),
        tabIndex: -1,
        readOnly: prop("readOnly"),
        required: prop("required"),
        id: getHiddenInputId(scope),
        style: _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.visuallyHiddenStyle,
        defaultValue: valueAsString
      });
    },
    getEyeDropperTriggerProps() {
      return normalize.button({
        ...parts.eyeDropperTrigger.attrs,
        type: "button",
        dir: prop("dir"),
        disabled,
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("invalid")),
        "data-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("readOnly")),
        "aria-label": "Pick a color from the screen",
        onClick() {
          if (!interactive) return;
          send({ type: "EYEDROPPER.CLICK" });
        }
      });
    },
    getSwatchGroupProps() {
      return normalize.element({
        ...parts.swatchGroup.attrs,
        role: "group"
      });
    },
    getSwatchTriggerState,
    getSwatchTriggerProps(props2) {
      const swatchState = getSwatchTriggerState(props2);
      return normalize.button({
        ...parts.swatchTrigger.attrs,
        disabled: swatchState.disabled,
        dir: prop("dir"),
        type: "button",
        "aria-label": `select ${swatchState.valueAsString} as the color`,
        "data-state": swatchState.checked ? "checked" : "unchecked",
        "data-value": swatchState.valueAsString,
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(swatchState.disabled),
        onClick() {
          if (swatchState.disabled) return;
          send({ type: "SWATCH_TRIGGER.CLICK", value: swatchState.value });
        },
        style: {
          "--color": swatchState.valueAsString,
          position: "relative"
        }
      });
    },
    getSwatchIndicatorProps(props2) {
      const swatchState = getSwatchTriggerState(props2);
      return normalize.element({
        ...parts.swatchIndicator.attrs,
        dir: prop("dir"),
        hidden: !swatchState.checked
      });
    },
    getSwatchProps(props2) {
      const { respectAlpha = true } = props2;
      const swatchState = getSwatchTriggerState(props2);
      const color = swatchState.value.toString(respectAlpha ? "css" : "hex");
      return normalize.element({
        ...parts.swatch.attrs,
        dir: prop("dir"),
        "data-state": swatchState.checked ? "checked" : "unchecked",
        "data-value": swatchState.valueAsString,
        style: {
          "--color": color,
          position: "relative",
          background: color
        }
      });
    },
    getFormatTriggerProps() {
      return normalize.button({
        ...parts.formatTrigger.attrs,
        dir: prop("dir"),
        type: "button",
        "aria-label": `change color format to ${getNextFormat(format)}`,
        onClick(event) {
          if (event.currentTarget.disabled) return;
          const nextFormat = getNextFormat(format);
          send({ type: "FORMAT.SET", format: nextFormat, src: "format-trigger" });
        }
      });
    },
    getFormatSelectProps() {
      return normalize.select({
        ...parts.formatSelect.attrs,
        "aria-label": "change color format",
        dir: prop("dir"),
        defaultValue: prop("format"),
        disabled,
        onChange(event) {
          const format2 = assertFormat(event.currentTarget.value);
          send({ type: "FORMAT.SET", format: format2, src: "format-select" });
        }
      });
    }
  };
}
var formats = ["hsba", "hsla", "rgba"];
var formatRegex = new RegExp(`^(${formats.join("|")})$`);
function getNextFormat(format) {
  const index = formats.indexOf(format);
  return formats[index + 1] ?? formats[0];
}
function assertFormat(format) {
  if (formatRegex.test(format)) return format;
  throw new Error(`Unsupported color format: ${format}`);
}
var parse = (colorString) => {
  return (0,_zag_js_color_utils__WEBPACK_IMPORTED_MODULE_2__.parseColor)(colorString);
};

// src/color-picker.machine.ts
var { and } = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_4__.createGuards)();
var machine = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_4__.createMachine)({
  props({ props: props2 }) {
    return {
      dir: "ltr",
      defaultValue: parse("#000000"),
      defaultFormat: "rgba",
      openAutoFocus: true,
      ...props2,
      positioning: {
        placement: "bottom",
        ...props2.positioning
      }
    };
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "idle";
  },
  context({ prop, bindable, getContext }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        isEqual(a, b) {
          return a.toString("css") === b?.toString("css");
        },
        hash(a) {
          return a.toString("css");
        },
        onChange(value) {
          const ctx = getContext();
          const valueAsString = value.toString(ctx.get("format"));
          prop("onValueChange")?.({ value, valueAsString });
        }
      })),
      format: bindable(() => ({
        defaultValue: prop("defaultFormat"),
        value: prop("format"),
        onChange(format) {
          prop("onFormatChange")?.({ format });
        }
      })),
      activeId: bindable(() => ({ defaultValue: null })),
      activeChannel: bindable(() => ({ defaultValue: null })),
      activeOrientation: bindable(() => ({ defaultValue: null })),
      fieldsetDisabled: bindable(() => ({ defaultValue: false })),
      restoreFocus: bindable(() => ({ defaultValue: true })),
      currentPlacement: bindable(() => ({
        defaultValue: void 0
      }))
    };
  },
  computed: {
    rtl: ({ prop }) => prop("dir") === "rtl",
    disabled: ({ prop, context }) => !!prop("disabled") || context.get("fieldsetDisabled"),
    interactive: ({ prop }) => !(prop("disabled") || prop("readOnly")),
    valueAsString: ({ context }) => context.get("value").toString(context.get("format")),
    areaValue: ({ context }) => {
      const format = context.get("format").startsWith("hsl") ? "hsla" : "hsba";
      return context.get("value").toFormat(format);
    }
  },
  effects: ["trackFormControl"],
  watch({ prop, context, action, track }) {
    track([() => context.hash("value")], () => {
      action(["syncInputElements", "dispatchChangeEvent"]);
    });
    track([() => context.get("format")], () => {
      action(["syncFormatSelectElement"]);
    });
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  on: {
    "VALUE.SET": {
      actions: ["setValue"]
    },
    "FORMAT.SET": {
      actions: ["setFormat"]
    },
    "CHANNEL_INPUT.CHANGE": {
      actions: ["setChannelColorFromInput"]
    },
    "EYEDROPPER.CLICK": {
      actions: ["openEyeDropper"]
    },
    "SWATCH_TRIGGER.CLICK": {
      actions: ["setValue"]
    }
  },
  states: {
    idle: {
      tags: ["closed"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open",
          actions: ["setInitialFocus"]
        },
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen", "setInitialFocus"]
          }
        ],
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen", "setInitialFocus"]
          }
        ],
        "CHANNEL_INPUT.FOCUS": {
          target: "focused",
          actions: ["setActiveChannel"]
        }
      }
    },
    focused: {
      tags: ["closed", "focused"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open",
          actions: ["setInitialFocus"]
        },
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen", "setInitialFocus"]
          }
        ],
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen", "setInitialFocus"]
          }
        ],
        "CHANNEL_INPUT.FOCUS": {
          actions: ["setActiveChannel"]
        },
        "CHANNEL_INPUT.BLUR": {
          target: "idle",
          actions: ["setChannelColorFromInput"]
        },
        "TRIGGER.BLUR": {
          target: "idle"
        }
      }
    },
    open: {
      tags: ["open"],
      effects: ["trackPositioning", "trackDismissableElement"],
      on: {
        "CONTROLLED.CLOSE": [
          {
            guard: "shouldRestoreFocus",
            target: "focused",
            actions: ["setReturnFocus"]
          },
          {
            target: "idle"
          }
        ],
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "idle",
            actions: ["invokeOnClose"]
          }
        ],
        "AREA.POINTER_DOWN": {
          target: "open:dragging",
          actions: ["setActiveChannel", "setAreaColorFromPoint", "focusAreaThumb"]
        },
        "AREA.FOCUS": {
          actions: ["setActiveChannel"]
        },
        "CHANNEL_SLIDER.POINTER_DOWN": {
          target: "open:dragging",
          actions: ["setActiveChannel", "setChannelColorFromPoint", "focusChannelThumb"]
        },
        "CHANNEL_SLIDER.FOCUS": {
          actions: ["setActiveChannel"]
        },
        "AREA.ARROW_LEFT": {
          actions: ["decrementAreaXChannel"]
        },
        "AREA.ARROW_RIGHT": {
          actions: ["incrementAreaXChannel"]
        },
        "AREA.ARROW_UP": {
          actions: ["incrementAreaYChannel"]
        },
        "AREA.ARROW_DOWN": {
          actions: ["decrementAreaYChannel"]
        },
        "AREA.PAGE_UP": {
          actions: ["incrementAreaXChannel"]
        },
        "AREA.PAGE_DOWN": {
          actions: ["decrementAreaXChannel"]
        },
        "CHANNEL_SLIDER.ARROW_LEFT": {
          actions: ["decrementChannel"]
        },
        "CHANNEL_SLIDER.ARROW_RIGHT": {
          actions: ["incrementChannel"]
        },
        "CHANNEL_SLIDER.ARROW_UP": {
          actions: ["incrementChannel"]
        },
        "CHANNEL_SLIDER.ARROW_DOWN": {
          actions: ["decrementChannel"]
        },
        "CHANNEL_SLIDER.PAGE_UP": {
          actions: ["incrementChannel"]
        },
        "CHANNEL_SLIDER.PAGE_DOWN": {
          actions: ["decrementChannel"]
        },
        "CHANNEL_SLIDER.HOME": {
          actions: ["setChannelToMin"]
        },
        "CHANNEL_SLIDER.END": {
          actions: ["setChannelToMax"]
        },
        "CHANNEL_INPUT.BLUR": {
          actions: ["setChannelColorFromInput"]
        },
        INTERACT_OUTSIDE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            guard: "shouldRestoreFocus",
            target: "focused",
            actions: ["invokeOnClose", "setReturnFocus"]
          },
          {
            target: "idle",
            actions: ["invokeOnClose"]
          }
        ],
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "idle",
            actions: ["invokeOnClose"]
          }
        ],
        "SWATCH_TRIGGER.CLICK": [
          {
            guard: and("isOpenControlled", "closeOnSelect"),
            actions: ["setValue", "invokeOnClose"]
          },
          {
            guard: "closeOnSelect",
            target: "focused",
            actions: ["setValue", "invokeOnClose", "setReturnFocus"]
          },
          {
            actions: ["setValue"]
          }
        ]
      }
    },
    "open:dragging": {
      tags: ["open"],
      exit: ["clearActiveChannel"],
      effects: ["trackPointerMove", "disableTextSelection", "trackPositioning", "trackDismissableElement"],
      on: {
        "CONTROLLED.CLOSE": [
          {
            guard: "shouldRestoreFocus",
            target: "focused",
            actions: ["setReturnFocus"]
          },
          {
            target: "idle"
          }
        ],
        "AREA.POINTER_MOVE": {
          actions: ["setAreaColorFromPoint", "focusAreaThumb"]
        },
        "AREA.POINTER_UP": {
          target: "open",
          actions: ["invokeOnChangeEnd"]
        },
        "CHANNEL_SLIDER.POINTER_MOVE": {
          actions: ["setChannelColorFromPoint", "focusChannelThumb"]
        },
        "CHANNEL_SLIDER.POINTER_UP": {
          target: "open",
          actions: ["invokeOnChangeEnd"]
        },
        INTERACT_OUTSIDE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            guard: "shouldRestoreFocus",
            target: "focused",
            actions: ["invokeOnClose", "setReturnFocus"]
          },
          {
            target: "idle",
            actions: ["invokeOnClose"]
          }
        ],
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "idle",
            actions: ["invokeOnClose"]
          }
        ]
      }
    }
  },
  implementations: {
    guards: {
      closeOnSelect: ({ prop }) => !!prop("closeOnSelect"),
      isOpenControlled: ({ prop }) => prop("open") != null,
      shouldRestoreFocus: ({ context }) => !!context.get("restoreFocus")
    },
    effects: {
      trackPositioning({ context, prop, scope }) {
        if (!context.get("currentPlacement")) {
          context.set("currentPlacement", prop("positioning")?.placement);
        }
        const anchorEl = getTriggerEl(scope);
        const getPositionerEl2 = () => getPositionerEl(scope);
        return (0,_zag_js_popper__WEBPACK_IMPORTED_MODULE_3__.getPlacement)(anchorEl, getPositionerEl2, {
          ...prop("positioning"),
          defer: true,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      trackDismissableElement({ context, scope, prop, send }) {
        const getContentEl2 = () => getContentEl(scope);
        return (0,_zag_js_dismissable__WEBPACK_IMPORTED_MODULE_5__.trackDismissableElement)(getContentEl2, {
          exclude: getTriggerEl(scope),
          defer: true,
          onInteractOutside(event) {
            prop("onInteractOutside")?.(event);
            if (event.defaultPrevented) return;
            context.set("restoreFocus", !(event.detail.focusable || event.detail.contextmenu));
          },
          onPointerDownOutside: prop("onPointerDownOutside"),
          onFocusOutside: prop("onFocusOutside"),
          onDismiss() {
            send({ type: "INTERACT_OUTSIDE" });
          }
        });
      },
      trackFormControl({ context, scope, send }) {
        const inputEl = getHiddenInputEl(scope);
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.trackFormControl)(inputEl, {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            send({ type: "VALUE.SET", value: context.initial("value"), src: "form.reset" });
          }
        });
      },
      trackPointerMove({ context, scope, event, send }) {
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.trackPointerMove)(scope.getDoc(), {
          onPointerMove({ point }) {
            const type = context.get("activeId") === "area" ? "AREA.POINTER_MOVE" : "CHANNEL_SLIDER.POINTER_MOVE";
            send({ type, point, format: event.format });
          },
          onPointerUp() {
            const type = context.get("activeId") === "area" ? "AREA.POINTER_UP" : "CHANNEL_SLIDER.POINTER_UP";
            send({ type });
          }
        });
      },
      disableTextSelection({ scope }) {
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.disableTextSelection)({
          doc: scope.getDoc(),
          target: getContentEl(scope)
        });
      }
    },
    actions: {
      openEyeDropper({ scope, context }) {
        const win = scope.getWin();
        const isSupported = "EyeDropper" in win;
        if (!isSupported) return;
        const picker = new win.EyeDropper();
        picker.open().then(({ sRGBHex }) => {
          const format = context.get("value").getFormat();
          const color = (0,_zag_js_color_utils__WEBPACK_IMPORTED_MODULE_2__.parseColor)(sRGBHex).toFormat(format);
          context.set("value", color);
        }).catch(() => void 0);
      },
      setActiveChannel({ context, event }) {
        context.set("activeId", event.id);
        if (event.channel) context.set("activeChannel", event.channel);
        if (event.orientation) context.set("activeOrientation", event.orientation);
      },
      clearActiveChannel({ context }) {
        context.set("activeChannel", null);
        context.set("activeId", null);
        context.set("activeOrientation", null);
      },
      setAreaColorFromPoint({ context, event, computed, scope }) {
        const v = event.format ? context.get("value").toFormat(event.format) : computed("areaValue");
        const { xChannel, yChannel } = event.channel || context.get("activeChannel");
        const percent = getAreaValueFromPoint(scope, event.point);
        if (!percent) return;
        const xValue = v.getChannelPercentValue(xChannel, percent.x);
        const yValue = v.getChannelPercentValue(yChannel, 1 - percent.y);
        const color = v.withChannelValue(xChannel, xValue).withChannelValue(yChannel, yValue);
        context.set("value", color);
      },
      setChannelColorFromPoint({ context, event, computed, scope }) {
        const channel = event.channel || context.get("activeId");
        const normalizedValue = event.format ? context.get("value").toFormat(event.format) : computed("areaValue");
        const percent = getChannelSliderValueFromPoint(scope, event.point, channel);
        if (!percent) return;
        const orientation = context.get("activeOrientation") || "horizontal";
        const channelPercent = orientation === "horizontal" ? percent.x : percent.y;
        const value = normalizedValue.getChannelPercentValue(channel, channelPercent);
        const color = normalizedValue.withChannelValue(channel, value);
        context.set("value", color);
      },
      setValue({ context, event }) {
        context.set("value", event.value);
      },
      setFormat({ context, event }) {
        context.set("format", event.format);
      },
      dispatchChangeEvent({ scope, computed }) {
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dispatchInputValueEvent)(getHiddenInputEl(scope), { value: computed("valueAsString") });
      },
      syncInputElements({ context, scope }) {
        syncChannelInputs(scope, context.get("value"));
      },
      invokeOnChangeEnd({ context, prop, computed }) {
        prop("onValueChangeEnd")?.({
          value: context.get("value"),
          valueAsString: computed("valueAsString")
        });
      },
      setChannelColorFromInput({ context, event, scope }) {
        const { channel, isTextField, value } = event;
        const currentAlpha = context.get("value").getChannelValue("alpha");
        let color;
        if (channel === "alpha") {
          let valueAsNumber = parseFloat(value);
          valueAsNumber = Number.isNaN(valueAsNumber) ? currentAlpha : valueAsNumber;
          color = context.get("value").withChannelValue("alpha", valueAsNumber);
        } else if (isTextField) {
          color = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_6__.tryCatch)(
            () => parse(value).withChannelValue("alpha", currentAlpha),
            () => context.get("value")
          );
        } else {
          const current = context.get("value").toFormat(context.get("format"));
          const valueAsNumber = Number.isNaN(value) ? current.getChannelValue(channel) : value;
          color = current.withChannelValue(channel, valueAsNumber);
        }
        syncChannelInputs(scope, context.get("value"), color);
        context.set("value", color);
      },
      incrementChannel({ context, event }) {
        const color = context.get("value").incrementChannel(event.channel, event.step);
        context.set("value", color);
      },
      decrementChannel({ context, event }) {
        const color = context.get("value").decrementChannel(event.channel, event.step);
        context.set("value", color);
      },
      incrementAreaXChannel({ context, event, computed }) {
        const { xChannel } = event.channel;
        const color = computed("areaValue").incrementChannel(xChannel, event.step);
        context.set("value", color);
      },
      decrementAreaXChannel({ context, event, computed }) {
        const { xChannel } = event.channel;
        const color = computed("areaValue").decrementChannel(xChannel, event.step);
        context.set("value", color);
      },
      incrementAreaYChannel({ context, event, computed }) {
        const { yChannel } = event.channel;
        const color = computed("areaValue").incrementChannel(yChannel, event.step);
        context.set("value", color);
      },
      decrementAreaYChannel({ context, event, computed }) {
        const { yChannel } = event.channel;
        const color = computed("areaValue").decrementChannel(yChannel, event.step);
        context.set("value", color);
      },
      setChannelToMax({ context, event }) {
        const value = context.get("value");
        const range = value.getChannelRange(event.channel);
        const color = value.withChannelValue(event.channel, range.maxValue);
        context.set("value", color);
      },
      setChannelToMin({ context, event }) {
        const value = context.get("value");
        const range = value.getChannelRange(event.channel);
        const color = value.withChannelValue(event.channel, range.minValue);
        context.set("value", color);
      },
      focusAreaThumb({ scope }) {
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => {
          getAreaThumbEl(scope)?.focus({ preventScroll: true });
        });
      },
      focusChannelThumb({ event, scope }) {
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => {
          getChannelSliderThumbEl(scope, event.channel)?.focus({ preventScroll: true });
        });
      },
      setInitialFocus({ prop, scope }) {
        if (!prop("openAutoFocus")) return;
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => {
          const element = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getInitialFocus)({
            root: getContentEl(scope),
            getInitialEl: prop("initialFocusEl")
          });
          element?.focus({ preventScroll: true });
        });
      },
      setReturnFocus({ scope }) {
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => {
          getTriggerEl(scope)?.focus({ preventScroll: true });
        });
      },
      syncFormatSelectElement({ context, scope }) {
        syncFormatSelect(scope, context.get("format"));
      },
      invokeOnOpen({ prop }) {
        prop("onOpenChange")?.({ open: true });
      },
      invokeOnClose({ prop }) {
        prop("onOpenChange")?.({ open: false });
      },
      toggleVisibility({ prop, event, send }) {
        send({ type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: event });
      }
    }
  }
});
function syncChannelInputs(scope, currentValue, nextValue) {
  const channelInputEls = getChannelInputEls(scope);
  (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => {
    channelInputEls.forEach((inputEl) => {
      const channel = inputEl.dataset.channel;
      (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.setElementValue)(inputEl, getChannelValue(nextValue || currentValue, channel));
    });
  });
}
function syncFormatSelect(scope, format) {
  const selectEl = getFormatSelectEl(scope);
  if (!selectEl) return;
  (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.setElementValue)(selectEl, format));
}
var props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_7__.createProps)()([
  "closeOnSelect",
  "dir",
  "disabled",
  "format",
  "defaultFormat",
  "getRootNode",
  "id",
  "ids",
  "initialFocusEl",
  "name",
  "positioning",
  "onFocusOutside",
  "onFormatChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onValueChange",
  "onValueChangeEnd",
  "defaultOpen",
  "open",
  "positioning",
  "required",
  "readOnly",
  "value",
  "defaultValue",
  "invalid",
  "openAutoFocus"
]);
var splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_6__.createSplitProps)(props);
var areaProps = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_7__.createProps)()(["xChannel", "yChannel"]);
var splitAreaProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_6__.createSplitProps)(areaProps);
var channelProps = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_7__.createProps)()(["channel", "orientation"]);
var splitChannelProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_6__.createSplitProps)(channelProps);
var swatchTriggerProps = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_7__.createProps)()(["value", "disabled"]);
var splitSwatchTriggerProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_6__.createSplitProps)(swatchTriggerProps);
var swatchProps = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_7__.createProps)()(["value", "respectAlpha"]);
var splitSwatchProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_6__.createSplitProps)(swatchProps);
var transparencyGridProps = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_7__.createProps)()(["size"]);
var splitTransparencyGridProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_6__.createSplitProps)(transparencyGridProps);




/***/ }),

/***/ "./node_modules/@zag-js/color-utils/dist/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@zag-js/color-utils/dist/index.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Color: () => (/* binding */ Color),
/* harmony export */   getColorAreaGradient: () => (/* binding */ getColorAreaGradient),
/* harmony export */   normalizeColor: () => (/* binding */ normalizeColor),
/* harmony export */   parseColor: () => (/* binding */ parseColor)
/* harmony export */ });
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");


var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, key + "" , value);

// src/color-format-gradient.ts
var generateRGB_R = (orientation, dir, zValue) => {
  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
  const result = {
    areaStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,0),rgb(${zValue},255,0))`
    },
    areaGradientStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,255),rgb(${zValue},255,255))`,
      WebkitMaskImage: maskImage,
      maskImage
    }
  };
  return result;
};
var generateRGB_G = (orientation, dir, zValue) => {
  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
  const result = {
    areaStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},0),rgb(255,${zValue},0))`
    },
    areaGradientStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},255),rgb(255,${zValue},255))`,
      WebkitMaskImage: maskImage,
      maskImage
    }
  };
  return result;
};
var generateRGB_B = (orientation, dir, zValue) => {
  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
  const result = {
    areaStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,0,${zValue}),rgb(255,0,${zValue}))`
    },
    areaGradientStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,255,${zValue}),rgb(255,255,${zValue}))`,
      WebkitMaskImage: maskImage,
      maskImage
    }
  };
  return result;
};
var generateHSL_H = (orientation, dir, zValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(dir)]}, hsla(0,0%,0%,1) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,1) 100%)`,
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,50%),hsla(0,0%,50%,0))`,
        `hsl(${zValue}, 100%, 50%)`
      ].join(",")
    }
  };
  return result;
};
var generateHSL_S = (orientation, dir, alphaValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(!dir)]}, hsla(0,0%,0%,${alphaValue}) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,${alphaValue}) 100%)`,
        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
        "hsl(0, 0%, 50%)"
      ].join(",")
    }
  };
  return result;
};
var generateHSL_L = (orientation, dir, zValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      backgroundImage: [
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,${zValue}%),hsla(0,0%,${zValue}%,0))`,
        `linear-gradient(to ${orientation[Number(dir)]},hsl(0,100%,${zValue}%),hsl(60,100%,${zValue}%),hsl(120,100%,${zValue}%),hsl(180,100%,${zValue}%),hsl(240,100%,${zValue}%),hsl(300,100%,${zValue}%),hsl(360,100%,${zValue}%))`
      ].join(",")
    }
  };
  return result;
};
var generateHSB_H = (orientation, dir, zValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(dir)]},hsl(0,0%,0%),hsla(0,0%,0%,0))`,
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,100%),hsla(0,0%,100%,0))`,
        `hsl(${zValue}, 100%, 50%)`
      ].join(",")
    }
  };
  return result;
};
var generateHSB_S = (orientation, dir, alphaValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,0%,${alphaValue}),hsla(0,0%,0%,0))`,
        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,0%),hsl(0,0%,100%))`
      ].join(",")
    }
  };
  return result;
};
var generateHSB_B = (orientation, dir, alphaValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,100%,${alphaValue}),hsla(0,0%,100%,0))`,
        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
        "#000"
      ].join(",")
    }
  };
  return result;
};

// src/area-gradient.ts
function getColorAreaGradient(color, options) {
  const { xChannel, yChannel, dir: dirProp = "ltr" } = options;
  const { zChannel } = color.getColorAxes({ xChannel, yChannel });
  const zValue = color.getChannelValue(zChannel);
  const { minValue: zMin, maxValue: zMax } = color.getChannelRange(zChannel);
  const orientation = ["top", dirProp === "rtl" ? "left" : "right"];
  let dir = false;
  let background = { areaStyles: {}, areaGradientStyles: {} };
  let alphaValue = (zValue - zMin) / (zMax - zMin);
  let isHSL = color.getFormat() === "hsla";
  switch (zChannel) {
    case "red": {
      dir = xChannel === "green";
      background = generateRGB_R(orientation, dir, zValue);
      break;
    }
    case "green": {
      dir = xChannel === "red";
      background = generateRGB_G(orientation, dir, zValue);
      break;
    }
    case "blue": {
      dir = xChannel === "red";
      background = generateRGB_B(orientation, dir, zValue);
      break;
    }
    case "hue": {
      dir = xChannel !== "saturation";
      if (isHSL) {
        background = generateHSL_H(orientation, dir, zValue);
      } else {
        background = generateHSB_H(orientation, dir, zValue);
      }
      break;
    }
    case "saturation": {
      dir = xChannel === "hue";
      if (isHSL) {
        background = generateHSL_S(orientation, dir, alphaValue);
      } else {
        background = generateHSB_S(orientation, dir, alphaValue);
      }
      break;
    }
    case "brightness": {
      dir = xChannel === "hue";
      background = generateHSB_B(orientation, dir, alphaValue);
      break;
    }
    case "lightness": {
      dir = xChannel === "hue";
      background = generateHSL_L(orientation, dir, zValue);
      break;
    }
  }
  return background;
}
var isEqualObject = (a, b) => {
  if (Object.keys(a).length !== Object.keys(b).length) return false;
  for (let key in a) if (a[key] !== b[key]) return false;
  return true;
};
var Color = class {
  toHexInt() {
    return this.toFormat("rgba").toHexInt();
  }
  getChannelValue(channel) {
    if (channel in this) return this[channel];
    throw new Error("Unsupported color channel: " + channel);
  }
  getChannelValuePercent(channel, valueToCheck) {
    const value = valueToCheck ?? this.getChannelValue(channel);
    const { minValue, maxValue } = this.getChannelRange(channel);
    return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.getValuePercent)(value, minValue, maxValue);
  }
  getChannelPercentValue(channel, percentToCheck) {
    const { minValue, maxValue, step } = this.getChannelRange(channel);
    const percentValue = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.getPercentValue)(percentToCheck, minValue, maxValue, step);
    return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.snapValueToStep)(percentValue, minValue, maxValue, step);
  }
  withChannelValue(channel, value) {
    const { minValue, maxValue } = this.getChannelRange(channel);
    if (channel in this) {
      let clone = this.clone();
      clone[channel] = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.clampValue)(value, minValue, maxValue);
      return clone;
    }
    throw new Error("Unsupported color channel: " + channel);
  }
  getColorAxes(xyChannels) {
    let { xChannel, yChannel } = xyChannels;
    let xCh = xChannel || this.getChannels().find((c) => c !== yChannel);
    let yCh = yChannel || this.getChannels().find((c) => c !== xCh);
    let zCh = this.getChannels().find((c) => c !== xCh && c !== yCh);
    return { xChannel: xCh, yChannel: yCh, zChannel: zCh };
  }
  incrementChannel(channel, stepSize) {
    const { minValue, maxValue, step } = this.getChannelRange(channel);
    const value = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.snapValueToStep)(
      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.clampValue)(this.getChannelValue(channel) + stepSize, minValue, maxValue),
      minValue,
      maxValue,
      step
    );
    return this.withChannelValue(channel, value);
  }
  decrementChannel(channel, stepSize) {
    return this.incrementChannel(channel, -stepSize);
  }
  isEqual(color) {
    const isSame = isEqualObject(this.toJSON(), color.toJSON());
    return isSame && this.getChannelValue("alpha") === color.getChannelValue("alpha");
  }
};
var _RGBColor = class _RGBColor extends Color {
  constructor(red, green, blue, alpha) {
    super();
    this.red = red;
    this.green = green;
    this.blue = blue;
    this.alpha = alpha;
  }
  static parse(value) {
    let colors = [];
    if (/^#[\da-f]+$/i.test(value) && [4, 5, 7, 9].includes(value.length)) {
      const values = (value.length < 6 ? value.replace(/[^#]/gi, "$&$&") : value).slice(1).split("");
      while (values.length > 0) {
        colors.push(parseInt(values.splice(0, 2).join(""), 16));
      }
      colors[3] = colors[3] !== void 0 ? colors[3] / 255 : void 0;
    }
    const match = value.match(/^rgba?\((.*)\)$/);
    if (match?.[1]) {
      colors = match[1].split(",").map((value2) => Number(value2.trim())).map((num, i) => (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.clampValue)(num, 0, i < 3 ? 255 : 1));
    }
    return colors.length < 3 ? void 0 : new _RGBColor(colors[0], colors[1], colors[2], colors[3] ?? 1);
  }
  toString(format) {
    switch (format) {
      case "hex":
        return "#" + (this.red.toString(16).padStart(2, "0") + this.green.toString(16).padStart(2, "0") + this.blue.toString(16).padStart(2, "0")).toUpperCase();
      case "hexa":
        return "#" + (this.red.toString(16).padStart(2, "0") + this.green.toString(16).padStart(2, "0") + this.blue.toString(16).padStart(2, "0") + Math.round(this.alpha * 255).toString(16).padStart(2, "0")).toUpperCase();
      case "rgb":
        return `rgb(${this.red}, ${this.green}, ${this.blue})`;
      case "css":
      case "rgba":
        return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;
      case "hsl":
        return this.toHSL().toString("hsl");
      case "hsb":
        return this.toHSB().toString("hsb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "rgba":
        return this;
      case "hsba":
        return this.toHSB();
      case "hsla":
        return this.toHSL();
      default:
        throw new Error("Unsupported color conversion: rgb -> " + format);
    }
  }
  toHexInt() {
    return this.red << 16 | this.green << 8 | this.blue;
  }
  /**
   * Converts an RGB color value to HSB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.
   * @returns An HSBColor object.
   */
  toHSB() {
    const red = this.red / 255;
    const green = this.green / 255;
    const blue = this.blue / 255;
    const min = Math.min(red, green, blue);
    const brightness = Math.max(red, green, blue);
    const chroma = brightness - min;
    const saturation = brightness === 0 ? 0 : chroma / brightness;
    let hue = 0;
    if (chroma !== 0) {
      switch (brightness) {
        case red:
          hue = (green - blue) / chroma + (green < blue ? 6 : 0);
          break;
        case green:
          hue = (blue - red) / chroma + 2;
          break;
        case blue:
          hue = (red - green) / chroma + 4;
          break;
      }
      hue /= 6;
    }
    return new HSBColor(
      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(hue * 360, 2),
      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(saturation * 100, 2),
      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(brightness * 100, 2),
      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.alpha, 2)
    );
  }
  /**
   * Converts an RGB color value to HSL.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.
   * @returns An HSLColor object.
   */
  toHSL() {
    const red = this.red / 255;
    const green = this.green / 255;
    const blue = this.blue / 255;
    const min = Math.min(red, green, blue);
    const max = Math.max(red, green, blue);
    const lightness = (max + min) / 2;
    const chroma = max - min;
    let hue = -1;
    let saturation = -1;
    if (chroma === 0) {
      hue = saturation = 0;
    } else {
      saturation = chroma / (lightness < 0.5 ? max + min : 2 - max - min);
      switch (max) {
        case red:
          hue = (green - blue) / chroma + (green < blue ? 6 : 0);
          break;
        case green:
          hue = (blue - red) / chroma + 2;
          break;
        case blue:
          hue = (red - green) / chroma + 4;
          break;
      }
      hue /= 6;
    }
    return new HSLColor(
      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(hue * 360, 2),
      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(saturation * 100, 2),
      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(lightness * 100, 2),
      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.alpha, 2)
    );
  }
  clone() {
    return new _RGBColor(this.red, this.green, this.blue, this.alpha);
  }
  getChannelFormatOptions(channel) {
    switch (channel) {
      case "red":
      case "green":
      case "blue":
        return { style: "decimal" };
      case "alpha":
        return { style: "percent" };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  formatChannelValue(channel, locale) {
    let options = this.getChannelFormatOptions(channel);
    let value = this.getChannelValue(channel);
    return new Intl.NumberFormat(locale, options).format(value);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "red":
      case "green":
      case "blue":
        return { minValue: 0, maxValue: 255, step: 1, pageSize: 17 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { r: this.red, g: this.green, b: this.blue, a: this.alpha };
  }
  getFormat() {
    return "rgba";
  }
  getChannels() {
    return _RGBColor.colorChannels;
  }
};
__publicField(_RGBColor, "colorChannels", ["red", "green", "blue"]);
var RGBColor = _RGBColor;

// src/hsl-color.ts
var HSL_REGEX = /hsl\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%)\)|hsla\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d(.\d+)?)\)/;
var _HSLColor = class _HSLColor extends Color {
  constructor(hue, saturation, lightness, alpha) {
    super();
    this.hue = hue;
    this.saturation = saturation;
    this.lightness = lightness;
    this.alpha = alpha;
  }
  static parse(value) {
    let m;
    if (m = value.match(HSL_REGEX)) {
      const [h, s, l, a] = (m[1] ?? m[2]).split(",").map((n) => Number(n.trim().replace("%", "")));
      return new _HSLColor((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.mod)(h, 360), (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.clampValue)(s, 0, 100), (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.clampValue)(l, 0, 100), (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.clampValue)(a ?? 1, 0, 1));
    }
  }
  toString(format) {
    switch (format) {
      case "hex":
        return this.toRGB().toString("hex");
      case "hexa":
        return this.toRGB().toString("hexa");
      case "hsl":
        return `hsl(${this.hue}, ${(0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.saturation, 2)}%, ${(0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.lightness, 2)}%)`;
      case "css":
      case "hsla":
        return `hsla(${this.hue}, ${(0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.saturation, 2)}%, ${(0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.lightness, 2)}%, ${this.alpha})`;
      case "hsb":
        return this.toHSB().toString("hsb");
      case "rgb":
        return this.toRGB().toString("rgb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "hsla":
        return this;
      case "hsba":
        return this.toHSB();
      case "rgba":
        return this.toRGB();
      default:
        throw new Error("Unsupported color conversion: hsl -> " + format);
    }
  }
  /**
   * Converts a HSL color to HSB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_HSV.
   * @returns An HSBColor object.
   */
  toHSB() {
    let saturation = this.saturation / 100;
    let lightness = this.lightness / 100;
    let brightness = lightness + saturation * Math.min(lightness, 1 - lightness);
    saturation = brightness === 0 ? 0 : 2 * (1 - lightness / brightness);
    return new HSBColor(
      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.hue, 2),
      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(saturation * 100, 2),
      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(brightness * 100, 2),
      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.alpha, 2)
    );
  }
  /**
   * Converts a HSL color to RGB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative.
   * @returns An RGBColor object.
   */
  toRGB() {
    let hue = this.hue;
    let saturation = this.saturation / 100;
    let lightness = this.lightness / 100;
    let a = saturation * Math.min(lightness, 1 - lightness);
    let fn = (n, k = (n + hue / 30) % 12) => lightness - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return new RGBColor(
      Math.round(fn(0) * 255),
      Math.round(fn(8) * 255),
      Math.round(fn(4) * 255),
      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.alpha, 2)
    );
  }
  clone() {
    return new _HSLColor(this.hue, this.saturation, this.lightness, this.alpha);
  }
  getChannelFormatOptions(channel) {
    switch (channel) {
      case "hue":
        return { style: "unit", unit: "degree", unitDisplay: "narrow" };
      case "saturation":
      case "lightness":
      case "alpha":
        return { style: "percent" };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  formatChannelValue(channel, locale) {
    let options = this.getChannelFormatOptions(channel);
    let value = this.getChannelValue(channel);
    if (channel === "saturation" || channel === "lightness") {
      value /= 100;
    }
    return new Intl.NumberFormat(locale, options).format(value);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "hue":
        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };
      case "saturation":
      case "lightness":
        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { h: this.hue, s: this.saturation, l: this.lightness, a: this.alpha };
  }
  getFormat() {
    return "hsla";
  }
  getChannels() {
    return _HSLColor.colorChannels;
  }
};
__publicField(_HSLColor, "colorChannels", ["hue", "saturation", "lightness"]);
var HSLColor = _HSLColor;

// src/hsb-color.ts
var HSB_REGEX = /hsb\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%)\)|hsba\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d(.\d+)?)\)/;
var _HSBColor = class _HSBColor extends Color {
  constructor(hue, saturation, brightness, alpha) {
    super();
    this.hue = hue;
    this.saturation = saturation;
    this.brightness = brightness;
    this.alpha = alpha;
  }
  static parse(value) {
    let m;
    if (m = value.match(HSB_REGEX)) {
      const [h, s, b, a] = (m[1] ?? m[2]).split(",").map((n) => Number(n.trim().replace("%", "")));
      return new _HSBColor((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.mod)(h, 360), (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.clampValue)(s, 0, 100), (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.clampValue)(b, 0, 100), (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.clampValue)(a ?? 1, 0, 1));
    }
  }
  toString(format) {
    switch (format) {
      case "css":
        return this.toHSL().toString("css");
      case "hex":
        return this.toRGB().toString("hex");
      case "hexa":
        return this.toRGB().toString("hexa");
      case "hsb":
        return `hsb(${this.hue}, ${(0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.saturation, 2)}%, ${(0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.brightness, 2)}%)`;
      case "hsba":
        return `hsba(${this.hue}, ${(0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.saturation, 2)}%, ${(0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.brightness, 2)}%, ${this.alpha})`;
      case "hsl":
        return this.toHSL().toString("hsl");
      case "rgb":
        return this.toRGB().toString("rgb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "hsba":
        return this;
      case "hsla":
        return this.toHSL();
      case "rgba":
        return this.toRGB();
      default:
        throw new Error("Unsupported color conversion: hsb -> " + format);
    }
  }
  /**
   * Converts a HSB color to HSL.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_HSL.
   * @returns An HSLColor object.
   */
  toHSL() {
    let saturation = this.saturation / 100;
    let brightness = this.brightness / 100;
    let lightness = brightness * (1 - saturation / 2);
    saturation = lightness === 0 || lightness === 1 ? 0 : (brightness - lightness) / Math.min(lightness, 1 - lightness);
    return new HSLColor(
      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.hue, 2),
      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(saturation * 100, 2),
      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(lightness * 100, 2),
      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.alpha, 2)
    );
  }
  /**
   * Converts a HSV color value to RGB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative.
   * @returns An RGBColor object.
   */
  toRGB() {
    let hue = this.hue;
    let saturation = this.saturation / 100;
    let brightness = this.brightness / 100;
    let fn = (n, k = (n + hue / 60) % 6) => brightness - saturation * brightness * Math.max(Math.min(k, 4 - k, 1), 0);
    return new RGBColor(
      Math.round(fn(5) * 255),
      Math.round(fn(3) * 255),
      Math.round(fn(1) * 255),
      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.alpha, 2)
    );
  }
  clone() {
    return new _HSBColor(this.hue, this.saturation, this.brightness, this.alpha);
  }
  getChannelFormatOptions(channel) {
    switch (channel) {
      case "hue":
        return { style: "unit", unit: "degree", unitDisplay: "narrow" };
      case "saturation":
      case "brightness":
      case "alpha":
        return { style: "percent" };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  formatChannelValue(channel, locale) {
    let options = this.getChannelFormatOptions(channel);
    let value = this.getChannelValue(channel);
    if (channel === "saturation" || channel === "brightness") {
      value /= 100;
    }
    return new Intl.NumberFormat(locale, options).format(value);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "hue":
        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };
      case "saturation":
      case "brightness":
        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { h: this.hue, s: this.saturation, b: this.brightness, a: this.alpha };
  }
  getFormat() {
    return "hsba";
  }
  getChannels() {
    return _HSBColor.colorChannels;
  }
};
__publicField(_HSBColor, "colorChannels", ["hue", "saturation", "brightness"]);
var HSBColor = _HSBColor;

// src/native-color.ts
var nativeColors = "aliceblue:f0f8ff,antiquewhite:faebd7,aqua:00ffff,aquamarine:7fffd4,azure:f0ffff,beige:f5f5dc,bisque:ffe4c4,black:000000,blanchedalmond:ffebcd,blue:0000ff,blueviolet:8a2be2,brown:a52a2a,burlywood:deb887,cadetblue:5f9ea0,chartreuse:7fff00,chocolate:d2691e,coral:ff7f50,cornflowerblue:6495ed,cornsilk:fff8dc,crimson:dc143c,cyan:00ffff,darkblue:00008b,darkcyan:008b8b,darkgoldenrod:b8860b,darkgray:a9a9a9,darkgreen:006400,darkkhaki:bdb76b,darkmagenta:8b008b,darkolivegreen:556b2f,darkorange:ff8c00,darkorchid:9932cc,darkred:8b0000,darksalmon:e9967a,darkseagreen:8fbc8f,darkslateblue:483d8b,darkslategray:2f4f4f,darkturquoise:00ced1,darkviolet:9400d3,deeppink:ff1493,deepskyblue:00bfff,dimgray:696969,dodgerblue:1e90ff,firebrick:b22222,floralwhite:fffaf0,forestgreen:228b22,fuchsia:ff00ff,gainsboro:dcdcdc,ghostwhite:f8f8ff,gold:ffd700,goldenrod:daa520,gray:808080,green:008000,greenyellow:adff2f,honeydew:f0fff0,hotpink:ff69b4,indianred:cd5c5c,indigo:4b0082,ivory:fffff0,khaki:f0e68c,lavender:e6e6fa,lavenderblush:fff0f5,lawngreen:7cfc00,lemonchiffon:fffacd,lightblue:add8e6,lightcoral:f08080,lightcyan:e0ffff,lightgoldenrodyellow:fafad2,lightgrey:d3d3d3,lightgreen:90ee90,lightpink:ffb6c1,lightsalmon:ffa07a,lightseagreen:20b2aa,lightskyblue:87cefa,lightslategray:778899,lightsteelblue:b0c4de,lightyellow:ffffe0,lime:00ff00,limegreen:32cd32,linen:faf0e6,magenta:ff00ff,maroon:800000,mediumaquamarine:66cdaa,mediumblue:0000cd,mediumorchid:ba55d3,mediumpurple:9370d8,mediumseagreen:3cb371,mediumslateblue:7b68ee,mediumspringgreen:00fa9a,mediumturquoise:48d1cc,mediumvioletred:c71585,midnightblue:191970,mintcream:f5fffa,mistyrose:ffe4e1,moccasin:ffe4b5,navajowhite:ffdead,navy:000080,oldlace:fdf5e6,olive:808000,olivedrab:6b8e23,orange:ffa500,orangered:ff4500,orchid:da70d6,palegoldenrod:eee8aa,palegreen:98fb98,paleturquoise:afeeee,palevioletred:d87093,papayawhip:ffefd5,peachpuff:ffdab9,peru:cd853f,pink:ffc0cb,plum:dda0dd,powderblue:b0e0e6,purple:800080,rebeccapurple:663399,red:ff0000,rosybrown:bc8f8f,royalblue:4169e1,saddlebrown:8b4513,salmon:fa8072,sandybrown:f4a460,seagreen:2e8b57,seashell:fff5ee,sienna:a0522d,silver:c0c0c0,skyblue:87ceeb,slateblue:6a5acd,slategray:708090,snow:fffafa,springgreen:00ff7f,steelblue:4682b4,tan:d2b48c,teal:008080,thistle:d8bfd8,tomato:ff6347,turquoise:40e0d0,violet:ee82ee,wheat:f5deb3,white:ffffff,whitesmoke:f5f5f5,yellow:ffff00,yellowgreen:9acd32";
var makeMap = (str) => {
  const map = /* @__PURE__ */ new Map();
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    const [key, val] = list[i].split(":");
    map.set(key, `#${val}`);
    if (key.includes("gray")) map.set(key.replace("gray", "grey"), `#${val}`);
  }
  return map;
};
var nativeColorMap = makeMap(nativeColors);

// src/parse-color.ts
var parseColor = (value) => {
  if (nativeColorMap.has(value)) {
    return parseColor(nativeColorMap.get(value));
  }
  const result = RGBColor.parse(value) || HSBColor.parse(value) || HSLColor.parse(value);
  if (!result) {
    const error = new Error("Invalid color value: " + value);
    Error.captureStackTrace?.(error, parseColor);
    throw error;
  }
  return result;
};
var normalizeColor = (v) => {
  return typeof v === "string" ? parseColor(v) : v;
};




/***/ }),

/***/ "./node_modules/@zag-js/core/dist/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@zag-js/core/dist/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   INIT_STATE: () => (/* binding */ INIT_STATE),
/* harmony export */   MachineStatus: () => (/* binding */ MachineStatus),
/* harmony export */   createGuards: () => (/* binding */ createGuards),
/* harmony export */   createMachine: () => (/* binding */ createMachine),
/* harmony export */   createScope: () => (/* binding */ createScope),
/* harmony export */   memo: () => (/* binding */ memo),
/* harmony export */   mergeProps: () => (/* binding */ mergeProps),
/* harmony export */   setup: () => (/* binding */ setup)
/* harmony export */ });
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");



// src/merge-props.ts
var clsx = (...args) => args.map((str) => str?.trim?.()).filter(Boolean).join(" ");
var CSS_REGEX = /((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g;
var serialize = (style) => {
  const res = {};
  let match;
  while (match = CSS_REGEX.exec(style)) {
    res[match[1]] = match[2];
  }
  return res;
};
var css = (a, b) => {
  if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(a)) {
    if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(b)) return `${a};${b}`;
    a = serialize(a);
  } else if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(b)) {
    b = serialize(b);
  }
  return Object.assign({}, a ?? {}, b ?? {});
};
function mergeProps(...args) {
  let result = {};
  for (let props of args) {
    for (let key in result) {
      if (key.startsWith("on") && typeof result[key] === "function" && typeof props[key] === "function") {
        result[key] = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.callAll)(props[key], result[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx(result[key], props[key]);
        continue;
      }
      if (key === "style") {
        result[key] = css(result[key], props[key]);
        continue;
      }
      result[key] = props[key] !== void 0 ? props[key] : result[key];
    }
    for (let key in props) {
      if (result[key] === void 0) {
        result[key] = props[key];
      }
    }
  }
  return result;
}
function memo(getDeps, fn, opts) {
  let deps = [];
  let result;
  return (depArgs) => {
    const newDeps = getDeps(depArgs);
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => !(0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isEqual)(deps[index], dep));
    if (!depsChanged) return result;
    deps = newDeps;
    result = fn(...newDeps);
    opts?.onChange?.(result);
    return result;
  };
}

// src/create-machine.ts
function createGuards() {
  return {
    and: (...guards) => {
      return function andGuard(params) {
        return guards.every((str) => params.guard(str));
      };
    },
    or: (...guards) => {
      return function orGuard(params) {
        return guards.some((str) => params.guard(str));
      };
    },
    not: (guard) => {
      return function notGuard(params) {
        return !params.guard(guard);
      };
    }
  };
}
function createMachine(config) {
  return config;
}
function setup() {
  return {
    guards: createGuards(),
    createMachine: (config) => {
      return createMachine(config);
    },
    choose: (transitions) => {
      return function chooseFn({ choose }) {
        return choose(transitions)?.actions;
      };
    }
  };
}

// src/types.ts
var MachineStatus = /* @__PURE__ */ ((MachineStatus2) => {
  MachineStatus2["NotStarted"] = "Not Started";
  MachineStatus2["Started"] = "Started";
  MachineStatus2["Stopped"] = "Stopped";
  return MachineStatus2;
})(MachineStatus || {});
var INIT_STATE = "__init__";
function createScope(props) {
  const getRootNode = () => props.getRootNode?.() ?? document;
  const getDoc = () => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getDocument)(getRootNode());
  const getWin = () => getDoc().defaultView ?? window;
  const getActiveElementFn = () => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getActiveElement)(getRootNode());
  const isActiveElement = (elem) => elem === getActiveElementFn();
  const getById = (id) => getRootNode().getElementById(id);
  return {
    ...props,
    getRootNode,
    getDoc,
    getWin,
    getActiveElement: getActiveElementFn,
    isActiveElement,
    getById
  };
}




/***/ }),

/***/ "./node_modules/@zag-js/dialog/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@zag-js/dialog/dist/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anatomy: () => (/* binding */ anatomy),
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   machine: () => (/* binding */ machine),
/* harmony export */   props: () => (/* binding */ props),
/* harmony export */   splitProps: () => (/* binding */ splitProps)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
/* harmony import */ var _zag_js_aria_hidden__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @zag-js/aria-hidden */ "./node_modules/@zag-js/aria-hidden/dist/index.mjs");
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _zag_js_dismissable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/dismissable */ "./node_modules/@zag-js/dismissable/dist/index.mjs");
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_focus_trap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/focus-trap */ "./node_modules/@zag-js/focus-trap/dist/index.mjs");
/* harmony import */ var _zag_js_remove_scroll__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/remove-scroll */ "./node_modules/@zag-js/remove-scroll/dist/index.mjs");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");










// src/dialog.anatomy.ts
var anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("dialog").parts(
  "trigger",
  "backdrop",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts = anatomy.build();

// src/dialog.dom.ts
var getPositionerId = (ctx) => ctx.ids?.positioner ?? `dialog:${ctx.id}:positioner`;
var getBackdropId = (ctx) => ctx.ids?.backdrop ?? `dialog:${ctx.id}:backdrop`;
var getContentId = (ctx) => ctx.ids?.content ?? `dialog:${ctx.id}:content`;
var getTriggerId = (ctx) => ctx.ids?.trigger ?? `dialog:${ctx.id}:trigger`;
var getTitleId = (ctx) => ctx.ids?.title ?? `dialog:${ctx.id}:title`;
var getDescriptionId = (ctx) => ctx.ids?.description ?? `dialog:${ctx.id}:description`;
var getCloseTriggerId = (ctx) => ctx.ids?.closeTrigger ?? `dialog:${ctx.id}:close`;
var getContentEl = (ctx) => ctx.getById(getContentId(ctx));
var getPositionerEl = (ctx) => ctx.getById(getPositionerId(ctx));
var getBackdropEl = (ctx) => ctx.getById(getBackdropId(ctx));
var getTriggerEl = (ctx) => ctx.getById(getTriggerId(ctx));
var getTitleEl = (ctx) => ctx.getById(getTitleId(ctx));
var getDescriptionEl = (ctx) => ctx.getById(getDescriptionId(ctx));
var getCloseTriggerEl = (ctx) => ctx.getById(getCloseTriggerId(ctx));

// src/dialog.connect.ts
function connect(service, normalize) {
  const { state, send, context, prop, scope } = service;
  const ariaLabel = prop("aria-label");
  const open = state.matches("open");
  return {
    open,
    setOpen(nextOpen) {
      const open2 = state.matches("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    getTriggerProps() {
      return normalize.button({
        ...parts.trigger.attrs,
        dir: prop("dir"),
        id: getTriggerId(scope),
        "aria-haspopup": "dialog",
        type: "button",
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": getContentId(scope),
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "TOGGLE" });
        }
      });
    },
    getBackdropProps() {
      return normalize.element({
        ...parts.backdrop.attrs,
        dir: prop("dir"),
        hidden: !open,
        id: getBackdropId(scope),
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize.element({
        ...parts.positioner.attrs,
        dir: prop("dir"),
        id: getPositionerId(scope),
        style: {
          pointerEvents: open ? void 0 : "none"
        }
      });
    },
    getContentProps() {
      const rendered = context.get("rendered");
      return normalize.element({
        ...parts.content.attrs,
        dir: prop("dir"),
        role: prop("role"),
        hidden: !open,
        id: getContentId(scope),
        tabIndex: -1,
        "data-state": open ? "open" : "closed",
        "aria-modal": true,
        "aria-label": ariaLabel || void 0,
        "aria-labelledby": ariaLabel || !rendered.title ? void 0 : getTitleId(scope),
        "aria-describedby": rendered.description ? getDescriptionId(scope) : void 0
      });
    },
    getTitleProps() {
      return normalize.element({
        ...parts.title.attrs,
        dir: prop("dir"),
        id: getTitleId(scope)
      });
    },
    getDescriptionProps() {
      return normalize.element({
        ...parts.description.attrs,
        dir: prop("dir"),
        id: getDescriptionId(scope)
      });
    },
    getCloseTriggerProps() {
      return normalize.button({
        ...parts.closeTrigger.attrs,
        dir: prop("dir"),
        id: getCloseTriggerId(scope),
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          event.stopPropagation();
          send({ type: "CLOSE" });
        }
      });
    }
  };
}
var machine = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_1__.createMachine)({
  props({ props: props2, scope }) {
    const alertDialog = props2.role === "alertdialog";
    const initialFocusEl = alertDialog ? () => getCloseTriggerEl(scope) : void 0;
    return {
      role: "dialog",
      modal: true,
      trapFocus: true,
      preventScroll: true,
      closeOnInteractOutside: !alertDialog,
      closeOnEscape: true,
      restoreFocus: true,
      initialFocusEl,
      ...props2
    };
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "closed";
  },
  context({ bindable }) {
    return {
      rendered: bindable(() => ({
        defaultValue: { title: true, description: true }
      }))
    };
  },
  watch({ track, action, prop }) {
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  states: {
    open: {
      entry: ["checkRenderedElements", "syncZIndex"],
      effects: ["trackDismissableElement", "trapFocus", "preventScroll", "hideContentBelow"],
      on: {
        "CONTROLLED.CLOSE": {
          target: "closed"
        },
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        TOGGLE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ]
      }
    },
    closed: {
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        TOGGLE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ]
      }
    }
  },
  implementations: {
    guards: {
      isOpenControlled: ({ prop }) => prop("open") != void 0
    },
    effects: {
      trackDismissableElement({ scope, send, prop }) {
        const getContentEl2 = () => getContentEl(scope);
        return (0,_zag_js_dismissable__WEBPACK_IMPORTED_MODULE_2__.trackDismissableElement)(getContentEl2, {
          defer: true,
          pointerBlocking: prop("modal"),
          exclude: [getTriggerEl(scope)],
          onInteractOutside(event) {
            prop("onInteractOutside")?.(event);
            if (!prop("closeOnInteractOutside")) {
              event.preventDefault();
            }
          },
          persistentElements: prop("persistentElements"),
          onFocusOutside: prop("onFocusOutside"),
          onPointerDownOutside: prop("onPointerDownOutside"),
          onEscapeKeyDown(event) {
            prop("onEscapeKeyDown")?.(event);
            if (!prop("closeOnEscape")) {
              event.preventDefault();
            }
          },
          onDismiss() {
            send({ type: "CLOSE", src: "interact-outside" });
          }
        });
      },
      preventScroll({ scope, prop }) {
        if (!prop("preventScroll")) return;
        return (0,_zag_js_remove_scroll__WEBPACK_IMPORTED_MODULE_3__.preventBodyScroll)(scope.getDoc());
      },
      trapFocus({ scope, prop }) {
        if (!prop("trapFocus") || !prop("modal")) return;
        const contentEl = () => getContentEl(scope);
        return (0,_zag_js_focus_trap__WEBPACK_IMPORTED_MODULE_4__.trapFocus)(contentEl, {
          preventScroll: true,
          returnFocusOnDeactivate: !!prop("restoreFocus"),
          initialFocus: prop("initialFocusEl"),
          setReturnFocus: (el) => prop("finalFocusEl")?.() ?? el
        });
      },
      hideContentBelow({ scope, prop }) {
        if (!prop("modal")) return;
        const getElements = () => [getContentEl(scope)];
        return (0,_zag_js_aria_hidden__WEBPACK_IMPORTED_MODULE_5__.ariaHidden)(getElements, { defer: true });
      }
    },
    actions: {
      checkRenderedElements({ context, scope }) {
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_6__.raf)(() => {
          context.set("rendered", {
            title: !!getTitleEl(scope),
            description: !!getDescriptionEl(scope)
          });
        });
      },
      syncZIndex({ scope }) {
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_6__.raf)(() => {
          const contentEl = getContentEl(scope);
          if (!contentEl) return;
          const styles = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_6__.getComputedStyle)(contentEl);
          const elems = [getPositionerEl(scope), getBackdropEl(scope)];
          elems.forEach((node) => {
            node?.style.setProperty("--z-index", styles.zIndex);
          });
        });
      },
      invokeOnClose({ prop }) {
        prop("onOpenChange")?.({ open: false });
      },
      invokeOnOpen({ prop }) {
        prop("onOpenChange")?.({ open: true });
      },
      toggleVisibility({ prop, send, event }) {
        send({
          type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE",
          previousEvent: event
        });
      }
    }
  }
});
var props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_7__.createProps)()([
  "aria-label",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "finalFocusEl",
  "getRootNode",
  "getRootNode",
  "id",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "defaultOpen",
  "open",
  "persistentElements",
  "preventScroll",
  "restoreFocus",
  "role",
  "trapFocus"
]);
var splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_8__.createSplitProps)(props);




/***/ }),

/***/ "./node_modules/@zag-js/dismissable/dist/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@zag-js/dismissable/dist/index.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   trackDismissableBranch: () => (/* binding */ trackDismissableBranch),
/* harmony export */   trackDismissableElement: () => (/* binding */ trackDismissableElement)
/* harmony export */ });
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_interact_outside__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/interact-outside */ "./node_modules/@zag-js/interact-outside/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");




// src/dismissable-layer.ts
function trackEscapeKeydown(node, fn) {
  const handleKeyDown = (event) => {
    if (event.key !== "Escape") return;
    if (event.isComposing) return;
    fn?.(event);
  };
  return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.addDomEvent)((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getDocument)(node), "keydown", handleKeyDown, { capture: true });
}
var layerStack = {
  layers: [],
  branches: [],
  count() {
    return this.layers.length;
  },
  pointerBlockingLayers() {
    return this.layers.filter((layer) => layer.pointerBlocking);
  },
  topMostPointerBlockingLayer() {
    return [...this.pointerBlockingLayers()].slice(-1)[0];
  },
  hasPointerBlockingLayer() {
    return this.pointerBlockingLayers().length > 0;
  },
  isBelowPointerBlockingLayer(node) {
    const index = this.indexOf(node);
    const highestBlockingIndex = this.topMostPointerBlockingLayer() ? this.indexOf(this.topMostPointerBlockingLayer()?.node) : -1;
    return index < highestBlockingIndex;
  },
  isTopMost(node) {
    const layer = this.layers[this.count() - 1];
    return layer?.node === node;
  },
  getNestedLayers(node) {
    return Array.from(this.layers).slice(this.indexOf(node) + 1);
  },
  isInNestedLayer(node, target) {
    return this.getNestedLayers(node).some((layer) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.contains)(layer.node, target));
  },
  isInBranch(target) {
    return Array.from(this.branches).some((branch) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.contains)(branch, target));
  },
  add(layer) {
    const num = this.layers.push(layer);
    layer.node.style.setProperty("--layer-index", `${num}`);
  },
  addBranch(node) {
    this.branches.push(node);
  },
  remove(node) {
    const index = this.indexOf(node);
    if (index < 0) return;
    if (index < this.count() - 1) {
      const _layers = this.getNestedLayers(node);
      _layers.forEach((layer) => layer.dismiss());
    }
    this.layers.splice(index, 1);
    node.style.removeProperty("--layer-index");
  },
  removeBranch(node) {
    const index = this.branches.indexOf(node);
    if (index >= 0) this.branches.splice(index, 1);
  },
  indexOf(node) {
    return this.layers.findIndex((layer) => layer.node === node);
  },
  dismiss(node) {
    this.layers[this.indexOf(node)]?.dismiss();
  },
  clear() {
    this.remove(this.layers[0].node);
  }
};
var originalBodyPointerEvents;
function assignPointerEventToLayers() {
  layerStack.layers.forEach(({ node }) => {
    node.style.pointerEvents = layerStack.isBelowPointerBlockingLayer(node) ? "none" : "auto";
  });
}
function clearPointerEvent(node) {
  node.style.pointerEvents = "";
}
function disablePointerEventsOutside(node, persistentElements) {
  const doc = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getDocument)(node);
  const cleanups = [];
  if (layerStack.hasPointerBlockingLayer() && !doc.body.hasAttribute("data-inert")) {
    originalBodyPointerEvents = document.body.style.pointerEvents;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = "none";
      doc.body.setAttribute("data-inert", "");
    });
  }
  if (persistentElements) {
    const persistedCleanup = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.waitForElements)(persistentElements, (el) => {
      cleanups.push((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.setStyle)(el, { pointerEvents: "auto" }));
    });
    cleanups.push(persistedCleanup);
  }
  return () => {
    if (layerStack.hasPointerBlockingLayer()) return;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = originalBodyPointerEvents;
      doc.body.removeAttribute("data-inert");
      if (doc.body.style.length === 0) doc.body.removeAttribute("style");
    });
    cleanups.forEach((fn) => fn());
  };
}

// src/dismissable-layer.ts
function trackDismissableElementImpl(node, options) {
  const { warnOnMissingNode = true } = options;
  if (warnOnMissingNode && !node) {
    (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_1__.warn)("[@zag-js/dismissable] node is `null` or `undefined`");
    return;
  }
  if (!node) {
    return;
  }
  const { onDismiss, pointerBlocking, exclude: excludeContainers, debug } = options;
  const layer = { dismiss: onDismiss, node, pointerBlocking };
  layerStack.add(layer);
  assignPointerEventToLayers();
  function onPointerDownOutside(event) {
    const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getEventTarget)(event.detail.originalEvent);
    if (layerStack.isBelowPointerBlockingLayer(node) || layerStack.isInBranch(target)) return;
    options.onPointerDownOutside?.(event);
    options.onInteractOutside?.(event);
    if (event.defaultPrevented) return;
    if (debug) {
      console.log("onPointerDownOutside:", event.detail.originalEvent);
    }
    onDismiss?.();
  }
  function onFocusOutside(event) {
    const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getEventTarget)(event.detail.originalEvent);
    if (layerStack.isInBranch(target)) return;
    options.onFocusOutside?.(event);
    options.onInteractOutside?.(event);
    if (event.defaultPrevented) return;
    if (debug) {
      console.log("onFocusOutside:", event.detail.originalEvent);
    }
    onDismiss?.();
  }
  function onEscapeKeyDown(event) {
    if (!layerStack.isTopMost(node)) return;
    options.onEscapeKeyDown?.(event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }
  function exclude(target) {
    if (!node) return false;
    const containers = typeof excludeContainers === "function" ? excludeContainers() : excludeContainers;
    const _containers = Array.isArray(containers) ? containers : [containers];
    const persistentElements = options.persistentElements?.map((fn) => fn()).filter(_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement);
    if (persistentElements) _containers.push(...persistentElements);
    return _containers.some((node2) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.contains)(node2, target)) || layerStack.isInNestedLayer(node, target);
  }
  const cleanups = [
    pointerBlocking ? disablePointerEventsOutside(node, options.persistentElements) : void 0,
    trackEscapeKeydown(node, onEscapeKeyDown),
    (0,_zag_js_interact_outside__WEBPACK_IMPORTED_MODULE_2__.trackInteractOutside)(node, { exclude, onFocusOutside, onPointerDownOutside, defer: options.defer })
  ];
  return () => {
    layerStack.remove(node);
    assignPointerEventToLayers();
    clearPointerEvent(node);
    cleanups.forEach((fn) => fn?.());
  };
}
function trackDismissableElement(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_1__.isFunction)(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      cleanups.push(trackDismissableElementImpl(node, options));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}
function trackDismissableBranch(nodeOrFn, options = {}) {
  const { defer } = options;
  const func = defer ? _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_1__.isFunction)(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      if (!node) {
        (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_1__.warn)("[@zag-js/dismissable] branch node is `null` or `undefined`");
        return;
      }
      layerStack.addBranch(node);
      cleanups.push(() => {
        layerStack.removeBranch(node);
      });
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}




/***/ }),

/***/ "./node_modules/@zag-js/dom-query/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@zag-js/dom-query/dist/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MAX_Z_INDEX: () => (/* binding */ MAX_Z_INDEX),
/* harmony export */   addDomEvent: () => (/* binding */ addDomEvent),
/* harmony export */   ariaAttr: () => (/* binding */ ariaAttr),
/* harmony export */   clickIfLink: () => (/* binding */ clickIfLink),
/* harmony export */   contains: () => (/* binding */ contains),
/* harmony export */   createScope: () => (/* binding */ createScope),
/* harmony export */   dataAttr: () => (/* binding */ dataAttr),
/* harmony export */   defaultItemToId: () => (/* binding */ defaultItemToId),
/* harmony export */   disableTextSelection: () => (/* binding */ disableTextSelection),
/* harmony export */   dispatchInputCheckedEvent: () => (/* binding */ dispatchInputCheckedEvent),
/* harmony export */   dispatchInputValueEvent: () => (/* binding */ dispatchInputValueEvent),
/* harmony export */   getActiveElement: () => (/* binding */ getActiveElement),
/* harmony export */   getBeforeInputValue: () => (/* binding */ getBeforeInputValue),
/* harmony export */   getByText: () => (/* binding */ getByText),
/* harmony export */   getByTypeahead: () => (/* binding */ getByTypeahead),
/* harmony export */   getComputedStyle: () => (/* binding */ getComputedStyle),
/* harmony export */   getDataUrl: () => (/* binding */ getDataUrl),
/* harmony export */   getDocument: () => (/* binding */ getDocument),
/* harmony export */   getDocumentElement: () => (/* binding */ getDocumentElement),
/* harmony export */   getEventKey: () => (/* binding */ getEventKey),
/* harmony export */   getEventPoint: () => (/* binding */ getEventPoint),
/* harmony export */   getEventStep: () => (/* binding */ getEventStep),
/* harmony export */   getEventTarget: () => (/* binding */ getEventTarget),
/* harmony export */   getFirstFocusable: () => (/* binding */ getFirstFocusable),
/* harmony export */   getFirstTabbable: () => (/* binding */ getFirstTabbable),
/* harmony export */   getFocusables: () => (/* binding */ getFocusables),
/* harmony export */   getInitialFocus: () => (/* binding */ getInitialFocus),
/* harmony export */   getLastTabbable: () => (/* binding */ getLastTabbable),
/* harmony export */   getNativeEvent: () => (/* binding */ getNativeEvent),
/* harmony export */   getNearestOverflowAncestor: () => (/* binding */ getNearestOverflowAncestor),
/* harmony export */   getNextTabbable: () => (/* binding */ getNextTabbable),
/* harmony export */   getNodeName: () => (/* binding */ getNodeName),
/* harmony export */   getOverflowAncestors: () => (/* binding */ getOverflowAncestors),
/* harmony export */   getParentNode: () => (/* binding */ getParentNode),
/* harmony export */   getPlatform: () => (/* binding */ getPlatform),
/* harmony export */   getRelativePoint: () => (/* binding */ getRelativePoint),
/* harmony export */   getScrollPosition: () => (/* binding */ getScrollPosition),
/* harmony export */   getTabIndex: () => (/* binding */ getTabIndex),
/* harmony export */   getTabbableEdges: () => (/* binding */ getTabbableEdges),
/* harmony export */   getTabbables: () => (/* binding */ getTabbables),
/* harmony export */   getUserAgent: () => (/* binding */ getUserAgent),
/* harmony export */   getWindow: () => (/* binding */ getWindow),
/* harmony export */   indexOfId: () => (/* binding */ indexOfId),
/* harmony export */   isAnchorElement: () => (/* binding */ isAnchorElement),
/* harmony export */   isAndroid: () => (/* binding */ isAndroid),
/* harmony export */   isApple: () => (/* binding */ isApple),
/* harmony export */   isCaretAtStart: () => (/* binding */ isCaretAtStart),
/* harmony export */   isChrome: () => (/* binding */ isChrome),
/* harmony export */   isComposingEvent: () => (/* binding */ isComposingEvent),
/* harmony export */   isContextMenuEvent: () => (/* binding */ isContextMenuEvent),
/* harmony export */   isCtrlOrMetaKey: () => (/* binding */ isCtrlOrMetaKey),
/* harmony export */   isDocument: () => (/* binding */ isDocument),
/* harmony export */   isDom: () => (/* binding */ isDom),
/* harmony export */   isDownloadingEvent: () => (/* binding */ isDownloadingEvent),
/* harmony export */   isEditableElement: () => (/* binding */ isEditableElement),
/* harmony export */   isElementVisible: () => (/* binding */ isElementVisible),
/* harmony export */   isFirefox: () => (/* binding */ isFirefox),
/* harmony export */   isFocusable: () => (/* binding */ isFocusable),
/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),
/* harmony export */   isIPad: () => (/* binding */ isIPad),
/* harmony export */   isIPhone: () => (/* binding */ isIPhone),
/* harmony export */   isInView: () => (/* binding */ isInView),
/* harmony export */   isInputElement: () => (/* binding */ isInputElement),
/* harmony export */   isIos: () => (/* binding */ isIos),
/* harmony export */   isKeyboardClick: () => (/* binding */ isKeyboardClick),
/* harmony export */   isLeftClick: () => (/* binding */ isLeftClick),
/* harmony export */   isMac: () => (/* binding */ isMac),
/* harmony export */   isModifierKey: () => (/* binding */ isModifierKey),
/* harmony export */   isNode: () => (/* binding */ isNode),
/* harmony export */   isOpeningInNewTab: () => (/* binding */ isOpeningInNewTab),
/* harmony export */   isOverflowElement: () => (/* binding */ isOverflowElement),
/* harmony export */   isPrintableKey: () => (/* binding */ isPrintableKey),
/* harmony export */   isRootElement: () => (/* binding */ isRootElement),
/* harmony export */   isSafari: () => (/* binding */ isSafari),
/* harmony export */   isSelfTarget: () => (/* binding */ isSelfTarget),
/* harmony export */   isShadowRoot: () => (/* binding */ isShadowRoot),
/* harmony export */   isTabbable: () => (/* binding */ isTabbable),
/* harmony export */   isTouchDevice: () => (/* binding */ isTouchDevice),
/* harmony export */   isTouchEvent: () => (/* binding */ isTouchEvent),
/* harmony export */   isValidTabEvent: () => (/* binding */ isValidTabEvent),
/* harmony export */   isVirtualClick: () => (/* binding */ isVirtualClick),
/* harmony export */   isVirtualPointerEvent: () => (/* binding */ isVirtualPointerEvent),
/* harmony export */   isVisualViewport: () => (/* binding */ isVisualViewport),
/* harmony export */   isWebKit: () => (/* binding */ isWebKit),
/* harmony export */   isWindow: () => (/* binding */ isWindow),
/* harmony export */   itemById: () => (/* binding */ itemById),
/* harmony export */   nextById: () => (/* binding */ nextById),
/* harmony export */   nextTick: () => (/* binding */ nextTick),
/* harmony export */   observeAttributes: () => (/* binding */ observeAttributes),
/* harmony export */   observeChildren: () => (/* binding */ observeChildren),
/* harmony export */   prevById: () => (/* binding */ prevById),
/* harmony export */   proxyTabFocus: () => (/* binding */ proxyTabFocus),
/* harmony export */   query: () => (/* binding */ query),
/* harmony export */   queryAll: () => (/* binding */ queryAll),
/* harmony export */   queueBeforeEvent: () => (/* binding */ queueBeforeEvent),
/* harmony export */   raf: () => (/* binding */ raf),
/* harmony export */   requestPointerLock: () => (/* binding */ requestPointerLock),
/* harmony export */   restoreTextSelection: () => (/* binding */ restoreTextSelection),
/* harmony export */   scrollIntoView: () => (/* binding */ scrollIntoView),
/* harmony export */   setAttribute: () => (/* binding */ setAttribute),
/* harmony export */   setCaretToEnd: () => (/* binding */ setCaretToEnd),
/* harmony export */   setElementChecked: () => (/* binding */ setElementChecked),
/* harmony export */   setElementValue: () => (/* binding */ setElementValue),
/* harmony export */   setProperty: () => (/* binding */ setProperty),
/* harmony export */   setStyle: () => (/* binding */ setStyle),
/* harmony export */   setStyleProperty: () => (/* binding */ setStyleProperty),
/* harmony export */   setVisuallyHidden: () => (/* binding */ setVisuallyHidden),
/* harmony export */   trackElementRect: () => (/* binding */ trackElementRect),
/* harmony export */   trackFormControl: () => (/* binding */ trackFormControl),
/* harmony export */   trackPointerMove: () => (/* binding */ trackPointerMove),
/* harmony export */   trackPress: () => (/* binding */ trackPress),
/* harmony export */   trackVisualViewport: () => (/* binding */ trackVisualViewport),
/* harmony export */   visuallyHiddenStyle: () => (/* binding */ visuallyHiddenStyle),
/* harmony export */   waitForElement: () => (/* binding */ waitForElement),
/* harmony export */   waitForElements: () => (/* binding */ waitForElements)
/* harmony export */ });
// src/caret.ts
function isCaretAtStart(input) {
  if (!input) return false;
  try {
    return input.selectionStart === 0 && input.selectionEnd === 0;
  } catch {
    return input.value === "";
  }
}
function setCaretToEnd(input) {
  if (!input) return;
  const start = input.selectionStart ?? 0;
  const end = input.selectionEnd ?? 0;
  if (Math.abs(end - start) !== 0) return;
  if (start !== 0) return;
  input.setSelectionRange(input.value.length, input.value.length);
}

// src/shared.ts
var clamp = (value) => Math.max(0, Math.min(1, value));
var wrap = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
var pipe = (...fns) => (arg) => fns.reduce((acc, fn) => fn(acc), arg);
var noop = () => void 0;
var isObject = (v) => typeof v === "object" && v !== null;
var MAX_Z_INDEX = 2147483647;
var dataAttr = (guard) => guard ? "" : void 0;
var ariaAttr = (guard) => guard ? "true" : void 0;

// src/node.ts
var ELEMENT_NODE = 1;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;
var isHTMLElement = (el) => isObject(el) && el.nodeType === ELEMENT_NODE && typeof el.nodeName === "string";
var isDocument = (el) => isObject(el) && el.nodeType === DOCUMENT_NODE;
var isWindow = (el) => isObject(el) && el === el.window;
var isVisualViewport = (el) => isObject(el) && el.constructor.name === "VisualViewport";
var getNodeName = (node) => {
  if (isHTMLElement(node)) return node.localName || "";
  return "#document";
};
function isRootElement(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
var isNode = (el) => isObject(el) && el.nodeType !== void 0;
var isShadowRoot = (el) => isNode(el) && el.nodeType === DOCUMENT_FRAGMENT_NODE && "host" in el;
var isInputElement = (el) => isHTMLElement(el) && el.localName === "input";
var isAnchorElement = (el) => !!el?.matches("a[href]");
var isElementVisible = (el) => {
  if (!isHTMLElement(el)) return false;
  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;
};
var TEXTAREA_SELECT_REGEX = /(textarea|select)/;
function isEditableElement(el) {
  if (el == null || !isHTMLElement(el)) return false;
  try {
    return isInputElement(el) && el.selectionStart != null || TEXTAREA_SELECT_REGEX.test(el.localName) || el.isContentEditable || el.getAttribute("contenteditable") === "true" || el.getAttribute("contenteditable") === "";
  } catch {
    return false;
  }
}
function contains(parent, child) {
  if (!parent || !child) return false;
  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false;
  const rootNode = child.getRootNode?.();
  if (parent === child) return true;
  if (parent.contains(child)) return true;
  if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    while (next) {
      if (parent === next) return true;
      next = next.parentNode || next.host;
    }
  }
  return false;
}
function getDocument(el) {
  if (isDocument(el)) return el;
  if (isWindow(el)) return el.document;
  return el?.ownerDocument ?? document;
}
function getDocumentElement(el) {
  return getDocument(el).documentElement;
}
function getWindow(el) {
  if (isShadowRoot(el)) return getWindow(el.host);
  if (isDocument(el)) return el.defaultView ?? window;
  if (isHTMLElement(el)) return el.ownerDocument?.defaultView ?? window;
  return window;
}
function getActiveElement(rootNode) {
  let activeElement = rootNode.activeElement;
  while (activeElement?.shadowRoot) {
    const el = activeElement.shadowRoot.activeElement;
    if (el === activeElement) break;
    else activeElement = el;
  }
  return activeElement;
}
function getParentNode(node) {
  if (getNodeName(node) === "html") return node;
  const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}

// src/computed-style.ts
var styleCache = /* @__PURE__ */ new WeakMap();
function getComputedStyle(el) {
  if (!styleCache.has(el)) {
    styleCache.set(el, getWindow(el).getComputedStyle(el));
  }
  return styleCache.get(el);
}

// src/data-url.ts
function getDataUrl(svg, opts) {
  const { type, quality = 0.92, background } = opts;
  if (!svg) throw new Error("[zag-js > getDataUrl]: Could not find the svg element");
  const win = getWindow(svg);
  const doc = win.document;
  const svgBounds = svg.getBoundingClientRect();
  const svgClone = svg.cloneNode(true);
  if (!svgClone.hasAttribute("viewBox")) {
    svgClone.setAttribute("viewBox", `0 0 ${svgBounds.width} ${svgBounds.height}`);
  }
  const serializer = new win.XMLSerializer();
  const source = '<?xml version="1.0" standalone="no"?>\r\n' + serializer.serializeToString(svgClone);
  const svgString = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
  if (type === "image/svg+xml") {
    return Promise.resolve(svgString).then((str) => {
      svgClone.remove();
      return str;
    });
  }
  const dpr = win.devicePixelRatio || 1;
  const canvas = doc.createElement("canvas");
  const image = new win.Image();
  image.src = svgString;
  canvas.width = svgBounds.width * dpr;
  canvas.height = svgBounds.height * dpr;
  const context = canvas.getContext("2d");
  if (type === "image/jpeg" || background) {
    context.fillStyle = background || "white";
    context.fillRect(0, 0, canvas.width, canvas.height);
  }
  return new Promise((resolve) => {
    image.onload = () => {
      context?.drawImage(image, 0, 0, canvas.width, canvas.height);
      resolve(canvas.toDataURL(type, quality));
      svgClone.remove();
    };
  });
}

// src/platform.ts
var isDom = () => typeof document !== "undefined";
function getPlatform() {
  const agent = navigator.userAgentData;
  return agent?.platform ?? navigator.platform;
}
function getUserAgent() {
  const ua2 = navigator.userAgentData;
  if (ua2 && Array.isArray(ua2.brands)) {
    return ua2.brands.map(({ brand, version }) => `${brand}/${version}`).join(" ");
  }
  return navigator.userAgent;
}
var pt = (v) => isDom() && v.test(getPlatform());
var ua = (v) => isDom() && v.test(getUserAgent());
var vn = (v) => isDom() && v.test(navigator.vendor);
var isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;
var isIPhone = () => pt(/^iPhone/i);
var isIPad = () => pt(/^iPad/i) || isMac() && navigator.maxTouchPoints > 1;
var isIos = () => isIPhone() || isIPad();
var isApple = () => isMac() || isIos();
var isMac = () => pt(/^Mac/i);
var isSafari = () => isApple() && vn(/apple/i);
var isFirefox = () => ua(/Firefox/i);
var isChrome = () => ua(/Chrome/i);
var isWebKit = () => ua(/AppleWebKit/i) && !isChrome();
var isAndroid = () => ua(/Android/i);

// src/event.ts
function getBeforeInputValue(event) {
  const { selectionStart, selectionEnd, value } = event.currentTarget;
  return value.slice(0, selectionStart) + event.data + value.slice(selectionEnd);
}
function getComposedPath(event) {
  return event.composedPath?.() ?? event.nativeEvent?.composedPath?.();
}
function getEventTarget(event) {
  const composedPath = getComposedPath(event);
  return composedPath?.[0] ?? event.target;
}
var isSelfTarget = (event) => {
  return contains(event.currentTarget, getEventTarget(event));
};
function isOpeningInNewTab(event) {
  const element = event.currentTarget;
  if (!element) return false;
  const isAppleDevice = isApple();
  if (isAppleDevice && !event.metaKey) return false;
  if (!isAppleDevice && !event.ctrlKey) return false;
  const localName = element.localName;
  if (localName === "a") return true;
  if (localName === "button" && element.type === "submit") return true;
  if (localName === "input" && element.type === "submit") return true;
  return false;
}
function isDownloadingEvent(event) {
  const element = event.currentTarget;
  if (!element) return false;
  const localName = element.localName;
  if (!event.altKey) return false;
  if (localName === "a") return true;
  if (localName === "button" && element.type === "submit") return true;
  if (localName === "input" && element.type === "submit") return true;
  return false;
}
function isComposingEvent(event) {
  return getNativeEvent(event).isComposing || event.keyCode === 229;
}
function isKeyboardClick(e) {
  return e.detail === 0 || e.clientX === 0 && e.clientY === 0;
}
function isCtrlOrMetaKey(e) {
  if (isMac()) return e.metaKey;
  return e.ctrlKey;
}
function isPrintableKey(e) {
  return e.key.length === 1 && !e.ctrlKey && !e.metaKey;
}
function isVirtualPointerEvent(e) {
  return e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === "mouse";
}
function isVirtualClick(e) {
  if (e.mozInputSource === 0 && e.isTrusted) return true;
  if (isAndroid() && e.pointerType) {
    return e.type === "click" && e.buttons === 1;
  }
  return e.detail === 0 && !e.pointerType;
}
var isLeftClick = (e) => e.button === 0;
var isContextMenuEvent = (e) => {
  return e.button === 2 || isMac() && e.ctrlKey && e.button === 0;
};
var isModifierKey = (e) => e.ctrlKey || e.altKey || e.metaKey;
var isTouchEvent = (event) => "touches" in event && event.touches.length > 0;
var keyMap = {
  Up: "ArrowUp",
  Down: "ArrowDown",
  Esc: "Escape",
  " ": "Space",
  ",": "Comma",
  Left: "ArrowLeft",
  Right: "ArrowRight"
};
var rtlKeyMap = {
  ArrowLeft: "ArrowRight",
  ArrowRight: "ArrowLeft"
};
function getEventKey(event, options = {}) {
  const { dir = "ltr", orientation = "horizontal" } = options;
  let key = event.key;
  key = keyMap[key] ?? key;
  const isRtl = dir === "rtl" && orientation === "horizontal";
  if (isRtl && key in rtlKeyMap) key = rtlKeyMap[key];
  return key;
}
function getNativeEvent(event) {
  return event.nativeEvent ?? event;
}
var pageKeys = /* @__PURE__ */ new Set(["PageUp", "PageDown"]);
var arrowKeys = /* @__PURE__ */ new Set(["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"]);
function getEventStep(event) {
  if (event.ctrlKey || event.metaKey) {
    return 0.1;
  } else {
    const isPageKey = pageKeys.has(event.key);
    const isSkipKey = isPageKey || event.shiftKey && arrowKeys.has(event.key);
    return isSkipKey ? 10 : 1;
  }
}
function getEventPoint(event, type = "client") {
  const point = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;
  return { x: point[`${type}X`], y: point[`${type}Y`] };
}
var addDomEvent = (target, eventName, handler, options) => {
  const node = typeof target === "function" ? target() : target;
  node?.addEventListener(eventName, handler, options);
  return () => {
    node?.removeEventListener(eventName, handler, options);
  };
};

// src/form.ts
function getDescriptor(el, options) {
  const { type = "HTMLInputElement", property = "value" } = options;
  const proto = getWindow(el)[type].prototype;
  return Object.getOwnPropertyDescriptor(proto, property) ?? {};
}
function getElementType(el) {
  if (el.localName === "input") return "HTMLInputElement";
  if (el.localName === "textarea") return "HTMLTextAreaElement";
  if (el.localName === "select") return "HTMLSelectElement";
}
function setElementValue(el, value, property = "value") {
  if (!el) return;
  const type = getElementType(el);
  if (type) {
    const descriptor = getDescriptor(el, { type, property });
    descriptor.set?.call(el, value);
  }
  el.setAttribute(property, value);
}
function setElementChecked(el, checked) {
  if (!el) return;
  const descriptor = getDescriptor(el, { type: "HTMLInputElement", property: "checked" });
  descriptor.set?.call(el, checked);
  if (checked) el.setAttribute("checked", "");
  else el.removeAttribute("checked");
}
function dispatchInputValueEvent(el, options) {
  const { value, bubbles = true } = options;
  if (!el) return;
  const win = getWindow(el);
  if (!(el instanceof win.HTMLInputElement)) return;
  setElementValue(el, `${value}`);
  el.dispatchEvent(new win.Event("input", { bubbles }));
}
function dispatchInputCheckedEvent(el, options) {
  const { checked, bubbles = true } = options;
  if (!el) return;
  const win = getWindow(el);
  if (!(el instanceof win.HTMLInputElement)) return;
  setElementChecked(el, checked);
  el.dispatchEvent(new win.Event("click", { bubbles }));
}
function getClosestForm(el) {
  return isFormElement(el) ? el.form : el.closest("form");
}
function isFormElement(el) {
  return el.matches("textarea, input, select, button");
}
function trackFormReset(el, callback) {
  if (!el) return;
  const form = getClosestForm(el);
  const onReset = (e) => {
    if (e.defaultPrevented) return;
    callback();
  };
  form?.addEventListener("reset", onReset, { passive: true });
  return () => form?.removeEventListener("reset", onReset);
}
function trackFieldsetDisabled(el, callback) {
  const fieldset = el?.closest("fieldset");
  if (!fieldset) return;
  callback(fieldset.disabled);
  const win = getWindow(fieldset);
  const obs = new win.MutationObserver(() => callback(fieldset.disabled));
  obs.observe(fieldset, {
    attributes: true,
    attributeFilter: ["disabled"]
  });
  return () => obs.disconnect();
}
function trackFormControl(el, options) {
  if (!el) return;
  const { onFieldsetDisabledChange, onFormReset } = options;
  const cleanups = [trackFormReset(el, onFormReset), trackFieldsetDisabled(el, onFieldsetDisabledChange)];
  return () => cleanups.forEach((cleanup) => cleanup?.());
}

// src/tabbable.ts
var isFrame = (el) => isHTMLElement(el) && el.tagName === "IFRAME";
var hasTabIndex = (el) => !Number.isNaN(parseInt(el.getAttribute("tabindex") || "0", 10));
var hasNegativeTabIndex = (el) => parseInt(el.getAttribute("tabindex") || "0", 10) < 0;
var focusableSelector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type";
var getFocusables = (container, includeContainer = false) => {
  if (!container) return [];
  const elements = Array.from(container.querySelectorAll(focusableSelector));
  const include = includeContainer == true || includeContainer == "if-empty" && elements.length === 0;
  if (include && isHTMLElement(container) && isFocusable(container)) {
    elements.unshift(container);
  }
  const focusableElements = elements.filter(isFocusable);
  focusableElements.forEach((element, i) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      focusableElements.splice(i, 1, ...getFocusables(frameBody));
    }
  });
  return focusableElements;
};
function isFocusable(element) {
  if (!element || element.closest("[inert]")) return false;
  return element.matches(focusableSelector) && isElementVisible(element);
}
function getFirstFocusable(container, includeContainer) {
  const [first] = getFocusables(container, includeContainer);
  return first || null;
}
function getTabbables(container, includeContainer) {
  if (!container) return [];
  const elements = Array.from(container.querySelectorAll(focusableSelector));
  const tabbableElements = elements.filter(isTabbable);
  if (includeContainer && isTabbable(container)) {
    tabbableElements.unshift(container);
  }
  tabbableElements.forEach((element, i) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      const allFrameTabbable = getTabbables(frameBody);
      tabbableElements.splice(i, 1, ...allFrameTabbable);
    }
  });
  if (!tabbableElements.length && includeContainer) {
    return elements;
  }
  return tabbableElements;
}
function isTabbable(el) {
  if (el != null && el.tabIndex > 0) return true;
  return isFocusable(el) && !hasNegativeTabIndex(el);
}
function getFirstTabbable(container, includeContainer) {
  const [first] = getTabbables(container, includeContainer);
  return first || null;
}
function getLastTabbable(container, includeContainer) {
  const elements = getTabbables(container, includeContainer);
  return elements[elements.length - 1] || null;
}
function getTabbableEdges(container, includeContainer) {
  const elements = getTabbables(container, includeContainer);
  const first = elements[0] || null;
  const last = elements[elements.length - 1] || null;
  return [first, last];
}
function getNextTabbable(container, current) {
  const tabbables = getTabbables(container);
  const doc = container?.ownerDocument || document;
  const currentElement = current ?? doc.activeElement;
  if (!currentElement) return null;
  const index = tabbables.indexOf(currentElement);
  return tabbables[index + 1] || null;
}
function getTabIndex(node) {
  if (node.tabIndex < 0) {
    if ((/^(audio|video|details)$/.test(node.localName) || isEditableElement(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
}

// src/initial-focus.ts
function getInitialFocus(options) {
  const { root, getInitialEl, filter, enabled = true } = options;
  if (!enabled) return;
  let node = null;
  node || (node = typeof getInitialEl === "function" ? getInitialEl() : getInitialEl);
  node || (node = root?.querySelector("[data-autofocus],[autofocus]"));
  if (!node) {
    const tabbables = getTabbables(root);
    node = filter ? tabbables.filter(filter)[0] : tabbables[0];
  }
  return node || root || void 0;
}
function isValidTabEvent(event) {
  const container = event.currentTarget;
  if (!container) return false;
  const [firstTabbable, lastTabbable] = getTabbableEdges(container);
  const doc = container.ownerDocument || document;
  if (doc.activeElement === firstTabbable && event.shiftKey) return false;
  if (doc.activeElement === lastTabbable && !event.shiftKey) return false;
  if (!firstTabbable && !lastTabbable) return false;
  return true;
}

// src/raf.ts
function nextTick(fn) {
  const set = /* @__PURE__ */ new Set();
  function raf2(fn2) {
    const id = globalThis.requestAnimationFrame(fn2);
    set.add(() => globalThis.cancelAnimationFrame(id));
  }
  raf2(() => raf2(fn));
  return function cleanup() {
    set.forEach((fn2) => fn2());
  };
}
function raf(fn) {
  let cleanup;
  const id = globalThis.requestAnimationFrame(() => {
    cleanup = fn();
  });
  return () => {
    globalThis.cancelAnimationFrame(id);
    cleanup?.();
  };
}
function queueBeforeEvent(el, type, cb) {
  const cancelTimer = raf(() => {
    el.removeEventListener(type, exec, true);
    cb();
  });
  const exec = () => {
    cancelTimer();
    cb();
  };
  el.addEventListener(type, exec, { once: true, capture: true });
  return cancelTimer;
}

// src/mutation-observer.ts
function observeAttributesImpl(node, options) {
  if (!node) return;
  const { attributes, callback: fn } = options;
  const win = node.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver((changes) => {
    for (const change of changes) {
      if (change.type === "attributes" && change.attributeName && attributes.includes(change.attributeName)) {
        fn(change);
      }
    }
  });
  obs.observe(node, { attributes: true, attributeFilter: attributes });
  return () => obs.disconnect();
}
function observeAttributes(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups.push(observeAttributesImpl(node, options));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}
function observeChildrenImpl(node, options) {
  const { callback: fn } = options;
  if (!node) return;
  const win = node.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver(fn);
  obs.observe(node, { childList: true, subtree: true });
  return () => obs.disconnect();
}
function observeChildren(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups.push(observeChildrenImpl(node, options));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}

// src/navigate.ts
function clickIfLink(el) {
  const click = () => el.click();
  if (isFirefox()) {
    queueBeforeEvent(el, "keyup", click);
  } else {
    queueMicrotask(click);
  }
}

// src/overflow.ts
function getNearestOverflowAncestor(el) {
  const parentNode = getParentNode(el);
  if (isRootElement(parentNode)) return getDocument(parentNode).body;
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) return parentNode;
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(el, list = []) {
  const scrollableAncestor = getNearestOverflowAncestor(el);
  const isBody = scrollableAncestor === el.ownerDocument.body;
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []));
}
var getElementRect = (el) => {
  if (isHTMLElement(el)) return el.getBoundingClientRect();
  if (isVisualViewport(el)) return { top: 0, left: 0, bottom: el.height, right: el.width };
  return { top: 0, left: 0, bottom: el.innerHeight, right: el.innerWidth };
};
function isInView(el, ancestor) {
  if (!isHTMLElement(el)) return true;
  const ancestorRect = getElementRect(ancestor);
  const elRect = el.getBoundingClientRect();
  return elRect.top >= ancestorRect.top && elRect.left >= ancestorRect.left && elRect.bottom <= ancestorRect.bottom && elRect.right <= ancestorRect.right;
}
var OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/;
function isOverflowElement(el) {
  const win = getWindow(el);
  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el);
  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isScrollable(el) {
  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth;
}
function scrollIntoView(el, options) {
  const { rootEl, ...scrollOptions } = options || {};
  if (!el || !rootEl) return;
  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) return;
  el.scrollIntoView(scrollOptions);
}
function getScrollPosition(element) {
  if (isHTMLElement(element)) {
    return { scrollLeft: element.scrollLeft, scrollTop: element.scrollTop };
  }
  return { scrollLeft: element.scrollX, scrollTop: element.scrollY };
}

// src/point.ts
function getRelativePoint(point, element) {
  const { left, top, width, height } = element.getBoundingClientRect();
  const offset = { x: point.x - left, y: point.y - top };
  const percent = { x: clamp(offset.x / width), y: clamp(offset.y / height) };
  function getPercentValue(options = {}) {
    const { dir = "ltr", orientation = "horizontal", inverted } = options;
    const invertX = typeof inverted === "object" ? inverted.x : inverted;
    const invertY = typeof inverted === "object" ? inverted.y : inverted;
    if (orientation === "horizontal") {
      return dir === "rtl" || invertX ? 1 - percent.x : percent.x;
    }
    return invertY ? 1 - percent.y : percent.y;
  }
  return { offset, percent, getPercentValue };
}

// src/pointer-lock.ts
function requestPointerLock(doc, fn) {
  const body = doc.body;
  const supported = "pointerLockElement" in doc || "mozPointerLockElement" in doc;
  const isLocked = () => !!doc.pointerLockElement;
  function onPointerChange() {
    fn?.(isLocked());
  }
  function onPointerError(event) {
    if (isLocked()) fn?.(false);
    console.error("PointerLock error occurred:", event);
    doc.exitPointerLock();
  }
  if (!supported) return;
  try {
    body.requestPointerLock();
  } catch {
  }
  const cleanup = [
    addDomEvent(doc, "pointerlockchange", onPointerChange, false),
    addDomEvent(doc, "pointerlockerror", onPointerError, false)
  ];
  return () => {
    cleanup.forEach((cleanup2) => cleanup2());
    doc.exitPointerLock();
  };
}

// src/text-selection.ts
var state = "default";
var userSelect = "";
var elementMap = /* @__PURE__ */ new WeakMap();
function disableTextSelectionImpl(options = {}) {
  const { target, doc } = options;
  const docNode = doc ?? document;
  const rootEl = docNode.documentElement;
  if (isIos()) {
    if (state === "default") {
      userSelect = rootEl.style.webkitUserSelect;
      rootEl.style.webkitUserSelect = "none";
    }
    state = "disabled";
  } else if (target) {
    elementMap.set(target, target.style.userSelect);
    target.style.userSelect = "none";
  }
  return () => restoreTextSelection({ target, doc: docNode });
}
function restoreTextSelection(options = {}) {
  const { target, doc } = options;
  const docNode = doc ?? document;
  const rootEl = docNode.documentElement;
  if (isIos()) {
    if (state !== "disabled") return;
    state = "restoring";
    setTimeout(() => {
      nextTick(() => {
        if (state === "restoring") {
          if (rootEl.style.webkitUserSelect === "none") {
            rootEl.style.webkitUserSelect = userSelect || "";
          }
          userSelect = "";
          state = "default";
        }
      });
    }, 300);
  } else {
    if (target && elementMap.has(target)) {
      const prevUserSelect = elementMap.get(target);
      if (target.style.userSelect === "none") {
        target.style.userSelect = prevUserSelect ?? "";
      }
      if (target.getAttribute("style") === "") {
        target.removeAttribute("style");
      }
      elementMap.delete(target);
    }
  }
}
function disableTextSelection(options = {}) {
  const { defer, target, ...restOptions } = options;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = typeof target === "function" ? target() : target;
      cleanups.push(disableTextSelectionImpl({ ...restOptions, target: node }));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}

// src/pointer-move.ts
function trackPointerMove(doc, handlers) {
  const { onPointerMove, onPointerUp } = handlers;
  const handleMove = (event) => {
    const point = getEventPoint(event);
    const distance = Math.sqrt(point.x ** 2 + point.y ** 2);
    const moveBuffer = event.pointerType === "touch" ? 10 : 5;
    if (distance < moveBuffer) return;
    if (event.pointerType === "mouse" && event.button === 0) {
      onPointerUp();
      return;
    }
    onPointerMove({ point, event });
  };
  const cleanups = [
    addDomEvent(doc, "pointermove", handleMove, false),
    addDomEvent(doc, "pointerup", onPointerUp, false),
    addDomEvent(doc, "pointercancel", onPointerUp, false),
    addDomEvent(doc, "contextmenu", onPointerUp, false),
    disableTextSelection({ doc })
  ];
  return () => {
    cleanups.forEach((cleanup) => cleanup());
  };
}

// src/press.ts
function trackPress(options) {
  const {
    pointerNode,
    keyboardNode = pointerNode,
    onPress,
    onPressStart,
    onPressEnd,
    isValidKey = (e) => e.key === "Enter"
  } = options;
  if (!pointerNode) return noop;
  const win = getWindow(pointerNode);
  const doc = getDocument(pointerNode);
  let removeStartListeners = noop;
  let removeEndListeners = noop;
  let removeAccessibleListeners = noop;
  const getInfo = (event) => ({
    point: getEventPoint(event),
    event
  });
  function startPress(event) {
    onPressStart?.(getInfo(event));
  }
  function cancelPress(event) {
    onPressEnd?.(getInfo(event));
  }
  const startPointerPress = (startEvent) => {
    removeEndListeners();
    const endPointerPress = (endEvent) => {
      const target = getEventTarget(endEvent);
      if (contains(pointerNode, target)) {
        onPress?.(getInfo(endEvent));
      } else {
        onPressEnd?.(getInfo(endEvent));
      }
    };
    const removePointerUpListener = addDomEvent(win, "pointerup", endPointerPress, { passive: !onPress, once: true });
    const removePointerCancelListener = addDomEvent(win, "pointercancel", cancelPress, {
      passive: !onPressEnd,
      once: true
    });
    removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
    if (doc.activeElement === keyboardNode && startEvent.pointerType === "mouse") {
      startEvent.preventDefault();
    }
    startPress(startEvent);
  };
  const removePointerListener = addDomEvent(pointerNode, "pointerdown", startPointerPress, { passive: !onPressStart });
  const removeFocusListener = addDomEvent(keyboardNode, "focus", startAccessiblePress);
  removeStartListeners = pipe(removePointerListener, removeFocusListener);
  function startAccessiblePress() {
    const handleKeydown = (keydownEvent) => {
      if (!isValidKey(keydownEvent)) return;
      const handleKeyup = (keyupEvent) => {
        if (!isValidKey(keyupEvent)) return;
        const evt2 = new win.PointerEvent("pointerup");
        const info = getInfo(evt2);
        onPress?.(info);
        onPressEnd?.(info);
      };
      removeEndListeners();
      removeEndListeners = addDomEvent(keyboardNode, "keyup", handleKeyup);
      const evt = new win.PointerEvent("pointerdown");
      startPress(evt);
    };
    const handleBlur = () => {
      const evt = new win.PointerEvent("pointercancel");
      cancelPress(evt);
    };
    const removeKeydownListener = addDomEvent(keyboardNode, "keydown", handleKeydown);
    const removeBlurListener = addDomEvent(keyboardNode, "blur", handleBlur);
    removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
  }
  return () => {
    removeStartListeners();
    removeEndListeners();
    removeAccessibleListeners();
  };
}

// src/proxy-tab-focus.ts
function proxyTabFocusImpl(container, options = {}) {
  const { triggerElement, onFocus, onFocusEnter } = options;
  const doc = container?.ownerDocument || document;
  const body = doc.body;
  function onKeyDown(event) {
    if (event.key !== "Tab") return;
    let elementToFocus = null;
    const [firstTabbable, lastTabbable] = getTabbableEdges(container, true);
    const nextTabbableAfterTrigger = getNextTabbable(body, triggerElement);
    const noTabbableElements = !firstTabbable && !lastTabbable;
    if (event.shiftKey && nextTabbableAfterTrigger === doc.activeElement) {
      onFocusEnter?.();
      elementToFocus = lastTabbable;
    } else if (event.shiftKey && (doc.activeElement === firstTabbable || noTabbableElements)) {
      elementToFocus = triggerElement;
    } else if (!event.shiftKey && doc.activeElement === triggerElement) {
      onFocusEnter?.();
      elementToFocus = firstTabbable;
    } else if (!event.shiftKey && (doc.activeElement === lastTabbable || noTabbableElements)) {
      elementToFocus = nextTabbableAfterTrigger;
    }
    if (!elementToFocus) return;
    event.preventDefault();
    if (typeof onFocus === "function") {
      onFocus(elementToFocus);
    } else {
      elementToFocus.focus();
    }
  }
  return addDomEvent(doc, "keydown", onKeyDown, true);
}
function proxyTabFocus(container, options) {
  const { defer, triggerElement, ...restOptions } = options;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = typeof container === "function" ? container() : container;
      const trigger = typeof triggerElement === "function" ? triggerElement() : triggerElement;
      cleanups.push(proxyTabFocusImpl(node, { triggerElement: trigger, ...restOptions }));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}

// src/query.ts
function queryAll(root, selector) {
  return Array.from(root?.querySelectorAll(selector) ?? []);
}
function query(root, selector) {
  return root?.querySelector(selector) ?? null;
}
var defaultItemToId = (v) => v.id;
function itemById(v, id, itemToId = defaultItemToId) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId(v, id, itemToId = defaultItemToId) {
  const item = itemById(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
function nextById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);
  return v[idx];
}
function prevById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  if (idx === -1) return loop ? v[v.length - 1] : null;
  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);
  return v[idx];
}

// src/resize-observer.ts
function trackElementRect(elements, options) {
  const { onEntry, measure, box = "border-box" } = options;
  const elems = (Array.isArray(elements) ? elements : [elements]).filter(isHTMLElement);
  const win = getWindow(elems[0]);
  const trigger = (entries) => {
    const rects = elems.map((el) => measure(el));
    onEntry({ rects, entries });
  };
  trigger([]);
  const obs = new win.ResizeObserver(trigger);
  elems.forEach((el) => obs.observe(el, { box }));
  return () => obs.disconnect();
}

// src/scope.ts
function createScope(methods) {
  const dom = {
    getRootNode: (ctx) => ctx.getRootNode?.() ?? document,
    getDoc: (ctx) => getDocument(dom.getRootNode(ctx)),
    getWin: (ctx) => dom.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => getActiveElement(dom.getRootNode(ctx)),
    isActiveElement: (ctx, elem) => elem === dom.getActiveElement(ctx),
    getById: (ctx, id) => dom.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      setElementValue(elem, value.toString());
    }
  };
  return { ...dom, ...methods };
}

// src/searchable.ts
var sanitize = (str) => str.split("").map((char) => {
  const code = char.charCodeAt(0);
  if (code > 0 && code < 128) return char;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText = (el) => {
  return sanitize(el.dataset?.valuetext ?? el.textContent ?? "");
};
var match = (valueText, query2) => {
  return valueText.trim().toLowerCase().startsWith(query2.toLowerCase());
};
function getByText(v, text, currentId, itemToId = defaultItemToId) {
  const index = currentId ? indexOfId(v, currentId, itemToId) : -1;
  let items = currentId ? wrap(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match(getValueText(item), text));
}

// src/set.ts
function setAttribute(el, attr, v) {
  const prev = el.getAttribute(attr);
  const exists = prev != null;
  el.setAttribute(attr, v);
  return () => {
    if (!exists) {
      el.removeAttribute(attr);
    } else {
      el.setAttribute(attr, prev);
    }
  };
}
function setProperty(el, prop, v) {
  const exists = prop in el;
  const prev = el[prop];
  el[prop] = v;
  return () => {
    if (!exists) {
      delete el[prop];
    } else {
      el[prop] = prev;
    }
  };
}
function setStyle(el, style) {
  if (!el) return noop;
  const prev = Object.keys(style).reduce((acc, key) => {
    acc[key] = el.style.getPropertyValue(key);
    return acc;
  }, {});
  Object.assign(el.style, style);
  return () => {
    Object.assign(el.style, prev);
    if (el.style.length === 0) {
      el.removeAttribute("style");
    }
  };
}
function setStyleProperty(el, prop, value) {
  if (!el) return noop;
  const prev = el.style.getPropertyValue(prop);
  el.style.setProperty(prop, value);
  return () => {
    el.style.setProperty(prop, prev);
    if (el.style.length === 0) {
      el.removeAttribute("style");
    }
  };
}

// src/typeahead.ts
function getByTypeaheadImpl(baseItems, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const query2 = isRepeated ? search[0] : search;
  let items = baseItems.slice();
  const next = getByText(items, query2, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next;
}
var getByTypeahead = /* @__PURE__ */ Object.assign(getByTypeaheadImpl, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent
});
function isValidTypeaheadEvent(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}

// src/visual-viewport.ts
function trackVisualViewport(doc, fn) {
  const win = doc?.defaultView || window;
  const onResize = () => {
    fn?.(getViewportSize(win));
  };
  onResize();
  return addDomEvent(win.visualViewport ?? win, "resize", onResize);
}
function getViewportSize(win) {
  return {
    width: win.visualViewport?.width || win.innerWidth,
    height: win.visualViewport?.height || win.innerHeight
  };
}

// src/visually-hidden.ts
var visuallyHiddenStyle = {
  border: "0",
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0",
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap",
  wordWrap: "normal"
};
function setVisuallyHidden(el) {
  Object.assign(el.style, visuallyHiddenStyle);
}

// src/wait-for.ts
var fps = 1e3 / 60;
function waitForElement(query2, cb) {
  const el = query2();
  if (isHTMLElement(el) && el.isConnected) {
    cb(el);
    return () => void 0;
  } else {
    const timerId = setInterval(() => {
      const el2 = query2();
      if (isHTMLElement(el2) && el2.isConnected) {
        cb(el2);
        clearInterval(timerId);
      }
    }, fps);
    return () => clearInterval(timerId);
  }
}
function waitForElements(queries, cb) {
  const cleanups = [];
  queries?.forEach((query2) => {
    const clean = waitForElement(query2, cb);
    cleanups.push(clean);
  });
  return () => {
    cleanups.forEach((fn) => fn());
  };
}




/***/ }),

/***/ "./node_modules/@zag-js/editable/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@zag-js/editable/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anatomy: () => (/* binding */ anatomy),
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   machine: () => (/* binding */ machine),
/* harmony export */   props: () => (/* binding */ props),
/* harmony export */   splitProps: () => (/* binding */ splitProps)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _zag_js_interact_outside__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/interact-outside */ "./node_modules/@zag-js/interact-outside/dist/index.mjs");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");







// src/editable.anatomy.ts
var anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("editable").parts(
  "root",
  "area",
  "label",
  "preview",
  "input",
  "editTrigger",
  "submitTrigger",
  "cancelTrigger",
  "control"
);
var parts = anatomy.build();

// src/editable.dom.ts
var getRootId = (ctx) => ctx.ids?.root ?? `editable:${ctx.id}`;
var getAreaId = (ctx) => ctx.ids?.area ?? `editable:${ctx.id}:area`;
var getLabelId = (ctx) => ctx.ids?.label ?? `editable:${ctx.id}:label`;
var getPreviewId = (ctx) => ctx.ids?.preview ?? `editable:${ctx.id}:preview`;
var getInputId = (ctx) => ctx.ids?.input ?? `editable:${ctx.id}:input`;
var getControlId = (ctx) => ctx.ids?.control ?? `editable:${ctx.id}:control`;
var getSubmitTriggerId = (ctx) => ctx.ids?.submitTrigger ?? `editable:${ctx.id}:submit`;
var getCancelTriggerId = (ctx) => ctx.ids?.cancelTrigger ?? `editable:${ctx.id}:cancel`;
var getEditTriggerId = (ctx) => ctx.ids?.editTrigger ?? `editable:${ctx.id}:edit`;
var getInputEl = (ctx) => ctx.getById(getInputId(ctx));
var getPreviewEl = (ctx) => ctx.getById(getPreviewId(ctx));
var getSubmitTriggerEl = (ctx) => ctx.getById(getSubmitTriggerId(ctx));
var getCancelTriggerEl = (ctx) => ctx.getById(getCancelTriggerId(ctx));
var getEditTriggerEl = (ctx) => ctx.getById(getEditTriggerId(ctx));

// src/editable.connect.ts
function connect(service, normalize) {
  const { state, context, send, prop, scope, computed } = service;
  const disabled = prop("disabled");
  const interactive = computed("isInteractive");
  const readOnly = prop("readOnly");
  const invalid = prop("invalid");
  const autoResize = prop("autoResize");
  const translations = prop("translations");
  const editing = state.matches("edit");
  const placeholderProp = prop("placeholder");
  const placeholder = typeof placeholderProp === "string" ? { edit: placeholderProp, preview: placeholderProp } : placeholderProp;
  const value = context.get("value");
  const empty = value.trim() === "";
  const valueText = empty ? placeholder?.preview ?? "" : value;
  return {
    editing,
    empty,
    value,
    valueText,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2, src: "setValue" });
    },
    clearValue() {
      send({ type: "VALUE.SET", value: "", src: "clearValue" });
    },
    edit() {
      if (!interactive) return;
      send({ type: "EDIT" });
    },
    cancel() {
      if (!interactive) return;
      send({ type: "CANCEL" });
    },
    submit() {
      if (!interactive) return;
      send({ type: "SUBMIT" });
    },
    getRootProps() {
      return normalize.element({
        ...parts.root.attrs,
        id: getRootId(scope),
        dir: prop("dir")
      });
    },
    getAreaProps() {
      return normalize.element({
        ...parts.area.attrs,
        id: getAreaId(scope),
        dir: prop("dir"),
        style: autoResize ? { display: "inline-grid" } : void 0,
        "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(editing),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-placeholder-shown": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(empty)
      });
    },
    getLabelProps() {
      return normalize.label({
        ...parts.label.attrs,
        id: getLabelId(scope),
        dir: prop("dir"),
        htmlFor: getInputId(scope),
        "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(editing),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(invalid),
        onClick() {
          if (editing) return;
          const previewEl = getPreviewEl(scope);
          previewEl?.focus({ preventScroll: true });
        }
      });
    },
    getInputProps() {
      return normalize.input({
        ...parts.input.attrs,
        dir: prop("dir"),
        "aria-label": translations?.input,
        name: prop("name"),
        form: prop("form"),
        id: getInputId(scope),
        hidden: autoResize ? void 0 : !editing,
        placeholder: placeholder?.edit,
        maxLength: prop("maxLength"),
        required: prop("required"),
        disabled,
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        readOnly,
        "data-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(readOnly),
        "aria-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.ariaAttr)(invalid),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(invalid),
        "data-autoresize": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(autoResize),
        defaultValue: value,
        size: autoResize ? 1 : void 0,
        onChange(event) {
          send({
            type: "VALUE.SET",
            src: "input.change",
            value: event.currentTarget.value
          });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isComposingEvent)(event)) return;
          const keyMap = {
            Escape() {
              send({ type: "CANCEL" });
              event.preventDefault();
            },
            Enter(event2) {
              if (!computed("submitOnEnter")) return;
              const { localName } = event2.currentTarget;
              if (localName === "textarea") {
                const submitMod = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isApple)() ? event2.metaKey : event2.ctrlKey;
                if (!submitMod) return;
                send({ type: "SUBMIT", src: "keydown.enter" });
                return;
              }
              if (localName === "input" && !event2.shiftKey && !event2.metaKey) {
                send({ type: "SUBMIT", src: "keydown.enter" });
                event2.preventDefault();
              }
            }
          };
          const exec = keyMap[event.key];
          if (exec) {
            exec(event);
          }
        },
        style: autoResize ? {
          gridArea: "1 / 1 / auto / auto",
          visibility: !editing ? "hidden" : void 0
        } : void 0
      });
    },
    getPreviewProps() {
      return normalize.element({
        id: getPreviewId(scope),
        ...parts.preview.attrs,
        dir: prop("dir"),
        "data-placeholder-shown": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(empty),
        "aria-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.ariaAttr)(readOnly),
        "data-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "aria-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.ariaAttr)(disabled),
        "aria-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.ariaAttr)(invalid),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(invalid),
        "aria-label": translations?.edit,
        "data-autoresize": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(autoResize),
        children: valueText,
        hidden: autoResize ? void 0 : editing,
        tabIndex: interactive ? 0 : void 0,
        onClick() {
          if (!interactive) return;
          if (prop("activationMode") !== "click") return;
          send({ type: "EDIT", src: "click" });
        },
        onFocus() {
          if (!interactive) return;
          if (prop("activationMode") !== "focus") return;
          send({ type: "EDIT", src: "focus" });
        },
        onDoubleClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          if (prop("activationMode") !== "dblclick") return;
          send({ type: "EDIT", src: "dblclick" });
        },
        style: autoResize ? {
          whiteSpace: "pre",
          userSelect: "none",
          gridArea: "1 / 1 / auto / auto",
          visibility: editing ? "hidden" : void 0,
          // in event the preview overflow's the parent element
          overflow: "hidden",
          textOverflow: "ellipsis"
        } : void 0
      });
    },
    getEditTriggerProps() {
      return normalize.button({
        ...parts.editTrigger.attrs,
        id: getEditTriggerId(scope),
        dir: prop("dir"),
        "aria-label": translations?.edit,
        hidden: editing,
        type: "button",
        disabled,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "EDIT", src: "edit.click" });
        }
      });
    },
    getControlProps() {
      return normalize.element({
        id: getControlId(scope),
        ...parts.control.attrs,
        dir: prop("dir")
      });
    },
    getSubmitTriggerProps() {
      return normalize.button({
        ...parts.submitTrigger.attrs,
        dir: prop("dir"),
        id: getSubmitTriggerId(scope),
        "aria-label": translations?.submit,
        hidden: !editing,
        disabled,
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "SUBMIT", src: "submit.click" });
        }
      });
    },
    getCancelTriggerProps() {
      return normalize.button({
        ...parts.cancelTrigger.attrs,
        dir: prop("dir"),
        "aria-label": translations?.cancel,
        id: getCancelTriggerId(scope),
        hidden: !editing,
        type: "button",
        disabled,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "CANCEL", src: "cancel.click" });
        }
      });
    }
  };
}
var machine = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_2__.createMachine)({
  props({ props: props2 }) {
    return {
      activationMode: "focus",
      submitMode: "both",
      defaultValue: "",
      selectOnFocus: true,
      ...props2,
      translations: {
        input: "editable input",
        edit: "edit",
        submit: "submit",
        cancel: "cancel",
        ...props2.translations
      }
    };
  },
  initialState({ prop }) {
    const edit = prop("edit") || prop("defaultEdit");
    return edit ? "edit" : "preview";
  },
  entry: ["focusInputIfNeeded"],
  context: ({ bindable, prop }) => {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          return prop("onValueChange")?.({ value });
        }
      })),
      previousValue: bindable(() => ({
        defaultValue: ""
      }))
    };
  },
  watch({ track, action, context, prop }) {
    track([() => context.get("value")], () => {
      action(["syncInputValue"]);
    });
    track([() => prop("edit")], () => {
      action(["toggleEditing"]);
    });
  },
  computed: {
    submitOnEnter({ prop }) {
      return ["both", "enter"].includes(prop("submitMode"));
    },
    submitOnBlur({ prop }) {
      return ["both", "blur"].includes(prop("submitMode"));
    },
    isInteractive({ prop }) {
      return !(prop("disabled") || prop("readOnly"));
    }
  },
  on: {
    "VALUE.SET": {
      actions: ["setValue"]
    }
  },
  states: {
    preview: {
      entry: ["blurInputIfNeeded"],
      on: {
        "CONTROLLED.EDIT": {
          target: "edit",
          actions: ["setPreviousValue", "focusInput"]
        },
        EDIT: [
          {
            guard: "isEditControlled",
            actions: ["invokeOnEdit"]
          },
          {
            target: "edit",
            actions: ["setPreviousValue", "focusInput", "invokeOnEdit"]
          }
        ]
      }
    },
    edit: {
      effects: ["trackInteractOutside"],
      on: {
        "CONTROLLED.PREVIEW": [
          {
            guard: "isSubmitEvent",
            target: "preview",
            actions: ["setPreviousValue", "restoreFocus", "invokeOnSubmit"]
          },
          {
            target: "preview",
            actions: ["revertValue", "restoreFocus", "invokeOnCancel"]
          }
        ],
        CANCEL: [
          {
            guard: "isEditControlled",
            actions: ["invokeOnPreview"]
          },
          {
            target: "preview",
            actions: ["revertValue", "restoreFocus", "invokeOnCancel", "invokeOnPreview"]
          }
        ],
        SUBMIT: [
          {
            guard: "isEditControlled",
            actions: ["invokeOnPreview"]
          },
          {
            target: "preview",
            actions: ["setPreviousValue", "restoreFocus", "invokeOnSubmit", "invokeOnPreview"]
          }
        ]
      }
    }
  },
  implementations: {
    guards: {
      isEditControlled: ({ prop }) => prop("edit") != void 0,
      isSubmitEvent: ({ event }) => event.previousEvent?.type === "SUBMIT"
    },
    effects: {
      trackInteractOutside({ send, scope, prop, computed }) {
        return (0,_zag_js_interact_outside__WEBPACK_IMPORTED_MODULE_3__.trackInteractOutside)(getInputEl(scope), {
          exclude(target) {
            const ignore = [getCancelTriggerEl(scope), getSubmitTriggerEl(scope)];
            return ignore.some((el) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.contains)(el, target));
          },
          onFocusOutside: prop("onFocusOutside"),
          onPointerDownOutside: prop("onPointerDownOutside"),
          onInteractOutside(event) {
            prop("onInteractOutside")?.(event);
            if (event.defaultPrevented) return;
            const { focusable } = event.detail;
            send({
              type: computed("submitOnBlur") ? "SUBMIT" : "CANCEL",
              src: "interact-outside",
              focusable
            });
          }
        });
      }
    },
    actions: {
      restoreFocus({ event, scope, prop }) {
        if (event.focusable) return;
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => {
          const finalEl = prop("finalFocusEl")?.() ?? getEditTriggerEl(scope);
          finalEl?.focus({ preventScroll: true });
        });
      },
      clearValue({ context }) {
        context.set("value", "");
      },
      focusInputIfNeeded({ action, prop }) {
        const edit = prop("edit") || prop("defaultEdit");
        if (!edit) return;
        action(["focusInput"]);
      },
      focusInput({ scope, prop }) {
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => {
          const inputEl = getInputEl(scope);
          if (!inputEl) return;
          if (prop("selectOnFocus")) {
            inputEl.select();
          } else {
            inputEl.focus({ preventScroll: true });
          }
        });
      },
      invokeOnCancel({ prop, context }) {
        const prev = context.get("previousValue");
        prop("onValueRevert")?.({ value: prev });
      },
      invokeOnSubmit({ prop, context }) {
        const value = context.get("value");
        prop("onValueCommit")?.({ value });
      },
      invokeOnEdit({ prop }) {
        prop("onEditChange")?.({ edit: true });
      },
      invokeOnPreview({ prop }) {
        prop("onEditChange")?.({ edit: false });
      },
      toggleEditing({ prop, send, event }) {
        send({
          type: prop("edit") ? "CONTROLLED.EDIT" : "CONTROLLED.PREVIEW",
          previousEvent: event
        });
      },
      syncInputValue({ context, scope }) {
        const inputEl = getInputEl(scope);
        if (!inputEl) return;
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.setElementValue)(inputEl, context.get("value"));
      },
      setValue({ context, prop, event }) {
        const max = prop("maxLength");
        const value = max != null ? event.value.slice(0, max) : event.value;
        context.set("value", value);
      },
      setPreviousValue({ context }) {
        context.set("previousValue", context.get("value"));
      },
      revertValue({ context }) {
        const value = context.get("previousValue");
        if (!value) return;
        context.set("value", value);
      },
      blurInputIfNeeded({ scope }) {
        getInputEl(scope)?.blur();
      }
    }
  }
});
var props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_4__.createProps)()([
  "activationMode",
  "autoResize",
  "dir",
  "disabled",
  "finalFocusEl",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "maxLength",
  "name",
  "onEditChange",
  "onFocusOutside",
  "onInteractOutside",
  "onPointerDownOutside",
  "onValueChange",
  "onValueCommit",
  "onValueRevert",
  "placeholder",
  "readOnly",
  "required",
  "selectOnFocus",
  "edit",
  "defaultEdit",
  "submitMode",
  "translations",
  "defaultValue",
  "value"
]);
var splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_5__.createSplitProps)(props);




/***/ }),

/***/ "./node_modules/@zag-js/file-upload/dist/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@zag-js/file-upload/dist/index.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anatomy: () => (/* binding */ anatomy),
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   itemProps: () => (/* binding */ itemProps),
/* harmony export */   machine: () => (/* binding */ machine),
/* harmony export */   props: () => (/* binding */ props),
/* harmony export */   splitItemProps: () => (/* binding */ splitItemProps),
/* harmony export */   splitProps: () => (/* binding */ splitProps)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_file_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/file-utils */ "./node_modules/@zag-js/file-utils/dist/index.mjs");
/* harmony import */ var _zag_js_i18n_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/i18n-utils */ "./node_modules/@zag-js/i18n-utils/dist/index.mjs");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");








// src/file-upload.anatomy.ts
var anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("file-upload").parts(
  "root",
  "dropzone",
  "item",
  "itemDeleteTrigger",
  "itemGroup",
  "itemName",
  "itemPreview",
  "itemPreviewImage",
  "itemSizeText",
  "label",
  "trigger",
  "clearTrigger"
);
var parts = anatomy.build();

// src/file-upload.dom.ts
var getRootId = (ctx) => ctx.ids?.root ?? `file:${ctx.id}`;
var getDropzoneId = (ctx) => ctx.ids?.dropzone ?? `file:${ctx.id}:dropzone`;
var getHiddenInputId = (ctx) => ctx.ids?.hiddenInput ?? `file:${ctx.id}:input`;
var getTriggerId = (ctx) => ctx.ids?.trigger ?? `file:${ctx.id}:trigger`;
var getLabelId = (ctx) => ctx.ids?.label ?? `file:${ctx.id}:label`;
var getItemId = (ctx, id) => ctx.ids?.item?.(id) ?? `file:${ctx.id}:item:${id}`;
var getItemNameId = (ctx, id) => ctx.ids?.itemName?.(id) ?? `file:${ctx.id}:item-name:${id}`;
var getItemSizeTextId = (ctx, id) => ctx.ids?.itemSizeText?.(id) ?? `file:${ctx.id}:item-size:${id}`;
var getItemPreviewId = (ctx, id) => ctx.ids?.itemPreview?.(id) ?? `file:${ctx.id}:item-preview:${id}`;
var getRootEl = (ctx) => ctx.getById(getRootId(ctx));
var getHiddenInputEl = (ctx) => ctx.getById(getHiddenInputId(ctx));
var getDropzoneEl = (ctx) => ctx.getById(getDropzoneId(ctx));
function isEventWithFiles(event) {
  const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventTarget)(event);
  if (!event.dataTransfer) return !!target && "files" in target;
  return event.dataTransfer.types.some((type) => {
    return type === "Files" || type === "application/x-moz-file";
  });
}
function isFilesWithinRange(ctx, incomingCount) {
  const { context, prop, computed } = ctx;
  if (!computed("multiple") && incomingCount > 1) return false;
  if (!computed("multiple") && incomingCount + context.get("acceptedFiles").length === 2) return true;
  if (incomingCount + context.get("acceptedFiles").length > prop("maxFiles")) return false;
  return true;
}
function getFilesFromEvent(ctx, files) {
  const { context, prop, computed } = ctx;
  const acceptedFiles = [];
  const rejectedFiles = [];
  files.forEach((file) => {
    const [accepted, acceptError] = (0,_zag_js_file_utils__WEBPACK_IMPORTED_MODULE_2__.isValidFileType)(file, computed("acceptAttr"));
    const [sizeMatch, sizeError] = (0,_zag_js_file_utils__WEBPACK_IMPORTED_MODULE_2__.isValidFileSize)(file, prop("minFileSize"), prop("maxFileSize"));
    const validateErrors = prop("validate")?.(file, {
      acceptedFiles: context.get("acceptedFiles"),
      rejectedFiles: context.get("rejectedFiles")
    });
    const valid = validateErrors ? validateErrors.length === 0 : true;
    if (accepted && sizeMatch && valid) {
      acceptedFiles.push(file);
    } else {
      const errors = [acceptError, sizeError];
      if (!valid) errors.push(...validateErrors ?? []);
      rejectedFiles.push({ file, errors: errors.filter(Boolean) });
    }
  });
  if (!isFilesWithinRange(ctx, acceptedFiles.length)) {
    acceptedFiles.forEach((file) => {
      rejectedFiles.push({ file, errors: ["TOO_MANY_FILES"] });
    });
    acceptedFiles.splice(0);
  }
  return {
    acceptedFiles,
    rejectedFiles
  };
}
function setInputFiles(inputEl, files) {
  const win = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getWindow)(inputEl);
  try {
    if ("DataTransfer" in win) {
      const dataTransfer = new win.DataTransfer();
      files.forEach((file) => {
        dataTransfer.items.add(file);
      });
      inputEl.files = dataTransfer.files;
    }
  } catch {
  }
}

// src/file-upload.connect.ts
function connect(service, normalize) {
  const { state, send, prop, computed, scope, context } = service;
  const disabled = prop("disabled");
  const allowDrop = prop("allowDrop");
  const translations = prop("translations");
  const dragging = state.matches("dragging");
  const focused = state.matches("focused") && !disabled;
  return {
    dragging,
    focused,
    disabled: !!disabled,
    openFilePicker() {
      if (disabled) return;
      send({ type: "OPEN" });
    },
    deleteFile(file) {
      send({ type: "FILE.DELETE", file });
    },
    acceptedFiles: context.get("acceptedFiles"),
    rejectedFiles: context.get("rejectedFiles"),
    setFiles(files) {
      const count = files.length;
      send({ type: "FILES.SET", files, count });
    },
    clearRejectedFiles() {
      send({ type: "REJECTED_FILES.CLEAR" });
    },
    clearFiles() {
      send({ type: "FILES.CLEAR" });
    },
    getFileSize(file) {
      return (0,_zag_js_i18n_utils__WEBPACK_IMPORTED_MODULE_3__.formatBytes)(file.size, prop("locale"));
    },
    createFileUrl(file, cb) {
      const win = scope.getWin();
      const url = win.URL.createObjectURL(file);
      cb(url);
      return () => win.URL.revokeObjectURL(url);
    },
    setClipboardFiles(dt) {
      if (disabled) return false;
      const items = Array.from(dt?.items ?? []);
      const files = items.reduce((acc, item) => {
        if (item.kind !== "file") return acc;
        const file = item.getAsFile();
        if (!file) return acc;
        return [...acc, file];
      }, []);
      if (!files.length) return false;
      send({ type: "FILES.SET", files });
      return true;
    },
    getRootProps() {
      return normalize.element({
        ...parts.root.attrs,
        dir: prop("dir"),
        id: getRootId(scope),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-dragging": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(dragging)
      });
    },
    getDropzoneProps(props2 = {}) {
      return normalize.element({
        ...parts.dropzone.attrs,
        dir: prop("dir"),
        id: getDropzoneId(scope),
        tabIndex: disabled || props2.disableClick ? void 0 : 0,
        role: props2.disableClick ? "application" : "button",
        "aria-label": translations.dropzone,
        "aria-disabled": disabled,
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("invalid")),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-dragging": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(dragging),
        onKeyDown(event) {
          if (disabled) return;
          if (event.defaultPrevented) return;
          if (!(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isSelfTarget)(event)) return;
          if (props2.disableClick) return;
          if (event.key !== "Enter" && event.key !== " ") return;
          send({ type: "DROPZONE.CLICK", src: "keydown" });
        },
        onClick(event) {
          if (disabled) return;
          if (event.defaultPrevented) return;
          if (props2.disableClick) return;
          if (!(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isSelfTarget)(event)) return;
          if (event.currentTarget.localName === "label") {
            event.preventDefault();
          }
          send({ type: "DROPZONE.CLICK" });
        },
        onDragOver(event) {
          if (disabled) return;
          if (!allowDrop) return;
          event.preventDefault();
          event.stopPropagation();
          try {
            event.dataTransfer.dropEffect = "copy";
          } catch {
          }
          const hasFiles = isEventWithFiles(event);
          if (!hasFiles) return;
          const count = event.dataTransfer.items.length;
          send({ type: "DROPZONE.DRAG_OVER", count });
        },
        onDragLeave(event) {
          if (disabled) return;
          if (!allowDrop) return;
          if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.contains)(event.currentTarget, event.relatedTarget)) return;
          send({ type: "DROPZONE.DRAG_LEAVE" });
        },
        onDrop(event) {
          if (disabled) return;
          if (allowDrop) {
            event.preventDefault();
            event.stopPropagation();
          }
          const hasFiles = isEventWithFiles(event);
          if (disabled || !hasFiles) return;
          (0,_zag_js_file_utils__WEBPACK_IMPORTED_MODULE_2__.getFileEntries)(event.dataTransfer.items, prop("directory")).then((files) => {
            send({ type: "DROPZONE.DROP", files: (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.flatArray)(files) });
          });
        },
        onFocus() {
          if (disabled) return;
          send({ type: "DROPZONE.FOCUS" });
        },
        onBlur() {
          if (disabled) return;
          send({ type: "DROPZONE.BLUR" });
        }
      });
    },
    getTriggerProps() {
      return normalize.button({
        ...parts.trigger.attrs,
        dir: prop("dir"),
        id: getTriggerId(scope),
        disabled,
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("invalid")),
        type: "button",
        onClick(event) {
          if (disabled) return;
          if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.contains)(getDropzoneEl(scope), event.currentTarget)) {
            event.stopPropagation();
          }
          send({ type: "OPEN" });
        }
      });
    },
    getHiddenInputProps() {
      return normalize.input({
        id: getHiddenInputId(scope),
        tabIndex: -1,
        disabled,
        type: "file",
        required: prop("required"),
        capture: prop("capture"),
        name: prop("name"),
        accept: computed("acceptAttr"),
        webkitdirectory: prop("directory") ? "" : void 0,
        multiple: computed("multiple") || prop("maxFiles") > 1,
        onClick(event) {
          event.stopPropagation();
          event.currentTarget.value = "";
        },
        onInput(event) {
          if (disabled) return;
          const { files } = event.currentTarget;
          send({ type: "FILES.SET", files: files ? Array.from(files) : [] });
        },
        style: _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.visuallyHiddenStyle
      });
    },
    getItemGroupProps() {
      return normalize.element({
        ...parts.itemGroup.attrs,
        dir: prop("dir"),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled)
      });
    },
    getItemProps(props2) {
      const { file } = props2;
      return normalize.element({
        ...parts.item.attrs,
        dir: prop("dir"),
        id: getItemId(scope, file.name),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled)
      });
    },
    getItemNameProps(props2) {
      const { file } = props2;
      return normalize.element({
        ...parts.itemName.attrs,
        dir: prop("dir"),
        id: getItemNameId(scope, file.name),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled)
      });
    },
    getItemSizeTextProps(props2) {
      const { file } = props2;
      return normalize.element({
        ...parts.itemSizeText.attrs,
        dir: prop("dir"),
        id: getItemSizeTextId(scope, file.name),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled)
      });
    },
    getItemPreviewProps(props2) {
      const { file } = props2;
      return normalize.element({
        ...parts.itemPreview.attrs,
        dir: prop("dir"),
        id: getItemPreviewId(scope, file.name),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled)
      });
    },
    getItemPreviewImageProps(props2) {
      const { file, url } = props2;
      const isImage = file.type.startsWith("image/");
      if (!isImage) {
        throw new Error("Preview Image is only supported for image files");
      }
      return normalize.img({
        ...parts.itemPreviewImage.attrs,
        alt: translations.itemPreview?.(file),
        src: url,
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled)
      });
    },
    getItemDeleteTriggerProps(props2) {
      const { file } = props2;
      return normalize.button({
        ...parts.itemDeleteTrigger.attrs,
        dir: prop("dir"),
        type: "button",
        disabled,
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "aria-label": translations.deleteFile?.(file),
        onClick() {
          if (disabled) return;
          send({ type: "FILE.DELETE", file });
        }
      });
    },
    getLabelProps() {
      return normalize.label({
        ...parts.label.attrs,
        dir: prop("dir"),
        id: getLabelId(scope),
        htmlFor: getHiddenInputId(scope),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled)
      });
    },
    getClearTriggerProps() {
      return normalize.button({
        ...parts.clearTrigger.attrs,
        dir: prop("dir"),
        type: "button",
        disabled,
        hidden: context.get("acceptedFiles").length === 0,
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          send({ type: "FILES.CLEAR" });
        }
      });
    }
  };
}
var machine = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_5__.createMachine)({
  props({ props: props2 }) {
    return {
      minFileSize: 0,
      maxFileSize: Number.POSITIVE_INFINITY,
      maxFiles: 1,
      allowDrop: true,
      preventDocumentDrop: true,
      ...props2,
      translations: {
        dropzone: "dropzone",
        itemPreview: (file) => `preview of ${file.name}`,
        deleteFile: (file) => `delete file ${file.name}`,
        ...props2.translations
      }
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable, getContext }) {
    return {
      acceptedFiles: bindable(() => ({
        defaultValue: [],
        isEqual: (a, b) => a.length === b?.length && a.every((file, i) => (0,_zag_js_file_utils__WEBPACK_IMPORTED_MODULE_2__.isFileEqual)(file, b[i])),
        hash(value) {
          return value.map((file) => `${file.name}-${file.size}`).join(",");
        },
        onChange(value) {
          const ctx = getContext();
          prop("onFileAccept")?.({ files: value });
          prop("onFileChange")?.({ acceptedFiles: value, rejectedFiles: ctx.get("rejectedFiles") });
        }
      })),
      rejectedFiles: bindable(() => ({
        defaultValue: [],
        isEqual: (a, b) => a.length === b?.length && a.every((file, i) => (0,_zag_js_file_utils__WEBPACK_IMPORTED_MODULE_2__.isFileEqual)(file.file, b[i].file)),
        onChange(value) {
          const ctx = getContext();
          prop("onFileReject")?.({ files: value });
          prop("onFileChange")?.({ acceptedFiles: ctx.get("acceptedFiles"), rejectedFiles: value });
        }
      }))
    };
  },
  computed: {
    acceptAttr: ({ prop }) => (0,_zag_js_file_utils__WEBPACK_IMPORTED_MODULE_2__.getAcceptAttrString)(prop("accept")),
    multiple: ({ prop }) => prop("maxFiles") > 1
  },
  watch({ track, context, action }) {
    track([() => context.hash("acceptedFiles")], () => {
      action(["syncInputElement"]);
    });
  },
  on: {
    "FILES.SET": {
      actions: ["setFilesFromEvent"]
    },
    "FILE.DELETE": {
      actions: ["removeFile"]
    },
    "FILES.CLEAR": {
      actions: ["clearFiles"]
    },
    "REJECTED_FILES.CLEAR": {
      actions: ["clearRejectedFiles"]
    }
  },
  effects: ["preventDocumentDrop"],
  states: {
    idle: {
      on: {
        OPEN: {
          actions: ["openFilePicker"]
        },
        "DROPZONE.CLICK": {
          actions: ["openFilePicker"]
        },
        "DROPZONE.FOCUS": {
          target: "focused"
        },
        "DROPZONE.DRAG_OVER": {
          target: "dragging"
        }
      }
    },
    focused: {
      on: {
        "DROPZONE.BLUR": {
          target: "idle"
        },
        OPEN: {
          actions: ["openFilePicker"]
        },
        "DROPZONE.CLICK": {
          actions: ["openFilePicker"]
        },
        "DROPZONE.DRAG_OVER": {
          target: "dragging"
        }
      }
    },
    dragging: {
      on: {
        "DROPZONE.DROP": {
          target: "idle",
          actions: ["setFilesFromEvent"]
        },
        "DROPZONE.DRAG_LEAVE": {
          target: "idle"
        }
      }
    }
  },
  implementations: {
    effects: {
      preventDocumentDrop({ prop, scope }) {
        if (!prop("preventDocumentDrop")) return;
        if (!prop("allowDrop")) return;
        if (prop("disabled")) return;
        const doc = scope.getDoc();
        const onDragOver = (event) => {
          event?.preventDefault();
        };
        const onDrop = (event) => {
          if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.contains)(getRootEl(scope), (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventTarget)(event))) return;
          event.preventDefault();
        };
        return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.callAll)((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.addDomEvent)(doc, "dragover", onDragOver, false), (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.addDomEvent)(doc, "drop", onDrop, false));
      }
    },
    actions: {
      syncInputElement({ scope, context }) {
        queueMicrotask(() => {
          const inputEl = getHiddenInputEl(scope);
          if (!inputEl) return;
          setInputFiles(inputEl, context.get("acceptedFiles"));
          const win = scope.getWin();
          inputEl.dispatchEvent(new win.Event("change", { bubbles: true }));
        });
      },
      openFilePicker({ scope }) {
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => {
          getHiddenInputEl(scope)?.click();
        });
      },
      setFilesFromEvent(params) {
        const { computed, context, event } = params;
        const result = getFilesFromEvent(params, event.files);
        const { acceptedFiles, rejectedFiles } = result;
        if (computed("multiple")) {
          context.set("acceptedFiles", (prev) => [...prev, ...acceptedFiles]);
          context.set("rejectedFiles", rejectedFiles);
          return;
        }
        if (acceptedFiles.length) {
          const files = [acceptedFiles[0]];
          context.set("acceptedFiles", files);
          context.set("rejectedFiles", rejectedFiles);
        } else if (rejectedFiles.length) {
          context.set("acceptedFiles", context.get("acceptedFiles"));
          context.set("rejectedFiles", rejectedFiles);
        }
      },
      removeFile({ context, event }) {
        const files = context.get("acceptedFiles").filter((file) => file !== event.file);
        const rejectedFiles = context.get("rejectedFiles").filter((item) => item.file !== event.file);
        context.set("acceptedFiles", files);
        context.set("rejectedFiles", rejectedFiles);
      },
      clearRejectedFiles({ context }) {
        context.set("acceptedFiles", context.get("acceptedFiles"));
        context.set("rejectedFiles", []);
      },
      clearFiles({ context }) {
        context.set("acceptedFiles", []);
        context.set("rejectedFiles", []);
      }
    }
  }
});
var props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_6__.createProps)()([
  "accept",
  "allowDrop",
  "capture",
  "dir",
  "directory",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "locale",
  "maxFiles",
  "maxFileSize",
  "minFileSize",
  "name",
  "invalid",
  "onFileAccept",
  "onFileReject",
  "onFileChange",
  "preventDocumentDrop",
  "required",
  "translations",
  "validate"
]);
var splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.createSplitProps)(props);
var itemProps = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_6__.createProps)()(["file"]);
var splitItemProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.createSplitProps)(itemProps);




/***/ }),

/***/ "./node_modules/@zag-js/file-utils/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@zag-js/file-utils/dist/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dataURItoBlob: () => (/* binding */ dataURItoBlob),
/* harmony export */   downloadFile: () => (/* binding */ downloadFile),
/* harmony export */   getAcceptAttrString: () => (/* binding */ getAcceptAttrString),
/* harmony export */   getFileDataUrl: () => (/* binding */ getFileDataUrl),
/* harmony export */   getFileEntries: () => (/* binding */ getFileEntries),
/* harmony export */   getTotalFileSize: () => (/* binding */ getTotalFileSize),
/* harmony export */   isFileEqual: () => (/* binding */ isFileEqual),
/* harmony export */   isMSEdge: () => (/* binding */ isMSEdge),
/* harmony export */   isValidFileSize: () => (/* binding */ isValidFileSize),
/* harmony export */   isValidFileType: () => (/* binding */ isValidFileType)
/* harmony export */ });
// src/data-transfer.ts
var getItemEntry = (item) => typeof item.getAsEntry === "function" ? item.getAsEntry() : typeof item.webkitGetAsEntry === "function" ? item.webkitGetAsEntry() : null;
var isDirectoryEntry = (entry) => entry.isDirectory;
var isFileEntry = (entry) => entry.isFile;
var addRelativePath = (file, path) => {
  Object.defineProperty(file, "relativePath", { value: path ? `${path}/${file.name}` : file.name });
  return file;
};
var getFileEntries = (items, traverseDirectories) => Promise.all(
  Array.from(items).filter((item) => item.kind === "file").map((item) => {
    const entry = getItemEntry(item);
    if (!entry) return null;
    if (isDirectoryEntry(entry) && traverseDirectories) {
      return getDirectoryFiles(entry.createReader(), `${entry.name}`);
    }
    if (isFileEntry(entry)) {
      return new Promise((resolve) => {
        entry.file((file) => {
          resolve(addRelativePath(file, ""));
        });
      });
    }
  }).filter((b) => b)
);
var getDirectoryFiles = (reader, path = "") => new Promise((resolve) => {
  const entryPromises = [];
  const readDirectoryEntries = () => {
    reader.readEntries((entries) => {
      if (entries.length === 0) {
        resolve(Promise.all(entryPromises).then((entries2) => entries2.flat()));
        return;
      }
      const promises = entries.map((entry) => {
        if (!entry) return null;
        if (isDirectoryEntry(entry)) {
          return getDirectoryFiles(entry.createReader(), `${path}${entry.name}`);
        }
        if (isFileEntry(entry)) {
          return new Promise((resolve2) => {
            entry.file((file) => {
              resolve2(addRelativePath(file, path));
            });
          });
        }
      }).filter((b) => b);
      entryPromises.push(Promise.all(promises));
      readDirectoryEntries();
    });
  };
  readDirectoryEntries();
});

// src/data-url-to-blob.ts
function dataURItoBlob(uri) {
  const binary = atob(uri.split(",")[1]);
  const mimeString = uri.split(",")[0].split(":")[1].split(";")[0];
  const buffer = new ArrayBuffer(binary.length);
  const intArray = new Uint8Array(buffer);
  for (let i = 0; i < binary.length; i++) {
    intArray[i] = binary.charCodeAt(i);
  }
  return new Blob([buffer], { type: mimeString });
}

// src/download-file.ts
function isMSEdge(win) {
  return Boolean(win.navigator && win.navigator.msSaveOrOpenBlob);
}
function downloadFile(options) {
  const { file, win, type, name } = options;
  const doc = win.document;
  const obj = typeof file === "string" ? new Blob([file], { type }) : file;
  const fileName = file instanceof File ? name || file.name : name;
  if (isMSEdge(win)) {
    win.navigator.msSaveOrOpenBlob(obj, fileName || "file-download");
    return;
  }
  const url = win.URL.createObjectURL(obj);
  const anchor = doc.createElement("a");
  anchor.style.display = "none";
  anchor.href = url;
  anchor.rel = "noopener";
  anchor.download = fileName || "file-download";
  doc.documentElement.appendChild(anchor);
  anchor.click();
  setTimeout(() => {
    win.URL.revokeObjectURL(url);
    anchor.remove();
  }, 0);
}

// src/get-accept-attr.ts
function isMIMEType(v) {
  return v === "audio/*" || v === "video/*" || v === "image/*" || v === "text/*" || /\w+\/[-+.\w]+/g.test(v);
}
function isExt(v) {
  return /^.*\.[\w]+$/.test(v);
}
var isValidMIME = (v) => isMIMEType(v) || isExt(v);
function getAcceptAttrString(accept) {
  if (accept == null) return;
  if (typeof accept === "string") {
    return accept;
  }
  if (Array.isArray(accept)) {
    return accept.filter(isValidMIME).join(",");
  }
  return Object.entries(accept).reduce((a, [mimeType, ext]) => [...a, mimeType, ...ext], []).filter(isValidMIME).join(",");
}

// src/get-file-data-url.ts
var getFileDataUrl = async (file) => {
  const reader = new FileReader();
  return new Promise((resolve, reject) => {
    reader.onerror = () => {
      reader.abort();
      reject(new Error("There was an error reading a file"));
    };
    reader.onloadend = () => {
      const { result } = reader;
      if (result instanceof ArrayBuffer) {
        reject(new Error("Expected DataURL as string from Blob/File, got ArrayBuffer"));
      } else {
        resolve(result || void 0);
      }
    };
    reader.readAsDataURL(file);
  });
};

// src/get-total-file-size.ts
var getTotalFileSize = (files) => {
  return files.reduce((acc, file) => acc + file.size, 0);
};

// src/is-file-equal.ts
var isFileEqual = (file1, file2) => {
  return file1.name === file2.name && file1.size === file2.size && file1.type === file2.type;
};

// src/is-valid-file-size.ts
var isDefined = (v) => v !== void 0 && v !== null;
function isValidFileSize(file, minSize, maxSize) {
  if (isDefined(file.size)) {
    if (isDefined(minSize) && isDefined(maxSize)) {
      if (file.size > maxSize) return [false, "FILE_TOO_LARGE"];
      if (file.size < minSize) return [false, "FILE_TOO_SMALL"];
    } else if (isDefined(minSize) && file.size < minSize) {
      return [false, "FILE_TOO_SMALL"];
    } else if (isDefined(maxSize) && file.size > maxSize) {
      return [false, "FILE_TOO_LARGE"];
    }
  }
  return [true, null];
}

// src/is-valid-file-type.ts
function isFileAccepted(file, accept) {
  if (file && accept) {
    const types = Array.isArray(accept) ? accept : typeof accept === "string" ? accept.split(",") : [];
    if (types.length === 0) return true;
    const fileName = file.name || "";
    const mimeType = (file.type || "").toLowerCase();
    const baseMimeType = mimeType.replace(/\/.*$/, "");
    return types.some((type) => {
      const validType = type.trim().toLowerCase();
      if (validType.charAt(0) === ".") {
        return fileName.toLowerCase().endsWith(validType);
      }
      if (validType.endsWith("/*")) {
        return baseMimeType === validType.replace(/\/.*$/, "");
      }
      return mimeType === validType;
    });
  }
  return true;
}
function isValidFileType(file, accept) {
  const isAcceptable = file.type === "application/x-moz-file" || isFileAccepted(file, accept);
  return [isAcceptable, isAcceptable ? null : "FILE_INVALID_TYPE"];
}




/***/ }),

/***/ "./node_modules/@zag-js/focus-trap/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@zag-js/focus-trap/dist/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FocusTrap: () => (/* binding */ FocusTrap),
/* harmony export */   trapFocus: () => (/* binding */ trapFocus)
/* harmony export */ });
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");


var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var activeFocusTraps = {
  activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      const activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap.pause();
      }
    }
    const trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap(trapStack, trap) {
    const trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0) {
      trapStack[trapStack.length - 1].unpause();
    }
  }
};
var sharedTrapStack = [];
var FocusTrap = class {
  constructor(elements, options) {
    __publicField(this, "trapStack");
    __publicField(this, "config");
    __publicField(this, "doc");
    __publicField(this, "state", {
      containers: [],
      containerGroups: [],
      tabbableGroups: [],
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false,
      delayInitialFocusTimer: void 0,
      recentNavEvent: void 0
    });
    __publicField(this, "listenerCleanups", []);
    __publicField(this, "handleFocus", (event) => {
      const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getEventTarget)(event);
      const targetContained = this.findContainerIndex(target, event) >= 0;
      if (targetContained || (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isDocument)(target)) {
        if (targetContained) {
          this.state.mostRecentlyFocusedNode = target;
        }
      } else {
        event.stopImmediatePropagation();
        let nextNode;
        let navAcrossContainers = true;
        if (this.state.mostRecentlyFocusedNode) {
          if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getTabIndex)(this.state.mostRecentlyFocusedNode) > 0) {
            const mruContainerIdx = this.findContainerIndex(this.state.mostRecentlyFocusedNode);
            const { tabbableNodes } = this.state.containerGroups[mruContainerIdx];
            if (tabbableNodes.length > 0) {
              const mruTabIdx = tabbableNodes.findIndex((node) => node === this.state.mostRecentlyFocusedNode);
              if (mruTabIdx >= 0) {
                if (this.config.isKeyForward(this.state.recentNavEvent)) {
                  if (mruTabIdx + 1 < tabbableNodes.length) {
                    nextNode = tabbableNodes[mruTabIdx + 1];
                    navAcrossContainers = false;
                  }
                } else {
                  if (mruTabIdx - 1 >= 0) {
                    nextNode = tabbableNodes[mruTabIdx - 1];
                    navAcrossContainers = false;
                  }
                }
              }
            }
          } else {
            if (!this.state.containerGroups.some((g) => g.tabbableNodes.some((n) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getTabIndex)(n) > 0))) {
              navAcrossContainers = false;
            }
          }
        } else {
          navAcrossContainers = false;
        }
        if (navAcrossContainers) {
          nextNode = this.findNextNavNode({
            // move FROM the MRU node, not event-related node (which will be the node that is
            //  outside the trap causing the focus escape we're trying to fix)
            target: this.state.mostRecentlyFocusedNode,
            isBackward: this.config.isKeyBackward(this.state.recentNavEvent)
          });
        }
        if (nextNode) {
          this.tryFocus(nextNode);
        } else {
          this.tryFocus(this.state.mostRecentlyFocusedNode || this.getInitialFocusNode());
        }
      }
      this.state.recentNavEvent = void 0;
    });
    __publicField(this, "handlePointerDown", (event) => {
      const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getEventTarget)(event);
      if (this.findContainerIndex(target, event) >= 0) {
        return;
      }
      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {
        this.deactivate({ returnFocus: this.config.returnFocusOnDeactivate });
        return;
      }
      if (valueOrHandler(this.config.allowOutsideClick, event)) {
        return;
      }
      event.preventDefault();
    });
    __publicField(this, "handleClick", (event) => {
      const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getEventTarget)(event);
      if (this.findContainerIndex(target, event) >= 0) {
        return;
      }
      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {
        return;
      }
      if (valueOrHandler(this.config.allowOutsideClick, event)) {
        return;
      }
      event.preventDefault();
      event.stopImmediatePropagation();
    });
    __publicField(this, "handleTabKey", (event) => {
      if (this.config.isKeyForward(event) || this.config.isKeyBackward(event)) {
        this.state.recentNavEvent = event;
        const isBackward = this.config.isKeyBackward(event);
        const destinationNode = this.findNextNavNode({ event, isBackward });
        if (!destinationNode) return;
        if (isTabEvent(event)) {
          event.preventDefault();
        }
        this.tryFocus(destinationNode);
      }
    });
    __publicField(this, "handleEscapeKey", (event) => {
      if (isEscapeEvent(event) && valueOrHandler(this.config.escapeDeactivates, event) !== false) {
        event.preventDefault();
        this.deactivate();
      }
    });
    __publicField(this, "_mutationObserver");
    __publicField(this, "setupMutationObserver", () => {
      const win = this.doc.defaultView || window;
      this._mutationObserver = new win.MutationObserver((mutations) => {
        const isFocusedNodeRemoved = mutations.some((mutation) => {
          const removedNodes = Array.from(mutation.removedNodes);
          return removedNodes.some((node) => node === this.state.mostRecentlyFocusedNode);
        });
        if (isFocusedNodeRemoved) {
          this.tryFocus(this.getInitialFocusNode());
        }
      });
    });
    __publicField(this, "updateObservedNodes", () => {
      this._mutationObserver?.disconnect();
      if (this.state.active && !this.state.paused) {
        this.state.containers.map((container) => {
          this._mutationObserver?.observe(container, { subtree: true, childList: true });
        });
      }
    });
    __publicField(this, "getInitialFocusNode", () => {
      let node = this.getNodeForOption("initialFocus", { hasFallback: true });
      if (node === false) {
        return false;
      }
      if (node === void 0 || node && !(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(node)) {
        if (this.findContainerIndex(this.doc.activeElement) >= 0) {
          node = this.doc.activeElement;
        } else {
          const firstTabbableGroup = this.state.tabbableGroups[0];
          const firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
          node = firstTabbableNode || this.getNodeForOption("fallbackFocus");
        }
      } else if (node === null) {
        node = this.getNodeForOption("fallbackFocus");
      }
      if (!node) {
        throw new Error("Your focus-trap needs to have at least one focusable element");
      }
      if (!node.isConnected) {
        node = this.getNodeForOption("fallbackFocus");
      }
      return node;
    });
    __publicField(this, "tryFocus", (node) => {
      if (node === false) return;
      if (node === (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getActiveElement)(this.doc)) return;
      if (!node || !node.focus) {
        this.tryFocus(this.getInitialFocusNode());
        return;
      }
      node.focus({ preventScroll: !!this.config.preventScroll });
      this.state.mostRecentlyFocusedNode = node;
      if (isSelectableInput(node)) {
        node.select();
      }
    });
    __publicField(this, "deactivate", (deactivateOptions) => {
      if (!this.state.active) return this;
      const options = {
        onDeactivate: this.config.onDeactivate,
        onPostDeactivate: this.config.onPostDeactivate,
        checkCanReturnFocus: this.config.checkCanReturnFocus,
        ...deactivateOptions
      };
      clearTimeout(this.state.delayInitialFocusTimer);
      this.state.delayInitialFocusTimer = void 0;
      this.removeListeners();
      this.state.active = false;
      this.state.paused = false;
      this.updateObservedNodes();
      activeFocusTraps.deactivateTrap(this.trapStack, this);
      const onDeactivate = this.getOption(options, "onDeactivate");
      const onPostDeactivate = this.getOption(options, "onPostDeactivate");
      const checkCanReturnFocus = this.getOption(options, "checkCanReturnFocus");
      const returnFocus = this.getOption(options, "returnFocus", "returnFocusOnDeactivate");
      onDeactivate?.();
      const finishDeactivation = () => {
        delay(() => {
          if (returnFocus) {
            const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);
            this.tryFocus(returnFocusNode);
          }
          onPostDeactivate?.();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);
        checkCanReturnFocus(returnFocusNode).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    });
    __publicField(this, "pause", (pauseOptions) => {
      if (this.state.paused || !this.state.active) {
        return this;
      }
      const onPause = this.getOption(pauseOptions, "onPause");
      const onPostPause = this.getOption(pauseOptions, "onPostPause");
      this.state.paused = true;
      onPause?.();
      this.removeListeners();
      this.updateObservedNodes();
      onPostPause?.();
      return this;
    });
    __publicField(this, "unpause", (unpauseOptions) => {
      if (!this.state.paused || !this.state.active) {
        return this;
      }
      const onUnpause = this.getOption(unpauseOptions, "onUnpause");
      const onPostUnpause = this.getOption(unpauseOptions, "onPostUnpause");
      this.state.paused = false;
      onUnpause?.();
      this.updateTabbableNodes();
      this.addListeners();
      this.updateObservedNodes();
      onPostUnpause?.();
      return this;
    });
    __publicField(this, "updateContainerElements", (containerElements) => {
      this.state.containers = Array.isArray(containerElements) ? containerElements.filter(Boolean) : [containerElements].filter(Boolean);
      if (this.state.active) {
        this.updateTabbableNodes();
      }
      this.updateObservedNodes();
      return this;
    });
    __publicField(this, "getReturnFocusNode", (previousActiveElement) => {
      const node = this.getNodeForOption("setReturnFocus", {
        params: [previousActiveElement]
      });
      return node ? node : node === false ? false : previousActiveElement;
    });
    __publicField(this, "getOption", (configOverrideOptions, optionName, configOptionName) => {
      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : (
        // @ts-expect-error
        this.config[configOptionName || optionName]
      );
    });
    __publicField(this, "getNodeForOption", (optionName, { hasFallback = false, params = [] } = {}) => {
      let optionValue = this.config[optionName];
      if (typeof optionValue === "function") optionValue = optionValue(...params);
      if (optionValue === true) optionValue = void 0;
      if (!optionValue) {
        if (optionValue === void 0 || optionValue === false) {
          return optionValue;
        }
        throw new Error(`\`${optionName}\` was specified but was not a node, or did not return a node`);
      }
      let node = optionValue;
      if (typeof optionValue === "string") {
        try {
          node = this.doc.querySelector(optionValue);
        } catch (err) {
          throw new Error(`\`${optionName}\` appears to be an invalid selector; error="${err.message}"`);
        }
        if (!node) {
          if (!hasFallback) {
            throw new Error(`\`${optionName}\` as selector refers to no known node`);
          }
        }
      }
      return node;
    });
    __publicField(this, "findNextNavNode", (opts) => {
      const { event, isBackward = false } = opts;
      const target = opts.target || (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getEventTarget)(event);
      this.updateTabbableNodes();
      let destinationNode = null;
      if (this.state.tabbableGroups.length > 0) {
        const containerIndex = this.findContainerIndex(target, event);
        const containerGroup = containerIndex >= 0 ? this.state.containerGroups[containerIndex] : void 0;
        if (containerIndex < 0) {
          if (isBackward) {
            destinationNode = this.state.tabbableGroups[this.state.tabbableGroups.length - 1].lastTabbableNode;
          } else {
            destinationNode = this.state.tabbableGroups[0].firstTabbableNode;
          }
        } else if (isBackward) {
          let startOfGroupIndex = this.state.tabbableGroups.findIndex(
            ({ firstTabbableNode }) => target === firstTabbableNode
          );
          if (startOfGroupIndex < 0 && (containerGroup?.container === target || (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(target) && !(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(target) && !containerGroup?.nextTabbableNode(target, false))) {
            startOfGroupIndex = containerIndex;
          }
          if (startOfGroupIndex >= 0) {
            const destinationGroupIndex = startOfGroupIndex === 0 ? this.state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];
            destinationNode = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getTabIndex)(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
          } else if (!isTabEvent(event)) {
            destinationNode = containerGroup?.nextTabbableNode(target, false);
          }
        } else {
          let lastOfGroupIndex = this.state.tabbableGroups.findIndex(
            ({ lastTabbableNode }) => target === lastTabbableNode
          );
          if (lastOfGroupIndex < 0 && (containerGroup?.container === target || (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(target) && !(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(target) && !containerGroup?.nextTabbableNode(target))) {
            lastOfGroupIndex = containerIndex;
          }
          if (lastOfGroupIndex >= 0) {
            const destinationGroupIndex = lastOfGroupIndex === this.state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];
            destinationNode = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getTabIndex)(target) >= 0 ? destinationGroup.firstTabbableNode : destinationGroup.firstDomTabbableNode;
          } else if (!isTabEvent(event)) {
            destinationNode = containerGroup?.nextTabbableNode(target);
          }
        }
      } else {
        destinationNode = this.getNodeForOption("fallbackFocus");
      }
      return destinationNode;
    });
    this.trapStack = options.trapStack || sharedTrapStack;
    const config = {
      returnFocusOnDeactivate: true,
      escapeDeactivates: true,
      delayInitialFocus: true,
      isKeyForward(e) {
        return isTabEvent(e) && !e.shiftKey;
      },
      isKeyBackward(e) {
        return isTabEvent(e) && e.shiftKey;
      },
      ...options
    };
    this.doc = config.document || (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getDocument)(Array.isArray(elements) ? elements[0] : elements);
    this.config = config;
    this.updateContainerElements(elements);
    this.setupMutationObserver();
  }
  get active() {
    return this.state.active;
  }
  get paused() {
    return this.state.paused;
  }
  findContainerIndex(element, event) {
    const composedPath = typeof event?.composedPath === "function" ? event.composedPath() : void 0;
    return this.state.containerGroups.findIndex(
      ({ container, tabbableNodes }) => container.contains(element) || composedPath?.includes(container) || tabbableNodes.find((node) => node === element)
    );
  }
  updateTabbableNodes() {
    this.state.containerGroups = this.state.containers.map((container) => {
      const tabbableNodes = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getTabbables)(container);
      const focusableNodes = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getFocusables)(container);
      const firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
      const lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
      const firstDomTabbableNode = focusableNodes.find((node) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(node));
      const lastDomTabbableNode = focusableNodes.slice().reverse().find((node) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(node));
      const posTabIndexesFound = !!tabbableNodes.find((node) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getTabIndex)(node) > 0);
      function nextTabbableNode(node, forward = true) {
        const nodeIdx = tabbableNodes.indexOf(node);
        if (nodeIdx < 0) {
          if (forward) {
            return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find((el) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(el));
          }
          return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find((el) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(el));
        }
        return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
      }
      return {
        container,
        tabbableNodes,
        focusableNodes,
        posTabIndexesFound,
        firstTabbableNode,
        lastTabbableNode,
        firstDomTabbableNode,
        lastDomTabbableNode,
        nextTabbableNode
      };
    });
    this.state.tabbableGroups = this.state.containerGroups.filter((group) => group.tabbableNodes.length > 0);
    if (this.state.tabbableGroups.length <= 0 && !this.getNodeForOption("fallbackFocus")) {
      throw new Error(
        "Your focus-trap must have at least one container with at least one tabbable node in it at all times"
      );
    }
    if (this.state.containerGroups.find((g) => g.posTabIndexesFound) && this.state.containerGroups.length > 1) {
      throw new Error(
        "At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps."
      );
    }
  }
  addListeners() {
    if (!this.state.active) return;
    activeFocusTraps.activateTrap(this.trapStack, this);
    this.state.delayInitialFocusTimer = this.config.delayInitialFocus ? delay(() => {
      this.tryFocus(this.getInitialFocusNode());
    }) : this.tryFocus(this.getInitialFocusNode());
    this.listenerCleanups.push(
      (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.addDomEvent)(this.doc, "focusin", this.handleFocus, true),
      (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.addDomEvent)(this.doc, "mousedown", this.handlePointerDown, { capture: true, passive: false }),
      (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.addDomEvent)(this.doc, "touchstart", this.handlePointerDown, { capture: true, passive: false }),
      (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.addDomEvent)(this.doc, "click", this.handleClick, { capture: true, passive: false }),
      (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.addDomEvent)(this.doc, "keydown", this.handleTabKey, { capture: true, passive: false }),
      (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.addDomEvent)(this.doc, "keydown", this.handleEscapeKey)
    );
    return this;
  }
  removeListeners() {
    if (!this.state.active) return;
    this.listenerCleanups.forEach((cleanup) => cleanup());
    this.listenerCleanups = [];
    return this;
  }
  activate(activateOptions) {
    if (this.state.active) {
      return this;
    }
    const onActivate = this.getOption(activateOptions, "onActivate");
    const onPostActivate = this.getOption(activateOptions, "onPostActivate");
    const checkCanFocusTrap = this.getOption(activateOptions, "checkCanFocusTrap");
    if (!checkCanFocusTrap) {
      this.updateTabbableNodes();
    }
    this.state.active = true;
    this.state.paused = false;
    this.state.nodeFocusedBeforeActivation = this.doc.activeElement || null;
    onActivate?.();
    const finishActivation = () => {
      if (checkCanFocusTrap) {
        this.updateTabbableNodes();
      }
      this.addListeners();
      this.updateObservedNodes();
      onPostActivate?.();
    };
    if (checkCanFocusTrap) {
      checkCanFocusTrap(this.state.containers.concat()).then(finishActivation, finishActivation);
      return this;
    }
    finishActivation();
    return this;
  }
};
var isTabEvent = (event) => event.key === "Tab";
var valueOrHandler = (value, ...params) => typeof value === "function" ? value(...params) : value;
var isEscapeEvent = (event) => !event.isComposing && event.key === "Escape";
var delay = (fn) => setTimeout(fn, 0);
var isSelectableInput = (node) => node.localName === "input" && "select" in node && typeof node.select === "function";

// src/index.ts
function trapFocus(el, options = {}) {
  let trap;
  const cleanup = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.raf)(() => {
    const contentEl = typeof el === "function" ? el() : el;
    if (!contentEl) return;
    trap = new FocusTrap(contentEl, {
      escapeDeactivates: false,
      allowOutsideClick: true,
      preventScroll: true,
      returnFocusOnDeactivate: true,
      delayInitialFocus: false,
      fallbackFocus: contentEl,
      ...options,
      document: (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getDocument)(contentEl)
    });
    try {
      trap.activate();
    } catch {
    }
  });
  return function destroy() {
    trap?.deactivate();
    cleanup();
  };
}




/***/ }),

/***/ "./node_modules/@zag-js/focus-visible/dist/index.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@zag-js/focus-visible/dist/index.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getInteractionModality: () => (/* binding */ getInteractionModality),
/* harmony export */   isFocusVisible: () => (/* binding */ isFocusVisible),
/* harmony export */   listenerMap: () => (/* binding */ listenerMap),
/* harmony export */   setInteractionModality: () => (/* binding */ setInteractionModality),
/* harmony export */   trackFocusVisible: () => (/* binding */ trackFocusVisible),
/* harmony export */   trackInteractionModality: () => (/* binding */ trackInteractionModality)
/* harmony export */ });
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");


// src/index.ts
function isValidKey(e) {
  return !(e.metaKey || !(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isMac)() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
var nonTextInputTypes = /* @__PURE__ */ new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]);
function isKeyboardFocusEvent(isTextInput, modality, e) {
  const target = e ? (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getEventTarget)(e) : null;
  const win = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getWindow)(target);
  isTextInput = isTextInput || target instanceof win.HTMLInputElement && !nonTextInputTypes.has(target?.type) || target instanceof win.HTMLTextAreaElement || target instanceof win.HTMLElement && target.isContentEditable;
  return !(isTextInput && modality === "keyboard" && e instanceof win.KeyboardEvent && !Reflect.has(FOCUS_VISIBLE_INPUT_KEYS, e.key));
}
var currentModality = null;
var changeHandlers = /* @__PURE__ */ new Set();
var listenerMap = /* @__PURE__ */ new Map();
var hasEventBeforeFocus = false;
var hasBlurredWindowRecently = false;
var FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};
function triggerChangeHandlers(modality, e) {
  for (let handler of changeHandlers) {
    handler(modality, e);
  }
}
function handleKeyboardEvent(e) {
  hasEventBeforeFocus = true;
  if (isValidKey(e)) {
    currentModality = "keyboard";
    triggerChangeHandlers("keyboard", e);
  }
}
function handlePointerEvent(e) {
  currentModality = "pointer";
  if (e.type === "mousedown" || e.type === "pointerdown") {
    hasEventBeforeFocus = true;
    triggerChangeHandlers("pointer", e);
  }
}
function handleClickEvent(e) {
  if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isVirtualClick)(e)) {
    hasEventBeforeFocus = true;
    currentModality = "virtual";
  }
}
function handleFocusEvent(e) {
  const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getEventTarget)(e);
  if (target === (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getWindow)(target) || target === (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getDocument)(target)) {
    return;
  }
  if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", e);
  }
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = false;
}
function handleWindowBlur() {
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = true;
}
function setupGlobalFocusEvents(root) {
  if (typeof window === "undefined" || listenerMap.get((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getWindow)(root))) {
    return;
  }
  const win = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getWindow)(root);
  const doc = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getDocument)(root);
  let focus = win.HTMLElement.prototype.focus;
  win.HTMLElement.prototype.focus = function() {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", null);
    hasEventBeforeFocus = true;
    focus.apply(this, arguments);
  };
  doc.addEventListener("keydown", handleKeyboardEvent, true);
  doc.addEventListener("keyup", handleKeyboardEvent, true);
  doc.addEventListener("click", handleClickEvent, true);
  win.addEventListener("focus", handleFocusEvent, true);
  win.addEventListener("blur", handleWindowBlur, false);
  if (typeof win.PointerEvent !== "undefined") {
    doc.addEventListener("pointerdown", handlePointerEvent, true);
    doc.addEventListener("pointermove", handlePointerEvent, true);
    doc.addEventListener("pointerup", handlePointerEvent, true);
  } else {
    doc.addEventListener("mousedown", handlePointerEvent, true);
    doc.addEventListener("mousemove", handlePointerEvent, true);
    doc.addEventListener("mouseup", handlePointerEvent, true);
  }
  win.addEventListener(
    "beforeunload",
    () => {
      tearDownWindowFocusTracking(root);
    },
    { once: true }
  );
  listenerMap.set(win, { focus });
}
var tearDownWindowFocusTracking = (root, loadListener) => {
  const win = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getWindow)(root);
  const doc = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getDocument)(root);
  if (!listenerMap.has(win)) {
    return;
  }
  win.HTMLElement.prototype.focus = listenerMap.get(win).focus;
  doc.removeEventListener("keydown", handleKeyboardEvent, true);
  doc.removeEventListener("keyup", handleKeyboardEvent, true);
  doc.removeEventListener("click", handleClickEvent, true);
  win.removeEventListener("focus", handleFocusEvent, true);
  win.removeEventListener("blur", handleWindowBlur, false);
  if (typeof win.PointerEvent !== "undefined") {
    doc.removeEventListener("pointerdown", handlePointerEvent, true);
    doc.removeEventListener("pointermove", handlePointerEvent, true);
    doc.removeEventListener("pointerup", handlePointerEvent, true);
  } else {
    doc.removeEventListener("mousedown", handlePointerEvent, true);
    doc.removeEventListener("mousemove", handlePointerEvent, true);
    doc.removeEventListener("mouseup", handlePointerEvent, true);
  }
  listenerMap.delete(win);
};
function getInteractionModality() {
  return currentModality;
}
function setInteractionModality(modality) {
  currentModality = modality;
  triggerChangeHandlers(modality, null);
}
function trackInteractionModality(props) {
  const { onChange, root } = props;
  setupGlobalFocusEvents(root);
  onChange({ modality: currentModality });
  const handler = () => onChange({ modality: currentModality });
  changeHandlers.add(handler);
  return () => {
    changeHandlers.delete(handler);
  };
}
function isFocusVisible() {
  return currentModality === "keyboard";
}
function trackFocusVisible(props = {}) {
  const { isTextInput, autoFocus, onChange, root } = props;
  setupGlobalFocusEvents(root);
  onChange?.({ isFocusVisible: autoFocus || isFocusVisible(), modality: currentModality });
  const handler = (modality, e) => {
    if (!isKeyboardFocusEvent(!!isTextInput, modality, e)) return;
    onChange?.({ isFocusVisible: isFocusVisible(), modality });
  };
  changeHandlers.add(handler);
  return () => {
    changeHandlers.delete(handler);
  };
}




/***/ }),

/***/ "./node_modules/@zag-js/hover-card/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@zag-js/hover-card/dist/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anatomy: () => (/* binding */ anatomy),
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   machine: () => (/* binding */ machine),
/* harmony export */   props: () => (/* binding */ props),
/* harmony export */   splitProps: () => (/* binding */ splitProps)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
/* harmony import */ var _zag_js_popper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/popper */ "./node_modules/@zag-js/popper/dist/index.mjs");
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _zag_js_dismissable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/dismissable */ "./node_modules/@zag-js/dismissable/dist/index.mjs");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");







// src/hover-card.anatomy.ts
var anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("hoverCard").parts("arrow", "arrowTip", "trigger", "positioner", "content");
var parts = anatomy.build();

// src/hover-card.dom.ts
var getTriggerId = (ctx) => ctx.ids?.trigger ?? `hover-card:${ctx.id}:trigger`;
var getContentId = (ctx) => ctx.ids?.content ?? `hover-card:${ctx.id}:content`;
var getPositionerId = (ctx) => ctx.ids?.positioner ?? `hover-card:${ctx.id}:popper`;
var getArrowId = (ctx) => ctx.ids?.arrow ?? `hover-card:${ctx.id}:arrow`;
var getTriggerEl = (ctx) => ctx.getById(getTriggerId(ctx));
var getContentEl = (ctx) => ctx.getById(getContentId(ctx));
var getPositionerEl = (ctx) => ctx.getById(getPositionerId(ctx));

// src/hover-card.connect.ts
function connect(service, normalize) {
  const { state, send, prop, context, scope } = service;
  const open = state.hasTag("open");
  const popperStyles = (0,_zag_js_popper__WEBPACK_IMPORTED_MODULE_1__.getPlacementStyles)({
    ...prop("positioning"),
    placement: context.get("currentPlacement")
  });
  return {
    open,
    setOpen(nextOpen) {
      const open2 = state.hasTag("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getArrowProps() {
      return normalize.element({
        id: getArrowId(scope),
        ...parts.arrow.attrs,
        dir: prop("dir"),
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize.element({
        ...parts.arrowTip.attrs,
        dir: prop("dir"),
        style: popperStyles.arrowTip
      });
    },
    getTriggerProps() {
      return normalize.element({
        ...parts.trigger.attrs,
        dir: prop("dir"),
        "data-placement": context.get("currentPlacement"),
        id: getTriggerId(scope),
        "data-state": open ? "open" : "closed",
        onPointerEnter(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_ENTER", src: "trigger" });
        },
        onPointerLeave(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_LEAVE", src: "trigger" });
        },
        onFocus() {
          send({ type: "TRIGGER_FOCUS" });
        },
        onBlur() {
          send({ type: "TRIGGER_BLUR" });
        }
      });
    },
    getPositionerProps() {
      return normalize.element({
        id: getPositionerId(scope),
        ...parts.positioner.attrs,
        dir: prop("dir"),
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize.element({
        ...parts.content.attrs,
        dir: prop("dir"),
        id: getContentId(scope),
        hidden: !open,
        tabIndex: -1,
        "data-state": open ? "open" : "closed",
        "data-placement": context.get("currentPlacement"),
        onPointerEnter(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_ENTER", src: "content" });
        },
        onPointerLeave(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_LEAVE", src: "content" });
        }
      });
    }
  };
}
var { not, and } = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_2__.createGuards)();
var machine = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_2__.createMachine)({
  props({ props: props2 }) {
    return {
      openDelay: 700,
      closeDelay: 300,
      ...props2,
      positioning: {
        placement: "bottom",
        ...props2.positioning
      }
    };
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "closed";
  },
  context({ prop, bindable }) {
    return {
      open: bindable(() => ({
        defaultValue: prop("defaultOpen"),
        value: prop("open"),
        onChange(value) {
          prop("onOpenChange")?.({ open: value });
        }
      })),
      currentPlacement: bindable(() => ({
        defaultValue: void 0
      })),
      isPointer: bindable(() => ({
        defaultValue: false
      }))
    };
  },
  watch({ track, context, action }) {
    track([() => context.get("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  states: {
    closed: {
      tags: ["closed"],
      entry: ["clearIsPointer"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        POINTER_ENTER: {
          target: "opening",
          actions: ["setIsPointer"]
        },
        TRIGGER_FOCUS: {
          target: "opening"
        },
        OPEN: {
          target: "opening"
        }
      }
    },
    opening: {
      tags: ["closed"],
      effects: ["waitForOpenDelay"],
      on: {
        OPEN_DELAY: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        "CONTROLLED.OPEN": {
          target: "open"
        },
        "CONTROLLED.CLOSE": {
          target: "closed"
        },
        POINTER_LEAVE: [
          {
            guard: "isOpenControlled",
            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
            actions: ["invokeOnClose", "toggleVisibility"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        TRIGGER_BLUR: [
          {
            guard: and("isOpenControlled", not("isPointer")),
            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
            actions: ["invokeOnClose", "toggleVisibility"]
          },
          {
            guard: not("isPointer"),
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        CLOSE: [
          {
            guard: "isOpenControlled",
            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
            actions: ["invokeOnClose", "toggleVisibility"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ]
      }
    },
    open: {
      tags: ["open"],
      effects: ["trackDismissableElement", "trackPositioning"],
      on: {
        "CONTROLLED.CLOSE": {
          target: "closed"
        },
        POINTER_ENTER: {
          actions: ["setIsPointer"]
        },
        POINTER_LEAVE: {
          target: "closing"
        },
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        TRIGGER_BLUR: [
          {
            guard: and("isOpenControlled", not("isPointer")),
            actions: ["invokeOnClose"]
          },
          {
            guard: not("isPointer"),
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "POSITIONING.SET": {
          actions: ["reposition"]
        }
      }
    },
    closing: {
      tags: ["open"],
      effects: ["trackPositioning", "waitForCloseDelay"],
      on: {
        CLOSE_DELAY: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "CONTROLLED.CLOSE": {
          target: "closed"
        },
        "CONTROLLED.OPEN": {
          target: "open"
        },
        POINTER_ENTER: {
          target: "open",
          // no need to invokeOnOpen here because it's still open (but about to close)
          actions: ["setIsPointer"]
        }
      }
    }
  },
  implementations: {
    guards: {
      isPointer: ({ context }) => !!context.get("isPointer"),
      isOpenControlled: ({ prop }) => prop("open") != null
    },
    effects: {
      waitForOpenDelay({ send, prop }) {
        const id = setTimeout(() => {
          send({ type: "OPEN_DELAY" });
        }, prop("openDelay"));
        return () => clearTimeout(id);
      },
      waitForCloseDelay({ send, prop }) {
        const id = setTimeout(() => {
          send({ type: "CLOSE_DELAY" });
        }, prop("closeDelay"));
        return () => clearTimeout(id);
      },
      trackPositioning({ context, prop, scope }) {
        if (!context.get("currentPlacement")) {
          context.set("currentPlacement", prop("positioning").placement);
        }
        const getPositionerEl2 = () => getPositionerEl(scope);
        return (0,_zag_js_popper__WEBPACK_IMPORTED_MODULE_1__.getPlacement)(getTriggerEl(scope), getPositionerEl2, {
          ...prop("positioning"),
          defer: true,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      trackDismissableElement({ send, scope, prop }) {
        const getContentEl2 = () => getContentEl(scope);
        return (0,_zag_js_dismissable__WEBPACK_IMPORTED_MODULE_3__.trackDismissableElement)(getContentEl2, {
          defer: true,
          exclude: [getTriggerEl(scope)],
          onDismiss() {
            send({ type: "CLOSE", src: "interact-outside" });
          },
          onInteractOutside: prop("onInteractOutside"),
          onPointerDownOutside: prop("onPointerDownOutside"),
          onFocusOutside(event) {
            event.preventDefault();
            prop("onFocusOutside")?.(event);
          }
        });
      }
    },
    actions: {
      invokeOnClose({ prop }) {
        prop("onOpenChange")?.({ open: false });
      },
      invokeOnOpen({ prop }) {
        prop("onOpenChange")?.({ open: true });
      },
      setIsPointer({ context }) {
        context.set("isPointer", true);
      },
      clearIsPointer({ context }) {
        context.set("isPointer", false);
      },
      reposition({ context, prop, scope, event }) {
        const getPositionerEl2 = () => getPositionerEl(scope);
        (0,_zag_js_popper__WEBPACK_IMPORTED_MODULE_1__.getPlacement)(getTriggerEl(scope), getPositionerEl2, {
          ...prop("positioning"),
          ...event.options,
          defer: true,
          listeners: false,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      toggleVisibility({ prop, event, send }) {
        queueMicrotask(() => {
          send({ type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: event });
        });
      }
    }
  }
});
var props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_4__.createProps)()([
  "closeDelay",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onOpenChange",
  "defaultOpen",
  "open",
  "openDelay",
  "positioning",
  "onInteractOutside",
  "onPointerDownOutside",
  "onFocusOutside"
]);
var splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_5__.createSplitProps)(props);




/***/ }),

/***/ "./node_modules/@zag-js/i18n-utils/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@zag-js/i18n-utils/dist/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createFilter: () => (/* binding */ createFilter),
/* harmony export */   formatBytes: () => (/* binding */ formatBytes),
/* harmony export */   formatDate: () => (/* binding */ formatDate),
/* harmony export */   formatList: () => (/* binding */ formatList),
/* harmony export */   formatNumber: () => (/* binding */ formatNumber),
/* harmony export */   formatRelativeTime: () => (/* binding */ formatRelativeTime),
/* harmony export */   getDefaultLocale: () => (/* binding */ getDefaultLocale),
/* harmony export */   getLocaleDir: () => (/* binding */ getLocaleDir),
/* harmony export */   isRTL: () => (/* binding */ isRTL),
/* harmony export */   trackLocale: () => (/* binding */ trackLocale)
/* harmony export */ });
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");


// src/cache.ts
function i18nCache(Ins) {
  const formatterCache = /* @__PURE__ */ new Map();
  return function create(locale, options) {
    const cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
    if (formatterCache.has(cacheKey)) {
      return formatterCache.get(cacheKey);
    }
    let formatter = new Ins(locale, options);
    formatterCache.set(cacheKey, formatter);
    return formatter;
  };
}

// src/filter.ts
var collatorCache = i18nCache(Intl.Collator);
function createFilter(options) {
  const { locale, ...rest } = options || {};
  const collator = collatorCache(locale || "en-US", { usage: "search", ...rest });
  function normalize(string) {
    string = string.normalize("NFC");
    if (collator.resolvedOptions().ignorePunctuation) {
      string = string.replace(/\p{P}/gu, "");
    }
    return string;
  }
  function startsWith(string, substring) {
    if (substring.length === 0) return true;
    string = normalize(string);
    substring = normalize(substring);
    return collator.compare(string.slice(0, substring.length), substring) === 0;
  }
  function endsWith(string, substring) {
    if (substring.length === 0) return true;
    string = normalize(string);
    substring = normalize(substring);
    return collator.compare(string.slice(-substring.length), substring) === 0;
  }
  function contains(string, substring) {
    if (substring.length === 0) return true;
    string = normalize(string);
    substring = normalize(substring);
    let scan = 0;
    let sliceLen = substring.length;
    for (; scan + sliceLen <= string.length; scan++) {
      let slice = string.slice(scan, scan + sliceLen);
      if (collator.compare(substring, slice) === 0) {
        return true;
      }
    }
    return false;
  }
  return {
    startsWith,
    endsWith,
    contains
  };
}

// src/format-number.ts
var getNumberFormatter = i18nCache(Intl.NumberFormat);
function formatNumber(v, locale, options = {}) {
  const formatter = getNumberFormatter(locale, options);
  return formatter.format(v);
}

// src/format-bytes.ts
var bitPrefixes = ["", "kilo", "mega", "giga", "tera"];
var bytePrefixes = ["", "kilo", "mega", "giga", "tera", "peta"];
var formatBytes = (bytes, locale = "en-US", options = {}) => {
  if (isNaN(bytes)) return "";
  if (bytes === 0) return "0 B";
  const { unit = "byte", unitDisplay = "short" } = options;
  const prefix = unit === "bit" ? bitPrefixes : bytePrefixes;
  const index = Math.max(0, Math.min(Math.floor(Math.log10(bytes) / 3), prefix.length - 1));
  const _unit = prefix[index] + unit;
  const _unitDisplay = unitDisplay || "short";
  const v = parseFloat((bytes / Math.pow(1e3, index)).toPrecision(3));
  return formatNumber(v, locale, {
    style: "unit",
    unit: _unit,
    unitDisplay: _unitDisplay
  });
};

// src/format-date.ts
var symbols = "\\s|\\.|-|/|\\\\|,|\\$|\\!|\\?|:|;";
function createRegEx(sign) {
  return new RegExp("(^|>|" + symbols + ")(" + sign + ")($|<|" + symbols + ")", "g");
}
var FORMATS = [
  "G",
  "GG",
  "GGG",
  "GGGG",
  "GGGGG",
  "y",
  "yo",
  "yy",
  "yyy",
  "yyyy",
  "Y",
  "Yo",
  "YY",
  "YYY",
  "YYYY",
  "Q",
  "Qo",
  "QQ",
  "QQQ",
  "QQQQ",
  "QQQQQ",
  "M",
  "Mo",
  "MM",
  "MMM",
  "MMMM",
  "MMMMM",
  "E",
  "EE",
  "EEE",
  "EEEE",
  "EEEEE",
  "EEEEEE",
  "a",
  "aa",
  "aaa",
  "aaaa",
  "aaaaa",
  "d",
  "do",
  "dd",
  "D",
  "Do",
  "DD",
  "DDD",
  "w",
  "wo",
  "ww",
  "s",
  "so",
  "ss",
  "m",
  "mo",
  "mm",
  "h",
  "ho",
  "hh",
  "H",
  "Ho",
  "HH",
  "z",
  "zz",
  "zzz",
  "zzzz",
  "T"
];
function ordinal(num) {
  const n = typeof num === "string" ? parseFloat(num) : num;
  let suffix = "th";
  if (n % 10 === 1 && n % 100 !== 11) {
    suffix = "st";
  } else if (n % 10 === 2 && n % 100 !== 12) {
    suffix = "nd";
  } else if (n % 10 === 3 && n % 100 !== 13) {
    suffix = "rd";
  }
  return `${n}${suffix}`;
}
function pad(num, length) {
  return String(num).padStart(length, "0");
}
function zone(str) {
  return str.split(/AM|PM/)[1].trim();
}
function getFormat(date, options) {
  const { locale, format, timeZone } = options;
  switch (format) {
    // era
    case "G":
    case "GG":
    case "GGG":
      return date.toLocaleString(locale, { era: "short" });
    case "GGGG":
      return date.toLocaleString(locale, { era: "long" });
    case "GGGGG":
      return date.toLocaleString(locale, { era: "narrow" });
    // year
    case "y":
    case "Y":
      return date.getFullYear();
    case "yo":
    case "Yo":
      return ordinal(date.toLocaleString(locale, { year: "numeric" }));
    case "yy":
    case "YY":
      return date.toLocaleString(locale, { year: "2-digit" });
    case "yyy":
    case "YYY":
      return date.toLocaleString(locale, { year: "numeric" }).padStart(3, "0");
    case "yyyy":
    case "YYYY":
      return date.toLocaleString(locale, { year: "numeric" }).padStart(4, "0");
    // quarter
    case "Q":
    case "QQQQQ":
      return Math.ceil((date.getMonth() + 1) / 3);
    case "Qo":
      return ordinal(Math.ceil((date.getMonth() + 1) / 3));
    case "QQ":
      return pad(Math.ceil((date.getMonth() + 1) / 3), 2);
    case "QQQ":
      return `Q${Math.ceil((date.getMonth() + 1) / 3)}`;
    case "QQQQ": {
      const base = ordinal(String(Math.ceil((date.getMonth() + 1) / 3)));
      return `${base} quarter`;
    }
    // month
    case "M":
      return date.getMonth() + 1;
    case "Mo":
      return ordinal(date.getMonth() + 1);
    case "MM":
      return date.toLocaleString(locale, { month: "2-digit" });
    case "MMM":
      return date.toLocaleString(locale, { month: "short" });
    case "MMMM":
      return date.toLocaleString(locale, { month: "long" });
    case "MMMMM":
      return date.toLocaleString(locale, { month: "narrow" });
    // week
    case "w":
      return Math.ceil(date.getDate() / 7);
    case "wo":
      return ordinal(Math.ceil(date.getDate() / 7));
    case "ww":
      return pad(Math.ceil(date.getDate() / 7), 2);
    // day
    case "d":
    case "D":
      return date.getDate();
    case "do":
    case "Do":
      return ordinal(date.getDate());
    case "dd":
    case "DD":
      return date.toLocaleString(locale, { day: "2-digit" });
    case "DDD":
      return pad(date.getDate(), 3);
    // weekday
    case "E":
    case "EE":
    case "EEE":
      return date.toLocaleString(locale, { weekday: "short" });
    case "EEEE":
      return date.toLocaleString(locale, { weekday: "long" });
    case "EEEEE":
      return date.toLocaleString(locale, { weekday: "narrow" });
    case "EEEEEE":
      return date.toLocaleString(locale, { weekday: "short" }).slice(0, 2);
    // hour
    case "h":
      return date.toLocaleString(locale, { hour: "numeric", hour12: true });
    case "ho":
      return ordinal(date.toLocaleString(locale, { hour: "2-digit", hour12: true }));
    case "hh":
      return date.toLocaleString(locale, { hour: "2-digit", hour12: true });
    case "H":
      return date.toLocaleString(locale, { hour: "numeric", hour12: false });
    case "Ho":
      return ordinal(+date.toLocaleString(locale, { hour: "numeric", hour12: false }));
    case "HH":
      return date.toLocaleString(locale, { hour: "2-digit", hour12: false });
    // minute
    case "m":
      return date.toLocaleString(locale, { minute: "numeric" });
    case "mo":
      return ordinal(date.toLocaleString(locale, { minute: "numeric" }));
    case "mm":
      return date.toLocaleString(locale, { minute: "2-digit" });
    // second
    case "s":
      return date.toLocaleString(locale, { second: "numeric" });
    case "so":
      return ordinal(date.toLocaleString(locale, { second: "numeric" }));
    case "ss":
      return date.toLocaleString(locale, { second: "2-digit" });
    // timestamp
    case "T":
      return date.getTime();
    // day period
    case "a":
    case "aa":
    case "aaa":
      return date.toLocaleString(locale, { hour: "numeric", hour12: true }).toLocaleUpperCase();
    case "aaaa":
      return date.toLocaleString(locale, { hour: "numeric", hour12: true }).toLocaleLowerCase();
    case "aaaaa":
      return date.toLocaleString(locale, { hour: "numeric", hour12: true }).charAt(0);
    // TODO:Revise this
    case "z":
    case "zz":
    case "zzz": {
      return zone(date.toLocaleString(locale, { timeZone, timeZoneName: "shortOffset" }));
    }
    case "zzzz":
      return zone(date.toLocaleString(locale, { timeZone, timeZoneName: "longOffset" }));
    default:
      throw new Error(`Unknown format: ${format}`);
  }
}
function formatDate(date, format, locale, timeZone) {
  let result = format;
  for (const key of FORMATS) {
    const res = getFormat(date, { locale, format: key, timeZone });
    result = result.replace(createRegEx(key), "$1" + res + "$3");
  }
  return result;
}

// src/format-list.ts
var getListFormatter = i18nCache(Intl.ListFormat);
function formatList(list, locale, options = {}) {
  const formatter = getListFormatter(locale, options);
  return formatter.format(list);
}

// src/format-relative-time.ts
var getRelativeTimeFormatter = i18nCache(Intl.RelativeTimeFormat);
function formatRelativeTime(value, locale, options = {}) {
  const rtf = getRelativeTimeFormatter(locale, options);
  const now = /* @__PURE__ */ new Date();
  const diff = getDistance(now, value);
  if (diff.years > 0) return rtf.format(diff.years * diff.sign, "year");
  if (diff.months > 0) return rtf.format(diff.months * diff.sign, "month");
  if (diff.weeks > 0) return rtf.format(diff.weeks * diff.sign, "week");
  if (diff.days > 0) return rtf.format(diff.days * diff.sign, "day");
  if (diff.hours > 0) return rtf.format(diff.hours * diff.sign, "hour");
  if (diff.minutes > 0) return rtf.format(diff.minutes * diff.sign, "minute");
  return rtf.format(diff.seconds * diff.sign, "second");
}
var SECOND_TO_MS = 1e3;
var MINUTE_TO_MS = 1e3 * 60;
var HOUR_TO_MS = 1e3 * 60 * 60;
var DAY_TO_MS = 1e3 * 60 * 60 * 24;
var WEEK_TO_MS = 1e3 * 60 * 60 * 24 * 7;
var MONTH_TO_MS = 1e3 * 60 * 60 * 24 * 30;
var YEAR_TO_MS = 1e3 * 60 * 60 * 24 * 365;
function getDistance(startDate, endDate) {
  const endTime = endDate.getTime();
  const startTime = startDate.getTime();
  const distance = Math.abs(endTime - startTime);
  return {
    sign: Math.sign(endTime - startTime),
    days: Math.floor(distance / DAY_TO_MS),
    hours: Math.floor(distance % DAY_TO_MS / HOUR_TO_MS),
    minutes: Math.floor(distance % HOUR_TO_MS / MINUTE_TO_MS),
    seconds: Math.floor(distance % MINUTE_TO_MS / SECOND_TO_MS),
    weeks: Math.floor(distance / WEEK_TO_MS),
    months: Math.floor(distance / MONTH_TO_MS),
    years: Math.floor(distance / YEAR_TO_MS)
  };
}

// src/is-rtl.ts
var RTL_SCRIPTS = /* @__PURE__ */ new Set([
  "Avst",
  "Arab",
  "Armi",
  "Syrc",
  "Samr",
  "Mand",
  "Thaa",
  "Mend",
  "Nkoo",
  "Adlm",
  "Rohg",
  "Hebr"
]);
var RTL_LANGS = /* @__PURE__ */ new Set([
  "ae",
  "ar",
  "arc",
  "bcc",
  "bqi",
  "ckb",
  "dv",
  "fa",
  "glk",
  "he",
  "ku",
  "mzn",
  "nqo",
  "pnb",
  "ps",
  "sd",
  "ug",
  "ur",
  "yi"
]);
function isRTL(locale) {
  if (Intl.Locale) {
    const script = new Intl.Locale(locale).maximize().script ?? "";
    return RTL_SCRIPTS.has(script);
  }
  const lang = locale.split("-")[0];
  return RTL_LANGS.has(lang);
}
function getLocaleDir(locale) {
  return isRTL(locale) ? "rtl" : "ltr";
}

// src/locale.ts
function getDefaultLocale() {
  let locale = typeof navigator !== "undefined" && (navigator.language || navigator.userLanguage) || "en-US";
  return {
    locale,
    dir: isRTL(locale) ? "rtl" : "ltr"
  };
}
function trackLocale(options = {}) {
  const { getRootNode, onLocaleChange } = options;
  onLocaleChange?.(getDefaultLocale());
  const handleLocaleChange = () => {
    onLocaleChange?.(getDefaultLocale());
  };
  const win = getRootNode ? (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getWindow)(getRootNode()) : window;
  win.addEventListener("languagechange", handleLocaleChange);
  return () => {
    win.removeEventListener("languagechange", handleLocaleChange);
  };
}




/***/ }),

/***/ "./node_modules/@zag-js/interact-outside/dist/index.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@zag-js/interact-outside/dist/index.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   trackInteractOutside: () => (/* binding */ trackInteractOutside)
/* harmony export */ });
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");



// src/index.ts

// src/frame-utils.ts
function getWindowFrames(win) {
  const frames = {
    each(cb) {
      for (let i = 0; i < win.frames?.length; i += 1) {
        const frame = win.frames[i];
        if (frame) cb(frame);
      }
    },
    addEventListener(event, listener, options) {
      frames.each((frame) => {
        try {
          frame.document.addEventListener(event, listener, options);
        } catch {
        }
      });
      return () => {
        try {
          frames.removeEventListener(event, listener, options);
        } catch {
        }
      };
    },
    removeEventListener(event, listener, options) {
      frames.each((frame) => {
        try {
          frame.document.removeEventListener(event, listener, options);
        } catch {
        }
      });
    }
  };
  return frames;
}
function getParentWindow(win) {
  const parent = win.frameElement != null ? win.parent : null;
  return {
    addEventListener: (event, listener, options) => {
      try {
        parent?.addEventListener(event, listener, options);
      } catch {
      }
      return () => {
        try {
          parent?.removeEventListener(event, listener, options);
        } catch {
        }
      };
    },
    removeEventListener: (event, listener, options) => {
      try {
        parent?.removeEventListener(event, listener, options);
      } catch {
      }
    }
  };
}

// src/index.ts
var POINTER_OUTSIDE_EVENT = "pointerdown.outside";
var FOCUS_OUTSIDE_EVENT = "focus.outside";
function isComposedPathFocusable(composedPath) {
  for (const node of composedPath) {
    if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(node) && (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(node)) return true;
  }
  return false;
}
var isPointerEvent = (event) => "clientY" in event;
function isEventPointWithin(node, event) {
  if (!isPointerEvent(event) || !node) return false;
  const rect = node.getBoundingClientRect();
  if (rect.width === 0 || rect.height === 0) return false;
  return rect.top <= event.clientY && event.clientY <= rect.top + rect.height && rect.left <= event.clientX && event.clientX <= rect.left + rect.width;
}
function isPointInRect(rect, point) {
  return rect.y <= point.y && point.y <= rect.y + rect.height && rect.x <= point.x && point.x <= rect.x + rect.width;
}
function isEventWithinScrollbar(event, ancestor) {
  if (!ancestor || !isPointerEvent(event)) return false;
  const isScrollableY = ancestor.scrollHeight > ancestor.clientHeight;
  const onScrollbarY = isScrollableY && event.clientX > ancestor.offsetLeft + ancestor.clientWidth;
  const isScrollableX = ancestor.scrollWidth > ancestor.clientWidth;
  const onScrollbarX = isScrollableX && event.clientY > ancestor.offsetTop + ancestor.clientHeight;
  const rect = {
    x: ancestor.offsetLeft,
    y: ancestor.offsetTop,
    width: ancestor.clientWidth + (isScrollableY ? 16 : 0),
    height: ancestor.clientHeight + (isScrollableX ? 16 : 0)
  };
  const point = {
    x: event.clientX,
    y: event.clientY
  };
  if (!isPointInRect(rect, point)) return false;
  return onScrollbarY || onScrollbarX;
}
function trackInteractOutsideImpl(node, options) {
  const { exclude, onFocusOutside, onPointerDownOutside, onInteractOutside, defer } = options;
  if (!node) return;
  const doc = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getDocument)(node);
  const win = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getWindow)(node);
  const frames = getWindowFrames(win);
  const parentWin = getParentWindow(win);
  function isEventOutside(event, target) {
    if (!(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(target)) return false;
    if (!target.isConnected) return false;
    if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.contains)(node, target)) return false;
    if (isEventPointWithin(node, event)) return false;
    const triggerEl = doc.querySelector(`[aria-controls="${node.id}"]`);
    if (triggerEl) {
      const triggerAncestor = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getNearestOverflowAncestor)(triggerEl);
      if (isEventWithinScrollbar(event, triggerAncestor)) return false;
    }
    const nodeAncestor = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getNearestOverflowAncestor)(node);
    if (isEventWithinScrollbar(event, nodeAncestor)) return false;
    return !exclude?.(target);
  }
  const pointerdownCleanups = /* @__PURE__ */ new Set();
  const isInShadowRoot = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(node?.getRootNode());
  function onPointerDown(event) {
    function handler(clickEvent) {
      const func = defer && !(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isTouchDevice)() ? _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.raf : (v) => v();
      const evt = clickEvent ?? event;
      const composedPath = evt?.composedPath?.() ?? [evt?.target];
      func(() => {
        const target = isInShadowRoot ? composedPath[0] : (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getEventTarget)(event);
        if (!node || !isEventOutside(event, target)) return;
        if (onPointerDownOutside || onInteractOutside) {
          const handler2 = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_1__.callAll)(onPointerDownOutside, onInteractOutside);
          node.addEventListener(POINTER_OUTSIDE_EVENT, handler2, { once: true });
        }
        fireCustomEvent(node, POINTER_OUTSIDE_EVENT, {
          bubbles: false,
          cancelable: true,
          detail: {
            originalEvent: evt,
            contextmenu: (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isContextMenuEvent)(evt),
            focusable: isComposedPathFocusable(composedPath),
            target
          }
        });
      });
    }
    if (event.pointerType === "touch") {
      pointerdownCleanups.forEach((fn) => fn());
      pointerdownCleanups.add((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.addDomEvent)(doc, "click", handler, { once: true }));
      pointerdownCleanups.add(parentWin.addEventListener("click", handler, { once: true }));
      pointerdownCleanups.add(frames.addEventListener("click", handler, { once: true }));
    } else {
      handler();
    }
  }
  const cleanups = /* @__PURE__ */ new Set();
  const timer = setTimeout(() => {
    cleanups.add((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.addDomEvent)(doc, "pointerdown", onPointerDown, true));
    cleanups.add(parentWin.addEventListener("pointerdown", onPointerDown, true));
    cleanups.add(frames.addEventListener("pointerdown", onPointerDown, true));
  }, 0);
  function onFocusin(event) {
    const func = defer ? _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.raf : (v) => v();
    func(() => {
      const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getEventTarget)(event);
      if (!node || !isEventOutside(event, target)) return;
      if (onFocusOutside || onInteractOutside) {
        const handler = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_1__.callAll)(onFocusOutside, onInteractOutside);
        node.addEventListener(FOCUS_OUTSIDE_EVENT, handler, { once: true });
      }
      fireCustomEvent(node, FOCUS_OUTSIDE_EVENT, {
        bubbles: false,
        cancelable: true,
        detail: {
          originalEvent: event,
          contextmenu: false,
          focusable: (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(target),
          target
        }
      });
    });
  }
  if (!(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isTouchDevice)()) {
    cleanups.add((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.addDomEvent)(doc, "focusin", onFocusin, true));
    cleanups.add(parentWin.addEventListener("focusin", onFocusin, true));
    cleanups.add(frames.addEventListener("focusin", onFocusin, true));
  }
  return () => {
    clearTimeout(timer);
    pointerdownCleanups.forEach((fn) => fn());
    cleanups.forEach((fn) => fn());
  };
}
function trackInteractOutside(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups.push(trackInteractOutsideImpl(node, options));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}
function fireCustomEvent(el, type, init) {
  const win = el.ownerDocument.defaultView || window;
  const event = new win.CustomEvent(type, init);
  return el.dispatchEvent(event);
}




/***/ }),

/***/ "./node_modules/@zag-js/menu/dist/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@zag-js/menu/dist/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anatomy: () => (/* binding */ anatomy),
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   itemGroupLabelProps: () => (/* binding */ itemGroupLabelProps),
/* harmony export */   itemGroupProps: () => (/* binding */ itemGroupProps),
/* harmony export */   itemProps: () => (/* binding */ itemProps),
/* harmony export */   machine: () => (/* binding */ machine),
/* harmony export */   optionItemProps: () => (/* binding */ optionItemProps),
/* harmony export */   props: () => (/* binding */ props),
/* harmony export */   splitItemGroupLabelProps: () => (/* binding */ splitItemGroupLabelProps),
/* harmony export */   splitItemGroupProps: () => (/* binding */ splitItemGroupProps),
/* harmony export */   splitItemProps: () => (/* binding */ splitItemProps),
/* harmony export */   splitOptionItemProps: () => (/* binding */ splitOptionItemProps),
/* harmony export */   splitProps: () => (/* binding */ splitProps)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_popper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/popper */ "./node_modules/@zag-js/popper/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");
/* harmony import */ var _zag_js_dismissable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @zag-js/dismissable */ "./node_modules/@zag-js/dismissable/dist/index.mjs");
/* harmony import */ var _zag_js_rect_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @zag-js/rect-utils */ "./node_modules/@zag-js/rect-utils/dist/index.mjs");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");









// src/menu.anatomy.ts
var anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("menu").parts(
  "arrow",
  "arrowTip",
  "content",
  "contextTrigger",
  "indicator",
  "item",
  "itemGroup",
  "itemGroupLabel",
  "itemIndicator",
  "itemText",
  "positioner",
  "separator",
  "trigger",
  "triggerItem"
);
var parts = anatomy.build();
var getTriggerId = (ctx) => ctx.ids?.trigger ?? `menu:${ctx.id}:trigger`;
var getContextTriggerId = (ctx) => ctx.ids?.contextTrigger ?? `menu:${ctx.id}:ctx-trigger`;
var getContentId = (ctx) => ctx.ids?.content ?? `menu:${ctx.id}:content`;
var getArrowId = (ctx) => ctx.ids?.arrow ?? `menu:${ctx.id}:arrow`;
var getPositionerId = (ctx) => ctx.ids?.positioner ?? `menu:${ctx.id}:popper`;
var getGroupId = (ctx, id) => ctx.ids?.group?.(id) ?? `menu:${ctx.id}:group:${id}`;
var getItemId = (ctx, id) => `${ctx.id}/${id}`;
var getItemValue = (el) => el?.dataset.value ?? null;
var getGroupLabelId = (ctx, id) => ctx.ids?.groupLabel?.(id) ?? `menu:${ctx.id}:group-label:${id}`;
var getContentEl = (ctx) => ctx.getById(getContentId(ctx));
var getPositionerEl = (ctx) => ctx.getById(getPositionerId(ctx));
var getTriggerEl = (ctx) => ctx.getById(getTriggerId(ctx));
var getItemEl = (ctx, value) => value ? ctx.getById(getItemId(ctx, value)) : null;
var getContextTriggerEl = (ctx) => ctx.getById(getContextTriggerId(ctx));
var getElements = (ctx) => {
  const ownerId = CSS.escape(getContentId(ctx));
  const selector = `[role^="menuitem"][data-ownedby=${ownerId}]:not([data-disabled])`;
  return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.queryAll)(getContentEl(ctx), selector);
};
var getFirstEl = (ctx) => (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.first)(getElements(ctx));
var getLastEl = (ctx) => (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.last)(getElements(ctx));
var isMatch = (el, value) => {
  if (!value) return false;
  return el.id === value || el.dataset.value === value;
};
var getNextEl = (ctx, opts) => {
  const items = getElements(ctx);
  const index = items.findIndex((el) => isMatch(el, opts.value));
  return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.next)(items, index, { loop: opts.loop ?? opts.loopFocus });
};
var getPrevEl = (ctx, opts) => {
  const items = getElements(ctx);
  const index = items.findIndex((el) => isMatch(el, opts.value));
  return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.prev)(items, index, { loop: opts.loop ?? opts.loopFocus });
};
var getElemByKey = (ctx, opts) => {
  const items = getElements(ctx);
  const item = items.find((el) => isMatch(el, opts.value));
  return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getByTypeahead)(items, { state: opts.typeaheadState, key: opts.key, activeId: item?.id ?? null });
};
var isTargetDisabled = (v) => {
  return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(v) && (v.dataset.disabled === "" || v.hasAttribute("disabled"));
};
var isTriggerItem = (el) => {
  return !!el?.getAttribute("role")?.startsWith("menuitem") && !!el?.hasAttribute("aria-controls");
};
var itemSelectEvent = "menu:select";
function dispatchSelectionEvent(el, value) {
  if (!el) return;
  const win = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getWindow)(el);
  const event = new win.CustomEvent(itemSelectEvent, { detail: { value } });
  el.dispatchEvent(event);
}

// src/menu.connect.ts
function connect(service, normalize) {
  const { context, send, state, computed, prop, scope } = service;
  const open = state.hasTag("open");
  const isSubmenu = computed("isSubmenu");
  const isTypingAhead = computed("isTypingAhead");
  const composite = prop("composite");
  const currentPlacement = context.get("currentPlacement");
  const anchorPoint = context.get("anchorPoint");
  const highlightedValue = context.get("highlightedValue");
  const popperStyles = (0,_zag_js_popper__WEBPACK_IMPORTED_MODULE_3__.getPlacementStyles)({
    ...prop("positioning"),
    placement: anchorPoint ? "bottom" : currentPlacement
  });
  function getItemState(props2) {
    return {
      id: getItemId(scope, props2.value),
      disabled: !!props2.disabled,
      highlighted: highlightedValue === props2.value
    };
  }
  function getOptionItemProps(props2) {
    const valueText = props2.valueText ?? props2.value;
    return { ...props2, id: props2.value, valueText };
  }
  function getOptionItemState(props2) {
    const itemState = getItemState(getOptionItemProps(props2));
    return {
      ...itemState,
      checked: !!props2.checked
    };
  }
  function getItemProps(props2) {
    const { closeOnSelect, valueText, value } = props2;
    const itemState = getItemState(props2);
    const id = getItemId(scope, value);
    return normalize.element({
      ...parts.item.attrs,
      id,
      role: "menuitem",
      "aria-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.ariaAttr)(itemState.disabled),
      "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(itemState.disabled),
      "data-ownedby": getContentId(scope),
      "data-highlighted": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(itemState.highlighted),
      "data-value": value,
      "data-valuetext": valueText,
      onDragStart(event) {
        const isLink = event.currentTarget.matches("a[href]");
        if (isLink) event.preventDefault();
      },
      onPointerMove(event) {
        if (itemState.disabled) return;
        if (event.pointerType !== "mouse") return;
        const target = event.currentTarget;
        if (itemState.highlighted) return;
        send({ type: "ITEM_POINTERMOVE", id, target, closeOnSelect });
      },
      onPointerLeave(event) {
        if (itemState.disabled) return;
        if (event.pointerType !== "mouse") return;
        const pointerMoved = service.event.previous()?.type.includes("POINTER");
        if (!pointerMoved) return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERLEAVE", id, target, closeOnSelect });
      },
      onPointerDown(event) {
        if (itemState.disabled) return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERDOWN", target, id, closeOnSelect });
      },
      onClick(event) {
        if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isDownloadingEvent)(event)) return;
        if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isOpeningInNewTab)(event)) return;
        if (itemState.disabled) return;
        const target = event.currentTarget;
        send({ type: "ITEM_CLICK", target, id, closeOnSelect });
      }
    });
  }
  return {
    highlightedValue,
    open,
    setOpen(nextOpen) {
      const open2 = state.hasTag("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    setHighlightedValue(value) {
      send({ type: "HIGHLIGHTED.SET", value });
    },
    setParent(parent) {
      send({ type: "PARENT.SET", value: parent, id: parent.prop("id") });
    },
    setChild(child) {
      send({ type: "CHILD.SET", value: child, id: child.prop("id") });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    addItemListener(props2) {
      const node = scope.getById(props2.id);
      if (!node) return;
      const listener = () => props2.onSelect?.();
      node.addEventListener(itemSelectEvent, listener);
      return () => node.removeEventListener(itemSelectEvent, listener);
    },
    getContextTriggerProps() {
      return normalize.element({
        ...parts.contextTrigger.attrs,
        dir: prop("dir"),
        id: getContextTriggerId(scope),
        onPointerDown(event) {
          if (event.pointerType === "mouse") return;
          const point = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventPoint)(event);
          send({ type: "CONTEXT_MENU_START", point });
        },
        onPointerCancel(event) {
          if (event.pointerType === "mouse") return;
          send({ type: "CONTEXT_MENU_CANCEL" });
        },
        onPointerMove(event) {
          if (event.pointerType === "mouse") return;
          send({ type: "CONTEXT_MENU_CANCEL" });
        },
        onPointerUp(event) {
          if (event.pointerType === "mouse") return;
          send({ type: "CONTEXT_MENU_CANCEL" });
        },
        onContextMenu(event) {
          const point = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventPoint)(event);
          send({ type: "CONTEXT_MENU", point });
          event.preventDefault();
        },
        style: {
          WebkitTouchCallout: "none",
          WebkitUserSelect: "none",
          userSelect: "none"
        }
      });
    },
    getTriggerItemProps(childApi) {
      const triggerProps = childApi.getTriggerProps();
      return (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_4__.mergeProps)(getItemProps({ value: triggerProps.id }), triggerProps);
    },
    getTriggerProps() {
      return normalize.button({
        ...isSubmenu ? parts.triggerItem.attrs : parts.trigger.attrs,
        "data-placement": context.get("currentPlacement"),
        type: "button",
        dir: prop("dir"),
        id: getTriggerId(scope),
        "data-uid": prop("id"),
        "aria-haspopup": composite ? "menu" : "dialog",
        "aria-controls": getContentId(scope),
        "aria-expanded": open || void 0,
        "data-state": open ? "open" : "closed",
        onPointerMove(event) {
          if (event.pointerType !== "mouse") return;
          const disabled = isTargetDisabled(event.currentTarget);
          if (disabled || !isSubmenu) return;
          const point = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventPoint)(event);
          send({ type: "TRIGGER_POINTERMOVE", target: event.currentTarget, point });
        },
        onPointerLeave(event) {
          if (isTargetDisabled(event.currentTarget)) return;
          if (event.pointerType !== "mouse") return;
          if (!isSubmenu) return;
          const point = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventPoint)(event);
          send({
            type: "TRIGGER_POINTERLEAVE",
            target: event.currentTarget,
            point
          });
        },
        onPointerDown(event) {
          if (isTargetDisabled(event.currentTarget)) return;
          if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isContextMenuEvent)(event)) return;
          event.preventDefault();
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (isTargetDisabled(event.currentTarget)) return;
          send({ type: "TRIGGER_CLICK", target: event.currentTarget });
        },
        onBlur() {
          send({ type: "TRIGGER_BLUR" });
        },
        onFocus() {
          send({ type: "TRIGGER_FOCUS" });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          const keyMap = {
            ArrowDown() {
              send({ type: "ARROW_DOWN" });
            },
            ArrowUp() {
              send({ type: "ARROW_UP" });
            },
            Enter() {
              send({ type: "ARROW_DOWN", src: "enter" });
            },
            Space() {
              send({ type: "ARROW_DOWN", src: "space" });
            }
          };
          const key = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventKey)(event, {
            orientation: "vertical",
            dir: prop("dir")
          });
          const exec = keyMap[key];
          if (exec) {
            event.preventDefault();
            exec(event);
          }
        }
      });
    },
    getIndicatorProps() {
      return normalize.element({
        ...parts.indicator.attrs,
        dir: prop("dir"),
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize.element({
        ...parts.positioner.attrs,
        dir: prop("dir"),
        id: getPositionerId(scope),
        style: popperStyles.floating
      });
    },
    getArrowProps() {
      return normalize.element({
        id: getArrowId(scope),
        ...parts.arrow.attrs,
        dir: prop("dir"),
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize.element({
        ...parts.arrowTip.attrs,
        dir: prop("dir"),
        style: popperStyles.arrowTip
      });
    },
    getContentProps() {
      return normalize.element({
        ...parts.content.attrs,
        id: getContentId(scope),
        "aria-label": prop("aria-label"),
        hidden: !open,
        "data-state": open ? "open" : "closed",
        role: composite ? "menu" : "dialog",
        tabIndex: 0,
        dir: prop("dir"),
        "aria-activedescendant": computed("highlightedId") || void 0,
        "aria-labelledby": getTriggerId(scope),
        "data-placement": currentPlacement,
        onPointerEnter(event) {
          if (event.pointerType !== "mouse") return;
          send({ type: "MENU_POINTERENTER" });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isSelfTarget)(event)) return;
          const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventTarget)(event);
          const sameMenu = target?.closest("[role=menu]") === event.currentTarget || target === event.currentTarget;
          if (!sameMenu) return;
          if (event.key === "Tab") {
            const valid = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isValidTabEvent)(event);
            if (!valid) {
              event.preventDefault();
              return;
            }
          }
          const item = getItemEl(scope, highlightedValue);
          const keyMap = {
            ArrowDown() {
              send({ type: "ARROW_DOWN" });
            },
            ArrowUp() {
              send({ type: "ARROW_UP" });
            },
            ArrowLeft() {
              send({ type: "ARROW_LEFT" });
            },
            ArrowRight() {
              send({ type: "ARROW_RIGHT" });
            },
            Enter() {
              send({ type: "ENTER" });
              if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isAnchorElement)(item)) {
                prop("navigate")?.({ value: highlightedValue, node: item });
              }
            },
            Space(event2) {
              if (isTypingAhead) {
                send({ type: "TYPEAHEAD", key: event2.key });
              } else {
                keyMap.Enter?.(event2);
              }
            },
            Home() {
              send({ type: "HOME" });
            },
            End() {
              send({ type: "END" });
            }
          };
          const key = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventKey)(event, { dir: prop("dir") });
          const exec = keyMap[key];
          if (exec) {
            exec(event);
            event.stopPropagation();
            event.preventDefault();
            return;
          }
          if (!prop("typeahead")) return;
          if (!(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isPrintableKey)(event)) return;
          if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isModifierKey)(event)) return;
          if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isEditableElement)(target)) return;
          send({ type: "TYPEAHEAD", key: event.key });
          event.preventDefault();
        }
      });
    },
    getSeparatorProps() {
      return normalize.element({
        ...parts.separator.attrs,
        role: "separator",
        dir: prop("dir"),
        "aria-orientation": "horizontal"
      });
    },
    getItemState,
    getItemProps,
    getOptionItemState,
    getOptionItemProps(props2) {
      const { type, disabled, onCheckedChange, closeOnSelect } = props2;
      const option = getOptionItemProps(props2);
      const itemState = getOptionItemState(props2);
      return {
        ...getItemProps(option),
        ...normalize.element({
          "data-type": type,
          ...parts.item.attrs,
          dir: prop("dir"),
          "data-value": option.value,
          role: `menuitem${type}`,
          "aria-checked": !!itemState.checked,
          "data-state": itemState.checked ? "checked" : "unchecked",
          onClick(event) {
            if (disabled) return;
            if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isDownloadingEvent)(event)) return;
            if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isOpeningInNewTab)(event)) return;
            const target = event.currentTarget;
            send({ type: "ITEM_CLICK", target, option, closeOnSelect });
            onCheckedChange?.(!itemState.checked);
          }
        })
      };
    },
    getItemIndicatorProps(props2) {
      const itemState = getOptionItemState(props2);
      return normalize.element({
        ...parts.itemIndicator.attrs,
        dir: prop("dir"),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(itemState.disabled),
        "data-highlighted": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(itemState.highlighted),
        "data-state": itemState.checked ? "checked" : "unchecked",
        hidden: !itemState.checked
      });
    },
    getItemTextProps(props2) {
      const itemState = getOptionItemState(props2);
      return normalize.element({
        ...parts.itemText.attrs,
        dir: prop("dir"),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(itemState.disabled),
        "data-highlighted": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(itemState.highlighted),
        "data-state": itemState.checked ? "checked" : "unchecked"
      });
    },
    getItemGroupLabelProps(props2) {
      return normalize.element({
        ...parts.itemGroupLabel.attrs,
        id: getGroupLabelId(scope, props2.htmlFor),
        dir: prop("dir")
      });
    },
    getItemGroupProps(props2) {
      return normalize.element({
        id: getGroupId(scope, props2.id),
        ...parts.itemGroup.attrs,
        dir: prop("dir"),
        "aria-labelledby": getGroupLabelId(scope, props2.id),
        role: "group"
      });
    }
  };
}
var { not, and, or } = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_4__.createGuards)();
var machine = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_4__.createMachine)({
  props({ props: props2 }) {
    return {
      closeOnSelect: true,
      typeahead: true,
      composite: true,
      loopFocus: false,
      navigate(details) {
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.clickIfLink)(details.node);
      },
      ...props2,
      positioning: {
        placement: "bottom-start",
        gutter: 8,
        ...props2.positioning
      }
    };
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "idle";
  },
  context({ bindable, prop }) {
    return {
      suspendPointer: bindable(() => ({
        defaultValue: false
      })),
      highlightedValue: bindable(() => ({
        defaultValue: prop("defaultHighlightedValue") || null,
        value: prop("highlightedValue"),
        onChange(value) {
          prop("onHighlightChange")?.({ highlightedValue: value });
        }
      })),
      lastHighlightedValue: bindable(() => ({
        defaultValue: null
      })),
      currentPlacement: bindable(() => ({
        defaultValue: void 0
      })),
      intentPolygon: bindable(() => ({
        defaultValue: null
      })),
      anchorPoint: bindable(() => ({
        defaultValue: null,
        hash(value) {
          return `x: ${value?.x}, y: ${value?.y}`;
        }
      }))
    };
  },
  refs() {
    return {
      parent: null,
      children: {},
      typeaheadState: { ..._zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getByTypeahead.defaultOptions },
      positioningOverride: {}
    };
  },
  computed: {
    isSubmenu: ({ refs }) => refs.get("parent") != null,
    isRtl: ({ prop }) => prop("dir") === "rtl",
    isTypingAhead: ({ refs }) => refs.get("typeaheadState").keysSoFar !== "",
    highlightedId: ({ context, scope, refs }) => resolveItemId(refs.get("children"), context.get("highlightedValue"), scope)
  },
  watch({ track, action, context, computed, prop }) {
    track([() => computed("isSubmenu")], () => {
      action(["setSubmenuPlacement"]);
    });
    track([() => context.hash("anchorPoint")], () => {
      action(["reposition"]);
    });
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  on: {
    "PARENT.SET": {
      actions: ["setParentMenu"]
    },
    "CHILD.SET": {
      actions: ["setChildMenu"]
    },
    OPEN: [
      {
        guard: "isOpenControlled",
        actions: ["invokeOnOpen"]
      },
      {
        target: "open",
        actions: ["invokeOnOpen"]
      }
    ],
    OPEN_AUTOFOCUS: [
      {
        guard: "isOpenControlled",
        actions: ["invokeOnOpen"]
      },
      {
        // internal: true,
        target: "open",
        actions: ["highlightFirstItem", "invokeOnOpen"]
      }
    ],
    CLOSE: [
      {
        guard: "isOpenControlled",
        actions: ["invokeOnClose"]
      },
      {
        target: "closed",
        actions: ["invokeOnClose"]
      }
    ],
    "HIGHLIGHTED.RESTORE": {
      actions: ["restoreHighlightedItem"]
    },
    "HIGHLIGHTED.SET": {
      actions: ["setHighlightedItem"]
    }
  },
  states: {
    idle: {
      tags: ["closed"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        "CONTROLLED.CLOSE": {
          target: "closed"
        },
        CONTEXT_MENU_START: {
          target: "opening:contextmenu",
          actions: ["setAnchorPoint"]
        },
        CONTEXT_MENU: [
          {
            guard: "isOpenControlled",
            actions: ["setAnchorPoint", "invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setAnchorPoint", "invokeOnOpen"]
          }
        ],
        TRIGGER_CLICK: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        TRIGGER_FOCUS: {
          guard: not("isSubmenu"),
          target: "closed"
        },
        TRIGGER_POINTERMOVE: {
          guard: "isSubmenu",
          target: "opening"
        }
      }
    },
    "opening:contextmenu": {
      tags: ["closed"],
      effects: ["waitForLongPress"],
      on: {
        "CONTROLLED.OPEN": { target: "open" },
        "CONTROLLED.CLOSE": { target: "closed" },
        CONTEXT_MENU_CANCEL: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "LONG_PRESS.OPEN": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ]
      }
    },
    opening: {
      tags: ["closed"],
      effects: ["waitForOpenDelay"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        "CONTROLLED.CLOSE": {
          target: "closed"
        },
        BLUR: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        TRIGGER_POINTERLEAVE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "DELAY.OPEN": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ]
      }
    },
    closing: {
      tags: ["open"],
      effects: ["trackPointerMove", "trackInteractOutside", "waitForCloseDelay"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        "CONTROLLED.CLOSE": {
          target: "closed",
          actions: ["focusParentMenu", "restoreParentHighlightedItem"]
        },
        // don't invoke on open here since the menu is still open (we're only keeping it open)
        MENU_POINTERENTER: {
          target: "open",
          actions: ["clearIntentPolygon"]
        },
        POINTER_MOVED_AWAY_FROM_SUBMENU: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["focusParentMenu", "restoreParentHighlightedItem"]
          }
        ],
        "DELAY.CLOSE": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["focusParentMenu", "restoreParentHighlightedItem", "invokeOnClose"]
          }
        ]
      }
    },
    closed: {
      tags: ["closed"],
      entry: ["clearHighlightedItem", "focusTrigger", "resumePointer"],
      on: {
        "CONTROLLED.OPEN": [
          {
            guard: or("isOpenAutoFocusEvent", "isArrowDownEvent"),
            target: "open",
            actions: ["highlightFirstItem"]
          },
          {
            guard: "isArrowUpEvent",
            target: "open",
            actions: ["highlightLastItem"]
          },
          {
            target: "open"
          }
        ],
        CONTEXT_MENU_START: {
          target: "opening:contextmenu",
          actions: ["setAnchorPoint"]
        },
        CONTEXT_MENU: [
          {
            guard: "isOpenControlled",
            actions: ["setAnchorPoint", "invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setAnchorPoint", "invokeOnOpen"]
          }
        ],
        TRIGGER_CLICK: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        TRIGGER_POINTERMOVE: {
          guard: "isTriggerItem",
          target: "opening"
        },
        TRIGGER_BLUR: { target: "idle" },
        ARROW_DOWN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["highlightFirstItem", "invokeOnOpen"]
          }
        ],
        ARROW_UP: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["highlightLastItem", "invokeOnOpen"]
          }
        ]
      }
    },
    open: {
      tags: ["open"],
      effects: ["trackInteractOutside", "trackPositioning", "scrollToHighlightedItem"],
      entry: ["focusMenu", "resumePointer"],
      on: {
        "CONTROLLED.CLOSE": [
          {
            target: "closed",
            guard: "isArrowLeftEvent",
            actions: ["focusParentMenu"]
          },
          {
            target: "closed"
          }
        ],
        TRIGGER_CLICK: [
          {
            guard: and(not("isTriggerItem"), "isOpenControlled"),
            actions: ["invokeOnClose"]
          },
          {
            guard: not("isTriggerItem"),
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        CONTEXT_MENU: {
          actions: ["setAnchorPoint", "focusMenu"]
        },
        ARROW_UP: {
          actions: ["highlightPrevItem", "focusMenu"]
        },
        ARROW_DOWN: {
          actions: ["highlightNextItem", "focusMenu"]
        },
        ARROW_LEFT: [
          {
            guard: and("isSubmenu", "isOpenControlled"),
            actions: ["invokeOnClose"]
          },
          {
            guard: "isSubmenu",
            target: "closed",
            actions: ["focusParentMenu", "invokeOnClose"]
          }
        ],
        HOME: {
          actions: ["highlightFirstItem", "focusMenu"]
        },
        END: {
          actions: ["highlightLastItem", "focusMenu"]
        },
        ARROW_RIGHT: {
          guard: "isTriggerItemHighlighted",
          actions: ["openSubmenu"]
        },
        ENTER: [
          {
            guard: "isTriggerItemHighlighted",
            actions: ["openSubmenu"]
          },
          {
            actions: ["clickHighlightedItem"]
          }
        ],
        ITEM_POINTERMOVE: [
          {
            guard: not("isPointerSuspended"),
            actions: ["setHighlightedItem", "focusMenu"]
          },
          {
            actions: ["setLastHighlightedItem"]
          }
        ],
        ITEM_POINTERLEAVE: {
          guard: and(not("isPointerSuspended"), not("isTriggerItem")),
          actions: ["clearHighlightedItem"]
        },
        ITEM_CLICK: [
          // == grouped ==
          {
            guard: and(
              not("isTriggerItemHighlighted"),
              not("isHighlightedItemEditable"),
              "closeOnSelect",
              "isOpenControlled"
            ),
            actions: ["invokeOnSelect", "setOptionState", "closeRootMenu", "invokeOnClose"]
          },
          {
            guard: and(not("isTriggerItemHighlighted"), not("isHighlightedItemEditable"), "closeOnSelect"),
            target: "closed",
            actions: ["invokeOnSelect", "setOptionState", "closeRootMenu", "invokeOnClose"]
          },
          //
          {
            guard: and(not("isTriggerItemHighlighted"), not("isHighlightedItemEditable")),
            actions: ["invokeOnSelect", "setOptionState"]
          },
          { actions: ["setHighlightedItem"] }
        ],
        TRIGGER_POINTERMOVE: {
          guard: "isTriggerItem",
          actions: ["setIntentPolygon"]
        },
        TRIGGER_POINTERLEAVE: {
          target: "closing"
        },
        ITEM_POINTERDOWN: {
          actions: ["setHighlightedItem"]
        },
        TYPEAHEAD: {
          actions: ["highlightMatchedItem"]
        },
        FOCUS_MENU: {
          actions: ["focusMenu"]
        },
        "POSITIONING.SET": {
          actions: ["reposition"]
        }
      }
    }
  },
  implementations: {
    guards: {
      closeOnSelect: ({ prop, event }) => !!(event?.closeOnSelect ?? prop("closeOnSelect")),
      // whether the trigger is also a menu item
      isTriggerItem: ({ event }) => isTriggerItem(event.target),
      // whether the trigger item is the active item
      isTriggerItemHighlighted: ({ event, scope, computed }) => {
        const target = event.target ?? scope.getById(computed("highlightedId"));
        return !!target?.hasAttribute("aria-controls");
      },
      isSubmenu: ({ computed }) => computed("isSubmenu"),
      isPointerSuspended: ({ context }) => context.get("suspendPointer"),
      isHighlightedItemEditable: ({ scope, computed }) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isEditableElement)(scope.getById(computed("highlightedId"))),
      // guard assertions (for controlled mode)
      isOpenControlled: ({ prop }) => prop("open") !== void 0,
      isArrowLeftEvent: ({ event }) => event.previousEvent?.type === "ARROW_LEFT",
      isArrowUpEvent: ({ event }) => event.previousEvent?.type === "ARROW_UP",
      isArrowDownEvent: ({ event }) => event.previousEvent?.type === "ARROW_DOWN",
      isOpenAutoFocusEvent: ({ event }) => event.previousEvent?.type === "OPEN_AUTOFOCUS"
    },
    effects: {
      waitForOpenDelay({ send }) {
        const timer = setTimeout(() => {
          send({ type: "DELAY.OPEN" });
        }, 100);
        return () => clearTimeout(timer);
      },
      waitForCloseDelay({ send }) {
        const timer = setTimeout(() => {
          send({ type: "DELAY.CLOSE" });
        }, 300);
        return () => clearTimeout(timer);
      },
      waitForLongPress({ send }) {
        const timer = setTimeout(() => {
          send({ type: "LONG_PRESS.OPEN" });
        }, 700);
        return () => clearTimeout(timer);
      },
      trackPositioning({ context, prop, scope, refs }) {
        if (!!getContextTriggerEl(scope)) return;
        const positioning = {
          ...prop("positioning"),
          ...refs.get("positioningOverride")
        };
        context.set("currentPlacement", positioning.placement);
        const getPositionerEl2 = () => getPositionerEl(scope);
        return (0,_zag_js_popper__WEBPACK_IMPORTED_MODULE_3__.getPlacement)(getTriggerEl(scope), getPositionerEl2, {
          ...positioning,
          defer: true,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      trackInteractOutside({ refs, scope, prop, computed, send }) {
        const getContentEl2 = () => getContentEl(scope);
        let restoreFocus = true;
        return (0,_zag_js_dismissable__WEBPACK_IMPORTED_MODULE_5__.trackDismissableElement)(getContentEl2, {
          defer: true,
          exclude: [getTriggerEl(scope)],
          onInteractOutside: prop("onInteractOutside"),
          onFocusOutside: prop("onFocusOutside"),
          onEscapeKeyDown(event) {
            prop("onEscapeKeyDown")?.(event);
            if (computed("isSubmenu")) event.preventDefault();
            closeRootMenu({ parent: refs.get("parent") });
          },
          onPointerDownOutside(event) {
            const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventTarget)(event.detail.originalEvent);
            const isWithinContextTrigger = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.contains)(getContextTriggerEl(scope), target);
            if (isWithinContextTrigger && event.detail.contextmenu) {
              event.preventDefault();
              return;
            }
            restoreFocus = !event.detail.focusable;
            prop("onPointerDownOutside")?.(event);
          },
          onDismiss() {
            send({ type: "CLOSE", src: "interact-outside", restoreFocus });
          }
        });
      },
      trackPointerMove({ context, scope, send, refs, flush }) {
        const parent = refs.get("parent");
        flush(() => {
          parent.context.set("suspendPointer", true);
        });
        const doc = scope.getDoc();
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.addDomEvent)(doc, "pointermove", (e) => {
          const isMovingToSubmenu = isWithinPolygon(context.get("intentPolygon"), {
            x: e.clientX,
            y: e.clientY
          });
          if (!isMovingToSubmenu) {
            send({ type: "POINTER_MOVED_AWAY_FROM_SUBMENU" });
            parent.context.set("suspendPointer", false);
          }
        });
      },
      scrollToHighlightedItem({ event, scope, computed }) {
        const exec = () => {
          if (event.type.startsWith("ITEM_POINTER")) return;
          const itemEl = scope.getById(computed("highlightedId"));
          const contentEl2 = getContentEl(scope);
          (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.scrollIntoView)(itemEl, { rootEl: contentEl2, block: "nearest" });
        };
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => exec());
        const contentEl = () => getContentEl(scope);
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.observeAttributes)(contentEl, {
          defer: true,
          attributes: ["aria-activedescendant"],
          callback: exec
        });
      }
    },
    actions: {
      setAnchorPoint({ context, event }) {
        context.set("anchorPoint", event.point);
      },
      setSubmenuPlacement({ computed, refs }) {
        if (!computed("isSubmenu")) return;
        const placement = computed("isRtl") ? "left-start" : "right-start";
        refs.set("positioningOverride", { placement, gutter: 0 });
      },
      reposition({ context, scope, prop, event, refs }) {
        const getPositionerEl2 = () => getPositionerEl(scope);
        const anchorPoint = context.get("anchorPoint");
        const getAnchorRect = anchorPoint ? () => ({ width: 0, height: 0, ...anchorPoint }) : void 0;
        const positioning = {
          ...prop("positioning"),
          ...refs.get("positioningOverride")
        };
        (0,_zag_js_popper__WEBPACK_IMPORTED_MODULE_3__.getPlacement)(getTriggerEl(scope), getPositionerEl2, {
          ...positioning,
          defer: true,
          getAnchorRect,
          ...event.options ?? {},
          listeners: false,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      setOptionState({ event }) {
        if (!event.option) return;
        const { checked, onCheckedChange, type } = event.option;
        if (type === "radio") {
          onCheckedChange?.(true);
        } else if (type === "checkbox") {
          onCheckedChange?.(!checked);
        }
      },
      clickHighlightedItem({ scope, computed }) {
        const itemEl = scope.getById(computed("highlightedId"));
        if (!itemEl || itemEl.dataset.disabled) return;
        queueMicrotask(() => itemEl.click());
      },
      setIntentPolygon({ context, scope, event }) {
        const menu = getContentEl(scope);
        const placement = context.get("currentPlacement");
        if (!menu || !placement) return;
        const rect = menu.getBoundingClientRect();
        const polygon = (0,_zag_js_rect_utils__WEBPACK_IMPORTED_MODULE_6__.getElementPolygon)(rect, placement);
        if (!polygon) return;
        const rightSide = (0,_zag_js_popper__WEBPACK_IMPORTED_MODULE_3__.getPlacementSide)(placement) === "right";
        const bleed = rightSide ? -5 : 5;
        context.set("intentPolygon", [{ ...event.point, x: event.point.x + bleed }, ...polygon]);
      },
      clearIntentPolygon({ context }) {
        context.set("intentPolygon", null);
      },
      resumePointer({ refs, flush }) {
        const parent = refs.get("parent");
        if (!parent) return;
        flush(() => {
          parent.context.set("suspendPointer", false);
        });
      },
      setHighlightedItem({ context, event }) {
        const value = event.value || getItemValue(event.target);
        context.set("highlightedValue", value);
      },
      clearHighlightedItem({ context }) {
        context.set("highlightedValue", null);
      },
      focusMenu({ scope }) {
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => {
          const contentEl = getContentEl(scope);
          const initialFocusEl = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getInitialFocus)({
            root: contentEl,
            enabled: !(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.contains)(contentEl, scope.getActiveElement()),
            filter(node) {
              return !node.role?.startsWith("menuitem");
            }
          });
          initialFocusEl?.focus({ preventScroll: true });
        });
      },
      highlightFirstItem({ context, scope }) {
        const fn = getContentEl(scope) ? queueMicrotask : _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf;
        fn(() => {
          const first2 = getFirstEl(scope);
          if (!first2) return;
          context.set("highlightedValue", getItemValue(first2));
        });
      },
      highlightLastItem({ context, scope }) {
        const fn = getContentEl(scope) ? queueMicrotask : _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf;
        fn(() => {
          const last2 = getLastEl(scope);
          if (!last2) return;
          context.set("highlightedValue", getItemValue(last2));
        });
      },
      highlightNextItem({ context, scope, event, prop }) {
        const next2 = getNextEl(scope, {
          loop: event.loop,
          value: context.get("highlightedValue"),
          loopFocus: prop("loopFocus")
        });
        context.set("highlightedValue", getItemValue(next2));
      },
      highlightPrevItem({ context, scope, event, prop }) {
        const prev2 = getPrevEl(scope, {
          loop: event.loop,
          value: context.get("highlightedValue"),
          loopFocus: prop("loopFocus")
        });
        context.set("highlightedValue", getItemValue(prev2));
      },
      invokeOnSelect({ context, prop, scope }) {
        const value = context.get("highlightedValue");
        if (value == null) return;
        const node = getItemEl(scope, value);
        dispatchSelectionEvent(node, value);
        prop("onSelect")?.({ value });
      },
      focusTrigger({ scope, context, event, computed }) {
        if (computed("isSubmenu") || context.get("anchorPoint") || event.restoreFocus === false) return;
        queueMicrotask(() => getTriggerEl(scope)?.focus({ preventScroll: true }));
      },
      highlightMatchedItem({ scope, context, event, refs }) {
        const node = getElemByKey(scope, {
          key: event.key,
          value: context.get("highlightedValue"),
          typeaheadState: refs.get("typeaheadState")
        });
        if (!node) return;
        context.set("highlightedValue", getItemValue(node));
      },
      setParentMenu({ refs, event }) {
        refs.set("parent", event.value);
      },
      setChildMenu({ refs, event }) {
        const children = refs.get("children");
        children[event.id] = event.value;
        refs.set("children", children);
      },
      closeRootMenu({ refs }) {
        closeRootMenu({ parent: refs.get("parent") });
      },
      openSubmenu({ refs, scope, computed }) {
        const item = scope.getById(computed("highlightedId"));
        const id = item?.getAttribute("data-uid");
        const children = refs.get("children");
        const child = id ? children[id] : null;
        child?.send({ type: "OPEN_AUTOFOCUS" });
      },
      focusParentMenu({ refs }) {
        refs.get("parent")?.send({ type: "FOCUS_MENU" });
      },
      setLastHighlightedItem({ context, event }) {
        context.set("lastHighlightedValue", getItemValue(event.target));
      },
      restoreHighlightedItem({ context }) {
        if (!context.get("lastHighlightedValue")) return;
        context.set("highlightedValue", context.get("lastHighlightedValue"));
        context.set("lastHighlightedValue", null);
      },
      restoreParentHighlightedItem({ refs }) {
        refs.get("parent")?.send({ type: "HIGHLIGHTED.RESTORE" });
      },
      invokeOnOpen({ prop }) {
        prop("onOpenChange")?.({ open: true });
      },
      invokeOnClose({ prop }) {
        prop("onOpenChange")?.({ open: false });
      },
      toggleVisibility({ prop, event, send }) {
        send({
          type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE",
          previousEvent: event
        });
      }
    }
  }
});
function closeRootMenu(ctx) {
  let parent = ctx.parent;
  while (parent && parent.computed("isSubmenu")) {
    parent = parent.refs.get("parent");
  }
  parent?.send({ type: "CLOSE" });
}
function isWithinPolygon(polygon, point) {
  if (!polygon) return false;
  return (0,_zag_js_rect_utils__WEBPACK_IMPORTED_MODULE_6__.isPointInPolygon)(polygon, point);
}
function resolveItemId(children, value, scope) {
  const hasChildren = Object.keys(children).length > 0;
  if (!value) return null;
  if (!hasChildren) {
    return getItemId(scope, value);
  }
  for (const id in children) {
    const childMenu = children[id];
    const childTriggerId = getTriggerId(childMenu.scope);
    if (childTriggerId === value) {
      return childTriggerId;
    }
  }
  return getItemId(scope, value);
}
var props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_7__.createProps)()([
  "anchorPoint",
  "aria-label",
  "closeOnSelect",
  "composite",
  "defaultHighlightedValue",
  "defaultOpen",
  "dir",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "loopFocus",
  "navigate",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onHighlightChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onSelect",
  "open",
  "positioning",
  "typeahead"
]);
var splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.createSplitProps)(props);
var itemProps = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_7__.createProps)()(["closeOnSelect", "disabled", "value", "valueText"]);
var splitItemProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.createSplitProps)(itemProps);
var itemGroupLabelProps = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_7__.createProps)()(["htmlFor"]);
var splitItemGroupLabelProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.createSplitProps)(itemGroupLabelProps);
var itemGroupProps = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_7__.createProps)()(["id"]);
var splitItemGroupProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.createSplitProps)(itemGroupProps);
var optionItemProps = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_7__.createProps)()([
  "checked",
  "closeOnSelect",
  "disabled",
  "onCheckedChange",
  "type",
  "value",
  "valueText"
]);
var splitOptionItemProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.createSplitProps)(optionItemProps);




/***/ }),

/***/ "./node_modules/@zag-js/number-input/dist/index.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@zag-js/number-input/dist/index.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anatomy: () => (/* binding */ anatomy),
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   machine: () => (/* binding */ machine),
/* harmony export */   props: () => (/* binding */ props),
/* harmony export */   splitProps: () => (/* binding */ splitProps)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _internationalized_number__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @internationalized/number */ "./node_modules/@internationalized/number/dist/NumberParser.mjs");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");







// src/number-input.anatomy.ts
var anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("numberInput").parts(
  "root",
  "label",
  "input",
  "control",
  "valueText",
  "incrementTrigger",
  "decrementTrigger",
  "scrubber"
);
var parts = anatomy.build();
var getRootId = (ctx) => ctx.ids?.root ?? `number-input:${ctx.id}`;
var getInputId = (ctx) => ctx.ids?.input ?? `number-input:${ctx.id}:input`;
var getIncrementTriggerId = (ctx) => ctx.ids?.incrementTrigger ?? `number-input:${ctx.id}:inc`;
var getDecrementTriggerId = (ctx) => ctx.ids?.decrementTrigger ?? `number-input:${ctx.id}:dec`;
var getScrubberId = (ctx) => ctx.ids?.scrubber ?? `number-input:${ctx.id}:scrubber`;
var getCursorId = (ctx) => `number-input:${ctx.id}:cursor`;
var getLabelId = (ctx) => ctx.ids?.label ?? `number-input:${ctx.id}:label`;
var getInputEl = (ctx) => ctx.getById(getInputId(ctx));
var getIncrementTriggerEl = (ctx) => ctx.getById(getIncrementTriggerId(ctx));
var getDecrementTriggerEl = (ctx) => ctx.getById(getDecrementTriggerId(ctx));
var getCursorEl = (ctx) => ctx.getDoc().getElementById(getCursorId(ctx));
var getPressedTriggerEl = (ctx, hint) => {
  let btnEl = null;
  if (hint === "increment") {
    btnEl = getIncrementTriggerEl(ctx);
  }
  if (hint === "decrement") {
    btnEl = getDecrementTriggerEl(ctx);
  }
  return btnEl;
};
var setupVirtualCursor = (ctx, point) => {
  if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isSafari)()) return;
  createVirtualCursor(ctx, point);
  return () => {
    getCursorEl(ctx)?.remove();
  };
};
var preventTextSelection = (ctx) => {
  const doc = ctx.getDoc();
  const html = doc.documentElement;
  const body = doc.body;
  body.style.pointerEvents = "none";
  html.style.userSelect = "none";
  html.style.cursor = "ew-resize";
  return () => {
    body.style.pointerEvents = "";
    html.style.userSelect = "";
    html.style.cursor = "";
    if (!html.style.length) {
      html.removeAttribute("style");
    }
    if (!body.style.length) {
      body.removeAttribute("style");
    }
  };
};
var getMousemoveValue = (ctx, opts) => {
  const { point, isRtl, event } = opts;
  const win = ctx.getWin();
  const x = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.roundToDpr)(event.movementX, win.devicePixelRatio);
  const y = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.roundToDpr)(event.movementY, win.devicePixelRatio);
  let hint = x > 0 ? "increment" : x < 0 ? "decrement" : null;
  if (isRtl && hint === "increment") hint = "decrement";
  if (isRtl && hint === "decrement") hint = "increment";
  const newPoint = { x: point.x + x, y: point.y + y };
  const width = win.innerWidth;
  const half = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.roundToDpr)(7.5, win.devicePixelRatio);
  newPoint.x = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.wrap)(newPoint.x + half, width) - half;
  return { hint, point: newPoint };
};
var createVirtualCursor = (ctx, point) => {
  const doc = ctx.getDoc();
  const el = doc.createElement("div");
  el.className = "scrubber--cursor";
  el.id = getCursorId(ctx);
  Object.assign(el.style, {
    width: "15px",
    height: "15px",
    position: "fixed",
    pointerEvents: "none",
    left: "0px",
    top: "0px",
    zIndex: _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.MAX_Z_INDEX,
    transform: point ? `translate3d(${point.x}px, ${point.y}px, 0px)` : void 0,
    willChange: "transform"
  });
  el.innerHTML = `
      <svg width="46" height="15" style="left: -15.5px; position: absolute; top: 0; filter: drop-shadow(rgba(0, 0, 0, 0.4) 0px 1px 1.1px);">
        <g transform="translate(2 3)">
          <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z" style="stroke-width: 2px; stroke: white;"></path>
          <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z"></path>
        </g>
      </svg>`;
  doc.body.appendChild(el);
};

// src/number-input.connect.ts
function connect(service, normalize) {
  const { state, send, prop, scope, computed } = service;
  const focused = state.hasTag("focus");
  const disabled = computed("isDisabled");
  const readOnly = prop("readOnly");
  const empty = computed("isValueEmpty");
  const invalid = computed("isOutOfRange") || !!prop("invalid");
  const isIncrementDisabled = disabled || !computed("canIncrement") || readOnly;
  const isDecrementDisabled = disabled || !computed("canDecrement") || readOnly;
  const translations = prop("translations");
  return {
    focused,
    invalid,
    empty,
    value: computed("formattedValue"),
    valueAsNumber: computed("valueAsNumber"),
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    clearValue() {
      send({ type: "VALUE.CLEAR" });
    },
    increment() {
      send({ type: "VALUE.INCREMENT" });
    },
    decrement() {
      send({ type: "VALUE.DECREMENT" });
    },
    setToMax() {
      send({ type: "VALUE.SET", value: prop("max") });
    },
    setToMin() {
      send({ type: "VALUE.SET", value: prop("min") });
    },
    focus() {
      getInputEl(scope)?.focus();
    },
    getRootProps() {
      return normalize.element({
        id: getRootId(scope),
        ...parts.root.attrs,
        dir: prop("dir"),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(focused),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(invalid)
      });
    },
    getLabelProps() {
      return normalize.label({
        ...parts.label.attrs,
        dir: prop("dir"),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(focused),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(invalid),
        id: getLabelId(scope),
        htmlFor: getInputId(scope)
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts.control.attrs,
        dir: prop("dir"),
        role: "group",
        "aria-disabled": disabled,
        "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(focused),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(invalid),
        "aria-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.ariaAttr)(invalid)
      });
    },
    getValueTextProps() {
      return normalize.element({
        ...parts.valueText.attrs,
        dir: prop("dir"),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(invalid),
        "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(focused)
      });
    },
    getInputProps() {
      return normalize.input({
        ...parts.input.attrs,
        dir: prop("dir"),
        name: prop("name"),
        form: prop("form"),
        id: getInputId(scope),
        role: "spinbutton",
        defaultValue: computed("formattedValue"),
        pattern: prop("pattern"),
        inputMode: prop("inputMode"),
        "aria-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.ariaAttr)(invalid),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(invalid),
        disabled,
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        readOnly,
        required: prop("required"),
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: "false",
        type: "text",
        "aria-roledescription": "numberfield",
        "aria-valuemin": prop("min"),
        "aria-valuemax": prop("max"),
        "aria-valuenow": Number.isNaN(computed("valueAsNumber")) ? void 0 : computed("valueAsNumber"),
        "aria-valuetext": computed("valueText"),
        onFocus() {
          send({ type: "INPUT.FOCUS" });
        },
        onBlur() {
          send({ type: "INPUT.BLUR" });
        },
        onInput(event) {
          send({ type: "INPUT.CHANGE", target: event.currentTarget, hint: "set" });
        },
        onBeforeInput(event) {
          try {
            const { selectionStart, selectionEnd, value } = event.currentTarget;
            const nextValue = value.slice(0, selectionStart) + (event.data ?? "") + value.slice(selectionEnd);
            const isValid = computed("parser").isValidPartialNumber(nextValue);
            if (!isValid) {
              event.preventDefault();
            }
          } catch {
          }
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (readOnly) return;
          if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isComposingEvent)(event)) return;
          const step = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventStep)(event) * prop("step");
          const keyMap = {
            ArrowUp() {
              send({ type: "INPUT.ARROW_UP", step });
              event.preventDefault();
            },
            ArrowDown() {
              send({ type: "INPUT.ARROW_DOWN", step });
              event.preventDefault();
            },
            Home() {
              if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isModifierKey)(event)) return;
              send({ type: "INPUT.HOME" });
              event.preventDefault();
            },
            End() {
              if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isModifierKey)(event)) return;
              send({ type: "INPUT.END" });
              event.preventDefault();
            },
            Enter() {
              send({ type: "INPUT.ENTER" });
            }
          };
          const exec = keyMap[event.key];
          exec?.(event);
        }
      });
    },
    getDecrementTriggerProps() {
      return normalize.button({
        ...parts.decrementTrigger.attrs,
        dir: prop("dir"),
        id: getDecrementTriggerId(scope),
        disabled: isDecrementDisabled,
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(isDecrementDisabled),
        "aria-label": translations.decrementLabel,
        type: "button",
        tabIndex: -1,
        "aria-controls": getInputId(scope),
        onPointerDown(event) {
          if (isDecrementDisabled || !(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isLeftClick)(event)) return;
          send({ type: "TRIGGER.PRESS_DOWN", hint: "decrement", pointerType: event.pointerType });
          if (event.pointerType === "mouse") {
            event.preventDefault();
          }
          if (event.pointerType === "touch") {
            event.currentTarget?.focus({ preventScroll: true });
          }
        },
        onPointerUp(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "decrement", pointerType: event.pointerType });
        },
        onPointerLeave() {
          if (isDecrementDisabled) return;
          send({ type: "TRIGGER.PRESS_UP", hint: "decrement" });
        }
      });
    },
    getIncrementTriggerProps() {
      return normalize.button({
        ...parts.incrementTrigger.attrs,
        dir: prop("dir"),
        id: getIncrementTriggerId(scope),
        disabled: isIncrementDisabled,
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(isIncrementDisabled),
        "aria-label": translations.incrementLabel,
        type: "button",
        tabIndex: -1,
        "aria-controls": getInputId(scope),
        onPointerDown(event) {
          if (isIncrementDisabled || !(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isLeftClick)(event)) return;
          send({ type: "TRIGGER.PRESS_DOWN", hint: "increment", pointerType: event.pointerType });
          if (event.pointerType === "mouse") {
            event.preventDefault();
          }
          if (event.pointerType === "touch") {
            event.currentTarget?.focus({ preventScroll: true });
          }
        },
        onPointerUp(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "increment", pointerType: event.pointerType });
        },
        onPointerLeave(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "increment", pointerType: event.pointerType });
        }
      });
    },
    getScrubberProps() {
      return normalize.element({
        ...parts.scrubber.attrs,
        dir: prop("dir"),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        id: getScrubberId(scope),
        role: "presentation",
        onMouseDown(event) {
          if (disabled) return;
          const point = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventPoint)(event);
          const win = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getWindow)(event.currentTarget);
          const dpr = win.devicePixelRatio;
          point.x = point.x - (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.roundToDpr)(7.5, dpr);
          point.y = point.y - (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.roundToDpr)(7.5, dpr);
          send({ type: "SCRUBBER.PRESS_DOWN", point });
          event.preventDefault();
        },
        style: {
          cursor: disabled ? void 0 : "ew-resize"
        }
      });
    }
  };
}

// src/cursor.ts
function recordCursor(inputEl) {
  if (!inputEl || inputEl.ownerDocument.activeElement !== inputEl) return;
  try {
    const { selectionStart: start, selectionEnd: end, value } = inputEl;
    const beforeTxt = value.substring(0, start);
    const afterTxt = value.substring(end);
    return {
      start,
      end,
      value,
      beforeTxt,
      afterTxt
    };
  } catch {
  }
}
function restoreCursor(inputEl, selection) {
  if (!inputEl || inputEl.ownerDocument.activeElement !== inputEl) return;
  if (!selection) {
    inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
    return;
  }
  try {
    const { value } = inputEl;
    const { beforeTxt = "", afterTxt = "", start } = selection;
    let startPos = value.length;
    if (value.endsWith(afterTxt)) {
      startPos = value.length - afterTxt.length;
    } else if (value.startsWith(beforeTxt)) {
      startPos = beforeTxt.length;
    } else if (start != null) {
      const beforeLastChar = beforeTxt[start - 1];
      const newIndex = value.indexOf(beforeLastChar, start - 1);
      if (newIndex !== -1) {
        startPos = newIndex + 1;
      }
    }
    inputEl.setSelectionRange(startPos, startPos);
  } catch {
  }
}
var createFormatter = (locale, options = {}) => {
  return new Intl.NumberFormat(locale, options);
};
var createParser = (locale, options = {}) => {
  return new _internationalized_number__WEBPACK_IMPORTED_MODULE_3__.NumberParser(locale, options);
};
var parseValue = (value, params) => {
  const { prop, computed } = params;
  if (!prop("formatOptions")) return parseFloat(value);
  return computed("parser").parse(String(value));
};
var formatValue = (value, params) => {
  const { prop, computed } = params;
  if (Number.isNaN(value)) return "";
  if (!prop("formatOptions")) return value.toString();
  return computed("formatter").format(value);
};
var getDefaultStep = (step, formatOptions) => {
  let defaultStep = step !== void 0 && !Number.isNaN(step) ? step : 1;
  if (formatOptions?.style === "percent" && (step === void 0 || Number.isNaN(step))) {
    defaultStep = 0.01;
  }
  return defaultStep;
};

// src/number-input.machine.ts
var { choose, guards, createMachine } = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_4__.setup)();
var { not, and } = guards;
var machine = createMachine({
  props({ props: props2 }) {
    const step = getDefaultStep(props2.step, props2.formatOptions);
    return {
      dir: "ltr",
      locale: "en-US",
      focusInputOnChange: true,
      clampValueOnBlur: !props2.allowOverflow,
      allowOverflow: false,
      inputMode: "decimal",
      pattern: "[0-9]*(.[0-9]+)?",
      defaultValue: "",
      step,
      min: Number.MIN_SAFE_INTEGER,
      max: Number.MAX_SAFE_INTEGER,
      spinOnPress: true,
      ...props2,
      translations: {
        incrementLabel: "increment value",
        decrementLabel: "decrease value",
        ...props2.translations
      }
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable, getComputed }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          const computed = getComputed();
          const valueAsNumber = parseValue(value, { computed, prop });
          prop("onValueChange")?.({ value, valueAsNumber });
        }
      })),
      hint: bindable(() => ({ defaultValue: null })),
      scrubberCursorPoint: bindable(() => ({
        defaultValue: null,
        hash(value) {
          return value ? `x:${value.x}, y:${value.y}` : "";
        }
      })),
      fieldsetDisabled: bindable(() => ({ defaultValue: false }))
    };
  },
  computed: {
    isRtl: ({ prop }) => prop("dir") === "rtl",
    valueAsNumber: ({ context, computed, prop }) => parseValue(context.get("value"), { computed, prop }),
    formattedValue: ({ computed, prop }) => formatValue(computed("valueAsNumber"), { computed, prop }),
    isAtMin: ({ computed, prop }) => (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.isValueAtMin)(computed("valueAsNumber"), prop("min")),
    isAtMax: ({ computed, prop }) => (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.isValueAtMax)(computed("valueAsNumber"), prop("max")),
    isOutOfRange: ({ computed, prop }) => !(0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.isValueWithinRange)(computed("valueAsNumber"), prop("min"), prop("max")),
    isValueEmpty: ({ context }) => context.get("value") === "",
    isDisabled: ({ prop, context }) => !!prop("disabled") || context.get("fieldsetDisabled"),
    canIncrement: ({ prop, computed }) => prop("allowOverflow") || !computed("isAtMax"),
    canDecrement: ({ prop, computed }) => prop("allowOverflow") || !computed("isAtMin"),
    valueText: ({ prop, context }) => prop("translations").valueText?.(context.get("value")),
    formatter: (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_4__.memo)(
      ({ prop }) => [prop("locale"), prop("formatOptions")],
      (locale, formatOptions) => createFormatter(locale, formatOptions)
    ),
    parser: (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_4__.memo)(
      ({ prop }) => [prop("locale"), prop("formatOptions")],
      (locale, formatOptions) => createParser(locale, formatOptions)
    )
  },
  watch({ track, action, context, computed, prop }) {
    track([() => context.get("value"), () => prop("locale")], () => {
      action(["syncInputElement"]);
    });
    track([() => computed("isOutOfRange")], () => {
      action(["invokeOnInvalid"]);
    });
    track([() => context.hash("scrubberCursorPoint")], () => {
      action(["setVirtualCursorPosition"]);
    });
  },
  effects: ["trackFormControl"],
  on: {
    "VALUE.SET": {
      actions: ["setRawValue"]
    },
    "VALUE.CLEAR": {
      actions: ["clearValue"]
    },
    "VALUE.INCREMENT": {
      actions: ["increment"]
    },
    "VALUE.DECREMENT": {
      actions: ["decrement"]
    }
  },
  states: {
    idle: {
      on: {
        "TRIGGER.PRESS_DOWN": [
          { guard: "isTouchPointer", target: "before:spin", actions: ["setHint"] },
          {
            target: "before:spin",
            actions: ["focusInput", "invokeOnFocus", "setHint"]
          }
        ],
        "SCRUBBER.PRESS_DOWN": {
          target: "scrubbing",
          actions: ["focusInput", "invokeOnFocus", "setHint", "setCursorPoint"]
        },
        "INPUT.FOCUS": {
          target: "focused",
          actions: ["focusInput", "invokeOnFocus"]
        }
      }
    },
    focused: {
      tags: ["focus"],
      effects: ["attachWheelListener"],
      on: {
        "TRIGGER.PRESS_DOWN": [
          { guard: "isTouchPointer", target: "before:spin", actions: ["setHint"] },
          { target: "before:spin", actions: ["focusInput", "setHint"] }
        ],
        "SCRUBBER.PRESS_DOWN": {
          target: "scrubbing",
          actions: ["focusInput", "setHint", "setCursorPoint"]
        },
        "INPUT.ARROW_UP": {
          actions: ["increment"]
        },
        "INPUT.ARROW_DOWN": {
          actions: ["decrement"]
        },
        "INPUT.HOME": {
          actions: ["decrementToMin"]
        },
        "INPUT.END": {
          actions: ["incrementToMax"]
        },
        "INPUT.CHANGE": {
          actions: ["setValue", "setHint"]
        },
        "INPUT.BLUR": [
          {
            guard: and("clampValueOnBlur", not("isInRange")),
            target: "idle",
            actions: ["setClampedValue", "clearHint", "invokeOnBlur"]
          },
          {
            guard: not("isInRange"),
            target: "idle",
            actions: ["setFormattedValue", "clearHint", "invokeOnBlur", "invokeOnInvalid"]
          },
          {
            target: "idle",
            actions: ["setFormattedValue", "clearHint", "invokeOnBlur"]
          }
        ],
        "INPUT.ENTER": {
          actions: ["setFormattedValue", "clearHint", "invokeOnBlur"]
        }
      }
    },
    "before:spin": {
      tags: ["focus"],
      effects: ["trackButtonDisabled", "waitForChangeDelay"],
      entry: choose([
        { guard: "isIncrementHint", actions: ["increment"] },
        { guard: "isDecrementHint", actions: ["decrement"] }
      ]),
      on: {
        CHANGE_DELAY: {
          target: "spinning",
          guard: and("isInRange", "spinOnPress")
        },
        "TRIGGER.PRESS_UP": [
          { guard: "isTouchPointer", target: "focused", actions: ["clearHint"] },
          { target: "focused", actions: ["focusInput", "clearHint"] }
        ]
      }
    },
    spinning: {
      tags: ["focus"],
      effects: ["trackButtonDisabled", "spinValue"],
      on: {
        SPIN: [
          {
            guard: "isIncrementHint",
            actions: ["increment"]
          },
          {
            guard: "isDecrementHint",
            actions: ["decrement"]
          }
        ],
        "TRIGGER.PRESS_UP": {
          target: "focused",
          actions: ["focusInput", "clearHint"]
        }
      }
    },
    scrubbing: {
      tags: ["focus"],
      effects: ["activatePointerLock", "trackMousemove", "setupVirtualCursor", "preventTextSelection"],
      on: {
        "SCRUBBER.POINTER_UP": {
          target: "focused",
          actions: ["focusInput", "clearCursorPoint"]
        },
        "SCRUBBER.POINTER_MOVE": [
          {
            guard: "isIncrementHint",
            actions: ["increment", "setCursorPoint"]
          },
          {
            guard: "isDecrementHint",
            actions: ["decrement", "setCursorPoint"]
          }
        ]
      }
    }
  },
  implementations: {
    guards: {
      clampValueOnBlur: ({ prop }) => prop("clampValueOnBlur"),
      spinOnPress: ({ prop }) => !!prop("spinOnPress"),
      isInRange: ({ computed }) => !computed("isOutOfRange"),
      isDecrementHint: ({ context, event }) => (event.hint ?? context.get("hint")) === "decrement",
      isIncrementHint: ({ context, event }) => (event.hint ?? context.get("hint")) === "increment",
      isTouchPointer: ({ event }) => event.pointerType === "touch"
    },
    effects: {
      waitForChangeDelay({ send }) {
        const id = setTimeout(() => {
          send({ type: "CHANGE_DELAY" });
        }, 300);
        return () => clearTimeout(id);
      },
      spinValue({ send }) {
        const id = setInterval(() => {
          send({ type: "SPIN" });
        }, 50);
        return () => clearInterval(id);
      },
      trackFormControl({ context, scope }) {
        const inputEl = getInputEl(scope);
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.trackFormControl)(inputEl, {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            context.set("value", context.initial("value"));
          }
        });
      },
      setupVirtualCursor({ context, scope }) {
        const point = context.get("scrubberCursorPoint");
        return setupVirtualCursor(scope, point);
      },
      preventTextSelection({ scope }) {
        return preventTextSelection(scope);
      },
      trackButtonDisabled({ context, scope, send }) {
        const hint = context.get("hint");
        const btn = getPressedTriggerEl(scope, hint);
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.observeAttributes)(btn, {
          attributes: ["disabled"],
          callback() {
            send({ type: "TRIGGER.PRESS_UP", src: "attr" });
          }
        });
      },
      attachWheelListener({ scope, send, prop }) {
        const inputEl = getInputEl(scope);
        if (!inputEl || !scope.isActiveElement(inputEl) || !prop("allowMouseWheel")) return;
        function onWheel(event) {
          event.preventDefault();
          const dir = Math.sign(event.deltaY) * -1;
          if (dir === 1) {
            send({ type: "VALUE.INCREMENT" });
          } else if (dir === -1) {
            send({ type: "VALUE.DECREMENT" });
          }
        }
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.addDomEvent)(inputEl, "wheel", onWheel, { passive: false });
      },
      activatePointerLock({ scope }) {
        if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isSafari)()) return;
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.requestPointerLock)(scope.getDoc());
      },
      trackMousemove({ scope, send, context, computed }) {
        const doc = scope.getDoc();
        function onMousemove(event) {
          const point = context.get("scrubberCursorPoint");
          const isRtl = computed("isRtl");
          const value = getMousemoveValue(scope, { point, isRtl, event });
          if (!value.hint) return;
          send({
            type: "SCRUBBER.POINTER_MOVE",
            hint: value.hint,
            point: value.point
          });
        }
        function onMouseup() {
          send({ type: "SCRUBBER.POINTER_UP" });
        }
        return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.callAll)((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.addDomEvent)(doc, "mousemove", onMousemove, false), (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.addDomEvent)(doc, "mouseup", onMouseup, false));
      }
    },
    actions: {
      focusInput({ scope, prop }) {
        if (!prop("focusInputOnChange")) return;
        const inputEl = getInputEl(scope);
        if (scope.isActiveElement(inputEl)) return;
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => inputEl?.focus({ preventScroll: true }));
      },
      increment({ context, event, prop, computed }) {
        let nextValue = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.incrementValue)(computed("valueAsNumber"), event.step ?? prop("step"));
        if (!prop("allowOverflow")) nextValue = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.clampValue)(nextValue, prop("min"), prop("max"));
        context.set("value", formatValue(nextValue, { computed, prop }));
      },
      decrement({ context, event, prop, computed }) {
        let nextValue = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.decrementValue)(computed("valueAsNumber"), event.step ?? prop("step"));
        if (!prop("allowOverflow")) nextValue = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.clampValue)(nextValue, prop("min"), prop("max"));
        context.set("value", formatValue(nextValue, { computed, prop }));
      },
      setClampedValue({ context, prop, computed }) {
        const nextValue = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.clampValue)(computed("valueAsNumber"), prop("min"), prop("max"));
        context.set("value", formatValue(nextValue, { computed, prop }));
      },
      setRawValue({ context, event, prop, computed }) {
        let nextValue = parseValue(event.value, { computed, prop });
        if (!prop("allowOverflow")) nextValue = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.clampValue)(nextValue, prop("min"), prop("max"));
        context.set("value", formatValue(nextValue, { computed, prop }));
      },
      setValue({ context, event }) {
        const value = event.target?.value ?? event.value;
        context.set("value", value);
      },
      clearValue({ context }) {
        context.set("value", "");
      },
      incrementToMax({ context, prop, computed }) {
        const value = formatValue(prop("max"), { computed, prop });
        context.set("value", value);
      },
      decrementToMin({ context, prop, computed }) {
        const value = formatValue(prop("min"), { computed, prop });
        context.set("value", value);
      },
      setHint({ context, event }) {
        context.set("hint", event.hint);
      },
      clearHint({ context }) {
        context.set("hint", null);
      },
      invokeOnFocus({ computed, prop }) {
        prop("onFocusChange")?.({
          focused: true,
          value: computed("formattedValue"),
          valueAsNumber: computed("valueAsNumber")
        });
      },
      invokeOnBlur({ computed, prop }) {
        prop("onFocusChange")?.({
          focused: false,
          value: computed("formattedValue"),
          valueAsNumber: computed("valueAsNumber")
        });
      },
      invokeOnInvalid({ computed, prop, event }) {
        if (event.type === "INPUT.CHANGE") return;
        const reason = computed("valueAsNumber") > prop("max") ? "rangeOverflow" : "rangeUnderflow";
        prop("onValueInvalid")?.({
          reason,
          value: computed("formattedValue"),
          valueAsNumber: computed("valueAsNumber")
        });
      },
      syncInputElement({ context, event, computed, scope }) {
        const value = event.type.endsWith("CHANGE") ? context.get("value") : computed("formattedValue");
        const inputEl = getInputEl(scope);
        const sel = recordCursor(inputEl);
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => {
          (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.setElementValue)(inputEl, value);
          restoreCursor(inputEl, sel);
        });
      },
      setFormattedValue({ context, computed }) {
        context.set("value", computed("formattedValue"));
      },
      setCursorPoint({ context, event }) {
        context.set("scrubberCursorPoint", event.point);
      },
      clearCursorPoint({ context }) {
        context.set("scrubberCursorPoint", null);
      },
      setVirtualCursorPosition({ context, scope }) {
        const cursorEl = getCursorEl(scope);
        const point = context.get("scrubberCursorPoint");
        if (!cursorEl || !point) return;
        cursorEl.style.transform = `translate3d(${point.x}px, ${point.y}px, 0px)`;
      }
    }
  }
});
var props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_5__.createProps)()([
  "allowMouseWheel",
  "allowOverflow",
  "clampValueOnBlur",
  "dir",
  "disabled",
  "focusInputOnChange",
  "form",
  "formatOptions",
  "getRootNode",
  "id",
  "ids",
  "inputMode",
  "invalid",
  "locale",
  "max",
  "min",
  "name",
  "onFocusChange",
  "onValueChange",
  "onValueInvalid",
  "pattern",
  "required",
  "readOnly",
  "spinOnPress",
  "step",
  "translations",
  "value",
  "defaultValue"
]);
var splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.createSplitProps)(props);




/***/ }),

/***/ "./node_modules/@zag-js/pin-input/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@zag-js/pin-input/dist/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anatomy: () => (/* binding */ anatomy),
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   machine: () => (/* binding */ machine),
/* harmony export */   props: () => (/* binding */ props),
/* harmony export */   splitProps: () => (/* binding */ splitProps)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");






// src/pin-input.anatomy.ts
var anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("pinInput").parts("root", "label", "input", "control");
var parts = anatomy.build();
var getRootId = (ctx) => ctx.ids?.root ?? `pin-input:${ctx.id}`;
var getInputId = (ctx, id) => ctx.ids?.input?.(id) ?? `pin-input:${ctx.id}:${id}`;
var getHiddenInputId = (ctx) => ctx.ids?.hiddenInput ?? `pin-input:${ctx.id}:hidden`;
var getLabelId = (ctx) => ctx.ids?.label ?? `pin-input:${ctx.id}:label`;
var getControlId = (ctx) => ctx.ids?.control ?? `pin-input:${ctx.id}:control`;
var getRootEl = (ctx) => ctx.getById(getRootId(ctx));
var getInputEls = (ctx) => {
  const ownerId = CSS.escape(getRootId(ctx));
  const selector = `input[data-ownedby=${ownerId}]`;
  return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.queryAll)(getRootEl(ctx), selector);
};
var getInputElAtIndex = (ctx, index) => getInputEls(ctx)[index];
var getFirstInputEl = (ctx) => getInputEls(ctx)[0];
var getHiddenInputEl = (ctx) => ctx.getById(getHiddenInputId(ctx));
var setInputValue = (inputEl, value) => {
  inputEl.value = value;
  inputEl.setAttribute("value", value);
};

// src/pin-input.utils.ts
var REGEX = {
  numeric: /^[0-9]+$/,
  alphabetic: /^[A-Za-z]+$/,
  alphanumeric: /^[a-zA-Z0-9]+$/i
};
function isValidType(type, value) {
  if (!type) return true;
  return !!REGEX[type]?.test(value);
}
function isValidValue(value, type, pattern) {
  if (!pattern) return isValidType(type, value);
  const regex = new RegExp(pattern, "g");
  return regex.test(value);
}

// src/pin-input.connect.ts
function connect(service, normalize) {
  const { send, context, computed, prop, scope } = service;
  const complete = computed("isValueComplete");
  const invalid = prop("invalid");
  const translations = prop("translations");
  const focusedIndex = context.get("focusedIndex");
  function focus() {
    getFirstInputEl(scope)?.focus();
  }
  return {
    focus,
    count: context.get("count"),
    items: Array.from({ length: context.get("count") }).map((_, i) => i),
    value: context.get("value"),
    valueAsString: computed("valueAsString"),
    complete,
    setValue(value) {
      if (!Array.isArray(value)) {
        (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.invariant)("[pin-input/setValue] value must be an array");
      }
      send({ type: "VALUE.SET", value });
    },
    clearValue() {
      send({ type: "VALUE.CLEAR" });
    },
    setValueAtIndex(index, value) {
      send({ type: "VALUE.SET", value, index });
    },
    getRootProps() {
      return normalize.element({
        dir: prop("dir"),
        ...parts.root.attrs,
        id: getRootId(scope),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(invalid),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("disabled")),
        "data-complete": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(complete),
        "data-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("readOnly"))
      });
    },
    getLabelProps() {
      return normalize.label({
        ...parts.label.attrs,
        dir: prop("dir"),
        htmlFor: getHiddenInputId(scope),
        id: getLabelId(scope),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(invalid),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("disabled")),
        "data-complete": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(complete),
        "data-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("readOnly")),
        onClick(event) {
          event.preventDefault();
          focus();
        }
      });
    },
    getHiddenInputProps() {
      return normalize.input({
        "aria-hidden": true,
        type: "text",
        tabIndex: -1,
        id: getHiddenInputId(scope),
        readOnly: prop("readOnly"),
        disabled: prop("disabled"),
        required: prop("required"),
        name: prop("name"),
        form: prop("form"),
        style: _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.visuallyHiddenStyle,
        maxLength: computed("valueLength"),
        defaultValue: computed("valueAsString")
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts.control.attrs,
        dir: prop("dir"),
        id: getControlId(scope)
      });
    },
    getInputProps(props2) {
      const { index } = props2;
      const inputType = prop("type") === "numeric" ? "tel" : "text";
      return normalize.input({
        ...parts.input.attrs,
        dir: prop("dir"),
        disabled: prop("disabled"),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("disabled")),
        "data-complete": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(complete),
        id: getInputId(scope, index.toString()),
        "data-index": index,
        "data-ownedby": getRootId(scope),
        "aria-label": translations?.inputLabel?.(index, computed("valueLength")),
        inputMode: prop("otp") || prop("type") === "numeric" ? "numeric" : "text",
        "aria-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.ariaAttr)(invalid),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(invalid),
        type: prop("mask") ? "password" : inputType,
        defaultValue: context.get("value")[index] || "",
        readOnly: prop("readOnly"),
        autoCapitalize: "none",
        autoComplete: prop("otp") ? "one-time-code" : "off",
        placeholder: focusedIndex === index ? "" : prop("placeholder"),
        onBeforeInput(event) {
          try {
            const value = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getBeforeInputValue)(event);
            const isValid = isValidValue(value, prop("type"), prop("pattern"));
            if (!isValid) {
              send({ type: "VALUE.INVALID", value });
              event.preventDefault();
            }
            if (value.length > 2) {
              event.currentTarget.setSelectionRange(0, 1, "forward");
            }
          } catch {
          }
        },
        onChange(event) {
          const evt = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getNativeEvent)(event);
          const { value } = event.currentTarget;
          if (evt.inputType === "insertFromPaste" || value.length > 2) {
            send({ type: "INPUT.PASTE", value });
            event.currentTarget.value = value[0];
            event.preventDefault();
            return;
          }
          if (evt.inputType === "deleteContentBackward") {
            send({ type: "INPUT.BACKSPACE" });
            return;
          }
          send({ type: "INPUT.CHANGE", value, index });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isComposingEvent)(event)) return;
          if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isModifierKey)(event)) return;
          const keyMap = {
            Backspace() {
              send({ type: "INPUT.BACKSPACE" });
            },
            Delete() {
              send({ type: "INPUT.DELETE" });
            },
            ArrowLeft() {
              send({ type: "INPUT.ARROW_LEFT" });
            },
            ArrowRight() {
              send({ type: "INPUT.ARROW_RIGHT" });
            },
            Enter() {
              send({ type: "INPUT.ENTER" });
            }
          };
          const exec = keyMap[(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventKey)(event, {
            dir: prop("dir"),
            orientation: "horizontal"
          })];
          if (exec) {
            exec(event);
            event.preventDefault();
          }
        },
        onFocus() {
          send({ type: "INPUT.FOCUS", index });
        },
        onBlur(event) {
          const target = event.relatedTarget;
          if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(target) && target.dataset.ownedby === getRootId(scope)) return;
          send({ type: "INPUT.BLUR", index });
        }
      });
    }
  };
}
var { choose, createMachine } = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_3__.setup)();
var machine = createMachine({
  props({ props: props2 }) {
    return {
      placeholder: "\u25CB",
      otp: false,
      type: "numeric",
      defaultValue: props2.count ? fill([], props2.count) : [],
      ...props2,
      translations: {
        inputLabel: (index, length) => `pin code ${index + 1} of ${length}`,
        ...props2.translations
      }
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable }) {
    return {
      value: bindable(() => ({
        value: prop("value"),
        defaultValue: prop("defaultValue"),
        isEqual: _zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.isEqual,
        onChange(value) {
          prop("onValueChange")?.({ value, valueAsString: value.join("") });
        }
      })),
      focusedIndex: bindable(() => ({
        sync: true,
        defaultValue: -1
      })),
      // TODO: Move this to `props` in next major version
      count: bindable(() => ({
        defaultValue: prop("count")
      }))
    };
  },
  computed: {
    _value: ({ context }) => fill(context.get("value"), context.get("count")),
    valueLength: ({ computed }) => computed("_value").length,
    filledValueLength: ({ computed }) => computed("_value").filter((v) => v?.trim() !== "").length,
    isValueComplete: ({ computed }) => computed("valueLength") === computed("filledValueLength"),
    valueAsString: ({ computed }) => computed("_value").join(""),
    focusedValue: ({ computed, context }) => computed("_value")[context.get("focusedIndex")] || ""
  },
  entry: choose([
    {
      guard: "autoFocus",
      actions: ["setInputCount", "setFocusIndexToFirst"]
    },
    { actions: ["setInputCount"] }
  ]),
  watch({ action, track, context, computed }) {
    track([() => context.get("focusedIndex")], () => {
      action(["focusInput", "selectInputIfNeeded"]);
    });
    track([() => context.get("value").join(",")], () => {
      action(["syncInputElements", "dispatchInputEvent"]);
    });
    track([() => computed("isValueComplete")], () => {
      action(["invokeOnComplete", "blurFocusedInputIfNeeded"]);
    });
  },
  on: {
    "VALUE.SET": [
      {
        guard: "hasIndex",
        actions: ["setValueAtIndex"]
      },
      { actions: ["setValue"] }
    ],
    "VALUE.CLEAR": {
      actions: ["clearValue", "setFocusIndexToFirst"]
    }
  },
  states: {
    idle: {
      on: {
        "INPUT.FOCUS": {
          target: "focused",
          actions: ["setFocusedIndex"]
        }
      }
    },
    focused: {
      on: {
        "INPUT.CHANGE": {
          actions: ["setFocusedValue", "syncInputValue", "setNextFocusedIndex"]
        },
        "INPUT.PASTE": {
          actions: ["setPastedValue", "setLastValueFocusIndex"]
        },
        "INPUT.FOCUS": {
          actions: ["setFocusedIndex"]
        },
        "INPUT.BLUR": {
          target: "idle",
          actions: ["clearFocusedIndex"]
        },
        "INPUT.DELETE": {
          guard: "hasValue",
          actions: ["clearFocusedValue"]
        },
        "INPUT.ARROW_LEFT": {
          actions: ["setPrevFocusedIndex"]
        },
        "INPUT.ARROW_RIGHT": {
          actions: ["setNextFocusedIndex"]
        },
        "INPUT.BACKSPACE": [
          {
            guard: "hasValue",
            actions: ["clearFocusedValue"]
          },
          {
            actions: ["setPrevFocusedIndex", "clearFocusedValue"]
          }
        ],
        "INPUT.ENTER": {
          guard: "isValueComplete",
          actions: ["requestFormSubmit"]
        },
        "VALUE.INVALID": {
          actions: ["invokeOnInvalid"]
        }
      }
    }
  },
  implementations: {
    guards: {
      autoFocus: ({ prop }) => !!prop("autoFocus"),
      hasValue: ({ context }) => context.get("value")[context.get("focusedIndex")] !== "",
      isValueComplete: ({ computed }) => computed("isValueComplete"),
      hasIndex: ({ event }) => event.index !== void 0
    },
    actions: {
      dispatchInputEvent({ computed, scope }) {
        const inputEl = getHiddenInputEl(scope);
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dispatchInputValueEvent)(inputEl, { value: computed("valueAsString") });
      },
      setInputCount({ scope, context, prop }) {
        if (prop("count")) return;
        const inputEls = getInputEls(scope);
        context.set("count", inputEls.length);
      },
      focusInput({ context, scope }) {
        const focusedIndex = context.get("focusedIndex");
        if (focusedIndex === -1) return;
        getInputElAtIndex(scope, focusedIndex)?.focus({ preventScroll: true });
      },
      selectInputIfNeeded({ context, prop, scope }) {
        const focusedIndex = context.get("focusedIndex");
        if (!prop("selectOnFocus") || focusedIndex === -1) return;
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => {
          getInputElAtIndex(scope, focusedIndex)?.select();
        });
      },
      invokeOnComplete({ computed, prop }) {
        if (!computed("isValueComplete")) return;
        prop("onValueComplete")?.({
          value: computed("_value"),
          valueAsString: computed("valueAsString")
        });
      },
      invokeOnInvalid({ context, event, prop }) {
        prop("onValueInvalid")?.({
          value: event.value,
          index: context.get("focusedIndex")
        });
      },
      clearFocusedIndex({ context }) {
        context.set("focusedIndex", -1);
      },
      setFocusedIndex({ context, event }) {
        context.set("focusedIndex", event.index);
      },
      setValue({ context, event }) {
        const value = fill(event.value, context.get("count"));
        context.set("value", value);
      },
      setFocusedValue({ context, event, computed, flush }) {
        const focusedValue = computed("focusedValue");
        const focusedIndex = context.get("focusedIndex");
        const value = getNextValue(focusedValue, event.value);
        flush(() => {
          context.set("value", (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.setValueAtIndex)(computed("_value"), focusedIndex, value));
        });
      },
      revertInputValue({ context, computed, scope }) {
        const inputEl = getInputElAtIndex(scope, context.get("focusedIndex"));
        setInputValue(inputEl, computed("focusedValue"));
      },
      syncInputValue({ context, event, scope }) {
        const value = context.get("value");
        const inputEl = getInputElAtIndex(scope, event.index);
        setInputValue(inputEl, value[event.index]);
      },
      syncInputElements({ context, scope }) {
        const inputEls = getInputEls(scope);
        const value = context.get("value");
        inputEls.forEach((inputEl, index) => {
          setInputValue(inputEl, value[index]);
        });
      },
      setPastedValue({ context, event, computed, flush }) {
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => {
          const valueAsString = computed("valueAsString");
          const focusedIndex = context.get("focusedIndex");
          const valueLength = computed("valueLength");
          const filledValueLength = computed("filledValueLength");
          const startIndex = Math.min(focusedIndex, filledValueLength);
          const left = startIndex > 0 ? valueAsString.substring(0, focusedIndex) : "";
          const right = event.value.substring(0, valueLength - startIndex);
          const value = fill(`${left}${right}`.split(""), valueLength);
          flush(() => {
            context.set("value", value);
          });
        });
      },
      setValueAtIndex({ context, event, computed }) {
        const nextValue = getNextValue(computed("focusedValue"), event.value);
        context.set("value", (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.setValueAtIndex)(computed("_value"), event.index, nextValue));
      },
      clearValue({ context }) {
        const nextValue = Array.from({ length: context.get("count") }).fill("");
        context.set("value", nextValue);
      },
      clearFocusedValue({ context, computed }) {
        const focusedIndex = context.get("focusedIndex");
        if (focusedIndex === -1) return;
        context.set("value", (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.setValueAtIndex)(computed("_value"), focusedIndex, ""));
      },
      setFocusIndexToFirst({ context }) {
        context.set("focusedIndex", 0);
      },
      setNextFocusedIndex({ context, computed }) {
        context.set("focusedIndex", Math.min(context.get("focusedIndex") + 1, computed("valueLength") - 1));
      },
      setPrevFocusedIndex({ context }) {
        context.set("focusedIndex", Math.max(context.get("focusedIndex") - 1, 0));
      },
      setLastValueFocusIndex({ context, computed }) {
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => {
          context.set("focusedIndex", Math.min(computed("filledValueLength"), computed("valueLength") - 1));
        });
      },
      blurFocusedInputIfNeeded({ context, prop, scope }) {
        if (!prop("blurOnComplete")) return;
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => {
          getInputElAtIndex(scope, context.get("focusedIndex"))?.blur();
        });
      },
      requestFormSubmit({ computed, prop, scope }) {
        if (!prop("name") || !computed("isValueComplete")) return;
        const inputEl = getHiddenInputEl(scope);
        inputEl?.form?.requestSubmit();
      }
    }
  }
});
function getNextValue(current, next) {
  let nextValue = next;
  if (current[0] === next[0]) nextValue = next[1];
  else if (current[0] === next[1]) nextValue = next[0];
  return nextValue.split("")[nextValue.length - 1];
}
function fill(value, count) {
  return Array.from({ length: count }).fill("").map((v, i) => value[i] || v);
}
var props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_4__.createProps)()([
  "autoFocus",
  "blurOnComplete",
  "count",
  "defaultValue",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "mask",
  "name",
  "onValueChange",
  "onValueComplete",
  "onValueInvalid",
  "otp",
  "pattern",
  "placeholder",
  "readOnly",
  "required",
  "selectOnFocus",
  "translations",
  "type",
  "value"
]);
var splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.createSplitProps)(props);




/***/ }),

/***/ "./node_modules/@zag-js/popover/dist/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@zag-js/popover/dist/index.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anatomy: () => (/* binding */ anatomy),
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   machine: () => (/* binding */ machine),
/* harmony export */   props: () => (/* binding */ props),
/* harmony export */   splitProps: () => (/* binding */ splitProps)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_popper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/popper */ "./node_modules/@zag-js/popper/dist/index.mjs");
/* harmony import */ var _zag_js_aria_hidden__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @zag-js/aria-hidden */ "./node_modules/@zag-js/aria-hidden/dist/index.mjs");
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _zag_js_dismissable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/dismissable */ "./node_modules/@zag-js/dismissable/dist/index.mjs");
/* harmony import */ var _zag_js_focus_trap__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @zag-js/focus-trap */ "./node_modules/@zag-js/focus-trap/dist/index.mjs");
/* harmony import */ var _zag_js_remove_scroll__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @zag-js/remove-scroll */ "./node_modules/@zag-js/remove-scroll/dist/index.mjs");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");











// src/popover.anatomy.ts
var anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("popover").parts(
  "arrow",
  "arrowTip",
  "anchor",
  "trigger",
  "indicator",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts = anatomy.build();
var getAnchorId = (scope) => scope.ids?.anchor ?? `popover:${scope.id}:anchor`;
var getTriggerId = (scope) => scope.ids?.trigger ?? `popover:${scope.id}:trigger`;
var getContentId = (scope) => scope.ids?.content ?? `popover:${scope.id}:content`;
var getPositionerId = (scope) => scope.ids?.positioner ?? `popover:${scope.id}:popper`;
var getArrowId = (scope) => scope.ids?.arrow ?? `popover:${scope.id}:arrow`;
var getTitleId = (scope) => scope.ids?.title ?? `popover:${scope.id}:title`;
var getDescriptionId = (scope) => scope.ids?.description ?? `popover:${scope.id}:desc`;
var getCloseTriggerId = (scope) => scope.ids?.closeTrigger ?? `popover:${scope.id}:close`;
var getAnchorEl = (scope) => scope.getById(getAnchorId(scope));
var getTriggerEl = (scope) => scope.getById(getTriggerId(scope));
var getContentEl = (scope) => scope.getById(getContentId(scope));
var getPositionerEl = (scope) => scope.getById(getPositionerId(scope));
var getTitleEl = (scope) => scope.getById(getTitleId(scope));
var getDescriptionEl = (scope) => scope.getById(getDescriptionId(scope));

// src/popover.connect.ts
function connect(service, normalize) {
  const { state, context, send, computed, prop, scope } = service;
  const open = state.matches("open");
  const currentPlacement = context.get("currentPlacement");
  const portalled = computed("currentPortalled");
  const rendered = context.get("renderedElements");
  const popperStyles = (0,_zag_js_popper__WEBPACK_IMPORTED_MODULE_1__.getPlacementStyles)({
    ...prop("positioning"),
    placement: currentPlacement
  });
  return {
    portalled,
    open,
    setOpen(nextOpen) {
      const open2 = state.matches("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getArrowProps() {
      return normalize.element({
        id: getArrowId(scope),
        ...parts.arrow.attrs,
        dir: prop("dir"),
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize.element({
        ...parts.arrowTip.attrs,
        dir: prop("dir"),
        style: popperStyles.arrowTip
      });
    },
    getAnchorProps() {
      return normalize.element({
        ...parts.anchor.attrs,
        dir: prop("dir"),
        id: getAnchorId(scope)
      });
    },
    getTriggerProps() {
      return normalize.button({
        ...parts.trigger.attrs,
        dir: prop("dir"),
        type: "button",
        "data-placement": currentPlacement,
        id: getTriggerId(scope),
        "aria-haspopup": "dialog",
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": getContentId(scope),
        onPointerDown(event) {
          if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_2__.isSafari)()) {
            event.currentTarget.focus();
          }
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "TOGGLE" });
        },
        onBlur(event) {
          send({ type: "TRIGGER_BLUR", target: event.relatedTarget });
        }
      });
    },
    getIndicatorProps() {
      return normalize.element({
        ...parts.indicator.attrs,
        dir: prop("dir"),
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize.element({
        id: getPositionerId(scope),
        ...parts.positioner.attrs,
        dir: prop("dir"),
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize.element({
        ...parts.content.attrs,
        dir: prop("dir"),
        id: getContentId(scope),
        tabIndex: -1,
        role: "dialog",
        hidden: !open,
        "data-state": open ? "open" : "closed",
        "data-expanded": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_2__.dataAttr)(open),
        "aria-labelledby": rendered.title ? getTitleId(scope) : void 0,
        "aria-describedby": rendered.description ? getDescriptionId(scope) : void 0,
        "data-placement": currentPlacement
      });
    },
    getTitleProps() {
      return normalize.element({
        ...parts.title.attrs,
        id: getTitleId(scope),
        dir: prop("dir")
      });
    },
    getDescriptionProps() {
      return normalize.element({
        ...parts.description.attrs,
        id: getDescriptionId(scope),
        dir: prop("dir")
      });
    },
    getCloseTriggerProps() {
      return normalize.button({
        ...parts.closeTrigger.attrs,
        dir: prop("dir"),
        id: getCloseTriggerId(scope),
        type: "button",
        "aria-label": "close",
        onClick(event) {
          if (event.defaultPrevented) return;
          event.stopPropagation();
          send({ type: "CLOSE" });
        }
      });
    }
  };
}
var machine = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_3__.createMachine)({
  props({ props: props2 }) {
    return {
      closeOnInteractOutside: true,
      closeOnEscape: true,
      autoFocus: true,
      modal: false,
      portalled: true,
      ...props2,
      positioning: {
        placement: "bottom",
        ...props2.positioning
      }
    };
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "closed";
  },
  context({ bindable }) {
    return {
      currentPlacement: bindable(() => ({
        defaultValue: void 0
      })),
      renderedElements: bindable(() => ({
        defaultValue: { title: true, description: true }
      }))
    };
  },
  computed: {
    currentPortalled: ({ prop }) => !!prop("modal") || !!prop("portalled")
  },
  watch({ track, prop, action }) {
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  entry: ["checkRenderedElements"],
  states: {
    closed: {
      on: {
        "CONTROLLED.OPEN": {
          target: "open",
          actions: ["setInitialFocus"]
        },
        TOGGLE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen", "setInitialFocus"]
          }
        ],
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen", "setInitialFocus"]
          }
        ]
      }
    },
    open: {
      effects: [
        "trapFocus",
        "preventScroll",
        "hideContentBelow",
        "trackPositioning",
        "trackDismissableElement",
        "proxyTabFocus"
      ],
      on: {
        "CONTROLLED.CLOSE": {
          target: "closed",
          actions: ["setFinalFocus"]
        },
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose", "setFinalFocus"]
          }
        ],
        TOGGLE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "POSITIONING.SET": {
          actions: ["reposition"]
        }
      }
    }
  },
  implementations: {
    guards: {
      isOpenControlled: ({ prop }) => prop("open") != void 0
    },
    effects: {
      trackPositioning({ context, prop, scope }) {
        context.set("currentPlacement", prop("positioning").placement);
        const anchorEl = getAnchorEl(scope) ?? getTriggerEl(scope);
        const getPositionerEl2 = () => getPositionerEl(scope);
        return (0,_zag_js_popper__WEBPACK_IMPORTED_MODULE_1__.getPlacement)(anchorEl, getPositionerEl2, {
          ...prop("positioning"),
          defer: true,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      trackDismissableElement({ send, prop, scope }) {
        const getContentEl2 = () => getContentEl(scope);
        let restoreFocus = true;
        return (0,_zag_js_dismissable__WEBPACK_IMPORTED_MODULE_4__.trackDismissableElement)(getContentEl2, {
          pointerBlocking: prop("modal"),
          exclude: getTriggerEl(scope),
          defer: true,
          onEscapeKeyDown(event) {
            prop("onEscapeKeyDown")?.(event);
            if (prop("closeOnEscape")) return;
            event.preventDefault();
          },
          onInteractOutside(event) {
            prop("onInteractOutside")?.(event);
            if (event.defaultPrevented) return;
            restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
            if (!prop("closeOnInteractOutside")) {
              event.preventDefault();
            }
          },
          onPointerDownOutside: prop("onPointerDownOutside"),
          onFocusOutside: prop("onFocusOutside"),
          persistentElements: prop("persistentElements"),
          onDismiss() {
            send({ type: "CLOSE", src: "interact-outside", restoreFocus });
          }
        });
      },
      proxyTabFocus({ prop, scope }) {
        if (prop("modal") || !prop("portalled")) return;
        const getContentEl2 = () => getContentEl(scope);
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_2__.proxyTabFocus)(getContentEl2, {
          triggerElement: getTriggerEl(scope),
          defer: true,
          onFocus(el) {
            el.focus({ preventScroll: true });
          }
        });
      },
      hideContentBelow({ prop, scope }) {
        if (!prop("modal")) return;
        const getElements = () => [getContentEl(scope), getTriggerEl(scope)];
        return (0,_zag_js_aria_hidden__WEBPACK_IMPORTED_MODULE_5__.ariaHidden)(getElements, { defer: true });
      },
      preventScroll({ prop, scope }) {
        if (!prop("modal")) return;
        return (0,_zag_js_remove_scroll__WEBPACK_IMPORTED_MODULE_6__.preventBodyScroll)(scope.getDoc());
      },
      trapFocus({ prop, scope }) {
        if (!prop("modal")) return;
        const contentEl = () => getContentEl(scope);
        return (0,_zag_js_focus_trap__WEBPACK_IMPORTED_MODULE_7__.trapFocus)(contentEl, {
          initialFocus: () => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_2__.getInitialFocus)({
            root: getContentEl(scope),
            getInitialEl: prop("initialFocusEl"),
            enabled: prop("autoFocus")
          })
        });
      }
    },
    actions: {
      reposition({ event, prop, scope, context }) {
        const anchorEl = getAnchorEl(scope) ?? getTriggerEl(scope);
        const getPositionerEl2 = () => getPositionerEl(scope);
        (0,_zag_js_popper__WEBPACK_IMPORTED_MODULE_1__.getPlacement)(anchorEl, getPositionerEl2, {
          ...prop("positioning"),
          ...event.options,
          defer: true,
          listeners: false,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      checkRenderedElements({ context, scope }) {
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_2__.raf)(() => {
          Object.assign(context.get("renderedElements"), {
            title: !!getTitleEl(scope),
            description: !!getDescriptionEl(scope)
          });
        });
      },
      setInitialFocus({ prop, scope }) {
        if (prop("modal")) return;
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_2__.raf)(() => {
          const element = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_2__.getInitialFocus)({
            root: getContentEl(scope),
            getInitialEl: prop("initialFocusEl"),
            enabled: prop("autoFocus")
          });
          element?.focus({ preventScroll: true });
        });
      },
      setFinalFocus({ event, scope }) {
        const restoreFocus = event.restoreFocus ?? event.previousEvent?.restoreFocus;
        if (restoreFocus != null && !restoreFocus) return;
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_2__.raf)(() => {
          const element = getTriggerEl(scope);
          element?.focus({ preventScroll: true });
        });
      },
      invokeOnOpen({ prop }) {
        prop("onOpenChange")?.({ open: true });
      },
      invokeOnClose({ prop }) {
        prop("onOpenChange")?.({ open: false });
      },
      toggleVisibility({ event, send, prop }) {
        send({ type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: event });
      }
    }
  }
});
var props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_8__.createProps)()([
  "autoFocus",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "defaultOpen",
  "open",
  "persistentElements",
  "portalled",
  "positioning"
]);
var splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_9__.createSplitProps)(props);




/***/ }),

/***/ "./node_modules/@zag-js/popper/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@zag-js/popper/dist/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getPlacement: () => (/* binding */ getPlacement),
/* harmony export */   getPlacementSide: () => (/* binding */ getPlacementSide),
/* harmony export */   getPlacementStyles: () => (/* binding */ getPlacementStyles),
/* harmony export */   isValidPlacement: () => (/* binding */ isValidPlacement)
/* harmony export */ });
/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/dom */ "./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs");
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");




// src/get-placement.ts
function createDOMRect(x = 0, y = 0, width = 0, height = 0) {
  if (typeof DOMRect === "function") {
    return new DOMRect(x, y, width, height);
  }
  const rect = {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x
  };
  return { ...rect, toJSON: () => rect };
}
function getDOMRect(anchorRect) {
  if (!anchorRect) return createDOMRect();
  const { x, y, width, height } = anchorRect;
  return createDOMRect(x, y, width, height);
}
function getAnchorElement(anchorElement, getAnchorRect) {
  return {
    contextElement: (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(anchorElement) ? anchorElement : void 0,
    getBoundingClientRect: () => {
      const anchor = anchorElement;
      const anchorRect = getAnchorRect?.(anchor);
      if (anchorRect || !anchor) {
        return getDOMRect(anchorRect);
      }
      return anchor.getBoundingClientRect();
    }
  };
}

// src/middleware.ts
var toVar = (value) => ({ variable: value, reference: `var(${value})` });
var cssVars = {
  arrowSize: toVar("--arrow-size"),
  arrowSizeHalf: toVar("--arrow-size-half"),
  arrowBg: toVar("--arrow-background"),
  transformOrigin: toVar("--transform-origin"),
  arrowOffset: toVar("--arrow-offset")
};
var getTransformOrigin = (arrow2) => ({
  top: "bottom center",
  "top-start": arrow2 ? `${arrow2.x}px bottom` : "left bottom",
  "top-end": arrow2 ? `${arrow2.x}px bottom` : "right bottom",
  bottom: "top center",
  "bottom-start": arrow2 ? `${arrow2.x}px top` : "top left",
  "bottom-end": arrow2 ? `${arrow2.x}px top` : "top right",
  left: "right center",
  "left-start": arrow2 ? `right ${arrow2.y}px` : "right top",
  "left-end": arrow2 ? `right ${arrow2.y}px` : "right bottom",
  right: "left center",
  "right-start": arrow2 ? `left ${arrow2.y}px` : "left top",
  "right-end": arrow2 ? `left ${arrow2.y}px` : "left bottom"
});
var transformOriginMiddleware = {
  name: "transformOrigin",
  fn({ placement, elements, middlewareData }) {
    const { arrow: arrow2 } = middlewareData;
    const transformOrigin = getTransformOrigin(arrow2)[placement];
    const { floating } = elements;
    floating.style.setProperty(cssVars.transformOrigin.variable, transformOrigin);
    return {
      data: { transformOrigin }
    };
  }
};
var rectMiddleware = {
  name: "rects",
  fn({ rects }) {
    return {
      data: rects
    };
  }
};
var shiftArrowMiddleware = (arrowEl) => {
  if (!arrowEl) return;
  return {
    name: "shiftArrow",
    fn({ placement, middlewareData }) {
      if (!middlewareData.arrow) return {};
      const { x, y } = middlewareData.arrow;
      const dir = placement.split("-")[0];
      Object.assign(arrowEl.style, {
        left: x != null ? `${x}px` : "",
        top: y != null ? `${y}px` : "",
        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`
      });
      return {};
    }
  };
};

// src/placement.ts
function isValidPlacement(v) {
  return /^(?:top|bottom|left|right)(?:-(?:start|end))?$/.test(v);
}
function getPlacementDetails(placement) {
  const [side, align] = placement.split("-");
  return { side, align, hasAlign: align != null };
}
function getPlacementSide(placement) {
  return placement.split("-")[0];
}

// src/get-placement.ts
var defaultOptions = {
  strategy: "absolute",
  placement: "bottom",
  listeners: true,
  gutter: 8,
  flip: true,
  slide: true,
  overlap: false,
  sameWidth: false,
  fitViewport: false,
  overflowPadding: 8,
  arrowPadding: 4
};
function roundByDpr(win, value) {
  const dpr = win.devicePixelRatio || 1;
  return Math.round(value * dpr) / dpr;
}
function getBoundaryMiddleware(opts) {
  return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_1__.runIfFn)(opts.boundary);
}
function getArrowMiddleware(arrowElement, opts) {
  if (!arrowElement) return;
  return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.arrow)({
    element: arrowElement,
    padding: opts.arrowPadding
  });
}
function getOffsetMiddleware(arrowElement, opts) {
  if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(opts.offset ?? opts.gutter)) return;
  return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.offset)(({ placement }) => {
    const arrowOffset = (arrowElement?.clientHeight || 0) / 2;
    const gutter = opts.offset?.mainAxis ?? opts.gutter;
    const mainAxis = typeof gutter === "number" ? gutter + arrowOffset : gutter ?? arrowOffset;
    const { hasAlign } = getPlacementDetails(placement);
    const shift2 = !hasAlign ? opts.shift : void 0;
    const crossAxis = opts.offset?.crossAxis ?? shift2;
    return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_1__.compact)({
      crossAxis,
      mainAxis,
      alignmentAxis: opts.shift
    });
  });
}
function getFlipMiddleware(opts) {
  if (!opts.flip) return;
  return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.flip)({
    boundary: getBoundaryMiddleware(opts),
    padding: opts.overflowPadding,
    fallbackPlacements: opts.flip === true ? void 0 : opts.flip
  });
}
function getShiftMiddleware(opts) {
  if (!opts.slide && !opts.overlap) return;
  return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.shift)({
    boundary: getBoundaryMiddleware(opts),
    mainAxis: opts.slide,
    crossAxis: opts.overlap,
    padding: opts.overflowPadding,
    limiter: (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.limitShift)()
  });
}
function getSizeMiddleware(opts) {
  return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.size)({
    padding: opts.overflowPadding,
    apply({ elements, rects, availableHeight, availableWidth }) {
      const floating = elements.floating;
      const referenceWidth = Math.round(rects.reference.width);
      availableWidth = Math.floor(availableWidth);
      availableHeight = Math.floor(availableHeight);
      floating.style.setProperty("--reference-width", `${referenceWidth}px`);
      floating.style.setProperty("--available-width", `${availableWidth}px`);
      floating.style.setProperty("--available-height", `${availableHeight}px`);
    }
  });
}
function hideWhenDetachedMiddleware(opts) {
  if (!opts.hideWhenDetached) return;
  return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.hide)({ strategy: "referenceHidden", boundary: opts.boundary?.() ?? "clippingAncestors" });
}
function getAutoUpdateOptions(opts) {
  if (!opts) return {};
  if (opts === true) {
    return { ancestorResize: true, ancestorScroll: true, elementResize: true, layoutShift: true };
  }
  return opts;
}
function getPlacementImpl(referenceOrVirtual, floating, opts = {}) {
  const reference = getAnchorElement(referenceOrVirtual, opts.getAnchorRect);
  if (!floating || !reference) return;
  const options = Object.assign({}, defaultOptions, opts);
  const arrowEl = floating.querySelector("[data-part=arrow]");
  const middleware = [
    getOffsetMiddleware(arrowEl, options),
    getFlipMiddleware(options),
    getShiftMiddleware(options),
    getArrowMiddleware(arrowEl, options),
    shiftArrowMiddleware(arrowEl),
    transformOriginMiddleware,
    getSizeMiddleware(options),
    hideWhenDetachedMiddleware(options),
    rectMiddleware
  ];
  const { placement, strategy, onComplete, onPositioned } = options;
  const updatePosition = async () => {
    if (!reference || !floating) return;
    const pos = await (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.computePosition)(reference, floating, {
      placement,
      middleware,
      strategy
    });
    onComplete?.(pos);
    onPositioned?.({ placed: true });
    const win = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getWindow)(floating);
    const x = roundByDpr(win, pos.x);
    const y = roundByDpr(win, pos.y);
    floating.style.setProperty("--x", `${x}px`);
    floating.style.setProperty("--y", `${y}px`);
    if (options.hideWhenDetached) {
      const isHidden = pos.middlewareData.hide?.referenceHidden;
      if (isHidden) {
        floating.style.setProperty("visibility", "hidden");
        floating.style.setProperty("pointer-events", "none");
      } else {
        floating.style.removeProperty("visibility");
        floating.style.removeProperty("pointer-events");
      }
    }
    const contentEl = floating.firstElementChild;
    if (contentEl) {
      const styles = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(contentEl);
      floating.style.setProperty("--z-index", styles.zIndex);
    }
  };
  const update = async () => {
    if (opts.updatePosition) {
      await opts.updatePosition({ updatePosition });
      onPositioned?.({ placed: true });
    } else {
      await updatePosition();
    }
  };
  const autoUpdateOptions = getAutoUpdateOptions(options.listeners);
  const cancelAutoUpdate = options.listeners ? (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.autoUpdate)(reference, floating, update, autoUpdateOptions) : _zag_js_utils__WEBPACK_IMPORTED_MODULE_1__.noop;
  update();
  return () => {
    cancelAutoUpdate?.();
    onPositioned?.({ placed: false });
  };
}
function getPlacement(referenceOrFn, floatingOrFn, opts = {}) {
  const { defer, ...options } = opts;
  const func = defer ? _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const reference = typeof referenceOrFn === "function" ? referenceOrFn() : referenceOrFn;
      const floating = typeof floatingOrFn === "function" ? floatingOrFn() : floatingOrFn;
      cleanups.push(getPlacementImpl(reference, floating, options));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}

// src/get-styles.ts
var ARROW_FLOATING_STYLE = {
  bottom: "rotate(45deg)",
  left: "rotate(135deg)",
  top: "rotate(225deg)",
  right: "rotate(315deg)"
};
function getPlacementStyles(options = {}) {
  const { placement, sameWidth, fitViewport, strategy = "absolute" } = options;
  return {
    arrow: {
      position: "absolute",
      width: cssVars.arrowSize.reference,
      height: cssVars.arrowSize.reference,
      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,
      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`
    },
    arrowTip: {
      // @ts-expect-error - Fix this
      transform: placement ? ARROW_FLOATING_STYLE[placement.split("-")[0]] : void 0,
      background: cssVars.arrowBg.reference,
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      position: "absolute",
      zIndex: "inherit"
    },
    floating: {
      position: strategy,
      isolation: "isolate",
      minWidth: sameWidth ? void 0 : "max-content",
      width: sameWidth ? "var(--reference-width)" : void 0,
      maxWidth: fitViewport ? "var(--available-width)" : void 0,
      maxHeight: fitViewport ? "var(--available-height)" : void 0,
      pointerEvents: !placement ? "none" : void 0,
      top: "0px",
      left: "0px",
      // move off-screen if placement is not defined
      transform: placement ? "translate3d(var(--x), var(--y), 0)" : "translate3d(0, -100vh, 0)",
      zIndex: "var(--z-index)"
    }
  };
}




/***/ }),

/***/ "./node_modules/@zag-js/presence/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@zag-js/presence/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   machine: () => (/* binding */ machine),
/* harmony export */   props: () => (/* binding */ props)
/* harmony export */ });
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");




// src/presence.connect.ts
function connect(service, _normalize) {
  const { state, send, context } = service;
  const present = state.matches("mounted", "unmountSuspended");
  return {
    skip: !context.get("initial"),
    present,
    setNode(node) {
      if (!node) return;
      send({ type: "NODE.SET", node });
    },
    unmount() {
      send({ type: "UNMOUNT" });
    }
  };
}
var machine = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_0__.createMachine)({
  props({ props: props2 }) {
    return { ...props2, present: !!props2.present };
  },
  initialState({ prop }) {
    return prop("present") ? "mounted" : "unmounted";
  },
  refs() {
    return {
      node: null,
      styles: null
    };
  },
  context({ bindable }) {
    return {
      unmountAnimationName: bindable(() => ({ defaultValue: null })),
      prevAnimationName: bindable(() => ({ defaultValue: null })),
      present: bindable(() => ({ defaultValue: false })),
      initial: bindable(() => ({
        sync: true,
        defaultValue: false
      }))
    };
  },
  exit: ["clearInitial", "cleanupNode"],
  watch({ track, action, prop }) {
    track([() => prop("present")], () => {
      action(["setInitial", "syncPresence"]);
    });
  },
  on: {
    "NODE.SET": {
      actions: ["setNode", "setStyles"]
    }
  },
  states: {
    mounted: {
      on: {
        UNMOUNT: {
          target: "unmounted",
          actions: ["clearPrevAnimationName", "invokeOnExitComplete"]
        },
        "UNMOUNT.SUSPEND": {
          target: "unmountSuspended"
        }
      }
    },
    unmountSuspended: {
      effects: ["trackAnimationEvents"],
      on: {
        MOUNT: {
          target: "mounted",
          actions: ["setPrevAnimationName"]
        },
        UNMOUNT: {
          target: "unmounted",
          actions: ["clearPrevAnimationName", "invokeOnExitComplete"]
        }
      }
    },
    unmounted: {
      on: {
        MOUNT: {
          target: "mounted",
          actions: ["setPrevAnimationName"]
        }
      }
    }
  },
  implementations: {
    actions: {
      setInitial: ({ context }) => {
        if (context.get("initial")) return;
        queueMicrotask(() => {
          context.set("initial", true);
        });
      },
      clearInitial: ({ context }) => {
        context.set("initial", false);
      },
      cleanupNode: ({ refs }) => {
        refs.set("node", null);
        refs.set("styles", null);
      },
      invokeOnExitComplete: ({ prop }) => {
        prop("onExitComplete")?.();
      },
      setNode: ({ refs, event }) => {
        refs.set("node", event.node);
      },
      setStyles: ({ refs, event }) => {
        refs.set("styles", (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(event.node));
      },
      syncPresence: ({ context, refs, send, prop }) => {
        const presentProp = prop("present");
        if (presentProp) {
          return send({ type: "MOUNT", src: "presence.changed" });
        }
        const node = refs.get("node");
        if (!presentProp && node?.ownerDocument.visibilityState === "hidden") {
          return send({ type: "UNMOUNT", src: "visibilitychange" });
        }
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => {
          const animationName = getAnimationName(refs.get("styles"));
          context.set("unmountAnimationName", animationName);
          if (animationName === "none" || animationName === context.get("prevAnimationName") || refs.get("styles")?.display === "none" || refs.get("styles")?.animationDuration === "0s") {
            send({ type: "UNMOUNT", src: "presence.changed" });
          } else {
            send({ type: "UNMOUNT.SUSPEND" });
          }
        });
      },
      setPrevAnimationName: ({ context, refs }) => {
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => {
          context.set("prevAnimationName", getAnimationName(refs.get("styles")));
        });
      },
      clearPrevAnimationName: ({ context }) => {
        context.set("prevAnimationName", null);
      }
    },
    effects: {
      trackAnimationEvents: ({ context, refs, send }) => {
        const node = refs.get("node");
        if (!node) return;
        const onStart = (event) => {
          const target = event.composedPath?.()?.[0] ?? event.target;
          if (target === node) {
            context.set("prevAnimationName", getAnimationName(refs.get("styles")));
          }
        };
        const onEnd = (event) => {
          const animationName = getAnimationName(refs.get("styles"));
          const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventTarget)(event);
          if (target === node && animationName === context.get("unmountAnimationName")) {
            send({ type: "UNMOUNT", src: "animationend" });
          }
        };
        node.addEventListener("animationstart", onStart);
        node.addEventListener("animationcancel", onEnd);
        node.addEventListener("animationend", onEnd);
        const cleanupStyles = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.setStyle)(node, { animationFillMode: "forwards" });
        return () => {
          node.removeEventListener("animationstart", onStart);
          node.removeEventListener("animationcancel", onEnd);
          node.removeEventListener("animationend", onEnd);
          (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.nextTick)(() => cleanupStyles());
        };
      }
    }
  }
});
function getAnimationName(styles) {
  return styles?.animationName || "none";
}
var props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_2__.createProps)()(["onExitComplete", "present", "immediate"]);




/***/ }),

/***/ "./node_modules/@zag-js/progress/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@zag-js/progress/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anatomy: () => (/* binding */ anatomy),
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   machine: () => (/* binding */ machine),
/* harmony export */   props: () => (/* binding */ props),
/* harmony export */   splitProps: () => (/* binding */ splitProps)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");





// src/progress.anatomy.ts
var anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("progress").parts(
  "root",
  "label",
  "track",
  "range",
  "valueText",
  "view",
  "circle",
  "circleTrack",
  "circleRange"
);
var parts = anatomy.build();

// src/progress.dom.ts
var getRootId = (ctx) => ctx.ids?.root ?? `progress-${ctx.id}`;
var getTrackId = (ctx) => ctx.ids?.track ?? `progress-${ctx.id}-track`;
var getLabelId = (ctx) => ctx.ids?.label ?? `progress-${ctx.id}-label`;
var getCircleId = (ctx) => ctx.ids?.circle ?? `progress-${ctx.id}-circle`;

// src/progress.connect.ts
function connect(service, normalize) {
  const { context, computed, prop, send, scope } = service;
  const percent = computed("percent");
  const percentAsString = computed("isIndeterminate") ? "" : computed("formatter").format(computed("percent") / 100);
  const max = prop("max");
  const min = prop("min");
  const orientation = prop("orientation");
  const translations = prop("translations");
  const indeterminate = computed("isIndeterminate");
  const value = context.get("value");
  const valueAsString = translations?.value({ value, max, percent, min }) ?? "";
  const progressState = getProgressState(value, max);
  const progressbarProps = {
    role: "progressbar",
    "aria-label": valueAsString,
    "data-max": max,
    "aria-valuemin": min,
    "aria-valuemax": max,
    "aria-valuenow": value ?? void 0,
    "data-orientation": orientation,
    "data-state": progressState
  };
  const circleProps2 = getCircleProps(service);
  return {
    value,
    valueAsString,
    min,
    max,
    percent,
    percentAsString,
    indeterminate,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2 });
    },
    setToMax() {
      send({ type: "VALUE.SET", value: max });
    },
    setToMin() {
      send({ type: "VALUE.SET", value: min });
    },
    getRootProps() {
      return normalize.element({
        dir: prop("dir"),
        ...parts.root.attrs,
        id: getRootId(scope),
        "data-max": max,
        "data-value": value ?? void 0,
        "data-state": progressState,
        "data-orientation": orientation,
        style: {
          "--percent": indeterminate ? void 0 : percent
        }
      });
    },
    getLabelProps() {
      return normalize.element({
        dir: prop("dir"),
        id: getLabelId(scope),
        ...parts.label.attrs,
        "data-orientation": orientation
      });
    },
    getValueTextProps() {
      return normalize.element({
        dir: prop("dir"),
        "aria-live": "polite",
        ...parts.valueText.attrs
      });
    },
    getTrackProps() {
      return normalize.element({
        dir: prop("dir"),
        id: getTrackId(scope),
        ...parts.track.attrs,
        ...progressbarProps
      });
    },
    getRangeProps() {
      return normalize.element({
        dir: prop("dir"),
        ...parts.range.attrs,
        "data-orientation": orientation,
        "data-state": progressState,
        style: {
          [computed("isHorizontal") ? "width" : "height"]: indeterminate ? void 0 : `${percent}%`
        }
      });
    },
    getCircleProps() {
      return normalize.element({
        dir: prop("dir"),
        id: getCircleId(scope),
        ...parts.circle.attrs,
        ...progressbarProps,
        ...circleProps2.root
      });
    },
    getCircleTrackProps() {
      return normalize.element({
        dir: prop("dir"),
        "data-orientation": orientation,
        ...parts.circleTrack.attrs,
        ...circleProps2.track
      });
    },
    getCircleRangeProps() {
      return normalize.element({
        dir: prop("dir"),
        ...parts.circleRange.attrs,
        ...circleProps2.range,
        "data-state": progressState
      });
    },
    getViewProps(props2) {
      return normalize.element({
        dir: prop("dir"),
        ...parts.view.attrs,
        "data-state": props2.state,
        hidden: props2.state !== progressState
      });
    }
  };
}
function getProgressState(value, maxValue) {
  return value == null ? "indeterminate" : value === maxValue ? "complete" : "loading";
}
var circleProps = {
  style: {
    "--radius": "calc(var(--size) / 2 - var(--thickness) / 2)",
    cx: "calc(var(--size) / 2)",
    cy: "calc(var(--size) / 2)",
    r: "var(--radius)",
    fill: "transparent",
    strokeWidth: "var(--thickness)"
  }
};
var rootProps = {
  style: {
    width: "var(--size)",
    height: "var(--size)"
  }
};
function getCircleProps(service) {
  const { context, computed } = service;
  return {
    root: rootProps,
    track: circleProps,
    range: {
      opacity: context.get("value") === 0 ? 0 : void 0,
      style: {
        ...circleProps.style,
        "--percent": computed("percent"),
        "--circumference": `calc(2 * 3.14159 * var(--radius))`,
        "--offset": `calc(var(--circumference) * (100 - var(--percent)) / 100)`,
        strokeDashoffset: `calc(var(--circumference) * ((100 - var(--percent)) / 100))`,
        strokeDasharray: computed("isIndeterminate") ? void 0 : `var(--circumference)`,
        transformOrigin: "center",
        transform: "rotate(-90deg)"
      }
    }
  };
}
var machine = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_1__.createMachine)({
  props({ props: props2 }) {
    const min = props2.min ?? 0;
    const max = props2.max ?? 100;
    return {
      ...props2,
      max,
      min,
      defaultValue: props2.defaultValue ?? midValue(min, max),
      orientation: "horizontal",
      formatOptions: {
        style: "percent",
        ...props2.formatOptions
      },
      translations: {
        value: ({ percent }) => percent === -1 ? "loading..." : `${percent} percent`,
        ...props2.translations
      }
    };
  },
  initialState() {
    return "idle";
  },
  entry: ["validateContext"],
  context({ bindable, prop }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          prop("onValueChange")?.({ value });
        }
      }))
    };
  },
  computed: {
    isIndeterminate: ({ context }) => context.get("value") === null,
    percent({ context, prop }) {
      const value = context.get("value");
      if (!(0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.isNumber)(value)) return -1;
      return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.getValuePercent)(value, prop("min"), prop("max")) * 100;
    },
    formatter: (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_1__.memo)(
      ({ prop }) => [prop("locale"), prop("formatOptions")],
      (locale, formatOptions) => new Intl.NumberFormat(locale, formatOptions)
    ),
    isHorizontal: ({ prop }) => prop("orientation") === "horizontal"
  },
  states: {
    idle: {
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        }
      }
    }
  },
  implementations: {
    actions: {
      setValue: ({ context, event, prop }) => {
        const value = event.value === null ? null : Math.max(0, Math.min(event.value, prop("max")));
        context.set("value", value);
      },
      validateContext: ({ context, prop }) => {
        const max = prop("max");
        const min = prop("min");
        const value = context.get("value");
        if (value == null) return;
        if (!isValidNumber(max)) {
          throw new Error(`[progress] The max value passed \`${max}\` is not a valid number`);
        }
        if (!isValidMax(value, max)) {
          throw new Error(`[progress] The value passed \`${value}\` exceeds the max value \`${max}\``);
        }
        if (!isValidMin(value, min)) {
          throw new Error(`[progress] The value passed \`${value}\` exceeds the min value \`${min}\``);
        }
      }
    }
  }
});
var isValidNumber = (max) => (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.isNumber)(max) && !isNaN(max);
var isValidMax = (value, max) => isValidNumber(value) && value <= max;
var isValidMin = (value, min) => isValidNumber(value) && value >= min;
var midValue = (min, max) => min + (max - min) / 2;
var props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_3__.createProps)()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "max",
  "min",
  "orientation",
  "translations",
  "value",
  "onValueChange",
  "defaultValue",
  "formatOptions",
  "locale"
]);
var splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.createSplitProps)(props);




/***/ }),

/***/ "./node_modules/@zag-js/qr-code/dist/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@zag-js/qr-code/dist/index.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anatomy: () => (/* binding */ anatomy),
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   machine: () => (/* binding */ machine),
/* harmony export */   props: () => (/* binding */ props),
/* harmony export */   splitProps: () => (/* binding */ splitProps)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var uqr__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uqr */ "./node_modules/uqr/dist/index.mjs");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");







// src/qr-code.anatomy.ts
var anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("qr-code").parts("root", "frame", "pattern", "overlay", "downloadTrigger");
var parts = anatomy.build();

// src/qr-code.dom.ts
var getRootId = (scope) => scope.ids?.root ?? `qrcode:${scope.id}:root`;
var getFrameId = (scope) => scope.ids?.frame ?? `qrcode:${scope.id}:frame`;
var getFrameEl = (scope) => scope.getById(getFrameId(scope));

// src/qr-code.connect.ts
function connect(service, normalize) {
  const { context, computed, send, scope, prop } = service;
  const encoded = computed("encoded");
  const pixelSize = prop("pixelSize");
  const height = encoded.size * pixelSize;
  const width = encoded.size * pixelSize;
  const paths = [];
  for (let row = 0; row < encoded.size; row++) {
    for (let col = 0; col < encoded.size; col++) {
      const x = col * pixelSize;
      const y = row * pixelSize;
      if (encoded.data[row][col]) {
        paths.push(`M${x},${y}h${pixelSize}v${pixelSize}h-${pixelSize}z`);
      }
    }
  }
  return {
    value: context.get("value"),
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    getDataUrl(type, quality) {
      const svgEl = getFrameEl(scope);
      return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getDataUrl)(svgEl, { type, quality });
    },
    getRootProps() {
      return normalize.element({
        id: getRootId(scope),
        ...parts.root.attrs,
        style: {
          "--qrcode-pixel-size": `${pixelSize}px`,
          "--qrcode-width": `${width}px`,
          "--qrcode-height": `${height}px`,
          position: "relative"
        }
      });
    },
    getFrameProps() {
      return normalize.svg({
        id: getFrameId(scope),
        ...parts.frame.attrs,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: `0 0 ${width} ${height}`
      });
    },
    getPatternProps() {
      return normalize.path({
        d: paths.join(""),
        ...parts.pattern.attrs
      });
    },
    getOverlayProps() {
      return normalize.element({
        ...parts.overlay.attrs,
        style: {
          position: "absolute",
          top: "50%",
          left: "50%",
          translate: "-50% -50%"
        }
      });
    },
    getDownloadTriggerProps(props2) {
      return normalize.button({
        type: "button",
        ...parts.downloadTrigger.attrs,
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "DOWNLOAD_TRIGGER.CLICK", ...props2 });
        }
      });
    }
  };
}
var machine = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_2__.createMachine)({
  props({ props: props2 }) {
    return {
      defaultValue: "",
      pixelSize: 10,
      ...props2
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable }) {
    return {
      value: bindable(() => ({
        value: prop("value"),
        defaultValue: prop("defaultValue"),
        onChange(value) {
          prop("onValueChange")?.({ value });
        }
      }))
    };
  },
  computed: {
    encoded: (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_2__.memo)(
      ({ context, prop }) => [context.get("value"), prop("encoding")],
      (value, encoding) => (0,uqr__WEBPACK_IMPORTED_MODULE_3__.encode)(value, encoding)
    )
  },
  states: {
    idle: {
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        },
        "DOWNLOAD_TRIGGER.CLICK": {
          actions: ["downloadQrCode"]
        }
      }
    }
  },
  implementations: {
    actions: {
      setValue({ context, event }) {
        context.set("value", event.value);
      },
      downloadQrCode({ event, scope }) {
        const { mimeType, quality, fileName } = event;
        const svgEl = getFrameEl(scope);
        const doc = scope.getDoc();
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getDataUrl)(svgEl, { type: mimeType, quality }).then((dataUri) => {
          const a = doc.createElement("a");
          a.href = dataUri;
          a.rel = "noopener";
          a.download = fileName;
          a.click();
          setTimeout(() => {
            a.remove();
          }, 0);
        });
      }
    }
  }
});
var props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_4__.createProps)()([
  "ids",
  "defaultValue",
  "value",
  "id",
  "encoding",
  "dir",
  "getRootNode",
  "onValueChange",
  "pixelSize"
]);
var splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_5__.createSplitProps)(props);




/***/ }),

/***/ "./node_modules/@zag-js/radio-group/dist/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@zag-js/radio-group/dist/index.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anatomy: () => (/* binding */ anatomy),
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   itemProps: () => (/* binding */ itemProps),
/* harmony export */   machine: () => (/* binding */ machine),
/* harmony export */   props: () => (/* binding */ props),
/* harmony export */   splitItemProps: () => (/* binding */ splitItemProps),
/* harmony export */   splitProps: () => (/* binding */ splitProps)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_focus_visible__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/focus-visible */ "./node_modules/@zag-js/focus-visible/dist/index.mjs");
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");







// src/radio-group.anatomy.ts
var anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("radio-group").parts(
  "root",
  "label",
  "item",
  "itemText",
  "itemControl",
  "indicator"
);
var parts = anatomy.build();
var getRootId = (ctx) => ctx.ids?.root ?? `radio-group:${ctx.id}`;
var getLabelId = (ctx) => ctx.ids?.label ?? `radio-group:${ctx.id}:label`;
var getItemId = (ctx, value) => ctx.ids?.item?.(value) ?? `radio-group:${ctx.id}:radio:${value}`;
var getItemHiddenInputId = (ctx, value) => ctx.ids?.itemHiddenInput?.(value) ?? `radio-group:${ctx.id}:radio:input:${value}`;
var getItemControlId = (ctx, value) => ctx.ids?.itemControl?.(value) ?? `radio-group:${ctx.id}:radio:control:${value}`;
var getItemLabelId = (ctx, value) => ctx.ids?.itemLabel?.(value) ?? `radio-group:${ctx.id}:radio:label:${value}`;
var getIndicatorId = (ctx) => ctx.ids?.indicator ?? `radio-group:${ctx.id}:indicator`;
var getRootEl = (ctx) => ctx.getById(getRootId(ctx));
var getItemHiddenInputEl = (ctx, value) => ctx.getById(getItemHiddenInputId(ctx, value));
var getIndicatorEl = (ctx) => ctx.getById(getIndicatorId(ctx));
var getFirstEnabledInputEl = (ctx) => getRootEl(ctx)?.querySelector("input:not(:disabled)");
var getFirstEnabledAndCheckedInputEl = (ctx) => getRootEl(ctx)?.querySelector("input:not(:disabled):checked");
var getInputEls = (ctx) => {
  const ownerId = CSS.escape(getRootId(ctx));
  const selector = `input[type=radio][data-ownedby='${ownerId}']:not([disabled])`;
  return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.queryAll)(getRootEl(ctx), selector);
};
var getRadioEl = (ctx, value) => {
  if (!value) return;
  return ctx.getById(getItemId(ctx, value));
};
var getOffsetRect = (el) => ({
  left: el?.offsetLeft ?? 0,
  top: el?.offsetTop ?? 0,
  width: el?.offsetWidth ?? 0,
  height: el?.offsetHeight ?? 0
});
var resolveRect = (rect) => ({
  width: `${rect.width}px`,
  height: `${rect.height}px`,
  left: `${rect.left}px`,
  top: `${rect.top}px`
});

// src/radio-group.connect.ts
function connect(service, normalize) {
  const { context, send, computed, prop, scope } = service;
  const groupDisabled = computed("isDisabled");
  const readOnly = prop("readOnly");
  function getItemState(props2) {
    const focused = context.get("focusedValue") === props2.value;
    const focusVisible = focused && (0,_zag_js_focus_visible__WEBPACK_IMPORTED_MODULE_2__.isFocusVisible)();
    return {
      value: props2.value,
      invalid: !!props2.invalid,
      disabled: !!props2.disabled || groupDisabled,
      checked: context.get("value") === props2.value,
      focused,
      focusVisible,
      hovered: context.get("hoveredValue") === props2.value,
      active: context.get("activeValue") === props2.value
    };
  }
  function getItemDataAttrs(props2) {
    const itemState = getItemState(props2);
    return {
      "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(itemState.focused),
      "data-focus-visible": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(itemState.focusVisible),
      "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(itemState.disabled),
      "data-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(readOnly),
      "data-state": itemState.checked ? "checked" : "unchecked",
      "data-hover": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(itemState.hovered),
      "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(itemState.invalid),
      "data-orientation": prop("orientation"),
      "data-ssr": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(context.get("ssr"))
    };
  }
  const focus = () => {
    const nodeToFocus = getFirstEnabledAndCheckedInputEl(scope) ?? getFirstEnabledInputEl(scope);
    nodeToFocus?.focus();
  };
  return {
    focus,
    value: context.get("value"),
    setValue(value) {
      send({ type: "SET_VALUE", value, isTrusted: false });
    },
    clearValue() {
      send({ type: "SET_VALUE", value: null, isTrusted: false });
    },
    getRootProps() {
      return normalize.element({
        ...parts.root.attrs,
        role: "radiogroup",
        id: getRootId(scope),
        "aria-labelledby": getLabelId(scope),
        "data-orientation": prop("orientation"),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(groupDisabled),
        "aria-orientation": prop("orientation"),
        dir: prop("dir"),
        style: {
          position: "relative"
        }
      });
    },
    getLabelProps() {
      return normalize.element({
        ...parts.label.attrs,
        dir: prop("dir"),
        "data-orientation": prop("orientation"),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(groupDisabled),
        id: getLabelId(scope),
        onClick: focus
      });
    },
    getItemState,
    getItemProps(props2) {
      const itemState = getItemState(props2);
      return normalize.label({
        ...parts.item.attrs,
        dir: prop("dir"),
        id: getItemId(scope, props2.value),
        htmlFor: getItemHiddenInputId(scope, props2.value),
        ...getItemDataAttrs(props2),
        onPointerMove() {
          if (itemState.disabled) return;
          if (itemState.hovered) return;
          send({ type: "SET_HOVERED", value: props2.value, hovered: true });
        },
        onPointerLeave() {
          if (itemState.disabled) return;
          send({ type: "SET_HOVERED", value: null });
        },
        onPointerDown(event) {
          if (itemState.disabled) return;
          if (itemState.focused && event.pointerType === "mouse") {
            event.preventDefault();
          }
          send({ type: "SET_ACTIVE", value: props2.value, active: true });
        },
        onPointerUp() {
          if (itemState.disabled) return;
          send({ type: "SET_ACTIVE", value: null });
        },
        onClick() {
          if (!itemState.disabled && (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isSafari)()) {
            getItemHiddenInputEl(scope, props2.value)?.focus();
          }
        }
      });
    },
    getItemTextProps(props2) {
      return normalize.element({
        ...parts.itemText.attrs,
        dir: prop("dir"),
        id: getItemLabelId(scope, props2.value),
        ...getItemDataAttrs(props2)
      });
    },
    getItemControlProps(props2) {
      const itemState = getItemState(props2);
      return normalize.element({
        ...parts.itemControl.attrs,
        dir: prop("dir"),
        id: getItemControlId(scope, props2.value),
        "data-active": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(itemState.active),
        "aria-hidden": true,
        ...getItemDataAttrs(props2)
      });
    },
    getItemHiddenInputProps(props2) {
      const itemState = getItemState(props2);
      return normalize.input({
        "data-ownedby": getRootId(scope),
        id: getItemHiddenInputId(scope, props2.value),
        type: "radio",
        name: prop("name") || prop("id"),
        form: prop("form"),
        value: props2.value,
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          if (event.currentTarget.checked) {
            send({ type: "SET_VALUE", value: props2.value, isTrusted: true });
          }
        },
        onBlur() {
          send({ type: "SET_FOCUSED", value: null, focused: false });
        },
        onFocus() {
          send({ type: "SET_FOCUSED", value: props2.value, focused: true });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: props2.value, active: true });
          }
        },
        onKeyUp(event) {
          if (event.defaultPrevented) return;
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: null });
          }
        },
        disabled: itemState.disabled,
        defaultChecked: itemState.checked,
        style: _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.visuallyHiddenStyle
      });
    },
    getIndicatorProps() {
      const rect = context.get("indicatorRect");
      return normalize.element({
        id: getIndicatorId(scope),
        ...parts.indicator.attrs,
        dir: prop("dir"),
        hidden: context.get("value") == null,
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(groupDisabled),
        "data-orientation": prop("orientation"),
        style: {
          "--transition-property": "left, top, width, height",
          "--left": rect?.left,
          "--top": rect?.top,
          "--width": rect?.width,
          "--height": rect?.height,
          position: "absolute",
          willChange: "var(--transition-property)",
          transitionProperty: "var(--transition-property)",
          transitionDuration: context.get("canIndicatorTransition") ? "var(--transition-duration, 150ms)" : "0ms",
          transitionTimingFunction: "var(--transition-timing-function)",
          [prop("orientation") === "horizontal" ? "left" : "top"]: prop("orientation") === "horizontal" ? "var(--left)" : "var(--top)"
        }
      });
    }
  };
}
var { not } = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_3__.createGuards)();
var machine = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_3__.createMachine)({
  props({ props: props2 }) {
    return {
      orientation: "vertical",
      ...props2
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          prop("onValueChange")?.({ value });
        }
      })),
      activeValue: bindable(() => ({
        defaultValue: null
      })),
      focusedValue: bindable(() => ({
        defaultValue: null
      })),
      hoveredValue: bindable(() => ({
        defaultValue: null
      })),
      indicatorRect: bindable(() => ({
        defaultValue: {}
      })),
      canIndicatorTransition: bindable(() => ({
        defaultValue: false
      })),
      fieldsetDisabled: bindable(() => ({
        defaultValue: false
      })),
      ssr: bindable(() => ({
        defaultValue: true
      }))
    };
  },
  refs() {
    return {
      indicatorCleanup: null
    };
  },
  computed: {
    isDisabled: ({ prop, context }) => !!prop("disabled") || context.get("fieldsetDisabled")
  },
  entry: ["syncIndicatorRect", "syncSsr"],
  exit: ["cleanupObserver"],
  effects: ["trackFormControlState", "trackFocusVisible"],
  watch({ track, action, context }) {
    track([() => context.get("value")], () => {
      action(["setIndicatorTransition", "syncIndicatorRect", "syncInputElements"]);
    });
  },
  on: {
    SET_VALUE: [
      {
        guard: not("isTrusted"),
        actions: ["setValue", "dispatchChangeEvent"]
      },
      {
        actions: ["setValue"]
      }
    ],
    SET_HOVERED: {
      actions: ["setHovered"]
    },
    SET_ACTIVE: {
      actions: ["setActive"]
    },
    SET_FOCUSED: {
      actions: ["setFocused"]
    }
  },
  states: {
    idle: {}
  },
  implementations: {
    guards: {
      isTrusted: ({ event }) => !!event.isTrusted
    },
    effects: {
      trackFormControlState({ context, scope }) {
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.trackFormControl)(getRootEl(scope), {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            context.set("value", context.initial("value"));
          }
        });
      },
      trackFocusVisible({ scope }) {
        return (0,_zag_js_focus_visible__WEBPACK_IMPORTED_MODULE_2__.trackFocusVisible)({ root: scope.getRootNode?.() });
      }
    },
    actions: {
      setValue({ context, event }) {
        context.set("value", event.value);
      },
      setHovered({ context, event }) {
        context.set("hoveredValue", event.value);
      },
      setActive({ context, event }) {
        context.set("activeValue", event.value);
      },
      setFocused({ context, event }) {
        context.set("focusedValue", event.value);
      },
      syncInputElements({ context, scope }) {
        const inputs = getInputEls(scope);
        inputs.forEach((input) => {
          input.checked = input.value === context.get("value");
        });
      },
      setIndicatorTransition({ context }) {
        context.set("canIndicatorTransition", (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.isString)(context.get("value")));
      },
      cleanupObserver({ refs }) {
        refs.get("indicatorCleanup")?.();
      },
      syncSsr({ context }) {
        context.set("ssr", false);
      },
      syncIndicatorRect({ context, scope, refs }) {
        refs.get("indicatorCleanup")?.();
        if (!getIndicatorEl(scope)) return;
        const value = context.get("value");
        const radioEl = getRadioEl(scope, value);
        if (value == null || !radioEl) {
          context.set("canIndicatorTransition", false);
          context.set("indicatorRect", {});
          return;
        }
        const indicatorCleanup = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.trackElementRect)([radioEl], {
          measure(el) {
            return getOffsetRect(el);
          },
          onEntry({ rects }) {
            context.set("indicatorRect", resolveRect(rects[0]));
          }
        });
        refs.set("indicatorCleanup", indicatorCleanup);
      },
      dispatchChangeEvent({ context, scope }) {
        const inputEls = getInputEls(scope);
        inputEls.forEach((inputEl) => {
          const checked = inputEl.value === context.get("value");
          if (checked === inputEl.checked) return;
          (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dispatchInputCheckedEvent)(inputEl, { checked });
        });
      }
    }
  }
});
var props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_5__.createProps)()([
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onValueChange",
  "orientation",
  "readOnly",
  "value",
  "defaultValue"
]);
var splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.createSplitProps)(props);
var itemProps = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_5__.createProps)()(["value", "disabled", "invalid"]);
var splitItemProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.createSplitProps)(itemProps);




/***/ }),

/***/ "./node_modules/@zag-js/rating-group/dist/index.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@zag-js/rating-group/dist/index.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anatomy: () => (/* binding */ anatomy),
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   itemProps: () => (/* binding */ itemProps),
/* harmony export */   machine: () => (/* binding */ machine),
/* harmony export */   props: () => (/* binding */ props),
/* harmony export */   splitItemProps: () => (/* binding */ splitItemProps),
/* harmony export */   splitProps: () => (/* binding */ splitProps)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");






// src/rating-group.anatomy.ts
var anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("rating-group").parts("root", "label", "item", "control");
var parts = anatomy.build();
var getRootId = (ctx) => ctx.ids?.root ?? `rating:${ctx.id}`;
var getLabelId = (ctx) => ctx.ids?.label ?? `rating:${ctx.id}:label`;
var getHiddenInputId = (ctx) => ctx.ids?.hiddenInput ?? `rating:${ctx.id}:input`;
var getControlId = (ctx) => ctx.ids?.control ?? `rating:${ctx.id}:control`;
var getItemId = (ctx, id) => ctx.ids?.item?.(id) ?? `rating:${ctx.id}:item:${id}`;
var getControlEl = (ctx) => ctx.getById(getControlId(ctx));
var getRadioEl = (ctx, value) => {
  const selector = `[role=radio][aria-posinset='${Math.ceil(value)}']`;
  return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.query)(getControlEl(ctx), selector);
};
var getHiddenInputEl = (ctx) => ctx.getById(getHiddenInputId(ctx));
var dispatchChangeEvent = (ctx, value) => {
  const inputEl = getHiddenInputEl(ctx);
  if (!inputEl) return;
  (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dispatchInputValueEvent)(inputEl, { value });
};

// src/rating-group.connect.ts
function connect(service, normalize) {
  const { context, send, prop, scope, computed } = service;
  const interactive = computed("isInteractive");
  const disabled = computed("isDisabled");
  const readOnly = prop("readOnly");
  const value = context.get("value");
  const hoveredValue = context.get("hoveredValue");
  const translations = prop("translations");
  function getItemState(props2) {
    const currentValue = computed("isHovering") ? hoveredValue : value;
    const equal = Math.ceil(currentValue) === props2.index;
    const highlighted = props2.index <= currentValue || equal;
    const half = equal && Math.abs(currentValue - props2.index) === 0.5;
    return {
      highlighted,
      half,
      checked: equal || value === -1 && props2.index === 1
    };
  }
  return {
    hovering: computed("isHovering"),
    value,
    hoveredValue,
    count: prop("count"),
    items: Array.from({ length: prop("count") }).map((_, index) => index + 1),
    setValue(value2) {
      send({ type: "SET_VALUE", value: value2 });
    },
    clearValue() {
      send({ type: "CLEAR_VALUE" });
    },
    getRootProps() {
      return normalize.element({
        ...parts.root.attrs,
        dir: prop("dir"),
        id: getRootId(scope)
      });
    },
    getHiddenInputProps() {
      return normalize.input({
        name: prop("name"),
        form: prop("form"),
        type: "text",
        hidden: true,
        disabled,
        readOnly,
        required: prop("required"),
        id: getHiddenInputId(scope),
        defaultValue: value
      });
    },
    getLabelProps() {
      return normalize.label({
        ...parts.label.attrs,
        dir: prop("dir"),
        id: getLabelId(scope),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        htmlFor: getHiddenInputId(scope),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          event.preventDefault();
          const radioEl = getRadioEl(scope, Math.max(1, context.get("value")));
          radioEl?.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize.element({
        id: getControlId(scope),
        ...parts.control.attrs,
        dir: prop("dir"),
        role: "radiogroup",
        "aria-orientation": "horizontal",
        "aria-labelledby": getLabelId(scope),
        "aria-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.ariaAttr)(readOnly),
        "data-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(readOnly),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        onPointerMove(event) {
          if (!interactive) return;
          if (event.pointerType === "touch") return;
          send({ type: "GROUP_POINTER_OVER" });
        },
        onPointerLeave(event) {
          if (!interactive) return;
          if (event.pointerType === "touch") return;
          send({ type: "GROUP_POINTER_LEAVE" });
        }
      });
    },
    getItemState,
    getItemProps(props2) {
      const { index } = props2;
      const itemState = getItemState(props2);
      const valueText = translations.ratingValueText(index);
      return normalize.element({
        ...parts.item.attrs,
        dir: prop("dir"),
        id: getItemId(scope, index.toString()),
        role: "radio",
        tabIndex: (() => {
          if (readOnly) return itemState.checked ? 0 : void 0;
          if (disabled) return void 0;
          return itemState.checked ? 0 : -1;
        })(),
        "aria-roledescription": "rating",
        "aria-label": valueText,
        "aria-disabled": disabled,
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(readOnly),
        "aria-setsize": prop("count"),
        "aria-checked": itemState.checked,
        "data-checked": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(itemState.checked),
        "aria-posinset": index,
        "data-highlighted": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(itemState.highlighted),
        "data-half": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(itemState.half),
        onPointerDown(event) {
          if (!interactive) return;
          if (!(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isLeftClick)(event)) return;
          event.preventDefault();
        },
        onPointerMove(event) {
          if (!interactive) return;
          const point = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventPoint)(event);
          const relativePoint = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getRelativePoint)(point, event.currentTarget);
          const percentX = relativePoint.getPercentValue({
            orientation: "horizontal",
            dir: prop("dir")
          });
          const isMidway = percentX < 0.5;
          send({ type: "POINTER_OVER", index, isMidway });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const keyMap = {
            ArrowLeft() {
              send({ type: "ARROW_LEFT" });
            },
            ArrowRight() {
              send({ type: "ARROW_RIGHT" });
            },
            ArrowUp() {
              send({ type: "ARROW_LEFT" });
            },
            ArrowDown() {
              send({ type: "ARROW_RIGHT" });
            },
            Space() {
              send({ type: "SPACE", value: index });
            },
            Home() {
              send({ type: "HOME" });
            },
            End() {
              send({ type: "END" });
            }
          };
          const key = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventKey)(event, { dir: prop("dir") });
          const exec = keyMap[key];
          if (exec) {
            event.preventDefault();
            exec(event);
          }
        },
        onClick() {
          if (!interactive) return;
          send({ type: "CLICK", value: index });
        },
        onFocus() {
          if (!interactive) return;
          send({ type: "FOCUS" });
        },
        onBlur() {
          if (!interactive) return;
          send({ type: "BLUR" });
        }
      });
    }
  };
}
var machine = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_2__.createMachine)({
  props({ props: props2 }) {
    return {
      name: "rating",
      count: 5,
      dir: "ltr",
      defaultValue: -1,
      ...props2,
      translations: {
        ratingValueText: (index) => `${index} stars`,
        ...props2.translations
      }
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          prop("onValueChange")?.({ value });
        }
      })),
      hoveredValue: bindable(() => ({
        defaultValue: -1,
        onChange(value) {
          prop("onHoverChange")?.({ hoveredValue: value });
        }
      })),
      fieldsetDisabled: bindable(() => ({
        defaultValue: false
      }))
    };
  },
  watch({ track, action, prop, context }) {
    track([() => prop("allowHalf")], () => {
      action(["roundValueIfNeeded"]);
    });
    track([() => context.get("value")], () => {
      action(["dispatchChangeEvent"]);
    });
  },
  computed: {
    isDisabled: ({ context, prop }) => !!prop("disabled") || context.get("fieldsetDisabled"),
    isInteractive: ({ computed, prop }) => !(computed("isDisabled") || prop("readOnly")),
    isHovering: ({ context }) => context.get("hoveredValue") > -1
  },
  effects: ["trackFormControlState"],
  on: {
    SET_VALUE: {
      actions: ["setValue"]
    },
    CLEAR_VALUE: {
      actions: ["clearValue"]
    }
  },
  states: {
    idle: {
      entry: ["clearHoveredValue"],
      on: {
        GROUP_POINTER_OVER: {
          target: "hover"
        },
        FOCUS: {
          target: "focus"
        },
        CLICK: {
          actions: ["setValue", "focusActiveRadio"]
        }
      }
    },
    focus: {
      on: {
        POINTER_OVER: {
          actions: ["setHoveredValue"]
        },
        GROUP_POINTER_LEAVE: {
          actions: ["clearHoveredValue"]
        },
        BLUR: {
          target: "idle"
        },
        SPACE: {
          guard: "isValueEmpty",
          actions: ["setValue"]
        },
        CLICK: {
          actions: ["setValue", "focusActiveRadio"]
        },
        ARROW_LEFT: {
          actions: ["setPrevValue", "focusActiveRadio"]
        },
        ARROW_RIGHT: {
          actions: ["setNextValue", "focusActiveRadio"]
        },
        HOME: {
          actions: ["setValueToMin", "focusActiveRadio"]
        },
        END: {
          actions: ["setValueToMax", "focusActiveRadio"]
        }
      }
    },
    hover: {
      on: {
        POINTER_OVER: {
          actions: ["setHoveredValue"]
        },
        GROUP_POINTER_LEAVE: [
          {
            guard: "isRadioFocused",
            target: "focus",
            actions: ["clearHoveredValue"]
          },
          {
            target: "idle",
            actions: ["clearHoveredValue"]
          }
        ],
        CLICK: {
          actions: ["setValue", "focusActiveRadio"]
        }
      }
    }
  },
  implementations: {
    guards: {
      isInteractive: ({ prop }) => !(prop("disabled") || prop("readOnly")),
      isHoveredValueEmpty: ({ context }) => context.get("hoveredValue") === -1,
      isValueEmpty: ({ context }) => context.get("value") <= 0,
      isRadioFocused: ({ scope }) => !!getControlEl(scope)?.contains(scope.getActiveElement())
    },
    effects: {
      trackFormControlState({ context, scope }) {
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.trackFormControl)(getHiddenInputEl(scope), {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            context.set("value", context.initial("value"));
          }
        });
      }
    },
    actions: {
      clearHoveredValue({ context }) {
        context.set("hoveredValue", -1);
      },
      focusActiveRadio({ scope, context }) {
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => getRadioEl(scope, context.get("value"))?.focus());
      },
      setPrevValue({ context, prop }) {
        const factor = prop("allowHalf") ? 0.5 : 1;
        context.set("value", Math.max(0, context.get("value") - factor));
      },
      setNextValue({ context, prop }) {
        const factor = prop("allowHalf") ? 0.5 : 1;
        const value = context.get("value") === -1 ? 0 : context.get("value");
        context.set("value", Math.min(prop("count"), value + factor));
      },
      setValueToMin({ context }) {
        context.set("value", 1);
      },
      setValueToMax({ context, prop }) {
        context.set("value", prop("count"));
      },
      setValue({ context, event }) {
        const hoveredValue = context.get("hoveredValue");
        const value = hoveredValue === -1 ? event.value : hoveredValue;
        context.set("value", value);
      },
      clearValue({ context }) {
        context.set("value", -1);
      },
      setHoveredValue({ context, prop, event }) {
        const half = prop("allowHalf") && event.isMidway;
        const factor = half ? 0.5 : 0;
        context.set("hoveredValue", event.index - factor);
      },
      roundValueIfNeeded({ context, prop }) {
        if (prop("allowHalf")) return;
        context.set("value", Math.round(context.get("value")));
      },
      dispatchChangeEvent({ context, scope }) {
        dispatchChangeEvent(scope, context.get("value"));
      }
    }
  }
});
var props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_3__.createProps)()([
  "allowHalf",
  "autoFocus",
  "count",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onHoverChange",
  "onValueChange",
  "required",
  "readOnly",
  "translations",
  "value",
  "defaultValue"
]);
var splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.createSplitProps)(props);
var itemProps = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_3__.createProps)()(["index"]);
var splitItemProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.createSplitProps)(itemProps);




/***/ }),

/***/ "./node_modules/@zag-js/react/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@zag-js/react/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Portal: () => (/* binding */ Portal),
/* harmony export */   mergeProps: () => (/* reexport safe */ _zag_js_core__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   normalizeProps: () => (/* binding */ normalizeProps),
/* harmony export */   useMachine: () => (/* binding */ useMachine)
/* harmony export */ });
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
"use client";










// src/index.ts
var useSafeLayoutEffect = typeof globalThis.document !== "undefined" ? react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;

// src/bindable.ts
function useBindable(props) {
  const initial = props().value ?? props().defaultValue;
  const eq = props().isEqual ?? Object.is;
  const [initialValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initial);
  const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialValue);
  const controlled = props().value !== void 0;
  const valueRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(value);
  valueRef.current = controlled ? props().value : value;
  const prevValue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(valueRef.current);
  useSafeLayoutEffect(() => {
    prevValue.current = valueRef.current;
  }, [value, props().value]);
  const setFn = (value2) => {
    const prev = prevValue.current;
    const next = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.isFunction)(value2) ? value2(prev) : value2;
    if (props().debug) {
      console.log(`[bindable > ${props().debug}] setValue`, { next, prev });
    }
    if (!controlled) setValue(next);
    if (!eq(next, prev)) {
      props().onChange?.(next, prev);
    }
  };
  function get() {
    return controlled ? props().value : value;
  }
  return {
    initial: initialValue,
    ref: valueRef,
    get,
    set(value2) {
      const exec = props().sync ? react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync : _zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.identity;
      exec(() => setFn(value2));
    },
    invoke(nextValue, prevValue2) {
      props().onChange?.(nextValue, prevValue2);
    },
    hash(value2) {
      return props().hash?.(value2) ?? String(value2);
    }
  };
}
useBindable.cleanup = (fn) => {
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => fn, []);
};
useBindable.ref = (defaultValue) => {
  const value = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(defaultValue);
  return {
    get: () => value.current,
    set: (next) => {
      value.current = next;
    }
  };
};
function useRefs(refs) {
  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(refs);
  return {
    get(key) {
      return ref.current[key];
    },
    set(key, value) {
      ref.current[key] = value;
    }
  };
}
var useTrack = (deps, effect) => {
  const render = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);
  const called = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    const mounted = render.current;
    const run = mounted && called.current;
    if (run) return effect();
    called.current = true;
  }, [...(deps ?? []).map((d) => typeof d === "function" ? d() : d)]);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    render.current = true;
    return () => {
      render.current = false;
    };
  }, []);
};

// src/machine.ts
function useMachine(machine, userProps = {}) {
  const scope = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
    const { id, ids, getRootNode } = userProps;
    return (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_0__.createScope)({ id, ids, getRootNode });
  }, [userProps]);
  const debug = (...args) => {
    if (machine.debug) console.log(...args);
  };
  const props = machine.props?.({ props: (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.compact)(userProps), scope }) ?? userProps;
  const prop = useProp(props);
  const context = machine.context?.({
    prop,
    bindable: useBindable,
    scope,
    flush,
    getContext() {
      return ctx;
    },
    getComputed() {
      return computed;
    },
    getRefs() {
      return refs;
    }
  });
  const contextRef = useLiveRef(context);
  const ctx = {
    get(key) {
      return contextRef.current?.[key].ref.current;
    },
    set(key, value) {
      contextRef.current?.[key].set(value);
    },
    initial(key) {
      return contextRef.current?.[key].initial;
    },
    hash(key) {
      const current = contextRef.current?.[key].get();
      return contextRef.current?.[key].hash(current);
    }
  };
  const effects = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(/* @__PURE__ */ new Map());
  const transitionRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);
  const previousEventRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);
  const eventRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({ type: "" });
  const getEvent = () => ({
    ...eventRef.current,
    current() {
      return eventRef.current;
    },
    previous() {
      return previousEventRef.current;
    }
  });
  const getState = () => ({
    ...state,
    matches(...values) {
      return values.includes(state.ref.current);
    },
    hasTag(tag) {
      return !!machine.states[state.ref.current]?.tags?.includes(tag);
    }
  });
  const refs = useRefs(machine.refs?.({ prop, context: ctx }) ?? {});
  const getParams = () => ({
    state: getState(),
    context: ctx,
    event: getEvent(),
    prop,
    send,
    action,
    guard,
    track: useTrack,
    refs,
    computed,
    flush,
    scope,
    choose
  });
  const action = (keys) => {
    const strs = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.isFunction)(keys) ? keys(getParams()) : keys;
    if (!strs) return;
    const fns = strs.map((s) => {
      const fn = machine.implementations?.actions?.[s];
      if (!fn) (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.warn)(`[zag-js] No implementation found for action "${JSON.stringify(s)}"`);
      return fn;
    });
    for (const fn of fns) {
      fn?.(getParams());
    }
  };
  const guard = (str) => {
    if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.isFunction)(str)) return str(getParams());
    return machine.implementations?.guards?.[str](getParams());
  };
  const effect = (keys) => {
    const strs = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.isFunction)(keys) ? keys(getParams()) : keys;
    if (!strs) return;
    const fns = strs.map((s) => {
      const fn = machine.implementations?.effects?.[s];
      if (!fn) (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.warn)(`[zag-js] No implementation found for effect "${JSON.stringify(s)}"`);
      return fn;
    });
    const cleanups = [];
    for (const fn of fns) {
      const cleanup = fn?.(getParams());
      if (cleanup) cleanups.push(cleanup);
    }
    return () => cleanups.forEach((fn) => fn?.());
  };
  const choose = (transitions) => {
    return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.toArray)(transitions).find((t) => {
      let result = !t.guard;
      if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.isString)(t.guard)) result = !!guard(t.guard);
      else if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.isFunction)(t.guard)) result = t.guard(getParams());
      return result;
    });
  };
  const computed = (key) => {
    (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_4__.ensure)(machine.computed, () => `[zag-js] No computed object found on machine`);
    const fn = machine.computed[key];
    return fn({
      context: ctx,
      event: getEvent(),
      prop,
      refs,
      scope,
      computed
    });
  };
  const state = useBindable(() => ({
    defaultValue: machine.initialState({ prop }),
    onChange(nextState, prevState) {
      if (prevState) {
        const exitEffects = effects.current.get(prevState);
        exitEffects?.();
        effects.current.delete(prevState);
      }
      if (prevState) {
        action(machine.states[prevState]?.exit);
      }
      action(transitionRef.current?.actions);
      const cleanup = effect(machine.states[nextState]?.effects);
      if (cleanup) effects.current.set(nextState, cleanup);
      if (prevState === _zag_js_core__WEBPACK_IMPORTED_MODULE_0__.INIT_STATE) {
        action(machine.entry);
        const cleanup2 = effect(machine.effects);
        if (cleanup2) effects.current.set(_zag_js_core__WEBPACK_IMPORTED_MODULE_0__.INIT_STATE, cleanup2);
      }
      action(machine.states[nextState]?.entry);
    }
  }));
  const hydratedStateRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(void 0);
  const statusRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(_zag_js_core__WEBPACK_IMPORTED_MODULE_0__.MachineStatus.NotStarted);
  useSafeLayoutEffect(() => {
    queueMicrotask(() => {
      const started = statusRef.current === _zag_js_core__WEBPACK_IMPORTED_MODULE_0__.MachineStatus.Started;
      statusRef.current = _zag_js_core__WEBPACK_IMPORTED_MODULE_0__.MachineStatus.Started;
      debug(started ? "rehydrating..." : "initializing...");
      const initialState = hydratedStateRef.current ?? state.initial;
      state.invoke(initialState, started ? state.get() : _zag_js_core__WEBPACK_IMPORTED_MODULE_0__.INIT_STATE);
    });
    const fns = effects.current;
    const currentState = state.ref.current;
    return () => {
      debug("unmounting...");
      hydratedStateRef.current = currentState;
      statusRef.current = _zag_js_core__WEBPACK_IMPORTED_MODULE_0__.MachineStatus.Stopped;
      fns.forEach((fn) => fn?.());
      effects.current = /* @__PURE__ */ new Map();
      transitionRef.current = null;
      queueMicrotask(() => {
        action(machine.exit);
      });
    };
  }, []);
  const getCurrentState = () => {
    if ("ref" in state) return state.ref.current;
    return state.get();
  };
  const send = (event) => {
    queueMicrotask(() => {
      if (statusRef.current !== _zag_js_core__WEBPACK_IMPORTED_MODULE_0__.MachineStatus.Started) return;
      previousEventRef.current = eventRef.current;
      eventRef.current = event;
      debug("send", event);
      let currentState = getCurrentState();
      const transitions = (
        // @ts-ignore
        machine.states[currentState].on?.[event.type] ?? // @ts-ignore
        machine.on?.[event.type]
      );
      const transition = choose(transitions);
      if (!transition) return;
      transitionRef.current = transition;
      const target = transition.target ?? currentState;
      debug("transition", transition);
      const changed = target !== currentState;
      if (changed) {
        (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync)(() => state.set(target));
      } else if (transition.reenter && !changed) {
        state.invoke(currentState, currentState);
      } else {
        action(transition.actions ?? []);
      }
    });
  };
  machine.watch?.(getParams());
  return {
    state: getState(),
    send,
    context: ctx,
    prop,
    scope,
    refs,
    computed,
    event: getEvent(),
    getStatus: () => statusRef.current
  };
}
function useLiveRef(value) {
  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(value);
  ref.current = value;
  return ref;
}
function useProp(value) {
  const ref = useLiveRef(value);
  return function get(key) {
    return ref.current[key];
  };
}
function flush(fn) {
  queueMicrotask(() => {
    (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync)(() => fn());
  });
}
var normalizeProps = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_5__.createNormalizer)((v) => v);
var Portal = (props) => {
  const { children, container, disabled, getRootNode } = props;
  const isServer = typeof window === "undefined";
  if (isServer || disabled) return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children });
  const doc = getRootNode?.().ownerDocument ?? document;
  const mountNode = container?.current ?? doc.body;
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: react__WEBPACK_IMPORTED_MODULE_1__.Children.map(children, (child) => (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(child, mountNode)) });
};




/***/ }),

/***/ "./node_modules/@zag-js/rect-utils/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@zag-js/rect-utils/dist/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AffineTransform: () => (/* binding */ AffineTransform),
/* harmony export */   addPoints: () => (/* binding */ addPoints),
/* harmony export */   alignRect: () => (/* binding */ alignRect),
/* harmony export */   clampPoint: () => (/* binding */ clampPoint),
/* harmony export */   clampSize: () => (/* binding */ clampSize),
/* harmony export */   closest: () => (/* binding */ closest),
/* harmony export */   closestSideToPoint: () => (/* binding */ closestSideToPoint),
/* harmony export */   closestSideToRect: () => (/* binding */ closestSideToRect),
/* harmony export */   collisions: () => (/* binding */ collisions),
/* harmony export */   constrainRect: () => (/* binding */ constrainRect),
/* harmony export */   contains: () => (/* binding */ contains),
/* harmony export */   containsPoint: () => (/* binding */ containsPoint),
/* harmony export */   containsRect: () => (/* binding */ containsRect),
/* harmony export */   createPoint: () => (/* binding */ createPoint),
/* harmony export */   createRect: () => (/* binding */ createRect),
/* harmony export */   debugPolygon: () => (/* binding */ debugPolygon),
/* harmony export */   distance: () => (/* binding */ distance),
/* harmony export */   distanceBtwEdges: () => (/* binding */ distanceBtwEdges),
/* harmony export */   distanceFromPoint: () => (/* binding */ distanceFromPoint),
/* harmony export */   distanceFromRect: () => (/* binding */ distanceFromRect),
/* harmony export */   expand: () => (/* binding */ expand),
/* harmony export */   fromRange: () => (/* binding */ fromRange),
/* harmony export */   getElementPolygon: () => (/* binding */ getElementPolygon),
/* harmony export */   getElementRect: () => (/* binding */ getElementRect),
/* harmony export */   getPointAngle: () => (/* binding */ getPointAngle),
/* harmony export */   getRectCenters: () => (/* binding */ getRectCenters),
/* harmony export */   getRectCorners: () => (/* binding */ getRectCorners),
/* harmony export */   getRectEdges: () => (/* binding */ getRectEdges),
/* harmony export */   getRectFromPoints: () => (/* binding */ getRectFromPoints),
/* harmony export */   getRotationRect: () => (/* binding */ getRotationRect),
/* harmony export */   getViewportRect: () => (/* binding */ getViewportRect),
/* harmony export */   getWindowRect: () => (/* binding */ getWindowRect),
/* harmony export */   inset: () => (/* binding */ inset),
/* harmony export */   intersection: () => (/* binding */ intersection),
/* harmony export */   intersects: () => (/* binding */ intersects),
/* harmony export */   isPoint: () => (/* binding */ isPoint),
/* harmony export */   isPointEqual: () => (/* binding */ isPointEqual),
/* harmony export */   isPointInPolygon: () => (/* binding */ isPointInPolygon),
/* harmony export */   isRect: () => (/* binding */ isRect),
/* harmony export */   isRectEqual: () => (/* binding */ isRectEqual),
/* harmony export */   isSizeEqual: () => (/* binding */ isSizeEqual),
/* harmony export */   isSymmetric: () => (/* binding */ isSymmetric),
/* harmony export */   resizeRect: () => (/* binding */ resizeRect),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   shift: () => (/* binding */ shift),
/* harmony export */   shrink: () => (/* binding */ shrink),
/* harmony export */   subtractPoints: () => (/* binding */ subtractPoints),
/* harmony export */   toRad: () => (/* binding */ toRad),
/* harmony export */   union: () => (/* binding */ union)
/* harmony export */ });
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/affine-transform.ts
var AffineTransform = class _AffineTransform {
  constructor([m00, m01, m02, m10, m11, m12] = [0, 0, 0, 0, 0, 0]) {
    __publicField(this, "m00");
    __publicField(this, "m01");
    __publicField(this, "m02");
    __publicField(this, "m10");
    __publicField(this, "m11");
    __publicField(this, "m12");
    __publicField(this, "rotate", (...args) => {
      return this.prepend(_AffineTransform.rotate(...args));
    });
    __publicField(this, "scale", (...args) => {
      return this.prepend(_AffineTransform.scale(...args));
    });
    __publicField(this, "translate", (...args) => {
      return this.prepend(_AffineTransform.translate(...args));
    });
    this.m00 = m00;
    this.m01 = m01;
    this.m02 = m02;
    this.m10 = m10;
    this.m11 = m11;
    this.m12 = m12;
  }
  applyTo(point) {
    const { x, y } = point;
    const { m00, m01, m02, m10, m11, m12 } = this;
    return {
      x: m00 * x + m01 * y + m02,
      y: m10 * x + m11 * y + m12
    };
  }
  prepend(other) {
    return new _AffineTransform([
      this.m00 * other.m00 + this.m01 * other.m10,
      // m00
      this.m00 * other.m01 + this.m01 * other.m11,
      // m01
      this.m00 * other.m02 + this.m01 * other.m12 + this.m02,
      // m02
      this.m10 * other.m00 + this.m11 * other.m10,
      // m10
      this.m10 * other.m01 + this.m11 * other.m11,
      // m11
      this.m10 * other.m02 + this.m11 * other.m12 + this.m12
      // m12
    ]);
  }
  append(other) {
    return new _AffineTransform([
      other.m00 * this.m00 + other.m01 * this.m10,
      // m00
      other.m00 * this.m01 + other.m01 * this.m11,
      // m01
      other.m00 * this.m02 + other.m01 * this.m12 + other.m02,
      // m02
      other.m10 * this.m00 + other.m11 * this.m10,
      // m10
      other.m10 * this.m01 + other.m11 * this.m11,
      // m11
      other.m10 * this.m02 + other.m11 * this.m12 + other.m12
      // m12
    ]);
  }
  get determinant() {
    return this.m00 * this.m11 - this.m01 * this.m10;
  }
  get isInvertible() {
    const det = this.determinant;
    return isFinite(det) && isFinite(this.m02) && isFinite(this.m12) && det !== 0;
  }
  invert() {
    const det = this.determinant;
    return new _AffineTransform([
      this.m11 / det,
      // m00
      -this.m01 / det,
      // m01
      (this.m01 * this.m12 - this.m11 * this.m02) / det,
      // m02
      -this.m10 / det,
      // m10
      this.m00 / det,
      // m11
      (this.m10 * this.m02 - this.m00 * this.m12) / det
      // m12
    ]);
  }
  get array() {
    return [this.m00, this.m01, this.m02, this.m10, this.m11, this.m12, 0, 0, 1];
  }
  get float32Array() {
    return new Float32Array(this.array);
  }
  // Static
  static get identity() {
    return new _AffineTransform([1, 0, 0, 0, 1, 0]);
  }
  static rotate(theta, origin) {
    const rotation = new _AffineTransform([Math.cos(theta), -Math.sin(theta), 0, Math.sin(theta), Math.cos(theta), 0]);
    if (origin && (origin.x !== 0 || origin.y !== 0)) {
      return _AffineTransform.multiply(
        _AffineTransform.translate(origin.x, origin.y),
        rotation,
        _AffineTransform.translate(-origin.x, -origin.y)
      );
    }
    return rotation;
  }
  static scale(sx, sy = sx, origin = { x: 0, y: 0 }) {
    const scale = new _AffineTransform([sx, 0, 0, 0, sy, 0]);
    if (origin.x !== 0 || origin.y !== 0) {
      return _AffineTransform.multiply(
        _AffineTransform.translate(origin.x, origin.y),
        scale,
        _AffineTransform.translate(-origin.x, -origin.y)
      );
    }
    return scale;
  }
  static translate(tx, ty) {
    return new _AffineTransform([1, 0, tx, 0, 1, ty]);
  }
  static multiply(...[first, ...rest]) {
    if (!first) return _AffineTransform.identity;
    return rest.reduce((result, item) => result.prepend(item), first);
  }
  get a() {
    return this.m00;
  }
  get b() {
    return this.m10;
  }
  get c() {
    return this.m01;
  }
  get d() {
    return this.m11;
  }
  get tx() {
    return this.m02;
  }
  get ty() {
    return this.m12;
  }
  get scaleComponents() {
    return { x: this.a, y: this.d };
  }
  get translationComponents() {
    return { x: this.tx, y: this.ty };
  }
  get skewComponents() {
    return { x: this.c, y: this.b };
  }
  toString() {
    return `matrix(${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.tx}, ${this.ty})`;
  }
};

// src/align.ts
function hAlign(a, ref, h) {
  let x = ref.minX;
  if (h === "left-inside") x = ref.minX;
  if (h === "left-outside") x = ref.minX - ref.width;
  if (h === "right-inside") x = ref.maxX - ref.width;
  if (h === "right-outside") x = ref.maxX;
  if (h === "center") x = ref.midX - ref.width / 2;
  return { ...a, x };
}
function vAlign(a, ref, v) {
  let y = ref.minY;
  if (v === "top-inside") y = ref.minY;
  if (v === "top-outside") y = ref.minY - a.height;
  if (v === "bottom-inside") y = ref.maxY - a.height;
  if (v === "bottom-outside") y = ref.maxY;
  if (v === "center") y = ref.midY - a.height / 2;
  return { ...a, y };
}
function alignRect(a, ref, options) {
  const { h, v } = options;
  return vAlign(hAlign(a, ref, h), ref, v);
}

// src/angle.ts
function getPointAngle(rect, point, reference = rect.center) {
  const x = point.x - reference.x;
  const y = point.y - reference.y;
  const deg = Math.atan2(x, y) * (180 / Math.PI) + 180;
  return 360 - deg;
}

// src/clamp.ts
var clamp = (value, min3, max2) => Math.min(Math.max(value, min3), max2);
var clampPoint = (position, size, boundaryRect) => {
  const x = clamp(position.x, boundaryRect.x, boundaryRect.x + boundaryRect.width - size.width);
  const y = clamp(position.y, boundaryRect.y, boundaryRect.y + boundaryRect.height - size.height);
  return { x, y };
};
var defaultMinSize = {
  width: 0,
  height: 0
};
var defaultMaxSize = {
  width: Infinity,
  height: Infinity
};
var clampSize = (size, minSize = defaultMinSize, maxSize = defaultMaxSize) => {
  return {
    width: Math.min(Math.max(size.width, minSize.width), maxSize.width),
    height: Math.min(Math.max(size.height, minSize.height), maxSize.height)
  };
};

// src/rect.ts
var createPoint = (x, y) => ({ x, y });
var subtractPoints = (a, b) => {
  if (!b) return a;
  return createPoint(a.x - b.x, a.y - b.y);
};
var addPoints = (a, b) => createPoint(a.x + b.x, a.y + b.y);
function isPoint(v) {
  return Reflect.has(v, "x") && Reflect.has(v, "y");
}
function createRect(r) {
  const { x, y, width, height } = r;
  const midX = x + width / 2;
  const midY = y + height / 2;
  return {
    x,
    y,
    width,
    height,
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height,
    midX,
    midY,
    center: createPoint(midX, midY)
  };
}
function isRect(v) {
  return Reflect.has(v, "x") && Reflect.has(v, "y") && Reflect.has(v, "width") && Reflect.has(v, "height");
}
function getRectCenters(v) {
  const top = createPoint(v.midX, v.minY);
  const right = createPoint(v.maxX, v.midY);
  const bottom = createPoint(v.midX, v.maxY);
  const left = createPoint(v.minX, v.midY);
  return { top, right, bottom, left };
}
function getRectCorners(v) {
  const top = createPoint(v.minX, v.minY);
  const right = createPoint(v.maxX, v.minY);
  const bottom = createPoint(v.maxX, v.maxY);
  const left = createPoint(v.minX, v.maxY);
  return { top, right, bottom, left };
}
function getRectEdges(v) {
  const c = getRectCorners(v);
  const top = [c.top, c.right];
  const right = [c.right, c.bottom];
  const bottom = [c.left, c.bottom];
  const left = [c.top, c.left];
  return { top, right, bottom, left };
}

// src/intersection.ts
function intersects(a, b) {
  return a.x < b.maxX && a.y < b.maxY && a.maxX > b.x && a.maxY > b.y;
}
function intersection(a, b) {
  const x = Math.max(a.x, b.x);
  const y = Math.max(a.y, b.y);
  const x2 = Math.min(a.x + a.width, b.x + b.width);
  const y2 = Math.min(a.y + a.height, b.y + b.height);
  return createRect({ x, y, width: x2 - x, height: y2 - y });
}
function collisions(a, b) {
  return {
    top: a.minY <= b.minY,
    right: a.maxX >= b.maxX,
    bottom: a.maxY >= b.maxY,
    left: a.minX <= b.minX
  };
}

// src/distance.ts
function distance(a, b = { x: 0, y: 0 }) {
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
}
function distanceFromPoint(r, p) {
  let x = 0;
  let y = 0;
  if (p.x < r.x) x = r.x - p.x;
  else if (p.x > r.maxX) x = p.x - r.maxX;
  if (p.y < r.y) y = r.y - p.y;
  else if (p.y > r.maxY) y = p.y - r.maxY;
  return { x, y, value: distance({ x, y }) };
}
function distanceFromRect(a, b) {
  if (intersects(a, b)) return { x: 0, y: 0, value: 0 };
  const left = a.x < b.x ? a : b;
  const right = b.x < a.x ? a : b;
  const upper = a.y < b.y ? a : b;
  const lower = b.y < a.y ? a : b;
  let x = left.x === right.x ? 0 : right.x - left.maxX;
  x = Math.max(0, x);
  let y = upper.y === lower.y ? 0 : lower.y - upper.maxY;
  y = Math.max(0, y);
  return { x, y, value: distance({ x, y }) };
}
function distanceBtwEdges(a, b) {
  return {
    left: b.x - a.x,
    top: b.y - a.y,
    right: a.maxX - b.maxX,
    bottom: a.maxY - b.maxY
  };
}

// src/closest.ts
function closest(...pts) {
  return (a) => {
    const ds = pts.map((b) => distance(b, a));
    const c = Math.min.apply(Math, ds);
    return pts[ds.indexOf(c)];
  };
}
function closestSideToRect(ref, r) {
  if (r.maxX <= ref.minX) return "left";
  if (r.minX >= ref.maxX) return "right";
  if (r.maxY <= ref.minY) return "top";
  if (r.minY >= ref.maxY) return "bottom";
  return "left";
}
function closestSideToPoint(ref, p) {
  const { x, y } = p;
  const dl = x - ref.minX;
  const dr = ref.maxX - x;
  const dt = y - ref.minY;
  const db = ref.maxY - y;
  let closest2 = dl;
  let side = "left";
  if (dr < closest2) {
    closest2 = dr;
    side = "right";
  }
  if (dt < closest2) {
    closest2 = dt;
    side = "top";
  }
  if (db < closest2) {
    side = "bottom";
  }
  return side;
}

// src/constrain.ts
var constrainRect = (rect, boundary) => {
  const left = Math.max(boundary.x, Math.min(rect.x, boundary.x + boundary.width - rect.width));
  const top = Math.max(boundary.y, Math.min(rect.y, boundary.y + boundary.height - rect.height));
  return {
    x: left,
    y: top,
    width: Math.min(rect.width, boundary.width),
    height: Math.min(rect.height, boundary.height)
  };
};

// src/contains.ts
function containsPoint(r, p) {
  return r.minX <= p.x && p.x <= r.maxX && r.minY <= p.y && p.y <= r.maxY;
}
function containsRect(a, b) {
  return Object.values(getRectCorners(b)).every((c) => containsPoint(a, c));
}
function contains(r, v) {
  return isRect(v) ? containsRect(r, v) : containsPoint(r, v);
}

// src/equality.ts
var isSizeEqual = (a, b) => {
  return a.width === b?.width && a.height === b?.height;
};
var isPointEqual = (a, b) => {
  return a.x === b?.x && a.y === b?.y;
};
var isRectEqual = (a, b) => {
  return isPointEqual(a, b) && isSizeEqual(a, b);
};

// src/from-element.ts
var styleCache = /* @__PURE__ */ new WeakMap();
function getCacheComputedStyle(el) {
  if (!styleCache.has(el)) {
    const win = el.ownerDocument.defaultView || window;
    styleCache.set(el, win.getComputedStyle(el));
  }
  return styleCache.get(el);
}
function getElementRect(el, opts = {}) {
  return createRect(getClientRect(el, opts));
}
function getClientRect(el, opts = {}) {
  const { excludeScrollbar = false, excludeBorders = false } = opts;
  const { x, y, width, height } = el.getBoundingClientRect();
  const r = { x, y, width, height };
  const style = getCacheComputedStyle(el);
  const { borderLeftWidth, borderTopWidth, borderRightWidth, borderBottomWidth } = style;
  const borderXWidth = sum(borderLeftWidth, borderRightWidth);
  const borderYWidth = sum(borderTopWidth, borderBottomWidth);
  if (excludeBorders) {
    r.width -= borderXWidth;
    r.height -= borderYWidth;
    r.x += px(borderLeftWidth);
    r.y += px(borderTopWidth);
  }
  if (excludeScrollbar) {
    const scrollbarWidth = el.offsetWidth - el.clientWidth - borderXWidth;
    const scrollbarHeight = el.offsetHeight - el.clientHeight - borderYWidth;
    r.width -= scrollbarWidth;
    r.height -= scrollbarHeight;
  }
  return r;
}
var px = (v) => parseFloat(v.replace("px", ""));
var sum = (...vals) => vals.reduce((sum2, v) => sum2 + (v ? px(v) : 0), 0);

// src/from-points.ts
function getRectFromPoints(...pts) {
  const xs = pts.map((p) => p.x);
  const ys = pts.map((p) => p.y);
  const x = Math.min(...xs);
  const y = Math.min(...ys);
  const width = Math.max(...xs) - x;
  const height = Math.max(...ys) - y;
  return createRect({ x, y, width, height });
}

// src/union.ts
var { min, max } = Math;
function union(...rs) {
  const pMin = {
    x: min(...rs.map((r) => r.minX)),
    y: min(...rs.map((r) => r.minY))
  };
  const pMax = {
    x: max(...rs.map((r) => r.maxX)),
    y: max(...rs.map((r) => r.maxY))
  };
  return getRectFromPoints(pMin, pMax);
}

// src/from-range.ts
function fromRange(range) {
  let rs = [];
  const rects = Array.from(range.getClientRects());
  if (rects.length) {
    rs = rs.concat(rects.map(createRect));
    return union.apply(void 0, rs);
  }
  let start = range.startContainer;
  if (start.nodeType === Node.TEXT_NODE) {
    start = start.parentNode;
  }
  if (start instanceof HTMLElement) {
    const r = getElementRect(start);
    rs.push({ ...r, x: r.maxX, width: 0 });
  }
  return union.apply(void 0, rs);
}

// src/from-rotation.ts
function toRad(d) {
  return d % 360 * Math.PI / 180;
}
function rotate(a, d, c) {
  const r = toRad(d);
  const sin = Math.sin(r);
  const cos = Math.cos(r);
  const x = a.x - c.x;
  const y = a.y - c.y;
  return {
    x: c.x + x * cos - y * sin,
    y: c.y + x * sin + y * cos
  };
}
function getRotationRect(r, deg) {
  const rr = Object.values(getRectCorners(r)).map((p) => rotate(p, deg, r.center));
  const xs = rr.map((p) => p.x);
  const ys = rr.map((p) => p.y);
  const minX = Math.min(...xs);
  const minY = Math.min(...ys);
  const maxX = Math.max(...xs);
  const maxY = Math.max(...ys);
  return createRect({
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  });
}

// src/from-window.ts
function getWindowRect(win, opts = {}) {
  return createRect(getViewportRect(win, opts));
}
function getViewportRect(win, opts) {
  const { excludeScrollbar = false } = opts;
  const { innerWidth, innerHeight, document: doc, visualViewport } = win;
  const width = visualViewport?.width || innerWidth;
  const height = visualViewport?.height || innerHeight;
  const rect = { x: 0, y: 0, width, height };
  if (excludeScrollbar) {
    const scrollbarWidth = innerWidth - doc.documentElement.clientWidth;
    const scrollbarHeight = innerHeight - doc.documentElement.clientHeight;
    rect.width -= scrollbarWidth;
    rect.height -= scrollbarHeight;
  }
  return rect;
}

// src/operations.ts
var isSymmetric = (v) => "dx" in v || "dy" in v;
function inset(r, i) {
  const v = isSymmetric(i) ? { left: i.dx, right: i.dx, top: i.dy, bottom: i.dy } : i;
  const { top = 0, right = 0, bottom = 0, left = 0 } = v;
  return createRect({
    x: r.x + left,
    y: r.y + top,
    width: r.width - left - right,
    height: r.height - top - bottom
  });
}
function expand(r, v) {
  const value = typeof v === "number" ? { dx: -v, dy: -v } : v;
  return inset(r, value);
}
function shrink(r, v) {
  const value = typeof v === "number" ? { dx: -v, dy: -v } : v;
  return inset(r, value);
}
function shift(r, o) {
  const { x = 0, y = 0 } = o;
  return createRect({
    x: r.x + x,
    y: r.y + y,
    width: r.width,
    height: r.height
  });
}

// src/polygon.ts
function getElementPolygon(rectValue, placement) {
  const rect = createRect(rectValue);
  const { top, right, left, bottom } = getRectCorners(rect);
  const [base] = placement.split("-");
  return {
    top: [left, top, right, bottom],
    right: [top, right, bottom, left],
    bottom: [top, left, bottom, right],
    left: [right, top, left, bottom]
  }[base];
}
function isPointInPolygon(polygon, point) {
  const { x, y } = point;
  let c = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {
      c = !c;
    }
  }
  return c;
}
function createPolygonElement() {
  const id = "debug-polygon";
  const existingPolygon = document.getElementById(id);
  if (existingPolygon) {
    return existingPolygon;
  }
  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  Object.assign(svg.style, {
    top: "0",
    left: "0",
    width: "100%",
    height: "100%",
    opacity: "0.15",
    position: "fixed",
    pointerEvents: "none",
    fill: "red"
  });
  const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
  polygon.setAttribute("id", id);
  polygon.setAttribute("points", "0,0 0,0");
  svg.appendChild(polygon);
  document.body.appendChild(svg);
  return polygon;
}
function debugPolygon(polygon) {
  const el = createPolygonElement();
  const points = polygon.map((point) => `${point.x},${point.y}`).join(" ");
  el.setAttribute("points", points);
  return () => {
    el.remove();
  };
}

// src/compass.ts
var compassDirectionMap = {
  n: { x: 0.5, y: 0 },
  ne: { x: 1, y: 0 },
  e: { x: 1, y: 0.5 },
  se: { x: 1, y: 1 },
  s: { x: 0.5, y: 1 },
  sw: { x: 0, y: 1 },
  w: { x: 0, y: 0.5 },
  nw: { x: 0, y: 0 }
};
var oppositeDirectionMap = {
  n: "s",
  ne: "sw",
  e: "w",
  se: "nw",
  s: "n",
  sw: "ne",
  w: "e",
  nw: "se"
};

// src/resize.ts
var { sign, abs, min: min2 } = Math;
function getRectExtentPoint(rect, direction) {
  const { minX, minY, maxX, maxY, midX, midY } = rect;
  const x = direction.includes("w") ? minX : direction.includes("e") ? maxX : midX;
  const y = direction.includes("n") ? minY : direction.includes("s") ? maxY : midY;
  return { x, y };
}
function getOppositeDirection(direction) {
  return oppositeDirectionMap[direction];
}
function resizeRect(rect, offset, direction, opts) {
  const { scalingOriginMode, lockAspectRatio } = opts;
  const extent = getRectExtentPoint(rect, direction);
  const oppositeDirection = getOppositeDirection(direction);
  const oppositeExtent = getRectExtentPoint(rect, oppositeDirection);
  if (scalingOriginMode === "center") {
    offset = { x: offset.x * 2, y: offset.y * 2 };
  }
  const newExtent = {
    x: extent.x + offset.x,
    y: extent.y + offset.y
  };
  const multiplier = {
    x: compassDirectionMap[direction].x * 2 - 1,
    y: compassDirectionMap[direction].y * 2 - 1
  };
  const newSize = {
    width: newExtent.x - oppositeExtent.x,
    height: newExtent.y - oppositeExtent.y
  };
  const scaleX = multiplier.x * newSize.width / rect.width;
  const scaleY = multiplier.y * newSize.height / rect.height;
  const largestMagnitude = abs(scaleX) > abs(scaleY) ? scaleX : scaleY;
  const scale = lockAspectRatio ? { x: largestMagnitude, y: largestMagnitude } : {
    x: extent.x === oppositeExtent.x ? 1 : scaleX,
    y: extent.y === oppositeExtent.y ? 1 : scaleY
  };
  if (extent.y === oppositeExtent.y) {
    scale.y = abs(scale.y);
  } else if (sign(scale.y) !== sign(scaleY)) {
    scale.y *= -1;
  }
  if (extent.x === oppositeExtent.x) {
    scale.x = abs(scale.x);
  } else if (sign(scale.x) !== sign(scaleX)) {
    scale.x *= -1;
  }
  switch (scalingOriginMode) {
    case "extent":
      return transformRect(rect, AffineTransform.scale(scale.x, scale.y, oppositeExtent), false);
    case "center":
      return transformRect(
        rect,
        AffineTransform.scale(scale.x, scale.y, {
          x: rect.midX,
          y: rect.midY
        }),
        false
      );
  }
}
function createRectFromPoints(initialPoint, finalPoint, normalized = true) {
  if (normalized) {
    return {
      x: min2(finalPoint.x, initialPoint.x),
      y: min2(finalPoint.y, initialPoint.y),
      width: abs(finalPoint.x - initialPoint.x),
      height: abs(finalPoint.y - initialPoint.y)
    };
  }
  return {
    x: initialPoint.x,
    y: initialPoint.y,
    width: finalPoint.x - initialPoint.x,
    height: finalPoint.y - initialPoint.y
  };
}
function transformRect(rect, transform, normalized = true) {
  const p1 = transform.applyTo({ x: rect.minX, y: rect.minY });
  const p2 = transform.applyTo({ x: rect.maxX, y: rect.maxY });
  return createRectFromPoints(p1, p2, normalized);
}




/***/ }),

/***/ "./node_modules/@zag-js/remove-scroll/dist/index.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@zag-js/remove-scroll/dist/index.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   preventBodyScroll: () => (/* binding */ preventBodyScroll)
/* harmony export */ });
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");


// src/index.ts
var LOCK_CLASSNAME = "data-scroll-lock";
function getPaddingProperty(documentElement) {
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
function preventBodyScroll(_document) {
  const doc = _document ?? document;
  const win = doc.defaultView ?? window;
  const { documentElement, body } = doc;
  const locked = body.hasAttribute(LOCK_CLASSNAME);
  if (locked) return;
  body.setAttribute(LOCK_CLASSNAME, "");
  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
  const setScrollbarWidthProperty = () => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.setStyleProperty)(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
  const paddingProperty = getPaddingProperty(documentElement);
  const setBodyStyle = () => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.setStyle)(body, {
    overflow: "hidden",
    [paddingProperty]: `${scrollbarWidth}px`
  });
  const setBodyStyleIOS = () => {
    const { scrollX, scrollY, visualViewport } = win;
    const offsetLeft = visualViewport?.offsetLeft ?? 0;
    const offsetTop = visualViewport?.offsetTop ?? 0;
    const restoreStyle = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.setStyle)(body, {
      position: "fixed",
      overflow: "hidden",
      top: `${-(scrollY - Math.floor(offsetTop))}px`,
      left: `${-(scrollX - Math.floor(offsetLeft))}px`,
      right: "0",
      [paddingProperty]: `${scrollbarWidth}px`
    });
    return () => {
      restoreStyle?.();
      win.scrollTo({ left: scrollX, top: scrollY, behavior: "instant" });
    };
  };
  const cleanups = [setScrollbarWidthProperty(), (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isIos)() ? setBodyStyleIOS() : setBodyStyle()];
  return () => {
    cleanups.forEach((fn) => fn?.());
    body.removeAttribute(LOCK_CLASSNAME);
  };
}




/***/ }),

/***/ "./node_modules/@zag-js/select/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@zag-js/select/dist/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anatomy: () => (/* binding */ anatomy),
/* harmony export */   collection: () => (/* binding */ collection),
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   itemGroupLabelProps: () => (/* binding */ itemGroupLabelProps),
/* harmony export */   itemGroupProps: () => (/* binding */ itemGroupProps),
/* harmony export */   itemProps: () => (/* binding */ itemProps),
/* harmony export */   machine: () => (/* binding */ machine),
/* harmony export */   props: () => (/* binding */ props),
/* harmony export */   splitItemGroupLabelProps: () => (/* binding */ splitItemGroupLabelProps),
/* harmony export */   splitItemGroupProps: () => (/* binding */ splitItemGroupProps),
/* harmony export */   splitItemProps: () => (/* binding */ splitItemProps),
/* harmony export */   splitProps: () => (/* binding */ splitProps)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
/* harmony import */ var _zag_js_collection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/collection */ "./node_modules/@zag-js/collection/dist/index.mjs");
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_popper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/popper */ "./node_modules/@zag-js/popper/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _zag_js_dismissable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @zag-js/dismissable */ "./node_modules/@zag-js/dismissable/dist/index.mjs");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");









// src/select.anatomy.ts
var anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("select").parts(
  "label",
  "positioner",
  "trigger",
  "indicator",
  "clearTrigger",
  "item",
  "itemText",
  "itemIndicator",
  "itemGroup",
  "itemGroupLabel",
  "list",
  "content",
  "root",
  "control",
  "valueText"
);
var parts = anatomy.build();
var collection = (options) => {
  return new _zag_js_collection__WEBPACK_IMPORTED_MODULE_1__.ListCollection(options);
};
collection.empty = () => {
  return new _zag_js_collection__WEBPACK_IMPORTED_MODULE_1__.ListCollection({ items: [] });
};

// src/select.dom.ts
var getRootId = (ctx) => ctx.ids?.root ?? `select:${ctx.id}`;
var getContentId = (ctx) => ctx.ids?.content ?? `select:${ctx.id}:content`;
var getTriggerId = (ctx) => ctx.ids?.trigger ?? `select:${ctx.id}:trigger`;
var getClearTriggerId = (ctx) => ctx.ids?.clearTrigger ?? `select:${ctx.id}:clear-trigger`;
var getLabelId = (ctx) => ctx.ids?.label ?? `select:${ctx.id}:label`;
var getControlId = (ctx) => ctx.ids?.control ?? `select:${ctx.id}:control`;
var getItemId = (ctx, id) => ctx.ids?.item?.(id) ?? `select:${ctx.id}:option:${id}`;
var getHiddenSelectId = (ctx) => ctx.ids?.hiddenSelect ?? `select:${ctx.id}:select`;
var getPositionerId = (ctx) => ctx.ids?.positioner ?? `select:${ctx.id}:positioner`;
var getItemGroupId = (ctx, id) => ctx.ids?.itemGroup?.(id) ?? `select:${ctx.id}:optgroup:${id}`;
var getItemGroupLabelId = (ctx, id) => ctx.ids?.itemGroupLabel?.(id) ?? `select:${ctx.id}:optgroup-label:${id}`;
var getHiddenSelectEl = (ctx) => ctx.getById(getHiddenSelectId(ctx));
var getContentEl = (ctx) => ctx.getById(getContentId(ctx));
var getTriggerEl = (ctx) => ctx.getById(getTriggerId(ctx));
var getClearTriggerEl = (ctx) => ctx.getById(getClearTriggerId(ctx));
var getPositionerEl = (ctx) => ctx.getById(getPositionerId(ctx));
var getItemEl = (ctx, id) => ctx.getById(getItemId(ctx, id));

// src/select.connect.ts
function connect(service, normalize) {
  const { context, prop, scope, state, computed, send } = service;
  const disabled = prop("disabled") || context.get("fieldsetDisabled");
  const invalid = prop("invalid");
  const readOnly = prop("readOnly");
  const composite = prop("composite");
  const collection2 = prop("collection");
  const open = state.hasTag("open");
  const focused = state.matches("focused");
  const highlightedValue = context.get("highlightedValue");
  const highlightedItem = context.get("highlightedItem");
  const selectedItems = context.get("selectedItems");
  const currentPlacement = context.get("currentPlacement");
  const isTypingAhead = computed("isTypingAhead");
  const interactive = computed("isInteractive");
  const ariaActiveDescendant = highlightedValue ? getItemId(scope, highlightedValue) : void 0;
  function getItemState(props2) {
    const _disabled = collection2.getItemDisabled(props2.item);
    const value = collection2.getItemValue(props2.item);
    (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.ensure)(value, () => `[zag-js] No value found for item ${JSON.stringify(props2.item)}`);
    return {
      value,
      disabled: Boolean(disabled || _disabled),
      highlighted: highlightedValue === value,
      selected: context.get("value").includes(value)
    };
  }
  const popperStyles = (0,_zag_js_popper__WEBPACK_IMPORTED_MODULE_3__.getPlacementStyles)({
    ...prop("positioning"),
    placement: currentPlacement
  });
  return {
    open,
    focused,
    empty: context.get("value").length === 0,
    highlightedItem,
    highlightedValue,
    selectedItems,
    hasSelectedItems: computed("hasSelectedItems"),
    value: context.get("value"),
    valueAsString: context.get("valueAsString"),
    collection: collection2,
    multiple: !!prop("multiple"),
    disabled: !!disabled,
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    focus() {
      getTriggerEl(scope)?.focus({ preventScroll: true });
    },
    setOpen(nextOpen) {
      const open2 = state.hasTag("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    selectValue(value) {
      send({ type: "ITEM.SELECT", value });
    },
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    selectAll() {
      send({ type: "VALUE.SET", value: collection2.getValues() });
    },
    highlightValue(value) {
      send({ type: "HIGHLIGHTED_VALUE.SET", value });
    },
    clearValue(value) {
      if (value) {
        send({ type: "ITEM.CLEAR", value });
      } else {
        send({ type: "VALUE.CLEAR" });
      }
    },
    getItemState,
    getRootProps() {
      return normalize.element({
        ...parts.root.attrs,
        dir: prop("dir"),
        id: getRootId(scope),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(invalid),
        "data-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(readOnly)
      });
    },
    getLabelProps() {
      return normalize.label({
        dir: prop("dir"),
        id: getLabelId(scope),
        ...parts.label.attrs,
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(disabled),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(invalid),
        "data-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(readOnly),
        htmlFor: getHiddenSelectId(scope),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          getTriggerEl(scope)?.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts.control.attrs,
        dir: prop("dir"),
        id: getControlId(scope),
        "data-state": open ? "open" : "closed",
        "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(focused),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(disabled),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(invalid)
      });
    },
    getValueTextProps() {
      return normalize.element({
        ...parts.valueText.attrs,
        dir: prop("dir"),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(disabled),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(invalid),
        "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(focused)
      });
    },
    getTriggerProps() {
      return normalize.button({
        id: getTriggerId(scope),
        disabled,
        dir: prop("dir"),
        type: "button",
        role: "combobox",
        "aria-controls": getContentId(scope),
        "aria-expanded": open,
        "aria-haspopup": "listbox",
        "data-state": open ? "open" : "closed",
        "aria-invalid": invalid,
        "aria-labelledby": getLabelId(scope),
        ...parts.trigger.attrs,
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(disabled),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(invalid),
        "data-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(readOnly),
        "data-placement": currentPlacement,
        "data-placeholder-shown": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(!computed("hasSelectedItems")),
        onClick(event) {
          if (!interactive) return;
          if (event.defaultPrevented) return;
          send({ type: "TRIGGER.CLICK" });
        },
        onFocus() {
          send({ type: "TRIGGER.FOCUS" });
        },
        onBlur() {
          send({ type: "TRIGGER.BLUR" });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const keyMap = {
            ArrowUp() {
              send({ type: "TRIGGER.ARROW_UP" });
            },
            ArrowDown(event2) {
              send({ type: event2.altKey ? "OPEN" : "TRIGGER.ARROW_DOWN" });
            },
            ArrowLeft() {
              send({ type: "TRIGGER.ARROW_LEFT" });
            },
            ArrowRight() {
              send({ type: "TRIGGER.ARROW_RIGHT" });
            },
            Home() {
              send({ type: "TRIGGER.HOME" });
            },
            End() {
              send({ type: "TRIGGER.END" });
            },
            Enter() {
              send({ type: "TRIGGER.ENTER" });
            },
            Space(event2) {
              if (isTypingAhead) {
                send({ type: "TRIGGER.TYPEAHEAD", key: event2.key });
              } else {
                send({ type: "TRIGGER.ENTER" });
              }
            }
          };
          const exec = keyMap[(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.getEventKey)(event, {
            dir: prop("dir"),
            orientation: "vertical"
          })];
          if (exec) {
            exec(event);
            event.preventDefault();
            return;
          }
          if (_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.getByTypeahead.isValidEvent(event)) {
            send({ type: "TRIGGER.TYPEAHEAD", key: event.key });
            event.preventDefault();
          }
        }
      });
    },
    getIndicatorProps() {
      return normalize.element({
        ...parts.indicator.attrs,
        dir: prop("dir"),
        "aria-hidden": true,
        "data-state": open ? "open" : "closed",
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(disabled),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(invalid),
        "data-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(readOnly)
      });
    },
    getItemProps(props2) {
      const itemState = getItemState(props2);
      return normalize.element({
        id: getItemId(scope, itemState.value),
        role: "option",
        ...parts.item.attrs,
        dir: prop("dir"),
        "data-value": itemState.value,
        "aria-selected": itemState.selected,
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-highlighted": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(itemState.highlighted),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(itemState.disabled),
        "aria-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.ariaAttr)(itemState.disabled),
        onPointerMove(event) {
          if (itemState.disabled || event.pointerType !== "mouse") return;
          if (itemState.value === highlightedValue) return;
          send({ type: "ITEM.POINTER_MOVE", value: itemState.value });
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (itemState.disabled) return;
          send({ type: "ITEM.CLICK", src: "pointerup", value: itemState.value });
        },
        onPointerLeave(event) {
          if (itemState.disabled) return;
          if (props2.persistFocus) return;
          if (event.pointerType !== "mouse") return;
          const pointerMoved = service.event.previous()?.type.includes("POINTER");
          if (!pointerMoved) return;
          send({ type: "ITEM.POINTER_LEAVE" });
        }
      });
    },
    getItemTextProps(props2) {
      const itemState = getItemState(props2);
      return normalize.element({
        ...parts.itemText.attrs,
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(itemState.disabled),
        "data-highlighted": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(itemState.highlighted)
      });
    },
    getItemIndicatorProps(props2) {
      const itemState = getItemState(props2);
      return normalize.element({
        "aria-hidden": true,
        ...parts.itemIndicator.attrs,
        "data-state": itemState.selected ? "checked" : "unchecked",
        hidden: !itemState.selected
      });
    },
    getItemGroupLabelProps(props2) {
      const { htmlFor } = props2;
      return normalize.element({
        ...parts.itemGroupLabel.attrs,
        id: getItemGroupLabelId(scope, htmlFor),
        dir: prop("dir"),
        role: "presentation"
      });
    },
    getItemGroupProps(props2) {
      const { id } = props2;
      return normalize.element({
        ...parts.itemGroup.attrs,
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(disabled),
        id: getItemGroupId(scope, id),
        "aria-labelledby": getItemGroupLabelId(scope, id),
        role: "group",
        dir: prop("dir")
      });
    },
    getClearTriggerProps() {
      return normalize.button({
        ...parts.clearTrigger.attrs,
        id: getClearTriggerId(scope),
        type: "button",
        "aria-label": "Clear value",
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.dataAttr)(invalid),
        disabled,
        hidden: !computed("hasSelectedItems"),
        dir: prop("dir"),
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "CLEAR.CLICK" });
        }
      });
    },
    getHiddenSelectProps() {
      const value = context.get("value");
      const defaultValue = prop("multiple") ? value : value?.[0];
      return normalize.select({
        name: prop("name"),
        form: prop("form"),
        disabled,
        multiple: prop("multiple"),
        required: prop("required"),
        "aria-hidden": true,
        id: getHiddenSelectId(scope),
        defaultValue,
        style: _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.visuallyHiddenStyle,
        tabIndex: -1,
        // Some browser extensions will focus the hidden select.
        // Let's forward the focus to the trigger.
        onFocus() {
          getTriggerEl(scope)?.focus({ preventScroll: true });
        },
        "aria-labelledby": getLabelId(scope)
      });
    },
    getPositionerProps() {
      return normalize.element({
        ...parts.positioner.attrs,
        dir: prop("dir"),
        id: getPositionerId(scope),
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize.element({
        hidden: !open,
        dir: prop("dir"),
        id: getContentId(scope),
        role: composite ? "listbox" : "dialog",
        ...parts.content.attrs,
        "data-state": open ? "open" : "closed",
        "data-placement": currentPlacement,
        "data-activedescendant": ariaActiveDescendant,
        "aria-activedescendant": composite ? ariaActiveDescendant : void 0,
        "aria-multiselectable": prop("multiple") && composite ? true : void 0,
        "aria-labelledby": getLabelId(scope),
        tabIndex: 0,
        onKeyDown(event) {
          if (!interactive) return;
          if (!(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.isSelfTarget)(event)) return;
          if (event.key === "Tab") {
            const valid = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.isValidTabEvent)(event);
            if (!valid) {
              event.preventDefault();
              return;
            }
          }
          const keyMap = {
            ArrowUp() {
              send({ type: "CONTENT.ARROW_UP" });
            },
            ArrowDown() {
              send({ type: "CONTENT.ARROW_DOWN" });
            },
            Home() {
              send({ type: "CONTENT.HOME" });
            },
            End() {
              send({ type: "CONTENT.END" });
            },
            Enter() {
              send({ type: "ITEM.CLICK", src: "keydown.enter" });
            },
            Space(event2) {
              if (isTypingAhead) {
                send({ type: "CONTENT.TYPEAHEAD", key: event2.key });
              } else {
                keyMap.Enter?.(event2);
              }
            }
          };
          const exec = keyMap[(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.getEventKey)(event)];
          if (exec) {
            exec(event);
            event.preventDefault();
            return;
          }
          const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.getEventTarget)(event);
          if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.isEditableElement)(target)) {
            return;
          }
          if (_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.getByTypeahead.isValidEvent(event)) {
            send({ type: "CONTENT.TYPEAHEAD", key: event.key });
            event.preventDefault();
          }
        }
      });
    },
    getListProps() {
      return normalize.element({
        ...parts.list.attrs,
        tabIndex: 0,
        role: !composite ? "listbox" : void 0,
        "aria-labelledby": getTriggerId(scope),
        "aria-activedescendant": !composite ? ariaActiveDescendant : void 0,
        "aria-multiselectable": !composite && prop("multiple") ? true : void 0
      });
    }
  };
}
var { and, not, or } = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_5__.createGuards)();
var machine = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_5__.createMachine)({
  props({ props: props2 }) {
    return {
      loopFocus: false,
      closeOnSelect: !props2.multiple,
      composite: true,
      defaultValue: [],
      ...props2,
      collection: props2.collection ?? collection.empty(),
      positioning: {
        placement: "bottom-start",
        gutter: 8,
        ...props2.positioning
      }
    };
  },
  context({ prop, bindable }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        isEqual: _zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.isEqual,
        onChange(value) {
          const items = prop("collection").findMany(value);
          return prop("onValueChange")?.({ value, items });
        }
      })),
      highlightedValue: bindable(() => ({
        defaultValue: prop("defaultHighlightedValue") || null,
        value: prop("highlightedValue"),
        onChange(value) {
          prop("onHighlightChange")?.({
            highlightedValue: value,
            highlightedItem: prop("collection").find(value),
            highlightedIndex: prop("collection").indexOf(value)
          });
        }
      })),
      currentPlacement: bindable(() => ({
        defaultValue: void 0
      })),
      fieldsetDisabled: bindable(() => ({
        defaultValue: false
      })),
      highlightedItem: bindable(() => ({
        defaultValue: null
      })),
      selectedItems: bindable(() => {
        const value = prop("value") ?? prop("defaultValue") ?? [];
        const items = prop("collection").findMany(value);
        return { defaultValue: items };
      }),
      valueAsString: bindable(() => {
        const value = prop("value") ?? prop("defaultValue") ?? [];
        return { defaultValue: prop("collection").stringifyMany(value) };
      })
    };
  },
  refs() {
    return {
      typeahead: { ..._zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.getByTypeahead.defaultOptions }
    };
  },
  computed: {
    hasSelectedItems: ({ context }) => context.get("value").length > 0,
    isTypingAhead: ({ refs }) => refs.get("typeahead").keysSoFar !== "",
    isDisabled: ({ prop, context }) => !!prop("disabled") || !!context.get("fieldsetDisabled"),
    isInteractive: ({ prop }) => !(prop("disabled") || prop("readOnly"))
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "idle";
  },
  entry: ["syncSelectElement"],
  watch({ context, prop, track, action }) {
    track([() => context.get("value").toString()], () => {
      action(["syncSelectedItems", "syncSelectElement", "dispatchChangeEvent"]);
    });
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
    track([() => context.get("highlightedValue")], () => {
      action(["syncHighlightedItem"]);
    });
    track([() => prop("collection").toString()], () => {
      action(["syncCollection"]);
    });
  },
  on: {
    "HIGHLIGHTED_VALUE.SET": {
      actions: ["setHighlightedItem"]
    },
    "ITEM.SELECT": {
      actions: ["selectItem"]
    },
    "ITEM.CLEAR": {
      actions: ["clearItem"]
    },
    "VALUE.SET": {
      actions: ["setSelectedItems"]
    },
    "VALUE.CLEAR": {
      actions: ["clearSelectedItems"]
    },
    "CLEAR.CLICK": {
      actions: ["clearSelectedItems", "focusTriggerEl"]
    }
  },
  effects: ["trackFormControlState"],
  states: {
    idle: {
      tags: ["closed"],
      on: {
        "CONTROLLED.OPEN": [
          {
            guard: "isTriggerClickEvent",
            target: "open",
            actions: ["setInitialFocus", "highlightFirstSelectedItem"]
          },
          {
            target: "open",
            actions: ["setInitialFocus"]
          }
        ],
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen", "setInitialFocus", "highlightFirstSelectedItem"]
          }
        ],
        "TRIGGER.FOCUS": {
          target: "focused"
        },
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitialFocus", "invokeOnOpen"]
          }
        ]
      }
    },
    focused: {
      tags: ["closed"],
      on: {
        "CONTROLLED.OPEN": [
          {
            guard: "isTriggerClickEvent",
            target: "open",
            actions: ["setInitialFocus", "highlightFirstSelectedItem"]
          },
          {
            guard: "isTriggerArrowUpEvent",
            target: "open",
            actions: ["setInitialFocus", "highlightComputedLastItem"]
          },
          {
            guard: or("isTriggerArrowDownEvent", "isTriggerEnterEvent"),
            target: "open",
            actions: ["setInitialFocus", "highlightComputedFirstItem"]
          },
          {
            target: "open",
            actions: ["setInitialFocus"]
          }
        ],
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitialFocus", "invokeOnOpen"]
          }
        ],
        "TRIGGER.BLUR": {
          target: "idle"
        },
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitialFocus", "invokeOnOpen", "highlightFirstSelectedItem"]
          }
        ],
        "TRIGGER.ENTER": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedFirstItem"]
          }
        ],
        "TRIGGER.ARROW_UP": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedLastItem"]
          }
        ],
        "TRIGGER.ARROW_DOWN": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedFirstItem"]
          }
        ],
        "TRIGGER.ARROW_LEFT": [
          {
            guard: and(not("multiple"), "hasSelectedItems"),
            actions: ["selectPreviousItem"]
          },
          {
            guard: not("multiple"),
            actions: ["selectLastItem"]
          }
        ],
        "TRIGGER.ARROW_RIGHT": [
          {
            guard: and(not("multiple"), "hasSelectedItems"),
            actions: ["selectNextItem"]
          },
          {
            guard: not("multiple"),
            actions: ["selectFirstItem"]
          }
        ],
        "TRIGGER.HOME": {
          guard: not("multiple"),
          actions: ["selectFirstItem"]
        },
        "TRIGGER.END": {
          guard: not("multiple"),
          actions: ["selectLastItem"]
        },
        "TRIGGER.TYPEAHEAD": {
          guard: not("multiple"),
          actions: ["selectMatchingItem"]
        }
      }
    },
    open: {
      tags: ["open"],
      exit: ["scrollContentToTop"],
      effects: ["trackDismissableElement", "computePlacement", "scrollToHighlightedItem"],
      on: {
        "CONTROLLED.CLOSE": [
          {
            guard: "restoreFocus",
            target: "focused",
            actions: ["focusTriggerEl", "clearHighlightedItem"]
          },
          {
            target: "idle",
            actions: ["clearHighlightedItem"]
          }
        ],
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            guard: "restoreFocus",
            target: "focused",
            actions: ["invokeOnClose", "focusTriggerEl", "clearHighlightedItem"]
          },
          {
            target: "idle",
            actions: ["invokeOnClose", "clearHighlightedItem"]
          }
        ],
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["invokeOnClose", "clearHighlightedItem"]
          }
        ],
        "ITEM.CLICK": [
          {
            guard: and("closeOnSelect", "isOpenControlled"),
            actions: ["selectHighlightedItem", "invokeOnClose"]
          },
          {
            guard: "closeOnSelect",
            target: "focused",
            actions: ["selectHighlightedItem", "invokeOnClose", "focusTriggerEl", "clearHighlightedItem"]
          },
          {
            actions: ["selectHighlightedItem"]
          }
        ],
        "CONTENT.HOME": {
          actions: ["highlightFirstItem"]
        },
        "CONTENT.END": {
          actions: ["highlightLastItem"]
        },
        "CONTENT.ARROW_DOWN": [
          {
            guard: and("hasHighlightedItem", "loop", "isLastItemHighlighted"),
            actions: ["highlightFirstItem"]
          },
          {
            guard: "hasHighlightedItem",
            actions: ["highlightNextItem"]
          },
          {
            actions: ["highlightFirstItem"]
          }
        ],
        "CONTENT.ARROW_UP": [
          {
            guard: and("hasHighlightedItem", "loop", "isFirstItemHighlighted"),
            actions: ["highlightLastItem"]
          },
          {
            guard: "hasHighlightedItem",
            actions: ["highlightPreviousItem"]
          },
          {
            actions: ["highlightLastItem"]
          }
        ],
        "CONTENT.TYPEAHEAD": {
          actions: ["highlightMatchingItem"]
        },
        "ITEM.POINTER_MOVE": {
          actions: ["highlightItem"]
        },
        "ITEM.POINTER_LEAVE": {
          actions: ["clearHighlightedItem"]
        },
        "POSITIONING.SET": {
          actions: ["reposition"]
        }
      }
    }
  },
  implementations: {
    guards: {
      loop: ({ prop }) => !!prop("loopFocus"),
      multiple: ({ prop }) => !!prop("multiple"),
      hasSelectedItems: ({ computed }) => !!computed("hasSelectedItems"),
      hasHighlightedItem: ({ context }) => context.get("highlightedValue") != null,
      isFirstItemHighlighted: ({ context, prop }) => context.get("highlightedValue") === prop("collection").firstValue,
      isLastItemHighlighted: ({ context, prop }) => context.get("highlightedValue") === prop("collection").lastValue,
      closeOnSelect: ({ prop, event }) => !!(event.closeOnSelect ?? prop("closeOnSelect")),
      restoreFocus: ({ event }) => restoreFocusFn(event),
      // guard assertions (for controlled mode)
      isOpenControlled: ({ prop }) => prop("open") !== void 0,
      isTriggerClickEvent: ({ event }) => event.previousEvent?.type === "TRIGGER.CLICK",
      isTriggerEnterEvent: ({ event }) => event.previousEvent?.type === "TRIGGER.ENTER",
      isTriggerArrowUpEvent: ({ event }) => event.previousEvent?.type === "TRIGGER.ARROW_UP",
      isTriggerArrowDownEvent: ({ event }) => event.previousEvent?.type === "TRIGGER.ARROW_DOWN"
    },
    effects: {
      trackFormControlState({ context, scope }) {
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.trackFormControl)(getHiddenSelectEl(scope), {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            const value = context.initial("value");
            context.set("value", value);
          }
        });
      },
      trackDismissableElement({ scope, send, prop }) {
        const contentEl = () => getContentEl(scope);
        let restoreFocus = true;
        return (0,_zag_js_dismissable__WEBPACK_IMPORTED_MODULE_6__.trackDismissableElement)(contentEl, {
          defer: true,
          exclude: [getTriggerEl(scope), getClearTriggerEl(scope)],
          onFocusOutside: prop("onFocusOutside"),
          onPointerDownOutside: prop("onPointerDownOutside"),
          onInteractOutside(event) {
            prop("onInteractOutside")?.(event);
            restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
          },
          onDismiss() {
            send({ type: "CLOSE", src: "interact-outside", restoreFocus });
          }
        });
      },
      computePlacement({ context, prop, scope }) {
        const positioning = prop("positioning");
        context.set("currentPlacement", positioning.placement);
        const triggerEl = () => getTriggerEl(scope);
        const positionerEl = () => getPositionerEl(scope);
        return (0,_zag_js_popper__WEBPACK_IMPORTED_MODULE_3__.getPlacement)(triggerEl, positionerEl, {
          defer: true,
          ...positioning,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      scrollToHighlightedItem({ context, prop, scope, event }) {
        const exec = (immediate) => {
          const highlightedValue = context.get("highlightedValue");
          if (highlightedValue == null) return;
          if (event.current().type.includes("POINTER")) return;
          const optionEl = getItemEl(scope, highlightedValue);
          const contentEl2 = getContentEl(scope);
          const scrollToIndexFn = prop("scrollToIndexFn");
          if (scrollToIndexFn) {
            const highlightedIndex = prop("collection").indexOf(highlightedValue);
            scrollToIndexFn?.({ index: highlightedIndex, immediate });
            return;
          }
          (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.scrollIntoView)(optionEl, { rootEl: contentEl2, block: "nearest" });
        };
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.raf)(() => exec(true));
        const contentEl = () => getContentEl(scope);
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.observeAttributes)(contentEl, {
          defer: true,
          attributes: ["data-activedescendant"],
          callback() {
            exec(false);
          }
        });
      }
    },
    actions: {
      reposition({ context, prop, scope, event }) {
        const positionerEl = () => getPositionerEl(scope);
        (0,_zag_js_popper__WEBPACK_IMPORTED_MODULE_3__.getPlacement)(getTriggerEl(scope), positionerEl, {
          ...prop("positioning"),
          ...event.options,
          defer: true,
          listeners: false,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      toggleVisibility({ send, prop, event }) {
        send({ type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: event });
      },
      highlightPreviousItem({ context, prop }) {
        const highlightedValue = context.get("highlightedValue");
        if (highlightedValue == null) return;
        const value = prop("collection").getPreviousValue(highlightedValue, 1, prop("loopFocus"));
        context.set("highlightedValue", value);
      },
      highlightNextItem({ context, prop }) {
        const highlightedValue = context.get("highlightedValue");
        if (highlightedValue == null) return;
        const value = prop("collection").getNextValue(highlightedValue, 1, prop("loopFocus"));
        context.set("highlightedValue", value);
      },
      highlightFirstItem({ context, prop }) {
        const value = prop("collection").firstValue;
        context.set("highlightedValue", value);
      },
      highlightLastItem({ context, prop }) {
        const value = prop("collection").lastValue;
        context.set("highlightedValue", value);
      },
      setInitialFocus({ scope }) {
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.raf)(() => {
          const element = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.getInitialFocus)({
            root: getContentEl(scope)
          });
          element?.focus({ preventScroll: true });
        });
      },
      focusTriggerEl({ event, scope }) {
        if (!restoreFocusFn(event)) return;
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_4__.raf)(() => {
          const element = getTriggerEl(scope);
          element?.focus({ preventScroll: true });
        });
      },
      selectHighlightedItem({ context, prop, event }) {
        let value = event.value ?? context.get("highlightedValue");
        if (value == null) return;
        const nullable = prop("deselectable") && !prop("multiple") && context.get("value").includes(value);
        value = nullable ? null : value;
        context.set("value", (prev) => {
          if (value == null) return [];
          if (prop("multiple")) return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.addOrRemove)(prev, value);
          return [value];
        });
      },
      highlightComputedFirstItem({ context, prop, computed }) {
        const collection2 = prop("collection");
        const value = computed("hasSelectedItems") ? collection2.sort(context.get("value"))[0] : collection2.firstValue;
        context.set("highlightedValue", value);
      },
      highlightComputedLastItem({ context, prop, computed }) {
        const collection2 = prop("collection");
        const value = computed("hasSelectedItems") ? collection2.sort(context.get("value"))[0] : collection2.lastValue;
        context.set("highlightedValue", value);
      },
      highlightFirstSelectedItem({ context, prop, computed }) {
        if (!computed("hasSelectedItems")) return;
        const value = prop("collection").sort(context.get("value"))[0];
        context.set("highlightedValue", value);
      },
      highlightItem({ context, event }) {
        context.set("highlightedValue", event.value);
      },
      highlightMatchingItem({ context, prop, event, refs }) {
        const value = prop("collection").search(event.key, {
          state: refs.get("typeahead"),
          currentValue: context.get("highlightedValue")
        });
        if (value == null) return;
        context.set("highlightedValue", value);
      },
      setHighlightedItem({ context, event }) {
        context.set("highlightedValue", event.value);
      },
      clearHighlightedItem({ context }) {
        context.set("highlightedValue", null);
      },
      selectItem({ context, prop, event }) {
        const nullable = prop("deselectable") && !prop("multiple") && context.get("value").includes(event.value);
        const value = nullable ? null : event.value;
        context.set("value", (prev) => {
          if (value == null) return [];
          if (prop("multiple")) return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.addOrRemove)(prev, value);
          return [value];
        });
      },
      clearItem({ context, event }) {
        context.set("value", (prev) => prev.filter((v) => v !== event.value));
      },
      setSelectedItems({ context, event }) {
        context.set("value", event.value);
      },
      clearSelectedItems({ context }) {
        context.set("value", []);
      },
      selectPreviousItem({ context, prop }) {
        const [firstItem] = context.get("value");
        const value = prop("collection").getPreviousValue(firstItem);
        if (value) context.set("value", [value]);
      },
      selectNextItem({ context, prop }) {
        const [firstItem] = context.get("value");
        const value = prop("collection").getNextValue(firstItem);
        if (value) context.set("value", [value]);
      },
      selectFirstItem({ context, prop }) {
        const value = prop("collection").firstValue;
        if (value) context.set("value", [value]);
      },
      selectLastItem({ context, prop }) {
        const value = prop("collection").lastValue;
        if (value) context.set("value", [value]);
      },
      selectMatchingItem({ context, prop, event, refs }) {
        const value = prop("collection").search(event.key, {
          state: refs.get("typeahead"),
          currentValue: context.get("value")[0]
        });
        if (value == null) return;
        context.set("value", [value]);
      },
      scrollContentToTop({ prop, scope }) {
        if (prop("scrollToIndexFn")) {
          prop("scrollToIndexFn")?.({ index: 0, immediate: true });
        } else {
          getContentEl(scope)?.scrollTo(0, 0);
        }
      },
      invokeOnOpen({ prop }) {
        prop("onOpenChange")?.({ open: true });
      },
      invokeOnClose({ prop }) {
        prop("onOpenChange")?.({ open: false });
      },
      syncSelectElement({ context, prop, scope }) {
        const selectEl = getHiddenSelectEl(scope);
        if (!selectEl) return;
        if (context.get("value").length === 0 && !prop("multiple")) {
          selectEl.selectedIndex = -1;
          return;
        }
        for (const option of selectEl.options) {
          option.selected = context.get("value").includes(option.value);
        }
      },
      syncCollection({ context, prop }) {
        const collection2 = prop("collection");
        const highlightedItem = collection2.find(context.get("highlightedValue"));
        if (highlightedItem) context.set("highlightedItem", highlightedItem);
        const selectedItems = collection2.findMany(context.get("value"));
        context.set("selectedItems", selectedItems);
        const valueAsString = collection2.stringifyItems(selectedItems);
        context.set("valueAsString", valueAsString);
      },
      syncSelectedItems({ context, prop }) {
        const collection2 = prop("collection");
        const prevSelectedItems = context.get("selectedItems");
        const value = context.get("value");
        const selectedItems = value.map((value2) => {
          const item = prevSelectedItems.find((item2) => collection2.getItemValue(item2) === value2);
          return item || collection2.find(value2);
        });
        context.set("selectedItems", selectedItems);
        context.set("valueAsString", collection2.stringifyItems(selectedItems));
      },
      syncHighlightedItem({ context, prop }) {
        const collection2 = prop("collection");
        const highlightedValue = context.get("highlightedValue");
        const highlightedItem = highlightedValue ? collection2.find(highlightedValue) : null;
        context.set("highlightedItem", highlightedItem);
      },
      dispatchChangeEvent({ scope }) {
        queueMicrotask(() => {
          const node = getHiddenSelectEl(scope);
          if (!node) return;
          const win = scope.getWin();
          const changeEvent = new win.Event("change", { bubbles: true, composed: true });
          node.dispatchEvent(changeEvent);
        });
      }
    }
  }
});
function restoreFocusFn(event) {
  const v = event.restoreFocus ?? event.previousEvent?.restoreFocus;
  return v == null || !!v;
}
var props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_7__.createProps)()([
  "closeOnSelect",
  "collection",
  "dir",
  "disabled",
  "deselectable",
  "form",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "invalid",
  "loopFocus",
  "multiple",
  "name",
  "onFocusOutside",
  "onHighlightChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onValueChange",
  "defaultOpen",
  "open",
  "composite",
  "positioning",
  "required",
  "readOnly",
  "scrollToIndexFn",
  "value",
  "defaultValue",
  "defaultHighlightedValue"
]);
var splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.createSplitProps)(props);
var itemProps = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_7__.createProps)()(["item", "persistFocus"]);
var splitItemProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.createSplitProps)(itemProps);
var itemGroupProps = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_7__.createProps)()(["id"]);
var splitItemGroupProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.createSplitProps)(itemGroupProps);
var itemGroupLabelProps = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_7__.createProps)()(["htmlFor"]);
var splitItemGroupLabelProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.createSplitProps)(itemGroupLabelProps);




/***/ }),

/***/ "./node_modules/@zag-js/slider/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@zag-js/slider/dist/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anatomy: () => (/* binding */ anatomy),
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   machine: () => (/* binding */ machine),
/* harmony export */   props: () => (/* binding */ props),
/* harmony export */   splitProps: () => (/* binding */ splitProps),
/* harmony export */   splitThumbProps: () => (/* binding */ splitThumbProps),
/* harmony export */   thumbProps: () => (/* binding */ thumbProps)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");






// src/slider.anatomy.ts
var anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("slider").parts(
  "root",
  "label",
  "thumb",
  "valueText",
  "track",
  "range",
  "control",
  "markerGroup",
  "marker",
  "draggingIndicator"
);
var parts = anatomy.build();
var getRootId = (ctx) => ctx.ids?.root ?? `slider:${ctx.id}`;
var getThumbId = (ctx, index) => ctx.ids?.thumb?.(index) ?? `slider:${ctx.id}:thumb:${index}`;
var getHiddenInputId = (ctx, index) => ctx.ids?.hiddenInput?.(index) ?? `slider:${ctx.id}:input:${index}`;
var getControlId = (ctx) => ctx.ids?.control ?? `slider:${ctx.id}:control`;
var getTrackId = (ctx) => ctx.ids?.track ?? `slider:${ctx.id}:track`;
var getRangeId = (ctx) => ctx.ids?.range ?? `slider:${ctx.id}:range`;
var getLabelId = (ctx) => ctx.ids?.label ?? `slider:${ctx.id}:label`;
var getValueTextId = (ctx) => ctx.ids?.valueText ?? `slider:${ctx.id}:value-text`;
var getMarkerId = (ctx, value) => ctx.ids?.marker?.(value) ?? `slider:${ctx.id}:marker:${value}`;
var getRootEl = (ctx) => ctx.getById(getRootId(ctx));
var getThumbEl = (ctx, index) => ctx.getById(getThumbId(ctx, index));
var getThumbEls = (ctx) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.queryAll)(getControlEl(ctx), "[role=slider]");
var getFirstThumbEl = (ctx) => getThumbEls(ctx)[0];
var getHiddenInputEl = (ctx, index) => ctx.getById(getHiddenInputId(ctx, index));
var getControlEl = (ctx) => ctx.getById(getControlId(ctx));
var getPointValue = (params, point) => {
  const { prop, scope } = params;
  const controlEl = getControlEl(scope);
  if (!controlEl) return;
  const relativePoint = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getRelativePoint)(point, controlEl);
  const percent = relativePoint.getPercentValue({
    orientation: prop("orientation"),
    dir: prop("dir"),
    inverted: { y: true }
  });
  return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.getPercentValue)(percent, prop("min"), prop("max"), prop("step"));
};
var dispatchChangeEvent = (ctx, value) => {
  value.forEach((value2, index) => {
    const inputEl = getHiddenInputEl(ctx, index);
    if (!inputEl) return;
    (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dispatchInputValueEvent)(inputEl, { value: value2 });
  });
};
var getOffsetRect = (el) => ({
  left: el?.offsetLeft ?? 0,
  top: el?.offsetTop ?? 0,
  width: el?.offsetWidth ?? 0,
  height: el?.offsetHeight ?? 0
});
function getBounds(value) {
  const firstValue = value[0];
  const lastThumb = value[value.length - 1];
  return [firstValue, lastThumb];
}
function getRangeOffsets(params) {
  const { prop, computed } = params;
  const valuePercent = computed("valuePercent");
  const [firstPercent, lastPercent] = getBounds(valuePercent);
  if (valuePercent.length === 1) {
    if (prop("origin") === "center") {
      const isNegative = valuePercent[0] < 50;
      const start = isNegative ? `${valuePercent[0]}%` : "50%";
      const end = isNegative ? "50%" : `${100 - valuePercent[0]}%`;
      return { start, end };
    }
    if (prop("origin") === "end") {
      return { start: `${lastPercent}%`, end: "0%" };
    }
    return { start: "0%", end: `${100 - lastPercent}%` };
  }
  return { start: `${firstPercent}%`, end: `${100 - lastPercent}%` };
}
function getRangeStyle(params) {
  const { computed } = params;
  const isVertical = computed("isVertical");
  const isRtl = computed("isRtl");
  if (isVertical) {
    return {
      position: "absolute",
      bottom: "var(--slider-range-start)",
      top: "var(--slider-range-end)"
    };
  }
  return {
    position: "absolute",
    [isRtl ? "right" : "left"]: "var(--slider-range-start)",
    [isRtl ? "left" : "right"]: "var(--slider-range-end)"
  };
}
function getVerticalThumbOffset(params, value) {
  const { context, prop } = params;
  const { height = 0 } = context.get("thumbSize") ?? {};
  const getValue = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.getValueTransformer)([prop("min"), prop("max")], [-height / 2, height / 2]);
  return parseFloat(getValue(value).toFixed(2));
}
function getHorizontalThumbOffset(params, value) {
  const { computed, context, prop } = params;
  const { width = 0 } = context.get("thumbSize") ?? {};
  const isRtl = computed("isRtl");
  if (isRtl) {
    const getValue2 = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.getValueTransformer)([prop("max"), prop("min")], [-width / 2, width / 2]);
    return -1 * parseFloat(getValue2(value).toFixed(2));
  }
  const getValue = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.getValueTransformer)([prop("min"), prop("max")], [-width / 2, width / 2]);
  return parseFloat(getValue(value).toFixed(2));
}
function getOffset(params, percent, value) {
  const { computed, prop } = params;
  if (prop("thumbAlignment") === "center") return `${percent}%`;
  const offset = computed("isVertical") ? getVerticalThumbOffset(params, value) : getHorizontalThumbOffset(params, value);
  return `calc(${percent}% - ${offset}px)`;
}
function getThumbOffset(params, value) {
  const { prop } = params;
  const percent = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.getValuePercent)(value, prop("min"), prop("max")) * 100;
  return getOffset(params, percent, value);
}
function getVisibility(params) {
  const { computed, prop } = params;
  let visibility = "visible";
  if (prop("thumbAlignment") === "contain" && !computed("hasMeasuredThumbSize")) {
    visibility = "hidden";
  }
  return visibility;
}
function getThumbStyle(params, index) {
  const { computed } = params;
  const placementProp = computed("isVertical") ? "bottom" : "insetInlineStart";
  return {
    visibility: getVisibility(params),
    position: "absolute",
    transform: "var(--slider-thumb-transform)",
    [placementProp]: `var(--slider-thumb-offset-${index})`
  };
}
function getControlStyle() {
  return {
    touchAction: "none",
    userSelect: "none",
    WebkitUserSelect: "none",
    position: "relative"
  };
}
function getRootStyle(params) {
  const { context, computed } = params;
  const isVertical = computed("isVertical");
  const isRtl = computed("isRtl");
  const range = getRangeOffsets(params);
  const thumbSize = context.get("thumbSize");
  const offsetStyles = context.get("value").reduce((styles, value, index) => {
    const offset = getThumbOffset(params, value);
    return { ...styles, [`--slider-thumb-offset-${index}`]: offset };
  }, {});
  return {
    ...offsetStyles,
    "--slider-thumb-width": (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.toPx)(thumbSize?.width),
    "--slider-thumb-height": (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.toPx)(thumbSize?.height),
    "--slider-thumb-transform": isVertical ? "translateY(50%)" : isRtl ? "translateX(50%)" : "translateX(-50%)",
    "--slider-range-start": range.start,
    "--slider-range-end": range.end
  };
}
function getMarkerStyle(params, value) {
  const { computed } = params;
  const isHorizontal = computed("isHorizontal");
  const isRtl = computed("isRtl");
  return {
    visibility: getVisibility(params),
    position: "absolute",
    pointerEvents: "none",
    [isHorizontal ? "insetInlineStart" : "bottom"]: getThumbOffset(params, value),
    translate: "var(--tx) var(--ty)",
    "--tx": isHorizontal ? isRtl ? "50%" : "-50%" : "0%",
    "--ty": !isHorizontal ? "50%" : "0%"
  };
}
function getMarkerGroupStyle() {
  return {
    userSelect: "none",
    WebkitUserSelect: "none",
    pointerEvents: "none",
    position: "relative"
  };
}
function normalizeValues(params, nextValues) {
  return nextValues.map((value, index) => {
    return constrainValue(params, value, index);
  });
}
function getRangeAtIndex(params, index) {
  const { context, prop } = params;
  return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.getValueRanges)(context.get("value"), prop("min"), prop("max"), prop("minStepsBetweenThumbs"))[index];
}
function constrainValue(params, value, index) {
  const { prop } = params;
  const range = getRangeAtIndex(params, index);
  const snapValue = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.snapValueToStep)(value, prop("min"), prop("max"), prop("step"));
  return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.clampValue)(snapValue, range.min, range.max);
}
function decrement(params, index, step) {
  const { context, prop } = params;
  const idx = index ?? context.get("focusedIndex");
  const range = getRangeAtIndex(params, idx);
  const nextValues = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.getPreviousStepValue)(idx, {
    ...range,
    step: step ?? prop("step"),
    values: context.get("value")
  });
  nextValues[idx] = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.clampValue)(nextValues[idx], range.min, range.max);
  return nextValues;
}
function increment(params, index, step) {
  const { context, prop } = params;
  const idx = index ?? context.get("focusedIndex");
  const range = getRangeAtIndex(params, idx);
  const nextValues = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.getNextStepValue)(idx, {
    ...range,
    step: step ?? prop("step"),
    values: context.get("value")
  });
  nextValues[idx] = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.clampValue)(nextValues[idx], range.min, range.max);
  return nextValues;
}
function getClosestIndex(params, pointValue) {
  const { context } = params;
  return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.getClosestValueIndex)(context.get("value"), pointValue);
}

// src/slider.connect.ts
function connect(service, normalize2) {
  const { state, send, context, prop, computed, scope } = service;
  const ariaLabel = prop("aria-label");
  const ariaLabelledBy = prop("aria-labelledby");
  const sliderValue = context.get("value");
  const focusedIndex = context.get("focusedIndex");
  const focused = state.matches("focus");
  const dragging = state.matches("dragging");
  const disabled = computed("isDisabled");
  const invalid = prop("invalid");
  const interactive = computed("isInteractive");
  const isHorizontal = prop("orientation") === "horizontal";
  const isVertical = prop("orientation") === "vertical";
  function getValuePercentFn(value) {
    return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.getValuePercent)(value, prop("min"), prop("max"));
  }
  function getPercentValueFn(percent) {
    return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.getPercentValue)(percent, prop("min"), prop("max"), prop("step"));
  }
  return {
    value: sliderValue,
    dragging,
    focused,
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    getThumbValue(index) {
      return sliderValue[index];
    },
    setThumbValue(index, value) {
      send({ type: "SET_VALUE", index, value });
    },
    getValuePercent: getValuePercentFn,
    getPercentValue: getPercentValueFn,
    getThumbPercent(index) {
      return getValuePercentFn(sliderValue[index]);
    },
    setThumbPercent(index, percent) {
      const value = getPercentValueFn(percent);
      send({ type: "SET_VALUE", index, value });
    },
    getThumbMin(index) {
      return getRangeAtIndex(service, index).min;
    },
    getThumbMax(index) {
      return getRangeAtIndex(service, index).max;
    },
    increment(index) {
      send({ type: "INCREMENT", index });
    },
    decrement(index) {
      send({ type: "DECREMENT", index });
    },
    focus() {
      if (!interactive) return;
      send({ type: "FOCUS", index: 0 });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts.label.attrs,
        dir: prop("dir"),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-orientation": prop("orientation"),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(invalid),
        "data-dragging": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(dragging),
        "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(focused),
        id: getLabelId(scope),
        htmlFor: getHiddenInputId(scope, 0),
        onClick(event) {
          if (!interactive) return;
          event.preventDefault();
          getFirstThumbEl(scope)?.focus();
        },
        style: {
          userSelect: "none",
          WebkitUserSelect: "none"
        }
      });
    },
    getRootProps() {
      return normalize2.element({
        ...parts.root.attrs,
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-orientation": prop("orientation"),
        "data-dragging": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(dragging),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(invalid),
        "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(focused),
        id: getRootId(scope),
        dir: prop("dir"),
        style: getRootStyle(service)
      });
    },
    getValueTextProps() {
      return normalize2.element({
        ...parts.valueText.attrs,
        dir: prop("dir"),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-orientation": prop("orientation"),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(invalid),
        "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(focused),
        id: getValueTextId(scope)
      });
    },
    getTrackProps() {
      return normalize2.element({
        ...parts.track.attrs,
        dir: prop("dir"),
        id: getTrackId(scope),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(invalid),
        "data-dragging": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(dragging),
        "data-orientation": prop("orientation"),
        "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(focused),
        style: { position: "relative" }
      });
    },
    getThumbProps(props2) {
      const { index = 0, name } = props2;
      const value = sliderValue[index];
      const range = getRangeAtIndex(service, index);
      const valueText = prop("getAriaValueText")?.({ value, index });
      const _ariaLabel = Array.isArray(ariaLabel) ? ariaLabel[index] : ariaLabel;
      const _ariaLabelledBy = Array.isArray(ariaLabelledBy) ? ariaLabelledBy[index] : ariaLabelledBy;
      return normalize2.element({
        ...parts.thumb.attrs,
        dir: prop("dir"),
        "data-index": index,
        "data-name": name,
        id: getThumbId(scope, index),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-orientation": prop("orientation"),
        "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(focused && focusedIndex === index),
        "data-dragging": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(dragging && focusedIndex === index),
        draggable: false,
        "aria-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.ariaAttr)(disabled),
        "aria-label": _ariaLabel,
        "aria-labelledby": _ariaLabelledBy ?? getLabelId(scope),
        "aria-orientation": prop("orientation"),
        "aria-valuemax": range.max,
        "aria-valuemin": range.min,
        "aria-valuenow": sliderValue[index],
        "aria-valuetext": valueText,
        role: "slider",
        tabIndex: disabled ? void 0 : 0,
        style: getThumbStyle(service, index),
        onPointerDown(event) {
          if (!interactive) return;
          send({ type: "THUMB_POINTER_DOWN", index });
          event.stopPropagation();
        },
        onBlur() {
          if (!interactive) return;
          send({ type: "BLUR" });
        },
        onFocus() {
          if (!interactive) return;
          send({ type: "FOCUS", index });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const step = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventStep)(event) * prop("step");
          const keyMap = {
            ArrowUp() {
              if (isHorizontal) return;
              send({ type: "ARROW_INC", step, src: "ArrowUp" });
            },
            ArrowDown() {
              if (isHorizontal) return;
              send({ type: "ARROW_DEC", step, src: "ArrowDown" });
            },
            ArrowLeft() {
              if (isVertical) return;
              send({ type: "ARROW_DEC", step, src: "ArrowLeft" });
            },
            ArrowRight() {
              if (isVertical) return;
              send({ type: "ARROW_INC", step, src: "ArrowRight" });
            },
            PageUp() {
              send({ type: "ARROW_INC", step, src: "PageUp" });
            },
            PageDown() {
              send({ type: "ARROW_DEC", step, src: "PageDown" });
            },
            Home() {
              send({ type: "HOME" });
            },
            End() {
              send({ type: "END" });
            }
          };
          const key = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventKey)(event, {
            dir: prop("dir"),
            orientation: prop("orientation")
          });
          const exec = keyMap[key];
          if (exec) {
            exec(event);
            event.preventDefault();
            event.stopPropagation();
          }
        }
      });
    },
    getHiddenInputProps(props2) {
      const { index = 0, name } = props2;
      return normalize2.input({
        name: name ?? (prop("name") ? prop("name") + (sliderValue.length > 1 ? "[]" : "") : void 0),
        form: prop("form"),
        type: "text",
        hidden: true,
        defaultValue: sliderValue[index],
        id: getHiddenInputId(scope, index)
      });
    },
    getRangeProps() {
      return normalize2.element({
        id: getRangeId(scope),
        ...parts.range.attrs,
        dir: prop("dir"),
        "data-dragging": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(dragging),
        "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(focused),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(invalid),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-orientation": prop("orientation"),
        style: getRangeStyle(service)
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts.control.attrs,
        dir: prop("dir"),
        id: getControlId(scope),
        "data-dragging": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(dragging),
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-orientation": prop("orientation"),
        "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(invalid),
        "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(focused),
        style: getControlStyle(),
        onPointerDown(event) {
          if (!interactive) return;
          if (!(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isLeftClick)(event)) return;
          if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isModifierKey)(event)) return;
          const point = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventPoint)(event);
          send({ type: "POINTER_DOWN", point });
          event.preventDefault();
          event.stopPropagation();
        }
      });
    },
    getMarkerGroupProps() {
      return normalize2.element({
        ...parts.markerGroup.attrs,
        role: "presentation",
        dir: prop("dir"),
        "aria-hidden": true,
        "data-orientation": prop("orientation"),
        style: getMarkerGroupStyle()
      });
    },
    getMarkerProps(props2) {
      const style = getMarkerStyle(service, props2.value);
      let markerState;
      if (props2.value < (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.first)(sliderValue)) {
        markerState = "under-value";
      } else if (props2.value > (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.last)(sliderValue)) {
        markerState = "over-value";
      } else {
        markerState = "at-value";
      }
      return normalize2.element({
        ...parts.marker.attrs,
        id: getMarkerId(scope, props2.value),
        role: "presentation",
        dir: prop("dir"),
        "data-orientation": prop("orientation"),
        "data-value": props2.value,
        "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
        "data-state": markerState,
        style
      });
    },
    getDraggingIndicatorProps(props2) {
      const { index = 0 } = props2;
      const isDragging = index === focusedIndex && dragging;
      return normalize2.element({
        ...parts.draggingIndicator.attrs,
        role: "presentation",
        dir: prop("dir"),
        hidden: !isDragging,
        "data-orientation": prop("orientation"),
        "data-state": isDragging ? "open" : "closed",
        style: getThumbStyle(service, index)
      });
    }
  };
}
var isEqualSize = (a, b) => {
  return a?.width === b?.width && a?.height === b?.height;
};
var normalize = (value, min, max, step, minStepsBetweenThumbs) => {
  const ranges = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.getValueRanges)(value, min, max, minStepsBetweenThumbs * step);
  return ranges.map((range) => {
    const snapValue = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.snapValueToStep)(range.value, range.min, range.max, step);
    return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.clampValue)(snapValue, range.min, range.max);
  });
};
var machine = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_3__.createMachine)({
  props({ props: props2 }) {
    const min = props2.min ?? 0;
    const max = props2.max ?? 100;
    const step = props2.step ?? 1;
    const defaultValue = props2.defaultValue ?? [min];
    const minStepsBetweenThumbs = props2.minStepsBetweenThumbs ?? 0;
    return {
      dir: "ltr",
      thumbAlignment: "contain",
      origin: "start",
      orientation: "horizontal",
      minStepsBetweenThumbs,
      ...props2,
      defaultValue: normalize(defaultValue, min, max, step, minStepsBetweenThumbs),
      value: props2.value ? normalize(props2.value, min, max, step, minStepsBetweenThumbs) : void 0,
      max,
      step,
      min
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable, getContext }) {
    return {
      thumbSize: bindable(() => ({
        defaultValue: prop("thumbSize") || null
      })),
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        isEqual: _zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.isEqual,
        hash(a) {
          return a.join(",");
        },
        onChange(value) {
          prop("onValueChange")?.({ value });
        }
      })),
      focusedIndex: bindable(() => ({
        defaultValue: -1,
        onChange(value) {
          const ctx = getContext();
          prop("onFocusChange")?.({ focusedIndex: value, value: ctx.get("value") });
        }
      })),
      fieldsetDisabled: bindable(() => ({
        defaultValue: false
      }))
    };
  },
  computed: {
    isHorizontal: ({ prop }) => prop("orientation") === "horizontal",
    isVertical: ({ prop }) => prop("orientation") === "vertical",
    isRtl: ({ prop }) => prop("orientation") === "horizontal" && prop("dir") === "rtl",
    isDisabled: ({ context, prop }) => !!prop("disabled") || context.get("fieldsetDisabled"),
    isInteractive: ({ prop, computed }) => !(prop("readOnly") || computed("isDisabled")),
    hasMeasuredThumbSize: ({ context }) => context.get("thumbSize") != null,
    valuePercent({ context, prop }) {
      return context.get("value").map((value) => 100 * (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.getValuePercent)(value, prop("min"), prop("max")));
    }
  },
  watch({ track, action, context }) {
    track([() => context.hash("value")], () => {
      action(["syncInputElements", "dispatchChangeEvent"]);
    });
  },
  effects: ["trackFormControlState", "trackThumbSize"],
  on: {
    SET_VALUE: [
      {
        guard: "hasIndex",
        actions: ["setValueAtIndex"]
      },
      {
        actions: ["setValue"]
      }
    ],
    INCREMENT: {
      actions: ["incrementThumbAtIndex"]
    },
    DECREMENT: {
      actions: ["decrementThumbAtIndex"]
    }
  },
  states: {
    idle: {
      on: {
        POINTER_DOWN: {
          target: "dragging",
          actions: ["setClosestThumbIndex", "setPointerValue", "focusActiveThumb"]
        },
        FOCUS: {
          target: "focus",
          actions: ["setFocusedIndex"]
        },
        THUMB_POINTER_DOWN: {
          target: "dragging",
          actions: ["setFocusedIndex", "focusActiveThumb"]
        }
      }
    },
    focus: {
      entry: ["focusActiveThumb"],
      on: {
        POINTER_DOWN: {
          target: "dragging",
          actions: ["setClosestThumbIndex", "setPointerValue", "focusActiveThumb"]
        },
        THUMB_POINTER_DOWN: {
          target: "dragging",
          actions: ["setFocusedIndex", "focusActiveThumb"]
        },
        ARROW_DEC: {
          actions: ["decrementThumbAtIndex", "invokeOnChangeEnd"]
        },
        ARROW_INC: {
          actions: ["incrementThumbAtIndex", "invokeOnChangeEnd"]
        },
        HOME: {
          actions: ["setFocusedThumbToMin", "invokeOnChangeEnd"]
        },
        END: {
          actions: ["setFocusedThumbToMax", "invokeOnChangeEnd"]
        },
        BLUR: {
          target: "idle",
          actions: ["clearFocusedIndex"]
        }
      }
    },
    dragging: {
      entry: ["focusActiveThumb"],
      effects: ["trackPointerMove"],
      on: {
        POINTER_UP: {
          target: "focus",
          actions: ["invokeOnChangeEnd"]
        },
        POINTER_MOVE: {
          actions: ["setPointerValue"]
        }
      }
    }
  },
  implementations: {
    guards: {
      hasIndex: ({ event }) => event.index != null
    },
    effects: {
      trackFormControlState({ context, scope }) {
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.trackFormControl)(getRootEl(scope), {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            context.set("value", context.initial("value"));
          }
        });
      },
      trackPointerMove({ scope, send }) {
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.trackPointerMove)(scope.getDoc(), {
          onPointerMove(info) {
            send({ type: "POINTER_MOVE", point: info.point });
          },
          onPointerUp() {
            send({ type: "POINTER_UP" });
          }
        });
      },
      trackThumbSize({ context, scope, prop }) {
        if (prop("thumbAlignment") !== "contain" || prop("thumbSize")) return;
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.trackElementRect)(getThumbEls(scope), {
          box: "border-box",
          measure(el) {
            return getOffsetRect(el);
          },
          onEntry({ rects }) {
            const size = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.pick)(rects[0], ["width", "height"]);
            if (isEqualSize(context.get("thumbSize"), size)) return;
            context.set("thumbSize", size);
          }
        });
      }
    },
    actions: {
      dispatchChangeEvent({ context, scope }) {
        dispatchChangeEvent(scope, context.get("value"));
      },
      syncInputElements({ context, scope }) {
        context.get("value").forEach((value, index) => {
          const inputEl = getHiddenInputEl(scope, index);
          (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.setElementValue)(inputEl, value.toString());
        });
      },
      invokeOnChangeEnd({ prop, context }) {
        prop("onValueChangeEnd")?.({ value: context.get("value") });
      },
      setClosestThumbIndex(params) {
        const { context, event } = params;
        const pointValue = getPointValue(params, event.point);
        if (pointValue == null) return;
        const focusedIndex = getClosestIndex(params, pointValue);
        context.set("focusedIndex", focusedIndex);
      },
      setFocusedIndex({ context, event }) {
        context.set("focusedIndex", event.index);
      },
      clearFocusedIndex({ context }) {
        context.set("focusedIndex", -1);
      },
      setPointerValue(params) {
        queueMicrotask(() => {
          const { context, event } = params;
          const pointValue = getPointValue(params, event.point);
          if (pointValue == null) return;
          const focusedIndex = context.get("focusedIndex");
          const value = constrainValue(params, pointValue, focusedIndex);
          context.set("value", (prev) => (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.setValueAtIndex)(prev, focusedIndex, value));
        });
      },
      focusActiveThumb({ scope, context }) {
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => {
          const thumbEl = getThumbEl(scope, context.get("focusedIndex"));
          thumbEl?.focus({ preventScroll: true });
        });
      },
      decrementThumbAtIndex(params) {
        const { context, event } = params;
        const value = decrement(params, event.index, event.step);
        context.set("value", value);
      },
      incrementThumbAtIndex(params) {
        const { context, event } = params;
        const value = increment(params, event.index, event.step);
        context.set("value", value);
      },
      setFocusedThumbToMin(params) {
        const { context } = params;
        const index = context.get("focusedIndex");
        const { min } = getRangeAtIndex(params, index);
        context.set("value", (prev) => (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.setValueAtIndex)(prev, index, min));
      },
      setFocusedThumbToMax(params) {
        const { context } = params;
        const index = context.get("focusedIndex");
        const { max } = getRangeAtIndex(params, index);
        context.set("value", (prev) => (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.setValueAtIndex)(prev, index, max));
      },
      setValueAtIndex(params) {
        const { context, event } = params;
        const value = constrainValue(params, event.value, event.index);
        context.set("value", (prev) => (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.setValueAtIndex)(prev, event.index, value));
      },
      setValue(params) {
        const { context, event } = params;
        const value = normalizeValues(params, event.value);
        context.set("value", value);
      }
    }
  }
});
var props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_4__.createProps)()([
  "aria-label",
  "aria-labelledby",
  "dir",
  "disabled",
  "form",
  "getAriaValueText",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "max",
  "min",
  "minStepsBetweenThumbs",
  "name",
  "onFocusChange",
  "onValueChange",
  "onValueChangeEnd",
  "orientation",
  "origin",
  "readOnly",
  "step",
  "thumbAlignment",
  "thumbAlignment",
  "thumbSize",
  "value",
  "defaultValue"
]);
var splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.createSplitProps)(props);
var thumbProps = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_4__.createProps)()(["index", "name"]);
var splitThumbProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.createSplitProps)(thumbProps);




/***/ }),

/***/ "./node_modules/@zag-js/store/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@zag-js/store/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   globalRef: () => (/* binding */ globalRef),
/* harmony export */   proxy: () => (/* binding */ proxy),
/* harmony export */   proxyWithComputed: () => (/* binding */ proxyWithComputed),
/* harmony export */   ref: () => (/* binding */ ref),
/* harmony export */   snapshot: () => (/* binding */ snapshot),
/* harmony export */   subscribe: () => (/* binding */ subscribe)
/* harmony export */ });
/* harmony import */ var proxy_compare__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! proxy-compare */ "./node_modules/proxy-compare/dist/index.js");


// src/global.ts
function glob() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function globalRef(key, value) {
  const g = glob();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var refSet = globalRef("__zag__refSet", () => /* @__PURE__ */ new WeakSet());

// src/utils.ts
var isReactElement = (x) => typeof x === "object" && x !== null && "$$typeof" in x && "props" in x;
var isVueElement = (x) => typeof x === "object" && x !== null && "__v_isVNode" in x;
var isDOMElement = (x) => typeof x === "object" && x !== null && "nodeType" in x && typeof x.nodeName === "string";
var isElement = (x) => isReactElement(x) || isVueElement(x) || isDOMElement(x);
var isObject = (x) => x !== null && typeof x === "object";
var canProxy = (x) => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !isElement(x) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer) && !(x instanceof Promise);
var isDev = () => "development" !== "production";

// src/clone.ts
function set(obj, key, val) {
  if (typeof val.value === "object" && !canProxy(val.value)) val.value = clone(val.value);
  if (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === "__proto__") {
    Object.defineProperty(obj, key, val);
  } else obj[key] = val.value;
}
function clone(x) {
  if (typeof x !== "object") return x;
  var i = 0, k, list, tmp, str = Object.prototype.toString.call(x);
  if (str === "[object Object]") {
    tmp = Object.create(Object.getPrototypeOf(x) || null);
  } else if (str === "[object Array]") {
    tmp = Array(x.length);
  } else if (str === "[object Set]") {
    tmp = /* @__PURE__ */ new Set();
    x.forEach(function(val) {
      tmp.add(clone(val));
    });
  } else if (str === "[object Map]") {
    tmp = /* @__PURE__ */ new Map();
    x.forEach(function(val, key) {
      tmp.set(clone(key), clone(val));
    });
  } else if (str === "[object Date]") {
    tmp = /* @__PURE__ */ new Date(+x);
  } else if (str === "[object RegExp]") {
    tmp = new RegExp(x.source, x.flags);
  } else if (str === "[object DataView]") {
    tmp = new x.constructor(clone(x.buffer));
  } else if (str === "[object ArrayBuffer]") {
    tmp = x.slice(0);
  } else if (str === "[object Blob]") {
    tmp = x.slice();
  } else if (str.slice(-6) === "Array]") {
    tmp = new x.constructor(x);
  }
  if (tmp) {
    for (list = Object.getOwnPropertySymbols(x); i < list.length; i++) {
      set(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));
    }
    for (i = 0, list = Object.getOwnPropertyNames(x); i < list.length; i++) {
      if (Object.hasOwnProperty.call(tmp, k = list[i]) && tmp[k] === x[k]) continue;
      set(tmp, k, Object.getOwnPropertyDescriptor(x, k));
    }
  }
  return tmp || x;
}
var proxyStateMap = globalRef("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version) => {
  const cache = snapCache.get(target);
  if (cache?.[0] === version) {
    return cache[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.markToTrack)(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet.has(value)) {
      (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.markToTrack)(value, false);
      snap[key] = value;
    } else if (proxyStateMap.has(value)) {
      snap[key] = snapshot(value);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction2 = (initialObject) => {
  if (!isObject(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      entry[1]?.();
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove], prop) => {
          if (remove) {
            remove();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject(value)) {
        value = (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.getUntracked)(value) || value;
      }
      let nextValue = value;
      if (Object.getOwnPropertyDescriptor(target, prop)?.set) ; else {
        if (!proxyStateMap.has(value) && canProxy(value)) {
          nextValue = proxy(value);
        }
        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction2,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  objectIs,
  newProxy,
  canProxy,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return proxyFunction(initialObject);
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (isDev() && !proxyState) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const addListener = proxyState[3];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener = addListener(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener();
  };
}
function snapshot(proxyObject) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (isDev() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion());
}
function ref(obj) {
  refSet.add(obj);
  return obj;
}

// src/proxy-computed.ts
function proxyWithComputed(initialObject, computedFns) {
  const keys = Object.keys(computedFns);
  keys.forEach((key) => {
    if (Object.getOwnPropertyDescriptor(initialObject, key)) {
      throw new Error("object property already defined");
    }
    const computedFn = computedFns[key];
    const { get, set: set2 } = typeof computedFn === "function" ? { get: computedFn } : computedFn;
    const desc = {};
    desc.get = () => get(snapshot(proxyObject));
    if (set2) {
      desc.set = (newValue) => set2(proxyObject, newValue);
    }
    Object.defineProperty(initialObject, key, desc);
  });
  const proxyObject = proxy(initialObject);
  return proxyObject;
}




/***/ }),

/***/ "./node_modules/@zag-js/switch/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@zag-js/switch/dist/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anatomy: () => (/* binding */ anatomy),
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   machine: () => (/* binding */ machine),
/* harmony export */   props: () => (/* binding */ props),
/* harmony export */   splitProps: () => (/* binding */ splitProps)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_focus_visible__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/focus-visible */ "./node_modules/@zag-js/focus-visible/dist/index.mjs");
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");







// src/switch.anatomy.ts
var anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("switch").parts("root", "label", "control", "thumb");
var parts = anatomy.build();

// src/switch.dom.ts
var getRootId = (ctx) => ctx.ids?.root ?? `switch:${ctx.id}`;
var getLabelId = (ctx) => ctx.ids?.label ?? `switch:${ctx.id}:label`;
var getThumbId = (ctx) => ctx.ids?.thumb ?? `switch:${ctx.id}:thumb`;
var getControlId = (ctx) => ctx.ids?.control ?? `switch:${ctx.id}:control`;
var getHiddenInputId = (ctx) => ctx.ids?.hiddenInput ?? `switch:${ctx.id}:input`;
var getRootEl = (ctx) => ctx.getById(getRootId(ctx));
var getHiddenInputEl = (ctx) => ctx.getById(getHiddenInputId(ctx));

// src/switch.connect.ts
function connect(service, normalize) {
  const { context, send, prop, scope } = service;
  const disabled = prop("disabled");
  const readOnly = prop("readOnly");
  const checked = !!context.get("checked");
  const focused = !disabled && context.get("focused");
  const focusVisible = !disabled && context.get("focusVisible");
  const dataAttrs = {
    "data-active": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(context.get("active")),
    "data-focus": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(focused),
    "data-focus-visible": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(focusVisible),
    "data-readonly": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(readOnly),
    "data-hover": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(context.get("hovered")),
    "data-disabled": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),
    "data-state": checked ? "checked" : "unchecked",
    "data-invalid": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(prop("invalid"))
  };
  return {
    checked,
    disabled,
    focused,
    setChecked(checked2) {
      send({ type: "CHECKED.SET", checked: checked2, isTrusted: false });
    },
    toggleChecked() {
      send({ type: "CHECKED.TOGGLE", checked, isTrusted: false });
    },
    getRootProps() {
      return normalize.label({
        ...parts.root.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        id: getRootId(scope),
        htmlFor: getHiddenInputId(scope),
        onPointerMove() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: true } });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: false } });
        },
        onClick(event) {
          if (disabled) return;
          const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getEventTarget)(event);
          if (target === getHiddenInputEl(scope)) {
            event.stopPropagation();
          }
          if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.isSafari)()) {
            getHiddenInputEl(scope)?.focus();
          }
        }
      });
    },
    getLabelProps() {
      return normalize.element({
        ...parts.label.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        id: getLabelId(scope)
      });
    },
    getThumbProps() {
      return normalize.element({
        ...parts.thumb.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        id: getThumbId(scope),
        "aria-hidden": true
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts.control.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        id: getControlId(scope),
        "aria-hidden": true
      });
    },
    getHiddenInputProps() {
      return normalize.input({
        id: getHiddenInputId(scope),
        type: "checkbox",
        required: prop("required"),
        defaultChecked: checked,
        disabled,
        "aria-labelledby": getLabelId(scope),
        "aria-invalid": prop("invalid"),
        name: prop("name"),
        form: prop("form"),
        value: prop("value"),
        style: _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.visuallyHiddenStyle,
        onFocus() {
          const focusVisible2 = (0,_zag_js_focus_visible__WEBPACK_IMPORTED_MODULE_2__.isFocusVisible)();
          send({ type: "CONTEXT.SET", context: { focused: true, focusVisible: focusVisible2 } });
        },
        onBlur() {
          send({ type: "CONTEXT.SET", context: { focused: false, focusVisible: false } });
        },
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          const checked2 = event.currentTarget.checked;
          send({ type: "CHECKED.SET", checked: checked2, isTrusted: true });
        }
      });
    }
  };
}
var { not } = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_3__.createGuards)();
var machine = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_3__.createMachine)({
  props({ props: props2 }) {
    return {
      defaultChecked: false,
      label: "switch",
      value: "on",
      ...props2
    };
  },
  initialState() {
    return "ready";
  },
  context({ prop, bindable }) {
    return {
      checked: bindable(() => ({
        defaultValue: prop("defaultChecked"),
        value: prop("checked"),
        onChange(value) {
          prop("onCheckedChange")?.({ checked: value });
        }
      })),
      fieldsetDisabled: bindable(() => ({
        defaultValue: false
      })),
      focusVisible: bindable(() => ({
        defaultValue: false
      })),
      active: bindable(() => ({
        defaultValue: false
      })),
      focused: bindable(() => ({
        defaultValue: false
      })),
      hovered: bindable(() => ({
        defaultValue: false
      }))
    };
  },
  computed: {
    isDisabled: ({ context, prop }) => prop("disabled") || context.get("fieldsetDisabled")
  },
  watch({ track, prop, context, action }) {
    track([() => prop("disabled")], () => {
      action(["removeFocusIfNeeded"]);
    });
    track([() => context.get("checked")], () => {
      action(["syncInputElement"]);
    });
  },
  effects: ["trackFormControlState", "trackPressEvent", "trackFocusVisible"],
  on: {
    "CHECKED.TOGGLE": [
      {
        guard: not("isTrusted"),
        actions: ["toggleChecked", "dispatchChangeEvent"]
      },
      {
        actions: ["toggleChecked"]
      }
    ],
    "CHECKED.SET": [
      {
        guard: not("isTrusted"),
        actions: ["setChecked", "dispatchChangeEvent"]
      },
      {
        actions: ["setChecked"]
      }
    ],
    "CONTEXT.SET": {
      actions: ["setContext"]
    }
  },
  states: {
    ready: {}
  },
  implementations: {
    guards: {
      isTrusted: ({ event }) => !!event.isTrusted
    },
    effects: {
      trackPressEvent({ computed, scope, context }) {
        if (computed("isDisabled")) return;
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.trackPress)({
          pointerNode: getRootEl(scope),
          keyboardNode: getHiddenInputEl(scope),
          isValidKey: (event) => event.key === " ",
          onPress: () => context.set("active", false),
          onPressStart: () => context.set("active", true),
          onPressEnd: () => context.set("active", false)
        });
      },
      trackFocusVisible({ computed, scope }) {
        if (computed("isDisabled")) return;
        return (0,_zag_js_focus_visible__WEBPACK_IMPORTED_MODULE_2__.trackFocusVisible)({ root: scope.getRootNode() });
      },
      trackFormControlState({ context, send, scope }) {
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.trackFormControl)(getHiddenInputEl(scope), {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            const checked = context.initial("checked");
            send({ type: "CHECKED.SET", checked: !!checked, src: "form-reset" });
          }
        });
      }
    },
    actions: {
      setContext({ context, event }) {
        for (const key in event.context) {
          context.set(key, event.context[key]);
        }
      },
      syncInputElement({ context, scope }) {
        const inputEl = getHiddenInputEl(scope);
        if (!inputEl) return;
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.setElementChecked)(inputEl, !!context.get("checked"));
      },
      removeFocusIfNeeded({ context, prop }) {
        if (prop("disabled")) {
          context.set("focused", false);
        }
      },
      setChecked({ context, event }) {
        context.set("checked", event.checked);
      },
      toggleChecked({ context }) {
        context.set("checked", !context.get("checked"));
      },
      dispatchChangeEvent({ context, scope }) {
        const inputEl = getHiddenInputEl(scope);
        (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dispatchInputCheckedEvent)(inputEl, { checked: context.get("checked") });
      }
    }
  }
});
var props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_4__.createProps)()([
  "checked",
  "defaultChecked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "label",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
var splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_5__.createSplitProps)(props);




/***/ }),

/***/ "./node_modules/@zag-js/tooltip/dist/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@zag-js/tooltip/dist/index.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anatomy: () => (/* binding */ anatomy),
/* harmony export */   connect: () => (/* binding */ connect),
/* harmony export */   machine: () => (/* binding */ machine),
/* harmony export */   props: () => (/* binding */ props),
/* harmony export */   splitProps: () => (/* binding */ splitProps)
/* harmony export */ });
/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ "./node_modules/@zag-js/anatomy/dist/index.mjs");
/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/dom-query */ "./node_modules/@zag-js/dom-query/dist/index.mjs");
/* harmony import */ var _zag_js_focus_visible__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/focus-visible */ "./node_modules/@zag-js/focus-visible/dist/index.mjs");
/* harmony import */ var _zag_js_popper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/popper */ "./node_modules/@zag-js/popper/dist/index.mjs");
/* harmony import */ var _zag_js_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/store */ "./node_modules/@zag-js/store/dist/index.mjs");
/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @zag-js/core */ "./node_modules/@zag-js/core/dist/index.mjs");
/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @zag-js/types */ "./node_modules/@zag-js/types/dist/index.mjs");
/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @zag-js/utils */ "./node_modules/@zag-js/utils/dist/index.mjs");









// src/tooltip.anatomy.ts
var anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)("tooltip").parts("trigger", "arrow", "arrowTip", "positioner", "content");
var parts = anatomy.build();

// src/tooltip.dom.ts
var getTriggerId = (scope) => scope.ids?.trigger ?? `tooltip:${scope.id}:trigger`;
var getContentId = (scope) => scope.ids?.content ?? `tooltip:${scope.id}:content`;
var getArrowId = (scope) => scope.ids?.arrow ?? `tooltip:${scope.id}:arrow`;
var getPositionerId = (scope) => scope.ids?.positioner ?? `tooltip:${scope.id}:popper`;
var getTriggerEl = (scope) => scope.getById(getTriggerId(scope));
var getPositionerEl = (scope) => scope.getById(getPositionerId(scope));
var store = (0,_zag_js_store__WEBPACK_IMPORTED_MODULE_1__.proxy)({ id: null });

// src/tooltip.connect.ts
function connect(service, normalize) {
  const { state, context, send, scope, prop, event: _event } = service;
  const id = prop("id");
  const hasAriaLabel = !!prop("aria-label");
  const open = state.matches("open", "closing");
  const triggerId = getTriggerId(scope);
  const contentId = getContentId(scope);
  const disabled = prop("disabled");
  const popperStyles = (0,_zag_js_popper__WEBPACK_IMPORTED_MODULE_2__.getPlacementStyles)({
    ...prop("positioning"),
    placement: context.get("currentPlacement")
  });
  return {
    open,
    setOpen(nextOpen) {
      const open2 = state.matches("open", "closing");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "open" : "close" });
    },
    reposition(options = {}) {
      send({ type: "positioning.set", options });
    },
    getTriggerProps() {
      return normalize.button({
        ...parts.trigger.attrs,
        id: triggerId,
        dir: prop("dir"),
        "data-expanded": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_3__.dataAttr)(open),
        "data-state": open ? "open" : "closed",
        "aria-describedby": open ? contentId : void 0,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (!prop("closeOnClick")) return;
          send({ type: "close", src: "trigger.click" });
        },
        onFocus(event) {
          queueMicrotask(() => {
            if (event.defaultPrevented) return;
            if (disabled) return;
            if (_event.src === "trigger.pointerdown") return;
            if (!(0,_zag_js_focus_visible__WEBPACK_IMPORTED_MODULE_4__.isFocusVisible)()) return;
            send({ type: "open", src: "trigger.focus" });
          });
        },
        onBlur(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (id === store.id) {
            send({ type: "close", src: "trigger.blur" });
          }
        },
        onPointerDown(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (!prop("closeOnPointerDown")) return;
          if (id === store.id) {
            send({ type: "close", src: "trigger.pointerdown" });
          }
        },
        onPointerMove(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (event.pointerType === "touch") return;
          send({ type: "pointer.move" });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "pointer.leave" });
        },
        onPointerCancel() {
          if (disabled) return;
          send({ type: "pointer.leave" });
        }
      });
    },
    getArrowProps() {
      return normalize.element({
        id: getArrowId(scope),
        ...parts.arrow.attrs,
        dir: prop("dir"),
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize.element({
        ...parts.arrowTip.attrs,
        dir: prop("dir"),
        style: popperStyles.arrowTip
      });
    },
    getPositionerProps() {
      return normalize.element({
        id: getPositionerId(scope),
        ...parts.positioner.attrs,
        dir: prop("dir"),
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize.element({
        ...parts.content.attrs,
        dir: prop("dir"),
        hidden: !open,
        "data-state": open ? "open" : "closed",
        role: hasAriaLabel ? void 0 : "tooltip",
        id: hasAriaLabel ? void 0 : contentId,
        "data-placement": context.get("currentPlacement"),
        onPointerEnter() {
          send({ type: "content.pointer.move" });
        },
        onPointerLeave() {
          send({ type: "content.pointer.leave" });
        },
        style: {
          pointerEvents: prop("interactive") ? "auto" : "none"
        }
      });
    }
  };
}
var { and, not } = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_5__.createGuards)();
var machine = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_5__.createMachine)({
  initialState: ({ prop }) => {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "closed";
  },
  props({ props: props2 }) {
    return {
      id: "x",
      openDelay: 1e3,
      closeDelay: 500,
      closeOnPointerDown: true,
      closeOnEscape: true,
      interactive: false,
      closeOnScroll: true,
      closeOnClick: true,
      disabled: false,
      ...props2,
      positioning: {
        placement: "bottom",
        ...props2.positioning
      }
    };
  },
  effects: ["trackFocusVisible", "trackStore"],
  context: ({ bindable }) => ({
    currentPlacement: bindable(() => ({ defaultValue: void 0 })),
    hasPointerMoveOpened: bindable(() => ({ defaultValue: false }))
  }),
  watch({ track, action, prop }) {
    track([() => prop("disabled")], () => {
      action(["closeIfDisabled"]);
    });
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  states: {
    closed: {
      entry: ["clearGlobalId"],
      on: {
        "controlled.open": {
          target: "open"
        },
        open: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        "pointer.leave": {
          actions: ["clearPointerMoveOpened"]
        },
        "pointer.move": [
          {
            guard: and("noVisibleTooltip", not("hasPointerMoveOpened")),
            target: "opening"
          },
          {
            guard: not("hasPointerMoveOpened"),
            target: "open",
            actions: ["setPointerMoveOpened", "invokeOnOpen"]
          }
        ]
      }
    },
    opening: {
      effects: ["trackScroll", "trackPointerlockChange", "waitForOpenDelay"],
      on: {
        "after.openDelay": [
          {
            guard: "isOpenControlled",
            actions: ["setPointerMoveOpened", "invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setPointerMoveOpened", "invokeOnOpen"]
          }
        ],
        "controlled.open": {
          target: "open"
        },
        "controlled.close": {
          target: "closed"
        },
        open: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        "pointer.leave": [
          {
            guard: "isOpenControlled",
            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
            actions: ["clearPointerMoveOpened", "invokeOnClose", "toggleVisibility"]
          },
          {
            target: "closed",
            actions: ["clearPointerMoveOpened", "invokeOnClose"]
          }
        ],
        close: [
          {
            guard: "isOpenControlled",
            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
            actions: ["invokeOnClose", "toggleVisibility"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ]
      }
    },
    open: {
      effects: ["trackEscapeKey", "trackScroll", "trackPointerlockChange", "trackPositioning"],
      entry: ["setGlobalId"],
      on: {
        "controlled.close": {
          target: "closed"
        },
        close: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "pointer.leave": [
          {
            guard: "isVisible",
            target: "closing",
            actions: ["clearPointerMoveOpened"]
          },
          // == group ==
          {
            guard: "isOpenControlled",
            actions: ["clearPointerMoveOpened", "invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["clearPointerMoveOpened", "invokeOnClose"]
          }
        ],
        "content.pointer.leave": {
          guard: "isInteractive",
          target: "closing"
        },
        "positioning.set": {
          actions: ["reposition"]
        }
      }
    },
    closing: {
      effects: ["trackPositioning", "waitForCloseDelay"],
      on: {
        "after.closeDelay": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "controlled.close": {
          target: "closed"
        },
        "controlled.open": {
          target: "open"
        },
        close: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "pointer.move": [
          {
            guard: "isOpenControlled",
            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
            actions: ["setPointerMoveOpened", "invokeOnOpen", "toggleVisibility"]
          },
          {
            target: "open",
            actions: ["setPointerMoveOpened", "invokeOnOpen"]
          }
        ],
        "content.pointer.move": {
          guard: "isInteractive",
          target: "open"
        },
        "positioning.set": {
          actions: ["reposition"]
        }
      }
    }
  },
  implementations: {
    guards: {
      noVisibleTooltip: () => store.id === null,
      isVisible: ({ prop }) => prop("id") === store.id,
      isInteractive: ({ prop }) => !!prop("interactive"),
      hasPointerMoveOpened: ({ context }) => context.get("hasPointerMoveOpened"),
      isOpenControlled: ({ prop }) => prop("open") !== void 0
    },
    actions: {
      setGlobalId: ({ prop }) => {
        store.id = prop("id");
      },
      clearGlobalId: ({ prop }) => {
        if (prop("id") === store.id) {
          store.id = null;
        }
      },
      invokeOnOpen: ({ prop }) => {
        prop("onOpenChange")?.({ open: true });
      },
      invokeOnClose: ({ prop }) => {
        prop("onOpenChange")?.({ open: false });
      },
      closeIfDisabled: ({ prop, send }) => {
        if (!prop("disabled")) return;
        send({ type: "close", src: "disabled.change" });
      },
      reposition: ({ context, event, prop, scope }) => {
        if (event.type !== "positioning.set") return;
        const getPositionerEl2 = () => getPositionerEl(scope);
        return (0,_zag_js_popper__WEBPACK_IMPORTED_MODULE_2__.getPlacement)(getTriggerEl(scope), getPositionerEl2, {
          ...prop("positioning"),
          ...event.options,
          defer: true,
          listeners: false,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      toggleVisibility: ({ prop, event, send }) => {
        queueMicrotask(() => {
          send({
            type: prop("open") ? "controlled.open" : "controlled.close",
            previousEvent: event
          });
        });
      },
      setPointerMoveOpened: ({ context }) => {
        context.set("hasPointerMoveOpened", true);
      },
      clearPointerMoveOpened: ({ context }) => {
        context.set("hasPointerMoveOpened", false);
      }
    },
    effects: {
      trackFocusVisible: ({ scope }) => {
        return (0,_zag_js_focus_visible__WEBPACK_IMPORTED_MODULE_4__.trackFocusVisible)({ root: scope.getRootNode?.() });
      },
      trackPositioning: ({ context, prop, scope }) => {
        if (!context.get("currentPlacement")) {
          context.set("currentPlacement", prop("positioning").placement);
        }
        const getPositionerEl2 = () => getPositionerEl(scope);
        return (0,_zag_js_popper__WEBPACK_IMPORTED_MODULE_2__.getPlacement)(getTriggerEl(scope), getPositionerEl2, {
          ...prop("positioning"),
          defer: true,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      trackPointerlockChange: ({ send, scope }) => {
        const doc = scope.getDoc();
        const onChange = () => send({ type: "close", src: "pointerlock:change" });
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_3__.addDomEvent)(doc, "pointerlockchange", onChange, false);
      },
      trackScroll: ({ send, prop, scope }) => {
        if (!prop("closeOnScroll")) return;
        const triggerEl = getTriggerEl(scope);
        if (!triggerEl) return;
        const overflowParents = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_3__.getOverflowAncestors)(triggerEl);
        const cleanups = overflowParents.map((overflowParent) => {
          const onScroll = () => {
            send({ type: "close", src: "scroll" });
          };
          return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_3__.addDomEvent)(overflowParent, "scroll", onScroll, {
            passive: true,
            capture: true
          });
        });
        return () => {
          cleanups.forEach((fn) => fn?.());
        };
      },
      trackStore: ({ prop, send }) => {
        let cleanup;
        queueMicrotask(() => {
          cleanup = (0,_zag_js_store__WEBPACK_IMPORTED_MODULE_1__.subscribe)(store, () => {
            if (store.id !== prop("id")) {
              send({ type: "close", src: "id.change" });
            }
          });
        });
        return () => cleanup?.();
      },
      trackEscapeKey: ({ send, prop }) => {
        if (!prop("closeOnEscape")) return;
        const onKeyDown = (event) => {
          if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_3__.isComposingEvent)(event)) return;
          if (event.key !== "Escape") return;
          event.stopPropagation();
          send({ type: "close", src: "keydown.escape" });
        };
        return (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_3__.addDomEvent)(document, "keydown", onKeyDown, true);
      },
      waitForOpenDelay: ({ send, prop }) => {
        const id = setTimeout(() => {
          send({ type: "after.openDelay" });
        }, prop("openDelay"));
        return () => clearTimeout(id);
      },
      waitForCloseDelay: ({ send, prop }) => {
        const id = setTimeout(() => {
          send({ type: "after.closeDelay" });
        }, prop("closeDelay"));
        return () => clearTimeout(id);
      }
    }
  }
});
var props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_6__.createProps)()([
  "aria-label",
  "closeDelay",
  "closeOnEscape",
  "closeOnPointerDown",
  "closeOnScroll",
  "closeOnClick",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "interactive",
  "onOpenChange",
  "defaultOpen",
  "open",
  "openDelay",
  "positioning"
]);
var splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_7__.createSplitProps)(props);




/***/ }),

/***/ "./node_modules/@zag-js/types/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@zag-js/types/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createNormalizer: () => (/* binding */ createNormalizer),
/* harmony export */   createProps: () => (/* binding */ createProps)
/* harmony export */ });
// src/prop-types.ts
function createNormalizer(fn) {
  return new Proxy({}, {
    get(_target, key) {
      if (key === "style")
        return (props) => {
          return fn({ style: props }).style;
        };
      return fn;
    }
  });
}

// src/create-props.ts
var createProps = () => (props) => Array.from(new Set(props));




/***/ }),

/***/ "./node_modules/@zag-js/utils/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@zag-js/utils/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   addOrRemove: () => (/* binding */ addOrRemove),
/* harmony export */   callAll: () => (/* binding */ callAll),
/* harmony export */   cast: () => (/* binding */ cast),
/* harmony export */   chunk: () => (/* binding */ chunk),
/* harmony export */   clampPercent: () => (/* binding */ clampPercent),
/* harmony export */   clampValue: () => (/* binding */ clampValue),
/* harmony export */   clear: () => (/* binding */ clear),
/* harmony export */   compact: () => (/* binding */ compact),
/* harmony export */   createSplitProps: () => (/* binding */ createSplitProps),
/* harmony export */   decrementValue: () => (/* binding */ decrementValue),
/* harmony export */   ensure: () => (/* binding */ ensure),
/* harmony export */   ensureProps: () => (/* binding */ ensureProps),
/* harmony export */   first: () => (/* binding */ first),
/* harmony export */   flatArray: () => (/* binding */ flatArray),
/* harmony export */   fromLength: () => (/* binding */ fromLength),
/* harmony export */   getClosestValue: () => (/* binding */ getClosestValue),
/* harmony export */   getClosestValueIndex: () => (/* binding */ getClosestValueIndex),
/* harmony export */   getMaxValueAtIndex: () => (/* binding */ getMaxValueAtIndex),
/* harmony export */   getMinValueAtIndex: () => (/* binding */ getMinValueAtIndex),
/* harmony export */   getNextStepValue: () => (/* binding */ getNextStepValue),
/* harmony export */   getPercentValue: () => (/* binding */ getPercentValue),
/* harmony export */   getPreviousStepValue: () => (/* binding */ getPreviousStepValue),
/* harmony export */   getValuePercent: () => (/* binding */ getValuePercent),
/* harmony export */   getValueRanges: () => (/* binding */ getValueRanges),
/* harmony export */   getValueSetterAtIndex: () => (/* binding */ getValueSetterAtIndex),
/* harmony export */   getValueTransformer: () => (/* binding */ getValueTransformer),
/* harmony export */   has: () => (/* binding */ has),
/* harmony export */   hasProp: () => (/* binding */ hasProp),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   incrementValue: () => (/* binding */ incrementValue),
/* harmony export */   insertAt: () => (/* binding */ insertAt),
/* harmony export */   invariant: () => (/* binding */ invariant),
/* harmony export */   isArray: () => (/* binding */ isArray),
/* harmony export */   isBoolean: () => (/* binding */ isBoolean),
/* harmony export */   isDev: () => (/* binding */ isDev),
/* harmony export */   isEmpty: () => (/* binding */ isEmpty),
/* harmony export */   isEqual: () => (/* binding */ isEqual),
/* harmony export */   isFunction: () => (/* binding */ isFunction),
/* harmony export */   isNaN: () => (/* binding */ isNaN),
/* harmony export */   isNull: () => (/* binding */ isNull),
/* harmony export */   isNumber: () => (/* binding */ isNumber),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   isObjectLike: () => (/* binding */ isObjectLike),
/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),
/* harmony export */   isString: () => (/* binding */ isString),
/* harmony export */   isValueAtMax: () => (/* binding */ isValueAtMax),
/* harmony export */   isValueAtMin: () => (/* binding */ isValueAtMin),
/* harmony export */   isValueWithinRange: () => (/* binding */ isValueWithinRange),
/* harmony export */   json: () => (/* binding */ json),
/* harmony export */   last: () => (/* binding */ last),
/* harmony export */   match: () => (/* binding */ match),
/* harmony export */   mod: () => (/* binding */ mod),
/* harmony export */   nan: () => (/* binding */ nan),
/* harmony export */   next: () => (/* binding */ next),
/* harmony export */   nextIndex: () => (/* binding */ nextIndex),
/* harmony export */   noop: () => (/* binding */ noop),
/* harmony export */   omit: () => (/* binding */ omit),
/* harmony export */   pick: () => (/* binding */ pick),
/* harmony export */   prev: () => (/* binding */ prev),
/* harmony export */   prevIndex: () => (/* binding */ prevIndex),
/* harmony export */   remove: () => (/* binding */ remove),
/* harmony export */   removeAt: () => (/* binding */ removeAt),
/* harmony export */   roundToDpr: () => (/* binding */ roundToDpr),
/* harmony export */   roundToStepPrecision: () => (/* binding */ roundToStepPrecision),
/* harmony export */   roundValue: () => (/* binding */ roundValue),
/* harmony export */   runIfFn: () => (/* binding */ runIfFn),
/* harmony export */   setRafInterval: () => (/* binding */ setRafInterval),
/* harmony export */   setRafTimeout: () => (/* binding */ setRafTimeout),
/* harmony export */   setValueAtIndex: () => (/* binding */ setValueAtIndex),
/* harmony export */   snapValueToStep: () => (/* binding */ snapValueToStep),
/* harmony export */   splitProps: () => (/* binding */ splitProps),
/* harmony export */   throttle: () => (/* binding */ throttle),
/* harmony export */   toArray: () => (/* binding */ toArray),
/* harmony export */   toFixedNumber: () => (/* binding */ toFixedNumber),
/* harmony export */   toPx: () => (/* binding */ toPx),
/* harmony export */   tryCatch: () => (/* binding */ tryCatch),
/* harmony export */   uniq: () => (/* binding */ uniq),
/* harmony export */   uuid: () => (/* binding */ uuid),
/* harmony export */   warn: () => (/* binding */ warn),
/* harmony export */   wrap: () => (/* binding */ wrap)
/* harmony export */ });
// src/array.ts
function toArray(v) {
  if (!v) return [];
  return Array.isArray(v) ? v : [v];
}
var fromLength = (length) => Array.from(Array(length).keys());
var first = (v) => v[0];
var last = (v) => v[v.length - 1];
var isEmpty = (v) => v.length === 0;
var has = (v, t) => v.indexOf(t) !== -1;
var add = (v, ...items) => v.concat(items);
var remove = (v, ...items) => v.filter((t) => !items.includes(t));
var removeAt = (v, i) => v.filter((_, idx) => idx !== i);
var insertAt = (v, i, ...items) => [...v.slice(0, i), ...items, ...v.slice(i)];
var uniq = (v) => Array.from(new Set(v));
var addOrRemove = (v, item) => {
  if (has(v, item)) return remove(v, item);
  return add(v, item);
};
function clear(v) {
  while (v.length > 0) v.pop();
  return v;
}
function nextIndex(v, idx, opts = {}) {
  const { step = 1, loop = true } = opts;
  const next2 = idx + step;
  const len = v.length;
  const last2 = len - 1;
  if (idx === -1) return step > 0 ? 0 : last2;
  if (next2 < 0) return loop ? last2 : 0;
  if (next2 >= len) return loop ? 0 : idx > len ? len : idx;
  return next2;
}
function next(v, idx, opts = {}) {
  return v[nextIndex(v, idx, opts)];
}
function prevIndex(v, idx, opts = {}) {
  const { step = 1, loop = true } = opts;
  return nextIndex(v, idx, { step: -step, loop });
}
function prev(v, index, opts = {}) {
  return v[prevIndex(v, index, opts)];
}
var chunk = (v, size) => {
  const res = [];
  return v.reduce((rows, value, index) => {
    if (index % size === 0) rows.push([value]);
    else last(rows)?.push(value);
    return rows;
  }, res);
};
function flatArray(arr) {
  return arr.reduce((flat, item) => {
    if (Array.isArray(item)) {
      return flat.concat(flatArray(item));
    }
    return flat.concat(item);
  }, []);
}

// src/equal.ts
var isArrayLike = (value) => value?.constructor.name === "Array";
var isArrayEqual = (a, b) => {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (!isEqual(a[i], b[i])) return false;
  }
  return true;
};
var isEqual = (a, b) => {
  if (Object.is(a, b)) return true;
  if (a == null && b != null || a != null && b == null) return false;
  if (typeof a?.isEqual === "function" && typeof b?.isEqual === "function") {
    return a.isEqual(b);
  }
  if (typeof a === "function" && typeof b === "function") {
    return a.toString() === b.toString();
  }
  if (isArrayLike(a) && isArrayLike(b)) {
    return isArrayEqual(Array.from(a), Array.from(b));
  }
  if (!(typeof a === "object") || !(typeof b === "object")) return false;
  const keys = Object.keys(b ?? /* @__PURE__ */ Object.create(null));
  const length = keys.length;
  for (let i = 0; i < length; i++) {
    const hasKey = Reflect.has(a, keys[i]);
    if (!hasKey) return false;
  }
  for (let i = 0; i < length; i++) {
    const key = keys[i];
    if (!isEqual(a[key], b[key])) return false;
  }
  return true;
};

// src/guard.ts
var isDev = () => "development" !== "production";
var isArray = (v) => Array.isArray(v);
var isBoolean = (v) => v === true || v === false;
var isObjectLike = (v) => v != null && typeof v === "object";
var isObject = (v) => isObjectLike(v) && !isArray(v);
var isNumber = (v) => typeof v === "number" && !Number.isNaN(v);
var isString = (v) => typeof v === "string";
var isFunction = (v) => typeof v === "function";
var isNull = (v) => v == null;
var hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
var baseGetTag = (v) => Object.prototype.toString.call(v);
var fnToString = Function.prototype.toString;
var objectCtorString = fnToString.call(Object);
var isPlainObject = (v) => {
  if (!isObjectLike(v) || baseGetTag(v) != "[object Object]") return false;
  const proto = Object.getPrototypeOf(v);
  if (proto === null) return true;
  const Ctor = hasProp(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && fnToString.call(Ctor) == objectCtorString;
};

// src/functions.ts
var runIfFn = (v, ...a) => {
  const res = typeof v === "function" ? v(...a) : v;
  return res ?? void 0;
};
var cast = (v) => v;
var identity = (v) => v();
var noop = () => {
};
var callAll = (...fns) => (...a) => {
  fns.forEach(function(fn) {
    fn?.(...a);
  });
};
var uuid = /* @__PURE__ */ (() => {
  let id = 0;
  return () => {
    id++;
    return id.toString(36);
  };
})();
function match(key, record, ...args) {
  if (key in record) {
    const fn = record[key];
    return isFunction(fn) ? fn(...args) : fn;
  }
  const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`);
  Error.captureStackTrace?.(error, match);
  throw error;
}
var tryCatch = (fn, fallback) => {
  try {
    return fn();
  } catch (error) {
    if (error instanceof Error) {
      Error.captureStackTrace?.(error, tryCatch);
    }
    return fallback?.();
  }
};
function throttle(fn, wait = 0) {
  let lastCall = 0;
  let timeout = null;
  return (...args) => {
    const now = Date.now();
    const timeSinceLastCall = now - lastCall;
    if (timeSinceLastCall >= wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      fn(...args);
      lastCall = now;
    } else if (!timeout) {
      timeout = setTimeout(() => {
        fn(...args);
        lastCall = Date.now();
        timeout = null;
      }, wait - timeSinceLastCall);
    }
  };
}

// src/number.ts
var { floor, abs, round, min, max, pow, sign } = Math;
var isNaN = (v) => Number.isNaN(v);
var nan = (v) => isNaN(v) ? 0 : v;
var mod = (v, m) => (v % m + m) % m;
var wrap = (v, vmax) => (v % vmax + vmax) % vmax;
var getMinValueAtIndex = (i, v, vmin) => i === 0 ? vmin : v[i - 1];
var getMaxValueAtIndex = (i, v, vmax) => i === v.length - 1 ? vmax : v[i + 1];
var isValueAtMax = (v, vmax) => nan(v) >= vmax;
var isValueAtMin = (v, vmin) => nan(v) <= vmin;
var isValueWithinRange = (v, vmin, vmax) => nan(v) >= vmin && nan(v) <= vmax;
var roundValue = (v, vmin, step) => round((nan(v) - vmin) / step) * step + vmin;
var clampValue = (v, vmin, vmax) => min(max(nan(v), vmin), vmax);
var clampPercent = (v) => clampValue(v, 0, 1);
var getValuePercent = (v, vmin, vmax) => (nan(v) - vmin) / (vmax - vmin);
var getPercentValue = (p, vmin, vmax, step) => clampValue(roundValue(p * (vmax - vmin) + vmin, vmin, step), vmin, vmax);
var roundToStepPrecision = (v, step) => {
  let rv = v;
  let ss = step.toString();
  let pi = ss.indexOf(".");
  let p = pi >= 0 ? ss.length - pi : 0;
  if (p > 0) {
    let pw = pow(10, p);
    rv = round(rv * pw) / pw;
  }
  return rv;
};
var roundToDpr = (v, dpr) => typeof dpr === "number" ? floor(v * dpr + 0.5) / dpr : round(v);
var snapValueToStep = (v, vmin, vmax, step) => {
  vmin = Number(vmin);
  vmax = Number(vmax);
  let remainder = (v - (isNaN(vmin) ? 0 : vmin)) % step;
  let sv = roundToStepPrecision(
    abs(remainder) * 2 >= step ? v + sign(remainder) * (step - abs(remainder)) : v - remainder,
    step
  );
  if (!isNaN(vmin)) {
    if (sv < vmin) {
      sv = vmin;
    } else if (!isNaN(vmax) && sv > vmax) {
      sv = vmin + floor(roundToStepPrecision((vmax - vmin) / step, step)) * step;
    }
  } else if (!isNaN(vmax) && sv > vmax) {
    sv = vmin + floor(roundToStepPrecision((vmax - vmin) / step, step)) * step;
  }
  return roundToStepPrecision(sv, step);
};
var setValueAtIndex = (vs, i, v) => {
  if (vs[i] === v) return vs;
  return [...vs.slice(0, i), v, ...vs.slice(i + 1)];
};
function getValueSetterAtIndex(index, ctx) {
  const minValueAtIndex = getMinValueAtIndex(index, ctx.values, ctx.min);
  const maxValueAtIndex = getMaxValueAtIndex(index, ctx.values, ctx.max);
  let nextValues = ctx.values.slice();
  return function setValue(value) {
    let nextValue = snapValueToStep(value, minValueAtIndex, maxValueAtIndex, ctx.step);
    nextValues = setValueAtIndex(nextValues, index, value);
    nextValues[index] = nextValue;
    return nextValues;
  };
}
function getNextStepValue(index, ctx) {
  const nextValue = ctx.values[index] + ctx.step;
  return getValueSetterAtIndex(index, ctx)(nextValue);
}
function getPreviousStepValue(index, ctx) {
  const nextValue = ctx.values[index] - ctx.step;
  return getValueSetterAtIndex(index, ctx)(nextValue);
}
var getClosestValueIndex = (vs, t) => {
  let i = vs.findIndex((v) => t - v < 0);
  if (i === 0) return i;
  if (i === -1) return vs.length - 1;
  let vLeft = vs[i - 1];
  let vRight = vs[i];
  if (abs(vLeft - t) < abs(vRight - t)) return i - 1;
  return i;
};
var getClosestValue = (vs, t) => vs[getClosestValueIndex(vs, t)];
var getValueRanges = (vs, vmin, vmax, gap) => vs.map((v, i) => ({
  min: i === 0 ? vmin : vs[i - 1] + gap,
  max: i === vs.length - 1 ? vmax : vs[i + 1] - gap,
  value: v
}));
var getValueTransformer = (va, vb) => {
  const [a, b] = va;
  const [c, d] = vb;
  return (v) => a === b || c === d ? c : c + (d - c) / (b - a) * (v - a);
};
var toFixedNumber = (v, d = 0, b = 10) => {
  const pow2 = Math.pow(b, d);
  return round(v * pow2) / pow2;
};
var countDecimals = (value) => {
  if (!Number.isFinite(value)) return 0;
  let e = 1, p = 0;
  while (Math.round(value * e) / e !== value) {
    e *= 10;
    p += 1;
  }
  return p;
};
var decimalOp = (a, op, b) => {
  let result = op === "+" ? a + b : a - b;
  if (a % 1 !== 0 || b % 1 !== 0) {
    const multiplier = 10 ** Math.max(countDecimals(a), countDecimals(b));
    a = Math.round(a * multiplier);
    b = Math.round(b * multiplier);
    result = op === "+" ? a + b : a - b;
    result /= multiplier;
  }
  return result;
};
var incrementValue = (v, s) => decimalOp(nan(v), "+", s);
var decrementValue = (v, s) => decimalOp(nan(v), "-", s);
var toPx = (v) => v != null ? `${v}px` : void 0;

// src/object.ts
function compact(obj) {
  if (!isPlainObject2(obj) || obj === void 0) return obj;
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact(value);
    }
  }
  return filtered;
}
var json = (v) => JSON.parse(JSON.stringify(v));
var isPlainObject2 = (v) => {
  return v && typeof v === "object" && v.constructor === Object;
};
function pick(obj, keys) {
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = value;
    }
  }
  return filtered;
}
function splitProps(props, keys) {
  const rest = {};
  const result = {};
  const keySet = new Set(keys);
  for (const key in props) {
    if (keySet.has(key)) {
      result[key] = props[key];
    } else {
      rest[key] = props[key];
    }
  }
  return [result, rest];
}
var createSplitProps = (keys) => {
  return function split(props) {
    return splitProps(props, keys);
  };
};
function omit(obj, keys) {
  return createSplitProps(keys)(obj)[1];
}

// src/timers.ts
function setRafInterval(callback, interval) {
  let start = performance.now();
  let handle;
  function loop(now) {
    handle = requestAnimationFrame(loop);
    const delta = now - start;
    if (delta >= interval) {
      start = now - delta % interval;
      callback({ startMs: start, deltaMs: delta });
    }
  }
  handle = requestAnimationFrame(loop);
  return () => cancelAnimationFrame(handle);
}
function setRafTimeout(callback, delay) {
  const start = performance.now();
  let handle;
  function loop(now) {
    handle = requestAnimationFrame(loop);
    const delta = now - start;
    if (delta >= delay) {
      callback();
    }
  }
  handle = requestAnimationFrame(loop);
  return () => cancelAnimationFrame(handle);
}

// src/warning.ts
function warn(...a) {
  const m = a.length === 1 ? a[0] : a[1];
  const c = a.length === 2 ? a[0] : true;
  if (c && "development" !== "production") {
    console.warn(m);
  }
}
function invariant(...a) {
  const m = a.length === 1 ? a[0] : a[1];
  const c = a.length === 2 ? a[0] : true;
  if (c && "development" !== "production") {
    throw new Error(m);
  }
}
function ensure(c, m) {
  if (c == null) throw new Error(m());
}
function ensureProps(props, keys, scope) {
  let missingKeys = [];
  for (const key of keys) {
    if (props[key] == null) missingKeys.push(key);
  }
  if (missingKeys.length > 0)
    throw new Error(`[zag-js${scope ? ` > ${scope}` : ""}] missing required props: ${missingKeys.join(", ")}`);
}




/***/ }),

/***/ "./node_modules/fast-safe-stringify/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fast-safe-stringify/index.js ***!
  \***************************************************/
/***/ ((module) => {

module.exports = stringify
stringify.default = stringify
stringify.stable = deterministicStringify
stringify.stableStringify = deterministicStringify

var LIMIT_REPLACE_NODE = '[...]'
var CIRCULAR_REPLACE_NODE = '[Circular]'

var arr = []
var replacerStack = []

function defaultOptions () {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  }
}

// Regular stringify
function stringify (obj, replacer, spacer, options) {
  if (typeof options === 'undefined') {
    options = defaultOptions()
  }

  decirc(obj, '', 0, [], undefined, 0, options)
  var res
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(obj, replacer, spacer)
    } else {
      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer)
    }
  } catch (_) {
    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
  } finally {
    while (arr.length !== 0) {
      var part = arr.pop()
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3])
      } else {
        part[0][part[1]] = part[2]
      }
    }
  }
  return res
}

function setReplace (replace, val, k, parent) {
  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k)
  if (propertyDescriptor.get !== undefined) {
    if (propertyDescriptor.configurable) {
      Object.defineProperty(parent, k, { value: replace })
      arr.push([parent, k, val, propertyDescriptor])
    } else {
      replacerStack.push([val, k, replace])
    }
  } else {
    parent[k] = replace
    arr.push([parent, k, val])
  }
}

function decirc (val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1
  var i
  if (typeof val === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)
        return
      }
    }

    if (
      typeof options.depthLimit !== 'undefined' &&
      depth > options.depthLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent)
      return
    }

    if (
      typeof options.edgesLimit !== 'undefined' &&
      edgeIndex + 1 > options.edgesLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent)
      return
    }

    stack.push(val)
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        decirc(val[i], i, i, stack, val, depth, options)
      }
    } else {
      var keys = Object.keys(val)
      for (i = 0; i < keys.length; i++) {
        var key = keys[i]
        decirc(val[key], key, i, stack, val, depth, options)
      }
    }
    stack.pop()
  }
}

// Stable-stringify
function compareFunction (a, b) {
  if (a < b) {
    return -1
  }
  if (a > b) {
    return 1
  }
  return 0
}

function deterministicStringify (obj, replacer, spacer, options) {
  if (typeof options === 'undefined') {
    options = defaultOptions()
  }

  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj
  var res
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(tmp, replacer, spacer)
    } else {
      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer)
    }
  } catch (_) {
    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
  } finally {
    // Ensure that we restore the object as it was.
    while (arr.length !== 0) {
      var part = arr.pop()
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3])
      } else {
        part[0][part[1]] = part[2]
      }
    }
  }
  return res
}

function deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1
  var i
  if (typeof val === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)
        return
      }
    }
    try {
      if (typeof val.toJSON === 'function') {
        return
      }
    } catch (_) {
      return
    }

    if (
      typeof options.depthLimit !== 'undefined' &&
      depth > options.depthLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent)
      return
    }

    if (
      typeof options.edgesLimit !== 'undefined' &&
      edgeIndex + 1 > options.edgesLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent)
      return
    }

    stack.push(val)
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        deterministicDecirc(val[i], i, i, stack, val, depth, options)
      }
    } else {
      // Create a temporary object in the required way
      var tmp = {}
      var keys = Object.keys(val).sort(compareFunction)
      for (i = 0; i < keys.length; i++) {
        var key = keys[i]
        deterministicDecirc(val[key], key, i, stack, val, depth, options)
        tmp[key] = val[key]
      }
      if (typeof parent !== 'undefined') {
        arr.push([parent, k, val])
        parent[k] = tmp
      } else {
        return tmp
      }
    }
    stack.pop()
  }
}

// wraps replacer function to handle values we couldn't replace
// and mark them as replaced value
function replaceGetterValues (replacer) {
  replacer =
    typeof replacer !== 'undefined'
      ? replacer
      : function (k, v) {
        return v
      }
  return function (key, val) {
    if (replacerStack.length > 0) {
      for (var i = 0; i < replacerStack.length; i++) {
        var part = replacerStack[i]
        if (part[1] === key && part[0] === val) {
          val = part[2]
          replacerStack.splice(i, 1)
          break
        }
      }
    }
    return replacer.call(this, key, val)
  }
}


/***/ }),

/***/ "./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var reactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

module.exports = hoistNonReactStatics;


/***/ }),

/***/ "./node_modules/jsge/modules/assetsm/src/AssetsManager.js":
/*!****************************************************************!*\
  !*** ./node_modules/jsge/modules/assetsm/src/AssetsManager.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AssetsManager)
/* harmony export */ });

const PROGRESS_EVENT_TYPE = {
    loadstart: "loadstart", 
    progress: "progress", 
    abort: "abort", 
    error: "error", 
    load: "load", 
    timeout: "timeout"
}

const ERROR_MESSAGES = {
    // Critical
    LOADER_NOT_REGISTERED: " loader is not registered.",
    RECURSION_ERROR: "Too much recursion. Stop iteration.",
    NOT_CORRECT_METHOD_TYPE: "uploadMethod should be instance of Promise and return upload result value",
    XML_FILE_EXTENSION_INCORRECT: " AtlasXML file extension is incorrect, only .xml file supported",
    TILESET_FILE_EXTENSION_INCORRECT: " tileset file extension is not correct, only .tsj, .json, .tsx, .xml files are supported",
    TILEMAP_FILE_EXTENSION_INCORRECT: " tilemap file extension is not correct, only .tmj, .json, .tmx, .xml files are supported",
    INPUT_PARAMS_ARE_INCORRECT: " fileKey and url should be provided",
    // Non critical
    ATLAS_IMAGE_LOADING_FAILED: "Error loading atlas image ",
    TILESET_LOADING_FAILED: "Error loading related tileset ",
    TILEMAP_LOADING_FAILED: "Error loading tilemap ",
    AUDIO_LOADING_FAILED: "Error loading audio ",
    IMAGE_LOADING_FAILED: "Error loading image ",
    XML_FORMAT_INCORRECT: " XML format is not correct.",
}

const FILE_FORMAT = {
    JSON: "JSON",
    XML: "XML",
    UNKNOWN: "UNKNOWN"
}

class Loader {
    /**
     * @type {string}
     */
    #fileType;
    /**
     * @type { (...args: any[]) => Promise<void> }
     */
    #uploadMethod;
    /**
     * name: url
     * @type { Map<string, string[]>}
     */
    #loadingQueue = new Map();
    /**
     * name: file
     * @type { Map<string, any>}
     */
    #store = new Map();
    /**
     * 
     * @param {string} name 
     * @param {Function} uploadMethod 
     */

    constructor(name, uploadMethod) {
        this.#fileType = name;
        this.#uploadMethod = (key, url, ...args) => {
            const upload = uploadMethod(key, url, ...args);
            if (upload instanceof Promise) {
                return upload.then((uploadResult) => this.#processUploadResult(uploadResult, key));
            } else {
                throw new TypeError(ERROR_MESSAGES.NOT_CORRECT_METHOD_TYPE);
            }
        }
    }

    /**
     * 
     * @param {null | Object} uploadResult 
     * @param {string} key 
     * @returns {Promise<void>}
     */
    #processUploadResult = (uploadResult, key) => {
        return new Promise((resolve, reject) => {
            if ( !uploadResult && uploadResult !== null ) {
                Warning("AssetsManager: uploadMethod for " + this.#fileType + " returns incorrect value");
            }
            this.#addUploadResultValue(key, uploadResult);
            this.#removeUploadFromQueue(key);
            resolve();
        });
    }

    /**
     * 
     * @param {string} key 
     * @param {*} value 
     */
    #addUploadResultValue(key, value) {
        this.#store.set(key, value);
    }

    /**
     * 
     * @param {string} key 
     */
    #removeUploadFromQueue(key) {
        this.#loadingQueue.delete(key);
    }

    get filesWaitingForUpload() {
        return this.#loadingQueue.size;
    }

    get loadingQueue() {
        return this.#loadingQueue
    };
    
    get uploadMethod() { 
        return this.#uploadMethod;
    }

    /**
     * 
     * @param {string} key 
     * @param {string[]} paramsArr 
     */
    _addFile = (key, paramsArr) => {
        if (this.#loadingQueue.has(key)) {
            Warning("AssetsManager: File " + this.#fileType + " with key " + key + " is already added");
        }
        this.#loadingQueue.set(key, paramsArr);
    }

    /**
     * 
     * @param {string} key 
     * @returns {boolean}
     */
    _isFileInQueue = (key) => {
        return this.#loadingQueue.has(key);
    }

    /**
     * 
     * @param {string} key 
     * @returns {any}
     */
    _getFile = (key) => {
        return this.#store.get(key);
    }
}

/**
 *  This class is used to preload 
 *  tilemaps, tilesets, images and audio,
 *  and easy access loaded files by keys
 */
class AssetsManager {

    /**
     * @type {number}
     */
    #MAX_LOADING_CYCLES = 5;
    /**
     * @type {EventTarget}
     */
    #emitter = new EventTarget();

    /**
     * @type { Map<string, Loader>}
     */
    #registeredLoaders = new Map();
    
    /**
     * @type {number}
     */
    #itemsLoaded = 0;

    constructor() {
        this.registerLoader("Audio", this._loadAudio);
        this.registerLoader("Image", this._loadImage);
        this.registerLoader("TileMap", this._loadTileMap);
        this.registerLoader("TileSet", this._loadTileSet);
        this.registerLoader("AtlasImageMap", this._loadAtlasImage);
        this.registerLoader("AtlasXML", this._loadAtlasXml);
    }

    /**
     * @returns {number}
     */
    get filesWaitingForUpload() {
        let files = 0;
        Array.from(this.#registeredLoaders.values()).map((loader) => files += loader.filesWaitingForUpload);
        return files;
    }

    /**
     * Register a new file type to upload. Method will dynamically add new methods.
     * @param {string} fileTypeName
     * @param {Function=} loadMethod loadMethod should return Promise<result>
     * @returns {void}
     */
    registerLoader = (fileTypeName, loadMethod = this._defaultUploadMethod) => {
        this["add" + fileTypeName] = (key, url, ...args) => {
            this.addFile(fileTypeName, key, url, ...args);
        }
        this["get" + fileTypeName] = (key) => {
            return this.getFile(fileTypeName, key);
        }
        this["is" + fileTypeName + ["InQueue"]] = (key) => {
            return this.isFileInQueue(fileTypeName, key);
        }

        const registeredFileType = this.#registeredLoaders.get(fileTypeName) || new Loader(fileTypeName, loadMethod);

        this.#registeredLoaders.set(fileTypeName, registeredFileType);
    }

    /**
     * Execute load audio, images from tilemaps and images queues
     * @returns {Promise<void>}
     */
    preload() {
        this.#dispatchLoadingStart();
        return new Promise(async(resolve, reject) => {
            this.#uploadFilesRecursive().then(() => {
                this.#dispatchLoadingFinish();
                resolve();
            }).catch((err) => {
                reject(err);
            });
        });
    }

    /**
     * 
     * @param {number} loadCount 
     * @returns {Promise<void>}
     */
    #uploadFilesRecursive(loadCount = 0) {
        return this.#uploadFiles().then(() => {
            if (this.filesWaitingForUpload === 0) {
                return Promise.resolve();
            } else {
                loadCount++;
                if (loadCount > this.#MAX_LOADING_CYCLES) {
                    const err = new Error(ERROR_MESSAGES.RECURSION_ERROR);
                    this.#dispatchLoadingError(err);
                    return Promise.reject(new Error(ERROR_MESSAGES.RECURSION_ERROR));
                } else {
                    return this.#uploadFilesRecursive(loadCount);
                }
            }
        });
    }

    /**
     * 
     * @returns {Promise<void>}
     */
    #uploadFiles() {
        return new Promise((resolve, reject) => {
            /** @type {Promise<void>[]} */
            let uploadPromises = [];
            Array.from(this.#registeredLoaders.values()).forEach((fileType) => {
                Array.from(fileType.loadingQueue.entries()).forEach((key_value) => {
                    /** @type {Promise<void>} */
                    const p = new Promise((res, rej) => fileType.uploadMethod(key_value[0], ...key_value[1]).then(() => res()));
                    uploadPromises.push(p);
                });
            });
    
            Promise.allSettled(uploadPromises).then((results) => {
                for (const result of results) {
                    if (result.status === "rejected") {
                        const error = result.reason;
                        // incorrect method is a critical issue
                        if (this.#isUploadErrorCritical(error)) {
                            reject(error);
                        } else {
                            Warning("AssetsManager: " + error.message);
                            this.#dispatchLoadingError(error);
                        }
                    }
                }
                resolve();
            });
        });
    }

    addEventListener(type, fn, ...args) {
        if (!PROGRESS_EVENT_TYPE[type]) {
            Warning("AssetsManager: Event type should be one of the ProgressEvent.type");
        } else {
            this.#emitter.addEventListener(type, fn, ...args);
        }   
    }

    removeEventListener(type, fn, ...args) {
        this.#emitter.removeEventListener(type, fn, ...args);
    }

    /**
     * Loads image atlas xml
     * @param {string} key
     * @param {string} url
     * @returns {Promise<HTMLElement | Error>}
     */
    _loadAtlasXml = (key, url) => {
        this.#checkXmlUrl(url);
        return fetch(url)
            .then(response => response.text())
            .then(str => new window.DOMParser().parseFromString(str, "text/xml"))
            .then(data => {
                const atlas = data.documentElement || data.activeElement,
                    atlasImagePath = atlas.attributes.getNamedItem("imagePath"),
                    childrenNodes = atlas.children;

                if (atlasImagePath) {
                    const relativePath = this.#calculateRelativePath(url);

                    this.addAtlasImageMap(key, relativePath + atlasImagePath.value, childrenNodes, relativePath);
                    return atlas;
                } else {
                    const err = new Error(key + ERROR_MESSAGES.XML_FORMAT_INCORRECT);
                    this.#dispatchLoadingError(err);
                    return err;
                    // return Promise.reject(err);
                }
            });
    }

    _loadAtlasImage = (key, url, atlasChildNodes, cors = "anonymous") => {
        return new Promise((resolve, reject) => {
            const img = new Image(),
                imageAtlas = new Map(),
                tempCanvas = document.createElement("canvas"),
                tempCtx = tempCanvas.getContext("2d");
            
            img.crossOrigin = cors;
            img.onload = () => {
                const imageBitmapPromises = [];
                let imageAtlasKeys = [];
                // fix dimensions
                tempCanvas.width = img.width;
                tempCanvas.height = img.height;
                tempCtx.drawImage(img, 0, 0);

                for(let childNode of atlasChildNodes) {
                    const nodeAttr = childNode.attributes,
                        fullName = nodeAttr.getNamedItem("name").value,
                        name = fullName.includes(".") ? fullName.split(".")[0] : fullName, // remove name ext
                        x = nodeAttr.getNamedItem("x").value,
                        y = nodeAttr.getNamedItem("y").value,
                        width = nodeAttr.getNamedItem("width").value,
                        height = nodeAttr.getNamedItem("height").value;
                    
                    // images are not cropped correctly in the mozilla@124.0, issue:
                    // https://bugzilla.mozilla.org/show_bug.cgi?id=1797567
                    // getImageData() crop them manually before 
                    // creating imageBitmap from atlas
                    imageBitmapPromises.push(createImageBitmap(tempCtx.getImageData(x, y, width, height), {premultiplyAlpha:"premultiply"}));
                    imageAtlasKeys.push(name);
                }
                this.#dispatchCurrentLoadingProgress();
                Promise.all(imageBitmapPromises).then((results) => {
                    results.forEach((image, idx) => {
                        const name = imageAtlasKeys[idx];
                        imageAtlas.set(name, image);
                        this.addImage(name, "empty url", image);
                    });
                    tempCanvas.remove();
                    resolve(imageAtlas);
                });
            };
            img.onerror = () => {
                const err = new Error(ERROR_MESSAGES.ATLAS_IMAGE_LOADING_FAILED + url);
                this.#dispatchLoadingError(err);
                resolve(null);
                //reject(err);
            };
            img.src = url;
        });
    }

    /**
     * Loads tileset
     * @param {string} key
     * @param {string} url 
     * @param {number} gid
     * @param {string} relativePath
     * @returns {Promise<Object>}
     */
    _loadTileSet = (key, url, gid=1, relativePath) => {
        const file_format = this.#checkTilesetUrl(url),
            loadPath = relativePath ? relativePath + url : url;
        if (file_format === FILE_FORMAT.JSON) {
            return fetch(loadPath)
                .then((response) => response.json())
                .then((data) => this._processTilesetData(data, relativePath, gid, url))
                .catch(() => {
                    const err = new Error(ERROR_MESSAGES.TILESET_LOADING_FAILED + url);
                    this.#dispatchLoadingError(err);
                    return Promise.resolve(null);
                    //return Promise.reject(err);
                });
        } else if (file_format === FILE_FORMAT.XML) {
            return fetch(loadPath)
                .then(response => response.text())
                .then(str => new window.DOMParser().parseFromString(str, "text/xml"))
                .then(xmlString => this._processTilesetXmlData(xmlString.documentElement))
                .then((data) => this._processTilesetData(data, relativePath, gid, url))
                .catch(() => {
                    const err = new Error(ERROR_MESSAGES.TILESET_LOADING_FAILED + url);
                    this.#dispatchLoadingError(err);
                    return Promise.resolve(null);
                });
        } else {
            return Promise.reject(loadPath + ERROR_MESSAGES.TILEMAP_FILE_EXTENSION_INCORRECT);
        }
    }

    /**
     * 
     * @param {Object} doc 
     * @returns {Object}
     */
    _processTilesetXmlData = (doc) => {
        const tilesetData = {
            columns: Number(doc.attributes?.columns?.value),
            name: doc.attributes?.name?.value,
            tilecount: Number(doc.attributes?.tilecount?.value),
            tiledversion: doc.attributes?.tiledversion?.value,
            tileheight: Number(doc.attributes?.tileheight?.value),
            tilewidth: Number(doc.attributes?.tilewidth?.value),
            version: doc.attributes?.version?.value,
            margin: doc.attributes?.margin ? Number(doc.attributes.margin.value) : 0,
            spacing: doc.attributes?.spacing ? Number(doc.attributes.margin.value) : 0,
            type: doc.tagName
        };
        
        this._processTilesetXmlChildData(tilesetData, doc.childNodes);
        
        return tilesetData;
    }

    /**
     * 
     * @param {any} tilesetData 
     * @param {any} nodes
     * @returns {void} 
     */
    _processTilesetXmlChildData(tilesetData, nodes) {
        for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i],
                name = node.nodeName;
                
            if (name === "image") {
                tilesetData.image = node?.attributes?.source?.value;
                tilesetData.imagewidth = node?.attributes?.width ? Number(node.attributes.width.value) : 0;
                tilesetData.imageheight = node?.attributes?.height ? Number(node.attributes.height.value) : 0;
            } else if (name === "tileoffset") {
                tilesetData.tileoffset = {
                    x: Number(node.attributes.x.value),
                    y: Number(node.attributes.y.value)
                };
            } else if (name === "tile") {
                if (!tilesetData.tiles) {
                    tilesetData.tiles = [];
                }
                //add boundaries / animations
                const tile = {
                    id: Number(node.attributes?.id?.value)
                }
                const childN = node.childNodes;
                
                for (let j = 0; j < childN.length; j++) {
                    const child = childN[j],
                        childName = child.nodeName;
                    if (childName === "objectgroup") {
                        tile.objectgroup = {
                            type: childName
                        }

                        if (child.attributes?.id) {
                            tile.objectgroup.id = Number(child.attributes?.id?.value);
                        }
                        if (child.attributes?.draworder) {
                            tile.objectgroup.draworder = child.attributes.draworder.value;
                        }
                        if (child.attributes?.opacity) {
                            tile.objectgroup.opacity = child.attributes.opacity.value;
                        }
                        if (child.attributes?.x && child.attributes?.y) {
                            tile.objectgroup.x = child.attributes.x.value;
                            tile.objectgroup.y = child.attributes.y.value;
                        }

                        tile.objectgroup.objects = [];

                        const objects = child.childNodes;
                        for (let k = 0; k < objects.length; k++) {
                            const obj = objects[k];
                            
                            if (obj.nodeName === "object") {
                                const objInc = {
                                    id: Number(obj.attributes?.id?.value),
                                    visible: obj.attributes.visible && obj.attributes.visible.value === "0" ? false : true,
                                    x: Number(obj.attributes?.x?.value),
                                    y: Number(obj.attributes?.y?.value),
                                    rotation: obj.attributes?.rotation ? Number(obj.attributes.rotation.value) :0,
                                };
                                if (obj.attributes?.width) {
                                    objInc.width = Number(obj.attributes.width.value); 
                                }
                                if (obj.attributes?.height) {
                                    objInc.height = Number(obj.attributes.height.value);
                                }
                                
                                const childObjects = obj.childNodes;
                                if (childObjects && childObjects.length > 0) {
                                    for (let n = 0; n < childObjects.length; n++) {
                                        const childObj = childObjects[n];
                                
                                        if (childObj.nodeName === "ellipse") {
                                            objInc.ellipse = true;
                                        } else if (childObj.nodeName === "point") {
                                            objInc.point = true;
                                        } else if (childObj.nodeName === "polygon") {
                                            const points = childObj.attributes?.points?.value;
                                            if (points && points.length > 0) {
                                                const pointsArr = points.split(" ").map((point) => {
                                                    const [x, y] = point.split(",");
                                                    return {x:Number(x), y:Number(y)};
                                                });
                                                objInc.polygon = pointsArr;
                                            }
                                        }
                                    }
                                }

                                tile.objectgroup.objects.push(objInc);
                            }
                        }
                    } else if (childName === "animation") {
                        //
                        tile.animation = [];
                        
                        const frames = child.childNodes;
                        for (let t = 0; t < frames.length; t++) {
                            const frame = frames[t];

                            if (frame.nodeName === "frame") {
                                const frameObject = {
                                    tileid: Number(frame.attributes?.tileid?.value),
                                    duration: Number(frame.attributes?.duration?.value)
                                }
                                tile.animation.push(frameObject);
                            }
                        }
                    }
                }

                tilesetData.tiles.push(tile);
            }
        }
    }
    /**
     * 
     * @param {Object} data 
     * @param {string} relativePath
     * @param {number=} gid
     * @param {string=} source
     * @returns {Promise<Object>}
     */
    _processTilesetData = (data, relativePath, gid, source) => {
        const {name, image } = data;
        if (name && image && !this.isFileInQueue("Image", name)) {
            this.addImage(name, relativePath ? relativePath + image : image);
        }
        if (gid) {
            data.firstgid = gid;
        }
        // if it is an external file
        if (source) {
            data.source = source;
        }
        return Promise.resolve(data);
    }

    /**
     * 
     * @param {string} key 
     * @param {string} url 
     * @returns {Promise<any>}
     */
    _defaultUploadMethod = (key, url) => {
        return fetch(url);
    }

    /**
     * Loads tilemap file and related data
     * @param {string} key 
     * @param {string} url 
     * @param {boolean} [attachTileSetData = true] - indicates, whenever tilesetData is attached, or will be loaded separately
     * @returns {Promise}
     */
    _loadTileMap = (key, url, attachTileSetData = true) => {
        const file_format = this.#checkTilemapUrl(url);
        
        let fetchData;
        if (file_format === FILE_FORMAT.JSON) {
            fetchData = fetch(url)
                .then((response) => response.json())
                .then((data) => this._processTileMapData(data, url, attachTileSetData))
                .catch((err) => {
                    if (err.message.includes("JSON.parse:")) {
                        err = new Error(ERROR_MESSAGES.TILEMAP_LOADING_FAILED + url);
                    }
                    this.#dispatchLoadingError(err);
                    return Promise.resolve(null);
                    //return Promise.reject(err);
                });
        } else if (FILE_FORMAT.XML) {
            fetchData = fetch(url)
                .then((response) => response.text())
                .then((rawText) => this._processTileMapXML(rawText))
                .then((tilemapData) => this._processTileMapData(tilemapData, url, attachTileSetData))
                .catch((err) => {
                    this.#dispatchLoadingError(err);
                    return Promise.resolve(null);
                    //return Promise.reject(err);
                });
        } else {
            return Promise.reject(url + ERROR_MESSAGES.TILEMAP_FILE_EXTENSION_INCORRECT);
        }

        return fetchData;
    }

    /**
     * 
     * @param {string} rawText 
     * @returns {Object}
     */
    _processTileMapXML = (rawText) => {
        const xmlDoc = new DOMParser().parseFromString(rawText, "text/xml");
                
        /** @type {Object} */
        const doc = xmlDoc.documentElement;
        const tilemapData = {
            type: doc.tagName,
            width: Number(doc.attributes?.width?.value),
            height: Number(doc.attributes?.height?.value),
            infinite: doc.attributes.infinite && doc.attributes.infinite.value === "1" ? true : false,
            nextlayerid: Number(doc.attributes?.nextlayerid?.value),
            nextobjectid: Number(doc.attributes?.nextobjectid?.value),
            orientation: doc.attributes?.orientation?.value,
            renderorder: doc.attributes?.renderorder?.value,
            tiledversion: doc.attributes?.tiledversion?.value,
            tileheight: Number(doc.attributes?.tileheight?.value),
            tilewidth: Number(doc.attributes?.tilewidth?.value),
            version: doc.attributes?.version?.value,
            /** @type {Array<Object>} */
            tilesets: [],
            /** @type {Array<Object>} */
            layers: []
        };
        const nodes = xmlDoc.documentElement.childNodes;
        for (let i = 0; i < nodes.length; i++) {
            /** @type {Object} */
            const node = nodes[i],
                name = node.nodeName;
                
            if (name === "tileset") {
                const tileset = {
                    firstgid: Number(node.attributes?.firstgid?.value)
                };
                if (node.attributes?.source) { // external tileset (will be loaded later)
                    tileset.source = node.attributes?.source?.value;
                } else {
                    // inline tileset
                    tileset.columns = Number(node.attributes?.columns?.value);
                    if (node.attributes?.margin) {
                        tileset.margin = Number(node.attributes?.margin?.value);
                    }
                    if (node.attributes?.spacing) {
                        tileset.spacing = node.attributes?.spacing?.value;
                    }
                    tileset.name = node.attributes?.name?.value;
                    
                    tileset.tilecount = Number(node.attributes?.tilecount?.value);
                    tileset.tilewidth = Number(node.attributes?.tilewidth?.value);
                    tileset.tileheight = Number(node.attributes?.tileheight?.value);

                    this._processTilesetXmlChildData(tileset, node.childNodes);
                }
                tilemapData.tilesets.push(tileset);
            } else if (name === "layer") {
                const layer = {
                    height: Number(node.attributes?.height?.value),
                    id: Number(node.attributes?.id?.value),
                    name: node.attributes?.name?.value,
                    width: Number(node.attributes?.width?.value),
                    data: node.textContent ? node.textContent.trim().split(",").map((val) => Number(val)): null
                }
                tilemapData.layers.push(layer);
            }
        }

        return tilemapData;
    }

    /**
     * 
     * @param {any} data 
     * @param {string} url 
     * @param {boolean} attachTileSetData 
     * @returns {Promise<any>}
     */
    _processTileMapData = (data, url, attachTileSetData) => {
        const relativePath = this.#calculateRelativePath(url);
        
        if (attachTileSetData === true && data.tilesets && data.tilesets.length > 0) {
            const tilesetPromises = [];
            // upload additional tileset data
            data.tilesets.forEach((tileset, idx) => {
                const { firstgid, source } = tileset;
                if (source) { // external tileset
                    const loadTilesetPromise = this._loadTileSet("default-" + firstgid, source, firstgid, relativePath)
                        .then((tilesetData) => {
                            this.#dispatchCurrentLoadingProgress();
                            return Promise.resolve(tilesetData);
                        });
                    tilesetPromises.push(loadTilesetPromise);
                } else { // inline tileset
                    const loadTilesetPromise = this._processTilesetData(tileset, relativePath)
                        .then((tilesetData) => {
                            this.#dispatchCurrentLoadingProgress();
                            return Promise.resolve(tilesetData);
                        });
                    tilesetPromises.push(loadTilesetPromise);
                }
            });
            //attach additional tileset data to tilemap data
            return Promise.all(tilesetPromises).then((tilesetDataArray) => {
                for (let i = 0; i < tilesetDataArray.length; i++) {
                    const tilesetData = tilesetDataArray[i];
                    data.tilesets[i] = tilesetData;
                    // @depricated
                    // save backward capability with jsge@1.5.71
                    data.tilesets[i].data = Object.assign({}, tilesetData);
                }
                return Promise.resolve(data);
            });
        } else {
            return Promise.resolve(data);
        }
    }

    /**
     * Loads audio file
     * @param {string} key 
     * @param {string} url 
     * @returns {Promise}
     */
    _loadAudio = (key, url) => {
        return new Promise((resolve) => {
            const audio = new Audio(url);
            
            audio.addEventListener("loadeddata", () => {
                this.#dispatchCurrentLoadingProgress();
                resolve(audio);
            });

            audio.addEventListener("error", () => {
                const err = new Error(ERROR_MESSAGES.AUDIO_LOADING_FAILED + url);
                this.#dispatchLoadingError(err);
                resolve(null);
                //reject(err);
            });
        });
    }

    /**
     * Loads image file.
     * @param {string} key 
     * @param {string} url
     * @param {ImageBitmap=} image - image could be add from another source
     * @param {string} [cors="anonymous"] // https://hacks.mozilla.org/2011/11/using-cors-to-load-webgl-textures-from-cross-domain-images
     * @returns {Promise}
     */
    _loadImage = (key, url, image, cors = "anonymous") => {
        return new Promise((resolve, reject) => {
            if (image) {
                resolve(image);
            } else {
                const img = new Image();
                img.crossOrigin = cors;
                img.onload = () => {
                    // do we need a bitmap? Without creating bitmap images has not premultiplied
                    // transparent pixels, and in some cases it creates white ages,
                    // in other - multiply pixels with the background
                    createImageBitmap(img, {premultiplyAlpha:"premultiply"}).then((imageBitmap) => {
                        this.#dispatchCurrentLoadingProgress();
                        resolve(imageBitmap);
                    });
                };
                img.onerror = () => {
                    const err = new Error(ERROR_MESSAGES.IMAGE_LOADING_FAILED + url);
                    this.#dispatchLoadingError(err);
                    resolve(null);
                    // reject(err);
                };
                img.src = url;
            }
        });
    }

    #checkXmlUrl(url) {
        if (url.includes(".xml")) {
            return;
        } else {
            Exception(url + ERROR_MESSAGES.XML_FILE_EXTENSION_INCORRECT);
        }
    }

    #checkTilesetUrl(url) {
        if (url.includes(".tsj") || url.includes(".json")) {
            return FILE_FORMAT.JSON;
        } else if (url.includes(".tsx") || url.includes(".xml")) {
            return FILE_FORMAT.XML;
        } else {
            return FILE_FORMAT.UNKNOWN;
        }
    }

    #checkTilemapUrl(url) {
        if (url.includes(".tmj") || url.includes(".json")) {
            return FILE_FORMAT.JSON;
        } else if (url.includes(".tmx") || url.includes(".xml")) {
            return FILE_FORMAT.XML;
        } else {
            return FILE_FORMAT.UNKNOWN;
        }
    }

    #isUploadErrorCritical(error) {
        return error.message.includes(ERROR_MESSAGES.NOT_CORRECT_METHOD_TYPE)
            || error.message.includes(ERROR_MESSAGES.XML_FILE_EXTENSION_INCORRECT)
            || error.message.includes(ERROR_MESSAGES.TILESET_FILE_EXTENSION_INCORRECT)
            || error.message.includes(ERROR_MESSAGES.TILEMAP_FILE_EXTENSION_INCORRECT)
            || error.message.includes(ERROR_MESSAGES.INPUT_PARAMS_ARE_INCORRECT)
            || error.message.includes(ERROR_MESSAGES.LOADER_NOT_REGISTERED);
    }

    /**
     * Calculate relative path for current url
     * for example: /folder/images/map.xml -> /folder/images/
     * @param {string} url 
     * @returns {string}
     */
    #calculateRelativePath(url) {
        let split = url.split("/"),
            length = split.length,
            lastEl = split[length - 1],
            //prelastEl = split[length - 2],
            relativePath = "/";
        
        // url ends with .ext
        if (lastEl.includes(".tmj") || lastEl.includes(".tmx") || lastEl.includes(".xml") || lastEl.includes(".json")) {
            split.pop();
            relativePath = split.join("/") + "/";
        // url ends with /
        }/* else if (prelastEl.includes(".tmj") || lastEl.includes(".tmx") || prelastEl.includes(".xml") || prelastEl.includes(".json")) {
            split.splice(length - 2, 2);
            relativePath = split.join("/") + "/";
        }*/
        return relativePath;
    }

    addFile(fileType, fileKey, url, ...args) {
        const loader = this.#registeredLoaders.get(fileType);
        if (loader) {
            this.#checkInputParams(fileKey, url, fileType);
            loader._addFile(fileKey, [url, ...args]);
        } else {
            Exception(fileType + ERROR_MESSAGES.LOADER_NOT_REGISTERED);
        }

    }

    isFileInQueue(fileType, fileKey) {
        const loader = this.#registeredLoaders.get(fileType);
        if (loader) {
            return loader._isFileInQueue(fileKey);
        } else {
            Exception("Loader for " + fileType + " is not registered!");
        }
    }

    getFile(fileType, fileKey) {
        const loader = this.#registeredLoaders.get(fileType);
        if (loader) {
            return loader._getFile(fileKey);
        } else {
            Exception("Loader for " + fileType + " is not registered!");
        }
    }

    #checkInputParams(fileKey, url, fileType) {
        const errorMessage = ERROR_MESSAGES.INPUT_PARAMS_ARE_INCORRECT;
        if (!fileKey || fileKey.trim().length === 0) {
            Exception("add" + fileType + "()" + errorMessage);
        }
        if (!url || url.trim().length === 0) {
            Exception("add" + fileType + "()" + errorMessage);
        }
        return;
    }

    #dispatchLoadingStart() {
        let total = this.filesWaitingForUpload;
        this.#emitter.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.loadstart, { total }));
    }

    #dispatchLoadingFinish() {
        this.#emitter.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.load));
    }

    #dispatchCurrentLoadingProgress() {
        const total = this.filesWaitingForUpload;
        this.#itemsLoaded += 1;
        this.#emitter.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.progress, { lengthComputable: true, loaded: this.#itemsLoaded, total }));
    }

    #dispatchLoadingError(error) {
        Warning("AssetsManger: " + error.message);
        this.#emitter.dispatchEvent(new ErrorEvent(PROGRESS_EVENT_TYPE.error, { error }));
    }
}

function Exception (message) {
    throw new Error(message);
}

function Warning (message) {
    console.warn(message);
}

/***/ }),

/***/ "./node_modules/jsge/src/base/2d/DrawCircleObject.js":
/*!***********************************************************!*\
  !*** ./node_modules/jsge/src/base/2d/DrawCircleObject.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DrawCircleObject: () => (/* binding */ DrawCircleObject)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./node_modules/jsge/src/constants.js");
/* harmony import */ var _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DrawShapeObject.js */ "./node_modules/jsge/src/base/2d/DrawShapeObject.js");



/**
 * Circle object to draw.
 * @extends DrawShapeObject
 * @see {@link DrawObjectFactory} should be created with factory method
 */
class DrawCircleObject extends _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_1__.DrawShapeObject {
    /**
     * @type {number}
     */
    #radius;

    /**
     * @type {Array<number>}
     */
    #vertices;

    /**
     * @hideconstructor
     */
    constructor(x, y, radius, bgColor) {
        super(_constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.CIRCLE, x, y, bgColor);
        this.#radius = radius;
        this.#vertices = this._interpolateConus(radius);
    }

    /**
     * Array of [x,y] cords.
     * @type {Array<number>}
     */
    get vertices () {
        return this.#vertices;
    }

    set vertices(value) {
        this.#vertices = value;
    }

    /**
     * @type {number}
     */
    get radius() {
        return this.#radius;
    }
}

/***/ }),

/***/ "./node_modules/jsge/src/base/2d/DrawConusObject.js":
/*!**********************************************************!*\
  !*** ./node_modules/jsge/src/base/2d/DrawConusObject.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DrawConusObject: () => (/* binding */ DrawConusObject)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./node_modules/jsge/src/constants.js");
/* harmony import */ var _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DrawShapeObject.js */ "./node_modules/jsge/src/base/2d/DrawShapeObject.js");



/**
 * Conus object to draw.
 * @extends DrawShapeObject
 * @see {@link DrawObjectFactory} should be created with factory method
 */
class DrawConusObject extends _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_1__.DrawShapeObject {
    /**
     * @type {number}
     */
    #radius;

    /**
     * @type {number}
     */
    #angle;

    /**
     * Array of [x,y] cords.
     * @type {Array<number>}
     */
    #vertices;
    #fade_min;

    /**
     * @hideconstructor
     */
    constructor(x, y, radius, bgColor, angle, fade = 0) {
        super(_constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.CONUS, x, y, bgColor);
        this.#radius = radius;
        this.#angle = angle;
        this.#fade_min = fade;
        this.#vertices = this._interpolateConus(radius, angle);
    }

    /**
     * Array of [x,y] cords.
     * @type {Array<number>}
     */
    get vertices () {
        return this.#vertices;
    }

    set vertices(value) {
        this.#vertices = value;
    }

    /**
     * @type {number}
     */
    get radius() {
        return this.#radius;
    }

    /**
     * @type {number}
     */
    get angle() {
        return this.#angle;
    }

    /**
     * @type {number}
     */
    get fade_min() {
        return this.#fade_min;
    }

    /**
     * @param {number} value - fade start pos in px
     */
    set fade_min(value) {
        this.#fade_min = value;
    }
}

/***/ }),

/***/ "./node_modules/jsge/src/base/2d/DrawImageObject.js":
/*!**********************************************************!*\
  !*** ./node_modules/jsge/src/base/2d/DrawImageObject.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DrawImageObject: () => (/* binding */ DrawImageObject)
/* harmony export */ });
/* harmony import */ var _AnimationEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AnimationEvent.js */ "./node_modules/jsge/src/base/AnimationEvent.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants.js */ "./node_modules/jsge/src/constants.js");
/* harmony import */ var _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DrawShapeObject.js */ "./node_modules/jsge/src/base/2d/DrawShapeObject.js");
/* harmony import */ var _Temp_ImageTempStorage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Temp/ImageTempStorage.js */ "./node_modules/jsge/src/base/Temp/ImageTempStorage.js");
/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Exception.js */ "./node_modules/jsge/src/base/Exception.js");





/**
 * Image object to draw
 * @extends DrawShapeObject
 * @see {@link DrawObjectFactory} should be created with factory method
 */
class DrawImageObject extends _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_2__.DrawShapeObject {
    /**
     * @type {number}
     */
    #w;
    /**
     * @type {number}
     */
    #h;
    /**
     * Image sprite key
     * @type {string}
     */
    #key;
    /**
     * @type {ImageBitmap}
     */
    #image;
    /**
     * @type {EventTarget}
     */
    #emitter;
    /**
     * @type {Map<string, AnimationEvent>}
     */
    #animations;
    /**
     * @type {null | string}
     */
    #activeAnimation;
    /**
     * @type {number}
     */
    #imageIndex;
    /**
     * @type {number}
     */
    #spacing = 0;
    /**
     * @type {number}
     */
    #margin = 0;
    /**
     * @type {Array<Array<number>>}
     */
    #vertices;
    /**
     * @type {Object | null}
     */
    #circleBoundaries;
    /**
     * @type {ImageTempStorage}
     */
    #textureStorage;

    /**
     * @hideconstructor
     */
    constructor(mapX, mapY, width, height, key, imageIndex = 0, boundaries, image, spacing = 0, margin = 0) {
        super(_constants_js__WEBPACK_IMPORTED_MODULE_1__.DRAW_TYPE.IMAGE, mapX, mapY);
        this.#key = key;
        this.#emitter = new EventTarget();
        this.#animations = new Map();
        this.image = image;
        this.#imageIndex = imageIndex;
        this.#spacing = spacing;
        this.#margin = margin;
        this.#w = width;
        this.#h = height;
        this.#vertices = boundaries && !boundaries.r ? this._convertVerticesArray(boundaries) : boundaries && boundaries.r ? this._calculateConusBoundaries(boundaries.r) : this._calculateRectVertices(width, height);
        this.#circleBoundaries = boundaries && typeof boundaries.r !== "undefined" ? boundaries : null;
    }

    /**
     * @type {number}
     */
    get width() {
        return this.#w;
    }

    /**
     * @type {number}
     */
    get height() {
        return this.#h;
    }

    set width(w) {
        this.#w = w;
    }

    set height(h) {
        this.#h = h;
    }

    /**
     * A key should match an image loaded through AssetsManager
     * @type {string}
     */
    get key() {
        return this.#key;
    }

    /**
     * @type {ImageBitmap}
     */
    get image() {
        return this.#image;
    }

    set image(value) {
        if (this.#textureStorage) {
            this.#textureStorage._isTextureRecalculated = true;
        }

        this.#image = value;
    }

    /**
     * Current image index
     * @type {number}
     */
    get imageIndex() {
        return this.#imageIndex;
    }

    set imageIndex(value) {
        this.#imageIndex = value;
    }

    /**
     * Image spacing (for tilesets.spacing > 0)
     * @type {number}
     */
    get spacing() {
        return this.#spacing;
    }

    /**
     * Image spacing (for tilesets.margin > 0)
     * @type {number}
     */
    get margin() {
        return this.#margin;
    }

    /**
     * Determines if image is animated or not
     * @type {boolean}
     */
    get hasAnimations() {
        return this.#animations.size > 0;
    }

    /**
     * @type {null | string}
     */
    get activeAnimation() {
        return this.#activeAnimation;
    }

    /**
     * @deprecated - use .vertices instead 
     * @type {Array<Array<number>>}
     */
    get boundaries() {
        return this.#vertices;
    }

    get vertices() {
        return this.#vertices;
    }

    get circleBoundaries() {
        return this.#circleBoundaries;
    }

    /**
     * @ignore
     */
    _processActiveAnimations() {
        const activeAnimation = this.#activeAnimation;
        if (activeAnimation) {
            const animationEvent = this.#animations.get(activeAnimation);
            animationEvent.iterateAnimationIndex();
            this.#imageIndex = animationEvent.currentSprite;
        }
    }
    /**
     * @ignore
     */
    get _textureStorage() {
        return this.#textureStorage;
    }

    /**
     * @ignore
     */
    set _textureStorage(texture) {
        this.#textureStorage = texture;
    }

    /**
     * Emit event
     * @param {string} eventName 
     * @param  {...any} eventParams 
     */
    emit(eventName, ...eventParams) {
        const event = new Event(eventName);
        event.data = [...eventParams];
        this.#emitter.dispatchEvent(event);
    }

    /**
     * Subscribe
     * @param {string} eventName 
     * @param {*} listener 
     * @param {*} options 
     */
    addEventListener(eventName, listener, options) {
        this.#emitter.addEventListener(eventName, listener, options);
    }

    /**
     * Unsubscribe
     * @param {string} eventName 
     * @param {*} listener 
     * @param {*} options 
     */
    removeEventListener(eventName, listener, options) {
        this.#emitter.removeEventListener(eventName, listener, options);
    }

    /**
     * Adds image animations
     * @param { string } eventName -animation name
     * @param { Array<number> | Array<{duration:number, id:number}> } animationSpriteIndexes - animation image indexes
     * @param { boolean } [isRepeated = false] - animation is cycled or not, cycled animation could be stopped only with stopRepeatedAnimation();
     */
    addAnimation (eventName, animationSpriteIndexes, isRepeated) {
        if (!this.#checkAnimationParams(animationSpriteIndexes)) {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_4__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.ERROR_CODES.UNEXPECTED_INPUT_PARAMS, " animationSpriteIndexes should be Array of indexes, or Array of objects {duration:number, id:number}");
        }
        const animationEvent = new _AnimationEvent_js__WEBPACK_IMPORTED_MODULE_0__.AnimationEvent(eventName, animationSpriteIndexes, isRepeated);
        this.#animations.set(eventName, animationEvent);
        this.addEventListener(eventName, this.#activateAnimation);
    }

    #checkAnimationParams (animationSpriteIndexes) {
        let isCorrect = true;
        animationSpriteIndexes.forEach(element => {
            if (typeof element !== "number") {
                if (typeof element.duration !== "number" || typeof element.id !== "number") {
                    isCorrect = false;
                }
            }     
        });
        return isCorrect;
    }
    #activateAnimation = (event) => {
        const animationName = event.type,
            animationEvent = this.#animations.get(animationName);
        // only one active animation can exist at a time
        if (this.#activeAnimation && this.#activeAnimation !== animationName) {
            this.stopRepeatedAnimation(this.#activeAnimation);
        }
        animationEvent.activateAnimation();
        this.#activeAnimation = animationName;
        this.#imageIndex = animationEvent.currentSprite;
    }; 

    /**
     *
     * @param {string=} eventName - animation name, if not provided - stop current active animation event
     */
    stopRepeatedAnimation (eventName) {
        this.#animations.get(eventName).deactivateAnimation();
        this.#activeAnimation = null;
    }

    /**
     * Removes animations
     */
    removeAllAnimations() {
        for (let [eventName, animationEvent] of this.#animations.entries()) {
            this.removeEventListener(eventName, animationEvent.activateAnimation);
            animationEvent.deactivateAnimation();
        }
        this.#animations.clear();
        this.#animations = undefined;
    }

    destroy() {
        this.removeAllAnimations();
        super.destroy();
    }
}

/***/ }),

/***/ "./node_modules/jsge/src/base/2d/DrawLineObject.js":
/*!*********************************************************!*\
  !*** ./node_modules/jsge/src/base/2d/DrawLineObject.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DrawLineObject: () => (/* binding */ DrawLineObject)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./node_modules/jsge/src/constants.js");
/* harmony import */ var _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DrawShapeObject.js */ "./node_modules/jsge/src/base/2d/DrawShapeObject.js");



/**
 * Line object to draw.
 * @extends DrawShapeObject
 * @see {@link DrawObjectFactory} should be created with factory method
 */
class DrawLineObject extends _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_1__.DrawShapeObject {
    /**
     * @type {Array<Array<number>>}
     */
    #vertices;

    /**
     * @hideconstructor
     */
    constructor(vertices, bgColor) {
        super(_constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.LINE, vertices[0][0], vertices[0][1], bgColor);
        this.#vertices = vertices;
    }

    /**
     * @type {Array<Array<number>>}
     */
    get vertices () {
        return this.#vertices;
    }

    set vertices(value) {
        this.#vertices = value;
    }
}

/***/ }),

/***/ "./node_modules/jsge/src/base/2d/DrawPolygonObject.js":
/*!************************************************************!*\
  !*** ./node_modules/jsge/src/base/2d/DrawPolygonObject.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DrawPolygonObject: () => (/* binding */ DrawPolygonObject)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./node_modules/jsge/src/constants.js");
/* harmony import */ var _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DrawShapeObject.js */ "./node_modules/jsge/src/base/2d/DrawShapeObject.js");



/**
 * @extends DrawShapeObject
 * @see {@link DrawObjectFactory} should be created with factory method
 */
class DrawPolygonObject extends _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_1__.DrawShapeObject {
    /**
     * @type {Array<Array<number>>}
     */
    #vertices;

    /**
     * @hideconstructor
     */
    constructor(vertices, bgColor) {
        super(_constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.POLYGON, vertices[0].x, vertices[0].y, bgColor);
        this.#vertices = this._convertVerticesArray(vertices);
    }

    /**
     * @type {Array<Array<number>>}
     */
    get vertices () {
        return this.#vertices;
    }

    set vertices(value) {
        this.#vertices = value;
    }
}

/***/ }),

/***/ "./node_modules/jsge/src/base/2d/DrawRectObject.js":
/*!*********************************************************!*\
  !*** ./node_modules/jsge/src/base/2d/DrawRectObject.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DrawRectObject: () => (/* binding */ DrawRectObject)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./node_modules/jsge/src/constants.js");
/* harmony import */ var _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DrawShapeObject.js */ "./node_modules/jsge/src/base/2d/DrawShapeObject.js");



/**
 * @extends DrawShapeObject
 * @see {@link DrawObjectFactory} should be created with factory method
 */
class DrawRectObject extends _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_1__.DrawShapeObject {
    /**
     * @type {number}
     */
    #w;
    /**
     * @type {number}
     */
    #h;
    /**
     * @type {Array<Array<number>>}
     */
    #vertices;

    /**
     * @hideconstructor
     */
    constructor(x, y, w, h, bgColor) {
        super(_constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.RECTANGLE, x, y, bgColor);
        this.#w = w;
        this.#h = h;
        this.#vertices = this._calculateRectVertices(w,h);
    }

    /**
     * @type {Array<Array<number>>}
     */
    get vertices () {
        return this.#vertices;
    }
    /**
     * @type {number}
     */
    get width() {
        return this.#w;
    }

    /**
     * @type {number}
     */
    get height() {
        return this.#h;
    }

    set width(w) {
        this.#w = w;
    }

    set height(h) {
        this.#h = h;
    }
}

/***/ }),

/***/ "./node_modules/jsge/src/base/2d/DrawShapeObject.js":
/*!**********************************************************!*\
  !*** ./node_modules/jsge/src/base/2d/DrawShapeObject.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DrawShapeObject: () => (/* binding */ DrawShapeObject)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./node_modules/jsge/src/constants.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../index.js */ "./node_modules/jsge/src/index.js");



/**
 * A base draw object.
 */
class DrawShapeObject {
    #x;
    #y;
    #bg;
    /**
     * @type {DRAW_TYPE}
     */
    #type;
    /**
     * Is used for blending pixel arithmetic
     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendFunc.
     * @type {Array<number>}
     */
    #blendFunc;
    
    /**
     * @type {number}
     */
    #sortIndex = 0;
    /**
     * @type {number}
     */
    #rotation = 0;
    /**
     * @type {number}
     */
    #id = _index_js__WEBPACK_IMPORTED_MODULE_1__.utils.generateUniqId();
    /**
     * @type {boolean}
     */
    #isRemoved = false;
    /**
     * @type {undefined | number | null}
     */
    #attachedMaskId;
    /**
     * @type {boolean}
     */
    #isMask;
    /**
     * @type {boolean}
     */
    #isOffsetTurnedOff = false;

    /**
     * @type {boolean}
     */
    #isChanged = false;
    /**
     * @hideconstructor
     */
    constructor(type, mapX, mapY, bgColor) {
        this.#x = mapX;
        this.#y = mapY;
        this.#bg = bgColor;
        this.#type = type;
    }

    /**
     * Background color as rgba(r,g,b,a).
     * @type {string}
     */
    get bgColor() {
        return this.#bg;
    }

    set bgColor(value) {
        this.#bg = value;
    }

    /**
     * @type {DRAW_TYPE}
     */
    get type() {
        return this.#type;
    }

    /**
     * @type {number}
     */
    get x() {
        return this.#x;
    }

    /**
     * @type {number}
     */
    get y () {
        return this.#y;
    }

    set x(posX) {
        this.#x = posX;
    }

    set y(posY) {
        this.#y = posY;
    }

    /**
     * @type {number}
     */
    get sortIndex () {
        return this.#sortIndex;
    }

    set sortIndex(value) {
        this.#sortIndex = value;
    }

    get blendFunc () {
        return this.#blendFunc;
    }

    set blendFunc(value) {
        this.#blendFunc = value;
    }

    /**
     * @type {number}
     */
    get rotation() {
        return this.#rotation;
    }

    set rotation(value) {
        this.#rotation = value;
    }

    /**
     * @type {number}
     */
    get id() {
        return this.#id;
    }

    /**
     * @type {boolean}
     */
    get isRemoved() {
        return this.#isRemoved;
    }
    /**
     * Destroy object on next render iteration.
     */
    destroy() {
        this.#isRemoved = true;
    }

    get isMaskAttached() {
        return !!this.#attachedMaskId;
    }

    /**
     * @ignore
     */
    get _maskId() {
        return this.#attachedMaskId;
    }

    /**
     * 
     * @param {DrawShapeObject} mask 
     */
    setMask(mask) {
        mask._isMask = true;
        this.#attachedMaskId = mask.id;
    }

    removeMask() {
        this.#attachedMaskId = null;
    }

    set _isMask(isSet) {
        this.#isMask = isSet;
    }

    get _isMask() {
        return this.#isMask;
    }

    get isOffsetTurnedOff() {
        return this.#isOffsetTurnedOff;
    }

    /**
     * turn off offset for specific draw object
     * gameStageData.centerCameraPosition() will take no effect on such object
     * Can be used for something that should be always on screen: control buttons, overlay masks etc.
     */
    turnOffOffset() {
        this.#isOffsetTurnedOff = true;
    }
    /**
     * @ignore
     * @param {number} width 
     * @param {number} height 
     * @returns {Array<Array<number>>}
     */
    _calculateRectVertices = (width, height) => {
        const halfW = width/2,
            halfH = height/2;
        return [[-halfW, -halfH], [halfW, -halfH], [halfW, halfH], [-halfW, halfH]];
    };

    /**
     * @param {number} radius 
     * @param {number} [angle = 2 * Math.PI]
     * @param {number} [step = Math.PI/12] 
     * @returns {Array<number>}
     * @ignore
     */
    _interpolateConus(radius, angle = 2*Math.PI, step = Math.PI/14) {
        let conusPolygonCoords = [0, 0];

        for (let r = 0; r <= angle; r += step) {
            let x2 = Math.cos(r) * radius,
                y2 = Math.sin(r) * radius;

            conusPolygonCoords.push(x2, y2);
        }

        return conusPolygonCoords;
    }

    /**
     * @param {number} radius 
     * @param {number} [angle = 2 * Math.PI]
     * @param {number} [step = Math.PI/12] 
     * @returns {Array<Array<number>>}
     * @ignore
     */
    _calculateConusBoundaries(radius, angle = 2*Math.PI, step = Math.PI/14) {
        let conusPolygonCoords = [];

        for (let r = 0; r <= angle; r += step) {
            let x2 = Math.cos(r) * radius,
                y2 = Math.sin(r) * radius;

            conusPolygonCoords.push([x2, y2]);
        }

        return conusPolygonCoords;
    }


    /**
     * @param {Array<Array<number>> | Array<{x:number, y:number}>} boundaries
     * @returns {Array<Array<number>>}
     * @ignore
     */
    _convertVerticesArray(boundaries) {
        if (typeof boundaries[0].x !== "undefined" && typeof boundaries[0].y !== "undefined") {
            return _index_js__WEBPACK_IMPORTED_MODULE_1__.utils.verticesArrayToArrayNumbers(boundaries);
        } else {
            return boundaries;
        }
    }
}

/***/ }),

/***/ "./node_modules/jsge/src/base/2d/DrawTextObject.js":
/*!*********************************************************!*\
  !*** ./node_modules/jsge/src/base/2d/DrawTextObject.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DrawTextObject: () => (/* binding */ DrawTextObject)
/* harmony export */ });
/* harmony import */ var _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DrawShapeObject.js */ "./node_modules/jsge/src/base/2d/DrawShapeObject.js");
/* harmony import */ var _Primitives_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Primitives.js */ "./node_modules/jsge/src/base/2d/Primitives.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../constants.js */ "./node_modules/jsge/src/constants.js");
/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Exception.js */ "./node_modules/jsge/src/base/Exception.js");
/* harmony import */ var _Temp_ImageTempStorage_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Temp/ImageTempStorage.js */ "./node_modules/jsge/src/base/Temp/ImageTempStorage.js");






/**
 * @extends DrawShapeObject
 * @see {@link DrawObjectFactory} should be created with factory method
 */
class DrawTextObject extends _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_0__.DrawShapeObject {
    #font;
    #textAlign;
    #textBaseline;
    #fillStyle;
    #strokeStyle;
    #text;
    #textMetrics;
    /**
     * @type {HTMLCanvasElement}
     */
    #textureCanvas = document.createElement("canvas");

    /**
     * @type {ImageTempStorage}
     */
    #textureStorage;

    /**
     * @hideconstructor
     */
    constructor(mapX, mapY, text, font, fillStyle) {
        super(_constants_js__WEBPACK_IMPORTED_MODULE_2__.DRAW_TYPE.TEXT, mapX, mapY);
        this.#text = text;
        this.#font = font;
        this.#fillStyle = fillStyle;
        this.#textMetrics;
        this.#calculateCanvasTextureAndMeasurements();
    }

    /**
     * Rectangle text box.
     * @type {Rectangle}
     */
    get boundariesBox() {
        const width = this.textMetrics ? Math.floor(this.textMetrics.width) : 300,
            height = this.textMetrics ? Math.floor(this.textMetrics.fontBoundingBoxAscent + this.textMetrics.fontBoundingBoxDescent): 30;
        return new _Primitives_js__WEBPACK_IMPORTED_MODULE_1__.Rectangle(this.x, this.y - height, width, height);
    }

    get vertices() {
        const bb = this.boundariesBox;
        return this._calculateRectVertices(bb.width, bb.height);
    }

    /**
     * @type {string}
     */
    get text() {
        return this.#text;
    }

    set text(value) {
        if (value !== this.#text) {
            this.#text = value;
            this.#calculateCanvasTextureAndMeasurements();
        }
    }

    /**
     * @type {string}
     */
    get font() {
        return this.#font;
    }

    set font(value) {
        if (value !== this.#font) {
            this.#font = value;
            this.#calculateCanvasTextureAndMeasurements();
        }
    }

    /**
     * @type {string}
     */
    get textAlign() {
        return this.#textAlign;
    }

    set textAlign(value) {
        if (value !== this.#textAlign) {
            this.#textAlign = value;
            this.#calculateCanvasTextureAndMeasurements();
        }
    }

    /**
     * @type {string}
     */
    get textBaseline() {
        return this.#textBaseline;
    }

    set textBaseline(value) {
        if (value !== this.#textBaseline) {
            this.#textBaseline = value;
            this.#calculateCanvasTextureAndMeasurements();
        }
    }

    /**
     * font color
     * @type {string}
     */
    get fillStyle() {
        return this.#fillStyle;
    }

    /**
     * font color
     */
    set fillStyle(value) {
        if (value !== this.#fillStyle) {
            this.#fillStyle = value;
            this.#calculateCanvasTextureAndMeasurements();
        }
    }

    /**
     * font stroke color
     * @type {string}
     */
    get strokeStyle() {
        return this.#strokeStyle;
    }

    /**
     * font stroke color
     */
    set strokeStyle(value) {
        if (value !== this.#strokeStyle) {
            this.#strokeStyle = value;
            this.#calculateCanvasTextureAndMeasurements();
        }
    }

    /**
     * @type {TextMetrics}
     */
    get textMetrics() {
        return this.#textMetrics;
    }

    /**
     * @ignore
     */
    set _textMetrics(value) {
        this.#textMetrics = value;
    }

    /**
     * @ignore
     */
    get _textureStorage() {
        return this.#textureStorage;
    }

    /**
     * @ignore
     */
    set _textureStorage(texture) {
        this.#textureStorage = texture;
    }

    /**
     * @ignore
     */
    get _textureCanvas() {
        return this.#textureCanvas;
    }

    /**
     * 
     * @returns {void}
     */
    #calculateCanvasTextureAndMeasurements() {
        const ctx = this.#textureCanvas.getContext("2d", { willReadFrequently: true }); // cpu counting instead gpu
        if (ctx) {
            //ctx.clearRect(0, 0, this.#textureCanvas.width, this.#textureCanvas.height);
            ctx.font = this.font;
            this._textMetrics = ctx.measureText(this.text);
            const boxWidth = this.boundariesBox.width, 
                boxHeight = this.boundariesBox.height;
            
            ctx.canvas.width = boxWidth;
            ctx.canvas.height = boxHeight;
            // after canvas resize, have to cleanup and set the font again
            ctx.clearRect(0, 0, boxWidth, boxHeight);
            ctx.font = this.font;
            ctx.textBaseline = "bottom";// bottom
            if (this.fillStyle) {
                ctx.fillStyle = this.fillStyle;
                ctx.fillText(this.text, 0, boxHeight);
            } 
            if (this.strokeStyle) {
                ctx.strokeStyle = this.strokeStyle;
                ctx.strokeText(this.text, 0, boxHeight);
            }
            
            if (this.#textureStorage) {
                this.#textureStorage._isTextureRecalculated = true;
            }

            // debug canvas
            // this.#textureCanvas.style.position = "absolute";
            // document.body.appendChild(this.#textureCanvas);
            
        } else {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_3__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_2__.ERROR_CODES.UNHANDLED_EXCEPTION, "can't getContext('2d')");
        }
    }
}

/***/ }),

/***/ "./node_modules/jsge/src/base/2d/DrawTiledLayer.js":
/*!*********************************************************!*\
  !*** ./node_modules/jsge/src/base/2d/DrawTiledLayer.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DrawTiledLayer: () => (/* binding */ DrawTiledLayer)
/* harmony export */ });
/* harmony import */ var _AnimationEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AnimationEvent.js */ "./node_modules/jsge/src/base/AnimationEvent.js");
/* harmony import */ var _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DrawShapeObject.js */ "./node_modules/jsge/src/base/2d/DrawShapeObject.js");
/* harmony import */ var _Temp_ImageTempStorage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Temp/ImageTempStorage.js */ "./node_modules/jsge/src/base/Temp/ImageTempStorage.js");
/* harmony import */ var _Temp_TiledLayerTempStorage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Temp/TiledLayerTempStorage.js */ "./node_modules/jsge/src/base/Temp/TiledLayerTempStorage.js");




/**
 * A render object represents a layer from tiled editor
 * @see {@link DrawObjectFactory} should be created with factory method
 */
class DrawTiledLayer {
    #layerKey;
    #tileMapKey;
    #tilemap;
    #tilesets;
    /**
     * @type {string}
     */
    #DELIMITER = "-#-";
    #tilesetImages;
    /**
     * @type {Array<ImageTempStorage>}
     */
    #textureStorages;
    #layerData;
    #setBoundaries;
    #drawBoundaries;
    #attachedMaskId;
    /**
     * @type {number}
     */
    #sortIndex = 0;
    /**
     * @type {Map<string, AnimationEvent>}
     */
    #animations = new Map();
    /**
     * @type {boolean}
     */
    #isOffsetTurnedOff;
    /**
     * @type {boolean}
     */
    #isRemoved = false;

    /**
     * @hideconstructor
     */
    constructor(layerKey, tileMapKey, tilemap, tilesets, tilesetImages, layerData, setBoundaries = false, shapeMask) {
        this.#layerKey = layerKey;
        this.#tileMapKey = tileMapKey;
        this.#tilemap = tilemap;
        this.#tilesets = tilesets;
        this.#textureStorages = [];
        this.#tilesetImages = tilesetImages;
        this.#layerData = layerData;
        
        this.#setBoundaries = setBoundaries;
        this.#drawBoundaries = setBoundaries ? setBoundaries : false;
        if (shapeMask) {
            this.setMask(shapeMask);
        }
        this.#processData(tilesets, layerData);
    }

    /**
     * A layer name.
     * @type {string}
     */
    get layerKey() {
        return this.#layerKey;
    }

    /**
     * A tilemap layer key, should match key from the tilemap.
     * @type {string}
     */
    get tileMapKey() {
        return this.#tileMapKey;
    }

    get tilemap() {
        return this.#tilemap;
    }
    
    get tilesets() {
        return this.#tilesets;
    }

    get tilesetImages() {
        return this.#tilesetImages;
    }

    get layerData() {
        return this.#layerData;
    }
    /**
     * Should the layer borders used as boundaries, or not
     * Can be set in GameStage.addRenderLayer() method.
     * @type {boolean}
     */
    get setBoundaries() {
        return this.#setBoundaries;
    }

    /**
     * Should draw a boundaries helper, or not
     * Can be set in SystemSettings.
     * @type {boolean}
     */
    get drawBoundaries() {
        return this.#drawBoundaries;
    }

    set drawBoundaries(value) {
        this.#drawBoundaries = value;
    }

    get isRemoved() {
        return this.#isRemoved;
    }

    set isRemoved(value) {
        this.#isRemoved = value;
    }
    /**
     * @ignore
     */
    get _maskId() {
        return this.#attachedMaskId;
    }
    /**
     * 
     * @param {DrawShapeObject} mask 
     */
    setMask(mask) {
        mask._isMask = true;
        this.#attachedMaskId = mask.id;
    }

    removeMask() {
        this.#attachedMaskId = null;
    }

    /**
     * @type {number}
     */
    get sortIndex () {
        return this.#sortIndex;
    }

    set sortIndex(value) {
        this.#sortIndex = value;
    }

    get isOffsetTurnedOff() {
        return this.#isOffsetTurnedOff;
    }
    turnOffOffset() {
        this.#isOffsetTurnedOff = true;
    }

    /**
     * Determines if image is animated or not
     * @type {boolean}
     */
    get hasAnimations() {
        return this.#animations.size > 0;
    }

    /**
     * @ignore
     */
    get _textureStorages() {
        return this.#textureStorages;
    }

    /**
     * @ignore
     */
    _setTextureStorage(index, value) {
        this.#textureStorages[index] = value;
    }

    /**
     * Tilesets has a property tiles, which could contain tile animations
     * or object boundaries, this is workaround for split this and add
     * additional properties for use in draw phase:
     * _hasAnimations
     * _animations - Map<id:activeSprite>
     * _hasBoundaries
     * _boundaries - Map<id:objectgroup>
     * @param {*} tilesets
     */
    #processData(tilesets, layerData) {
        //     ,       
        //       
        //        
        let ellipseBLen = 0,
            pointBLen = 0,
            polygonBLen = 0;
        tilesets.forEach((tileset, idx) => {
            const tiles = tileset.tiles,
                name = tileset.name,
                firstgid = tileset.firstgid,
                nextTileset = this.tilesets[idx + 1],
                nextgid = nextTileset ? nextTileset.firstgid : 1_000_000_000;
                
            if (tiles) {
                for (let tile of tiles) {
                    const animation = tile.animation,
                        objectgroup = tile.objectgroup,
                        id = tile.id;
                    if (animation) {
                        const eventName = name + this.#DELIMITER + id, 
                            animationIndexes = this.#fixAnimationsItems(animation),
                            animationEvent = new _AnimationEvent_js__WEBPACK_IMPORTED_MODULE_0__.AnimationEvent(eventName, animationIndexes, true);

                        this.#animations.set(eventName, animationEvent);
                        // add additional properties
                        if (!tileset._hasAnimations) {
                            tileset._hasAnimations = true;
                            tileset._animations = new Map();
                            //
                            tileset._animations.set(id, animationIndexes[0][0]);
                        }
                        this.#activateAnimation(animationEvent);
                    }
                    if (objectgroup && this.#setBoundaries) {
                        if (tileset._hasBoundaries) {
                            tileset._boundaries.set(id, objectgroup);
                        } else {
                            // add additional properties
                            tileset._hasBoundaries = true;
                            tileset._boundaries = new Map();
                            tileset._boundaries.set(id, objectgroup);
                        }
                        objectgroup.objects.forEach((object) => {
                            if (object.ellipse) {
                                const cellsWithB = layerData.data.filter((tile) => tile === id + firstgid).length;
                                ellipseBLen += (4 * cellsWithB); // (x, y, wRad, hRad) * layer items
                            } else if (object.point) {
                                const cellsWithB = layerData.data.filter((tile) => tile === id + firstgid).length;
                                pointBLen += (2 * cellsWithB); // (x, y) * layer items
                            } else if (object.polygon) {
                                const cellsWithB = layerData.data.filter((tile) => tile === id + firstgid).length;
                                polygonBLen += (object.polygon.length * 2 * cellsWithB); // (each point * 2(x,y) ) * layer items
                            } else { // rect object
                                const cellsWithB = layerData.data.filter((tile) => tile === id + firstgid).length;
                                polygonBLen += (16 * cellsWithB); // (4 faces * 4 cords for each one) * layer items
                            }
                        });
                    }
                }
            }
            
            const nonEmptyCells = layerData.data.filter((tile) => ((tile >= firstgid) && (tile < nextgid))).length,
                cells = layerData.data.length;

            if (this.#setBoundaries) {
                polygonBLen+=(nonEmptyCells * 16); // potential boundaries also nonEmptyCells
            }
            //         
            // help class for draw calculations
            tileset._temp = new _Temp_TiledLayerTempStorage_js__WEBPACK_IMPORTED_MODULE_3__.TiledLayerTempStorage(cells, nonEmptyCells);
        });
        
        // save boundaries max possible lengths
        layerData.ellipseBoundariesLen = ellipseBLen;
        layerData.pointBoundariesLen = pointBLen;
        layerData.polygonBoundariesLen = polygonBLen;
    }

    /**
     * 
     * @param {Array<{duration:number, tileid:number}>} animation 
     * @returns {Array<{duration:number, id:number}>}
     */
    #fixAnimationsItems(animation) {
        return animation.map((animation_item) => ({duration:animation_item.duration, id: animation_item.tileid}));
    }
    /**
     * @ignore
     */
    _processActiveAnimations() {
        for (let animationEvent of this.#animations.values()) {
            if (animationEvent.isActive) {
                animationEvent.iterateAnimationIndex();
                this.#switchCurrentActiveSprite(animationEvent);
            }
        }
    }

    #activateAnimation = (animationEvent) => {
        animationEvent.activateAnimation();
        this.#switchCurrentActiveSprite(animationEvent);
    }; 

    #switchCurrentActiveSprite = (animationEvent) => {
        const [tilesetKey, animationId] = animationEvent.name.split(this.#DELIMITER),
            tilesetIndex = this.#tilesets.findIndex(tileset => tileset.name === tilesetKey),
            tileset = this.#tilesets[tilesetIndex];
            
        tileset._animations.set(parseInt(animationId), animationEvent.currentSprite);
    };

    /**
     *
     * @param {string} eventName - animation name
     */
    stopRepeatedAnimation (eventName) {
        this.#animations.get(eventName).deactivateAnimation();
    }

    /**
     * Removes animations
     */
    removeAllAnimations() {
        for (let [eventName, animationEvent] of this.#animations.entries()) {
            this.removeEventListener(eventName, animationEvent.activateAnimation);
            animationEvent.deactivateAnimation();
        }
        this.#animations.clear();
        this.#animations = undefined;
    }

    destroy() {
        this.removeAllAnimations();
        super.destroy();
    }
}


/***/ }),

/***/ "./node_modules/jsge/src/base/2d/Primitives.js":
/*!*****************************************************!*\
  !*** ./node_modules/jsge/src/base/2d/Primitives.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Rectangle: () => (/* binding */ Rectangle),
/* harmony export */   Vector: () => (/* binding */ Vector),
/* harmony export */   Vertex: () => (/* binding */ Vertex)
/* harmony export */ });
class Vertex {
    #x;
    #y;
    constructor(x, y) {
        this.#x = x;
        this.#y = y;
    }

    get x() {
        return this.#x;
    }

    get y() {
        return this.#y;
    }
}

class Rectangle {
    #x;
    #y;
    #w;
    #h;
    constructor(x, y, w, h) {
        this.#x = x;
        this.#y = y;
        this.#w = w;
        this.#h = h; 
    }
    /**
     * @type {number}
     */
    get x() {
        return this.#x;
    }
    /**
     * @type {number}
     */
    get y() {
        return this.#y;
    }
    /**
     * @type {number}
     */
    get width() {
        return this.#w;
    }
    /**
     * @type {number}
     */
    get height() {
        return this.#h;
    }
}

class Vector {
    #x;
    #y;
    constructor(x1, y1, x2, y2) {
        this.#x = x2 - x1;
        this.#y = y2 - y1;
    }

    get x() {
        return this.#x;
    }

    get y() {
        return this.#y;
    }

    get length() {
        return Math.sqrt(Math.pow(this.#x, 2) + Math.pow(this.#y, 2));
    }

    get tetaAngle() {
        return Math.atan2(this.#y, this.#x);
    }
}



/***/ }),

/***/ "./node_modules/jsge/src/base/AnimationEvent.js":
/*!******************************************************!*\
  !*** ./node_modules/jsge/src/base/AnimationEvent.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnimationEvent: () => (/* binding */ AnimationEvent)
/* harmony export */ });
class AnimationEvent {
    #eventName;
    /**
     * @type {number}
     */
    #defaultDurationTime = 100;
    /**
     * Array [sprite index, duration]
     * @type { Array<Array<number, number>> }
     */
    #animationSpriteIndexes;
    /**
     * 
     * @type {number}
     */
    #currentAnimationItemIndex;
    /**
     * @type {boolean}
     */
    #isActive;
    /**
     * @type {boolean}
     */
    #isRepeated;
    /**
     * @type {number}
     */
    #lastAnimationTimeStamp;
    
    constructor(eventName, animationSpriteIndexes, isRepeated = false, currentSpriteIndex, isActive = false) {
        this.#eventName = eventName;
        this.#animationSpriteIndexes = this.#convertToArray(animationSpriteIndexes);
        this.#currentAnimationItemIndex = currentSpriteIndex ? currentSpriteIndex : 0;
        this.#isActive = isActive;
        this.#isRepeated = isRepeated;
    }

    get name() {
        return this.#eventName;
    }

    get isActive() {
        return this.#isActive;
    }

    get currentSprite() {
        return this.#animationSpriteIndexes[this.#currentAnimationItemIndex][0];
    }

    get _isLastSprite() {
        return (this.#animationSpriteIndexes.length - 1) === this.#currentAnimationItemIndex;
    }

    iterateAnimationIndex() {
        const currentIndex = this.#currentAnimationItemIndex,
            currentDuration = this.#animationSpriteIndexes[currentIndex][1],
            lastIterationTime = Date.now() - this.#lastAnimationTimeStamp;
        // iterate or skip
        if (currentDuration < lastIterationTime) {
            if (!this._isLastSprite) {
                this.#currentAnimationItemIndex++;
            } else {
                if (!this.#isRepeated) {
                    this.deactivateAnimation();
                } else {
                    // take first element
                    this.#currentAnimationItemIndex = 0;
                    
                }
            }
            // reset timestamp
            this.#lastAnimationTimeStamp = Date.now();
        }
    }

    activateAnimation = () => {
        this.#isActive = true;
        this.#currentAnimationItemIndex = 0;
        this.#lastAnimationTimeStamp = Date.now();
    };

    deactivateAnimation = () => {
        this.#isActive = false;
    };

    #convertToArray(animationSpriteIndexes) {
        let animationArray = [];
        animationSpriteIndexes.forEach(element => {
            if (typeof element.id === "number" && typeof element.duration === "number") {
                animationArray.push([element.id, element.duration]);
            } else {
                animationArray.push([element, this.#defaultDurationTime]);
            }
            
        });
        return animationArray;
    }
}

/***/ }),

/***/ "./node_modules/jsge/src/base/DrawObjectFactory.js":
/*!*********************************************************!*\
  !*** ./node_modules/jsge/src/base/DrawObjectFactory.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DrawObjectFactory: () => (/* binding */ DrawObjectFactory)
/* harmony export */ });
/* harmony import */ var _2d_DrawRectObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./2d/DrawRectObject.js */ "./node_modules/jsge/src/base/2d/DrawRectObject.js");
/* harmony import */ var _2d_DrawTextObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./2d/DrawTextObject.js */ "./node_modules/jsge/src/base/2d/DrawTextObject.js");
/* harmony import */ var _2d_DrawConusObject_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./2d/DrawConusObject.js */ "./node_modules/jsge/src/base/2d/DrawConusObject.js");
/* harmony import */ var _2d_DrawImageObject_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./2d/DrawImageObject.js */ "./node_modules/jsge/src/base/2d/DrawImageObject.js");
/* harmony import */ var _2d_DrawLineObject_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./2d/DrawLineObject.js */ "./node_modules/jsge/src/base/2d/DrawLineObject.js");
/* harmony import */ var _2d_DrawPolygonObject_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./2d/DrawPolygonObject.js */ "./node_modules/jsge/src/base/2d/DrawPolygonObject.js");
/* harmony import */ var _2d_DrawCircleObject_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./2d/DrawCircleObject.js */ "./node_modules/jsge/src/base/2d/DrawCircleObject.js");
/* harmony import */ var _2d_DrawTiledLayer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./2d/DrawTiledLayer.js */ "./node_modules/jsge/src/base/2d/DrawTiledLayer.js");
/* harmony import */ var _2d_DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./2d/DrawShapeObject.js */ "./node_modules/jsge/src/base/2d/DrawShapeObject.js");
/* harmony import */ var _GameStageData_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./GameStageData.js */ "./node_modules/jsge/src/base/GameStageData.js");
/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Exception.js */ "./node_modules/jsge/src/base/Exception.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../constants.js */ "./node_modules/jsge/src/constants.js");
/* harmony import */ var _modules_assetsm_src_AssetsManager_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../modules/assetsm/src/AssetsManager.js */ "./node_modules/jsge/modules/assetsm/src/AssetsManager.js");














/**
 * Creates drawObjects instances.<br>
 * accessible via GameStage.draw <br>
 * Attach images for image objects and tilemaps <br>
 * Adds drawObjects to current GameStage.stageData
 * @see {@link GameStage} a part of GameStage
 */
class DrawObjectFactory {
    /**
     * @type {AssetsManager}
     */
    #iLoader;
    /**
     * @type {GameStageData | null}
     */
    #currentPageData;
    /**
     * @hideconstructor 
     */
    constructor(iLoader) {
        this.#iLoader = iLoader;
    }

    get stageData() {
        return this.#currentPageData;
    }

    /**
     * 
     * @param {*} renderObject 
     * @returns {void}
     */
    #addObjectToPageData(renderObject) {
        this.#currentPageData._renderObject = renderObject;
    }
    /**
     * @param {number} x 
     * @param {number} y 
     * @param {number} width 
     * @param {number} height 
     * @param {string} backgroundColor - rgba(r,g,b,a)
     * @returns {DrawRectObject}
     */
    rect(x, y, width, height, backgroundColor) {
        const renderObject = new _2d_DrawRectObject_js__WEBPACK_IMPORTED_MODULE_0__.DrawRectObject(x, y, width, height, backgroundColor);
        this.#addObjectToPageData(renderObject);
        return renderObject; 
    }

    /**
     * @param {number} x 
     * @param {number} y 
     * @param {string} text 
     * @param {string} font - size fontFamily
     * @param {string} color - rgba(r,g,b,a)
     * @returns {DrawTextObject}
     */
    text(x, y, text, font, color) {
        const renderObject = new _2d_DrawTextObject_js__WEBPACK_IMPORTED_MODULE_1__.DrawTextObject(x, y, text, font, color);
        this.#addObjectToPageData(renderObject);
        return renderObject;
    }

    /**
     * 
     * @param {number} radius 
     * @param {string} bgColor - rgba(r,g,b,a)
     * @param {number=} angle
     * @param {number=} [fade=0] (0 - 1)
     * @returns {DrawConusObject}
     */
    conus(x, y, radius, bgColor, angle, fade = 0) {
        const renderObject = new _2d_DrawConusObject_js__WEBPACK_IMPORTED_MODULE_2__.DrawConusObject(x, y, radius, bgColor, angle, fade);
        this.#addObjectToPageData(renderObject);
        return renderObject;
    }

    /**
     * 
     * @param {number} radius 
     * @param {string} bgColor - rgba(r,g,b,a)
     * @returns {DrawCircleObject}
     */
    circle(x, y, radius, bgColor) {
        const renderObject = new _2d_DrawCircleObject_js__WEBPACK_IMPORTED_MODULE_6__.DrawCircleObject(x, y, radius, bgColor);
        this.#addObjectToPageData(renderObject);
        return renderObject;
    }

    /**
     * @param {number} x 
     * @param {number} y 
     * @param {number} width 
     * @param {number} height 
     * @param {string} key 
     * @param {number} [imageIndex = 0]
     * @param {Array<{x:Number, y:Number}> | {r:number}=} boundaries - boundaries as polygon, or circle
     * @param {number} [spacing = 0] - for tilesets.spacing > 0
     * @param {number} [margin = 0] - for tilesets.margin > 0
     * @returns {DrawImageObject}
     */
    image(x, y, width, height, key, imageIndex = 0, boundaries, spacing = 0, margin = 0) {
        const image = this.#iLoader.getImage(key);

        if (!image) {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_10__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_11__.ERROR_CODES.CANT_GET_THE_IMAGE, "iLoader can't get the image with key: " + key);
        }
            
        const renderObject = new _2d_DrawImageObject_js__WEBPACK_IMPORTED_MODULE_3__.DrawImageObject(x, y, width, height, key, imageIndex, boundaries, image, spacing, margin);
        
        this.#addObjectToPageData(renderObject);
        return renderObject;
    }

    /**
     * @param {Array<number>} vertices 
     * @param {string} color - rgba(r,g,b,a)
     * @returns {DrawLineObject}
     */
    line(vertices, color) {
        const renderObject = new _2d_DrawLineObject_js__WEBPACK_IMPORTED_MODULE_4__.DrawLineObject(vertices, color);
        this.#addObjectToPageData(renderObject);
        return renderObject;
    }

    /**
     * @param {Array<{x:number, y:number}>} vertices - should go in anticlockwise order
     * @param {string} bgColor - rgba(r,g,b,a)
     * @returns {DrawPolygonObject}
     */
    polygon(vertices, bgColor) {
        const renderObject = new _2d_DrawPolygonObject_js__WEBPACK_IMPORTED_MODULE_5__.DrawPolygonObject(vertices, bgColor);
        this.#addObjectToPageData(renderObject);
        return renderObject;
    }

    /**
     * 
     * @param {string} layerKey 
     * @param {string} tileMapKey 
     * @param {boolean=} setBoundaries 
     * @param {DrawShapeObject=} shapeMask 
     * @returns {DrawTiledLayer}
     */
    tiledLayer(layerKey, tileMapKey, setBoundaries, shapeMask) {
        const tilemap = this.#iLoader.getTileMap(tileMapKey),
            layerData = Object.assign({}, tilemap.layers.find((layer) => layer.name === layerKey)), // copy to avoid change same tilemap instance in different tiledLayers
            tilesetIds = Array.from(new Set(layerData.data.filter((id) => id !== 0))).sort((a, b) => a - b),
            tilesets = tilemap.tilesets.map((tileset) => Object.assign({}, tileset)).filter((tileset) => {
                const tilesetStartI = tileset.firstgid,
                    tilesetLastI = tilesetStartI + tileset.tilecount;
                if (tilesetIds.find((id) => ((id >= tilesetStartI) && (id < tilesetLastI)))) {
                    return true;
                } else {
                    return false;
                }
            }), // copy to avoid change same tilemap instance in different tiledLayers
            tilesetImages = tilesets.map((tileset) => this.#iLoader.getImage(tileset.name)),
            renderObject = new _2d_DrawTiledLayer_js__WEBPACK_IMPORTED_MODULE_7__.DrawTiledLayer(layerKey, tileMapKey, tilemap, tilesets, tilesetImages, layerData, setBoundaries, shapeMask);
        if (tilesetImages.length > 1) {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_10__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_11__.WARNING_CODES.MULTIPLE_IMAGE_TILESET, " tileset " + layerKey + " includes multiple images, it can case performance issues!");
        }
        //console.log(layerKey);
        //console.log(tilesetIds);
        this.#addObjectToPageData(renderObject);
        return renderObject;
    }

    /**
     * @ignore
     * @param {string} methodKey 
     * @param {Function} createObjectInstance
     */
    _registerNewObjectMethod = (methodKey, createObjectInstance) => {
        this[methodKey] = (...args) => this.#createObjectAndAddToPageData(createObjectInstance, ...args);
    };

    /**
     * @ignore
     * @param {Function} createInstance
     * @param {Array<any>} args
     */
    #createObjectAndAddToPageData = (createInstance, ...args) => {
        const instance = createInstance(...args);
        this.#addObjectToPageData(instance);
        return instance;
    };

    /**
     * @ignore
     * @param {GameStageData} pageData;
     */
    _attachPageData = (pageData) => {
        this.#currentPageData = pageData;
    };
    /**
     * @ignore
     */
    _detachPageData = () => {
        this.#currentPageData = null;
    };
}

/***/ }),

/***/ "./node_modules/jsge/src/base/Events/SystemEvent.js":
/*!**********************************************************!*\
  !*** ./node_modules/jsge/src/base/Events/SystemEvent.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SystemEvent: () => (/* binding */ SystemEvent)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./node_modules/jsge/src/constants.js");
/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Exception.js */ "./node_modules/jsge/src/base/Exception.js");



class SystemEvent extends Event {
    #data;
    constructor(eventValue, data){
        super(eventValue);
        if (!this.#isEventExist(eventValue)) {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.UNEXPECTED_EVENT_NAME, ", Please check if event is exist");
        }
        this.#data = data;
    }

    #isEventExist(eventValue) {
        return Object.values(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.SERVER_CLIENT).find(eventVal => eventVal === eventValue);
    }

    get data () {
        return this.#data;
    }
}

/***/ }),

/***/ "./node_modules/jsge/src/base/Exception.js":
/*!*************************************************!*\
  !*** ./node_modules/jsge/src/base/Exception.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Exception: () => (/* binding */ Exception),
/* harmony export */   Warning: () => (/* binding */ Warning)
/* harmony export */ });
function Exception (code, message) {
    throw new Error(code + ": " + message);
}

function Warning (code, message) {
    console.warn(code, message);
}

/***/ }),

/***/ "./node_modules/jsge/src/base/GameStage.js":
/*!*************************************************!*\
  !*** ./node_modules/jsge/src/base/GameStage.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GameStage: () => (/* binding */ GameStage)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "./node_modules/jsge/src/constants.js");
/* harmony import */ var _GameStageData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameStageData.js */ "./node_modules/jsge/src/base/GameStageData.js");
/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Exception.js */ "./node_modules/jsge/src/base/Exception.js");
/* harmony import */ var _modules_assetsm_src_AssetsManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../modules/assetsm/src/AssetsManager.js */ "./node_modules/jsge/modules/assetsm/src/AssetsManager.js");
/* harmony import */ var _DrawObjectFactory_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DrawObjectFactory.js */ "./node_modules/jsge/src/base/DrawObjectFactory.js");
/* harmony import */ var _2d_DrawCircleObject_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./2d/DrawCircleObject.js */ "./node_modules/jsge/src/base/2d/DrawCircleObject.js");
/* harmony import */ var _2d_DrawConusObject_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./2d/DrawConusObject.js */ "./node_modules/jsge/src/base/2d/DrawConusObject.js");
/* harmony import */ var _2d_DrawImageObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./2d/DrawImageObject.js */ "./node_modules/jsge/src/base/2d/DrawImageObject.js");
/* harmony import */ var _2d_DrawLineObject_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./2d/DrawLineObject.js */ "./node_modules/jsge/src/base/2d/DrawLineObject.js");
/* harmony import */ var _2d_DrawPolygonObject_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./2d/DrawPolygonObject.js */ "./node_modules/jsge/src/base/2d/DrawPolygonObject.js");
/* harmony import */ var _2d_DrawRectObject_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./2d/DrawRectObject.js */ "./node_modules/jsge/src/base/2d/DrawRectObject.js");
/* harmony import */ var _2d_DrawTextObject_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./2d/DrawTextObject.js */ "./node_modules/jsge/src/base/2d/DrawTextObject.js");
/* harmony import */ var _ISystem_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ISystem.js */ "./node_modules/jsge/src/base/ISystem.js");
/* harmony import */ var _ISystemAudio_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./ISystemAudio.js */ "./node_modules/jsge/src/base/ISystemAudio.js");
/* harmony import */ var _configs_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../configs.js */ "./node_modules/jsge/src/configs.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../utils.js */ "./node_modules/jsge/src/utils.js");
/* harmony import */ var _2d_Primitives_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./2d/Primitives.js */ "./node_modules/jsge/src/base/2d/Primitives.js");


















/**
 * Represents the stage of the game,<br>
 * Contains pages logic.<br>
 * Instances should be created and registered with System.registerStage() factory method
 * 
 * @see {@link System} instances of this class holds by the System class
 * @hideconstructor
 * @abstract
 */
class GameStage {
    /**
     * @type {string}
     */
    #name;
    /**
     * @type {boolean}
     */
    #isInitiated = false;
    /**
     * @type {boolean}
     */
    #isActive;
    /**
     * @type {ISystem}
     */
    #iSystemReference;
    /**
     * @type {GameStageData}
     */
    #stageData;

    constructor() {
        this.#isActive = false;
        
    }

    /**
     * Register stage
     * @param {string} name
     * @param {ISystem} system 
     * @ignore
     */
    _register(name, system) {
        this.#name = name;
        this.#iSystemReference = system;
        this.#stageData = new _GameStageData_js__WEBPACK_IMPORTED_MODULE_1__.GameStageData(this.#iSystemReference.systemSettings.gameOptions);
        this.#setWorldDimensions();
        this.#setCanvasSize();
        this.register();
    }

    /**
     * Initialization stage
     * @ignore
     */
    _init() {
        this.init();
        this.#isInitiated = true;
    }

    /**
     * @tutorial stages_lifecycle
     * Custom logic for register stage
     */
    register() {}
    /**
     * @tutorial stages_lifecycle
     * Custom logic for init stage
     */
    init() {}
    /**
     * Custom logic for start stage
     * @param {Object=} options
     */
    start(options) {}
    /**
     * @tutorial stages_lifecycle
     * Custom logic for stop stage
     */
    stop() {}
    /**
     * Custom logic for resize stage
     */
    resize() {}

    /**
     * @tutorial assets_manager
     * @returns {AssetsManager}
     */
    get iLoader() {
        return this.#iSystemReference.iLoader;
    }

    /**
     * @returns {DrawObjectFactory}
     */
    get draw() {
        return this.#iSystemReference.drawObjectFactory;
    }

    /**
     * Attach all canvas elements from the #views to container
     * @param {HTMLElement} container
     * @ignore
     */
    _attachCanvasToContainer(container) {
        this.#attachElementToContainer(this.canvasHtmlElement, container);
    }

    /**
     * Add render object to the stageData
     * @param { DrawConusObject | DrawImageObject | 
     *          DrawLineObject | DrawPolygonObject | 
     *          DrawRectObject | DrawCircleObject | 
     *          DrawTextObject } renderObject 
     */
    addRenderObject = (renderObject) => {
        const data = this.stageData,
            isDataAlreadyAdded = data.renderObjects.indexOf(renderObject) !== -1;
        if (isDataAlreadyAdded) {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.NEW_BEHAVIOR_INTRODUCED, "stage.draw methods add objects to pageData, no need to call addRenderObject");
        } else {
            data._renderObject = renderObject;
        }
    };

    /**
     * Determines if this stage render is Active or not
     * @returns {boolean}
     */
    get isActive() {
        return this.#isActive;
    }

    /**
     * Determines if this stage is initialized or not
     * @returns {boolean}
     */
    get isInitiated() {
        return this.#isInitiated;
    }

    /**
     * Current stage name
     * @returns {string}
     */
    get name () {
        return this.#name;
    }

    /**
     * @returns {GameStageData}
     */
    get stageData() {
        return this.#stageData;
    }

    /**
     * @returns {SystemSettings}
     */
    get systemSettings() {
        return this.#iSystemReference.systemSettings;
    }

    /**
     * @returns {ISystemAudio}
     */
    get audio() {
        return this.#iSystemReference.audio;
    }

    /**
     * @returns {ISystem}
     */
    get iSystem() {
        return this.#iSystemReference;
    }

    get canvasHtmlElement() {
        return document.getElementsByTagName("canvas")[0];
    }

    /**
     * 
     * @param {string} eventName 
     * @param {*} listener 
     * @param {*=} options 
     */
    addEventListener = (eventName, listener, options) => {
        this.iSystem.addEventListener(eventName, listener, options);
    };

    /**
     * 
     * @param {string} eventName 
     * @param {*} listener 
     * @param {*=} options 
     */
    removeEventListener = (eventName, listener, options) => {
        this.iSystem.removeEventListener(eventName, listener, options);
    };

    /**
     * Start stage render
     * @param {Object=} options 
     * @ignore
     */
    _start(options) {
        this.start(options);
        this.#isActive = true;
        window.addEventListener("resize", this._resize);
        this._resize();
    }

    /**
     * Stop stage render
     * @ignore
     */
    _stop() {
        this.#isActive = false;
        window.removeEventListener("resize", this._resize);
        this.stop();
    }

    /**
     * Resize event
     * @ignore
     */
    _resize = () => {
        this.#setCanvasSize();
        this.resize();
    };

    /**
     * 
     * @param {HTMLCanvasElement} htmlElement 
     * @param {HTMLElement} container 
     */
    #attachElementToContainer(htmlElement, container) {
        container.appendChild(htmlElement);
    }

    #setWorldDimensions() {
        const width = this.systemSettings.worldSize ? this.systemSettings.worldSize.width : 0,
            height = this.systemSettings.worldSize ? this.systemSettings.worldSize.height : 0;
            
        this.stageData._setWorldDimensions(width, height);
    }

    //////////////////////////////////////////////////////
    //***************************************************/
    //****************** Collisions ********************//
    //**************************************************//
    //////////////////////////////////////////////////////

    /**
     * 
     * @param {number} x 
     * @param {number} y 
     * @param {DrawImageObject} drawObject 
     * @returns {{x:number, y:number, p:number} | boolean}
     */
    isBoundariesCollision = (x, y, drawObject) => {
        const drawObjectType = drawObject.type,
            vertices = drawObject.vertices,
            circleBoundaries = drawObject.circleBoundaries;
        switch(drawObjectType) {
        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.TEXT:
        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.RECTANGLE:
        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.CONUS:
        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.IMAGE:
            if (!circleBoundaries) {
                return this.#isPolygonToBoundariesCollision(x, y, vertices, drawObject.rotation);
            } else {
                return this.#isCircleToBoundariesCollision(x, y, drawObject.circleBoundaries.r);
            }
        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.CIRCLE:
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.METHOD_NOT_IMPLEMENTED, "isObjectCollision.circle check is not implemented yet!");
            break;
        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.LINE:
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.METHOD_NOT_IMPLEMENTED, "isObjectCollision.line check is not implemented yet, please use .rect instead line!");
            break;
        default:
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.UNKNOWN_DRAW_OBJECT, "unknown object type!");
        }
        return false;
    };

    /**
     * 
     * @param {number} x 
     * @param {number} y 
     * @param {DrawImageObject} drawObject
     * @param {Array<DrawImageObject>} objects - objects array to check
     * @returns {Array<Object> | boolean} - array of objects with collisions, or false if no collision happen
     */
    isObjectsCollision = (x, y, drawObject, objects) => {
        const drawObjectType = drawObject.type,
            drawObjectBoundaries = drawObject.vertices,
            circleBoundaries = drawObject.circleBoundaries;
        switch(drawObjectType) {
            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.TEXT:
            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.RECTANGLE:
            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.CONUS:
            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.IMAGE:
                if (!circleBoundaries) {
                    return this.#isPolygonToObjectsCollision(x, y, drawObjectBoundaries, drawObject.rotation, objects);
                } else {
                    return this.#isCircleToObjectsCollision(x, y, circleBoundaries, objects);
                }
            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.CIRCLE:
                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.METHOD_NOT_IMPLEMENTED, "isObjectCollision.circle check is not implemented yet!");
                break;
            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.LINE:
                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.METHOD_NOT_IMPLEMENTED, "isObjectCollision.line check is not implemented yet, please use .rect instead line!");
                break;
            default:
                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.UNKNOWN_DRAW_OBJECT, "unknown object type!");
        }
        return false;
    };
    #isPolygonToObjectsCollision(x, y, polygonVertices, polygonRotation, objects) {
        const len = objects.length;

        let collisions = [];
        for (let i = 0; i < len; i++) {
            const mapObject = objects[i],
                drawMapObjectType = mapObject.type;

            let coll;
            
            switch(drawMapObjectType) {
            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.TEXT:
            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.RECTANGLE:
            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.CONUS:
            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.IMAGE:
                coll = this.#isPolygonToPolygonCollision(x, y, polygonVertices, polygonRotation, mapObject);
                break;
            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.CIRCLE:
                console.warn("isObjectCollision.circle check is not implemented yet!");
                break;
            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.LINE:
                console.warn("isObjectCollision.line check is not implemented, please use rect instead");
                break;
            default:
                console.warn("unknown object type!");
            }
            if (coll) {
                collisions.push(mapObject);
            }
        }
        if (collisions.length > 0) {
            return collisions;
        } else {
            return false;
        }
    }

    #isCircleToObjectsCollision(x, y, drawObjectBoundaries, objects) {
        const radius = drawObjectBoundaries.r;

        const len = objects.length;

        let collisions = [];
        for (let i = 0; i < len; i++) {
            const mapObject = objects[i],
                drawMapObjectType = mapObject.type,
                circleBoundaries = mapObject.circleBoundaries;

            /**
             * @type {boolean | Object}
             */
            let coll;
            
            switch(drawMapObjectType) {
                case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.TEXT:
                case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.RECTANGLE:
                case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.CONUS:
                case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.IMAGE:
                    if (!circleBoundaries) {
                        coll = this.#isCircleToPolygonCollision(x, y, radius, mapObject);
                    } else {
                        coll = this.#isCircleToCircleCollision(x, y, radius, mapObject.x, mapObject.y, circleBoundaries.r);
                    }
                    break;
                case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.CIRCLE:
                    console.warn("isObjectCollision.circle check is not implemented yet!");
                    break;
                case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.LINE:
                    console.warn("isObjectCollision.line check is not implemented, please use rect instead");
                    break;
                default:
                    console.warn("unknown object type!");
            }
            if (coll) {
                collisions.push(mapObject);
            }
        }
        if (collisions.length > 0) {
            return collisions;
        } else {
            return false;
        }
    }
 
    #takeTheClosestCollision(collisions) {
        return collisions.sort((a,b) => a.p < b.p)[0];
    }

    #isCircleToPolygonCollision(x, y, radius, mapObject) {
        const [mapOffsetX, mapOffsetY] = this.stageData.worldOffset,
            xWithOffset = x - mapOffsetX,
            yWithOffset = y - mapOffsetY,
            mapObjXWithOffset = mapObject.x - mapOffsetX,
            mapObjYWithOffset = mapObject.y - mapOffsetY,
            mapObjVertices = mapObject.vertices, 
            mapObjRotation = mapObject.rotation,
            len = mapObjVertices.length;
        //console.log("map object check:");
        //console.log(mapObject);
        for (let i = 0; i < len; i+=1) {
            const mapObjFirstVertex = mapObjVertices[i];
            let mapObjNextVertex = mapObjVertices[i + 1];
            if (!mapObjNextVertex) {
                mapObjNextVertex = mapObjVertices[0];
            }
            const vertex = this.#calculateShiftedVertexPos(mapObjFirstVertex, mapObjXWithOffset, mapObjYWithOffset, mapObjRotation),
                nextVertex = this.#calculateShiftedVertexPos(mapObjNextVertex, mapObjXWithOffset, mapObjYWithOffset, mapObjRotation),
                edge = {
                    x1: vertex[0],
                    y1: vertex[1],
                    x2: nextVertex[0],
                    y2: nextVertex[1]
                },
                intersect = (0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.isCircleLineIntersect)(xWithOffset, yWithOffset, radius, edge);
            if (intersect) {
            //console.log("polygon: ", polygonWithOffsetAndRotation);
            //console.log("intersect: ", intersect);
                return intersect;
            }
        }
        return false;
    }

    #isCircleToCircleCollision(circle1X, circle1Y, circle1R, circle2X, circle2Y, circle2R) {
        const len = new _2d_Primitives_js__WEBPACK_IMPORTED_MODULE_16__.Vector(circle1X, circle1Y, circle2X, circle2Y).length;
        if ((len - (circle1R + circle2R)) > 0) {
            return false;
        } else {
            //@todo calculate point of intersect
            return true;
        }
    }

    #isPolygonToPolygonCollision(x, y, polygonVertices, polygonRotation, mapObject) {
        const [mapOffsetX, mapOffsetY] = this.stageData.worldOffset,
            xWithOffset = x - mapOffsetX,
            yWithOffset = y - mapOffsetY,
            mapObjXWithOffset = mapObject.x - mapOffsetX,
            mapObjYWithOffset = mapObject.y - mapOffsetY,
            mapObjVertices = mapObject.vertices, 
            mapObjRotation = mapObject.rotation,
            polygonWithOffsetAndRotation = polygonVertices.map((vertex) => (this.#calculateShiftedVertexPos(vertex, xWithOffset, yWithOffset, polygonRotation))),
            len = mapObjVertices.length;
        //console.log("map object check:");
        //console.log(mapObject);
        for (let i = 0; i < len; i+=1) {
            const mapObjFirstVertex = mapObjVertices[i];
            let mapObjNextVertex = mapObjVertices[i + 1];
            if (!mapObjNextVertex) {
                mapObjNextVertex = mapObjVertices[0];
            }
            const vertex = this.#calculateShiftedVertexPos(mapObjFirstVertex, mapObjXWithOffset, mapObjYWithOffset, mapObjRotation),
                nextVertex = this.#calculateShiftedVertexPos(mapObjNextVertex, mapObjXWithOffset, mapObjYWithOffset, mapObjRotation),
                edge = {
                    x1: vertex[0],
                    y1: vertex[1],
                    x2: nextVertex[0],
                    y2: nextVertex[1]
                },
                intersect = (0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.isPolygonLineIntersect)(polygonWithOffsetAndRotation, edge);
            if (intersect) {
                //console.log("polygon: ", polygonWithOffsetAndRotation);
                //console.log("intersect: ", intersect);
                return intersect;
            }
        }
        return false;
    }

    #calculateShiftedVertexPos(vertex, centerX, centerY, rotation) {
        const vector = new _2d_Primitives_js__WEBPACK_IMPORTED_MODULE_16__.Vector(0, 0, vertex[0], vertex[1]),
            vertexAngle = (0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.angle_2points)(0, 0, vertex[0], vertex[1]),
            len = vector.length;
            
        const newX = centerX + (len * Math.cos(rotation + vertexAngle)),
            newY = centerY + (len * Math.sin(rotation + vertexAngle));
        return [newX, newY];
    }
    /**
     * 
     * @param {number} x 
     * @param {number} y 
     * @param {number} r 
     * @returns {{x:number, y:number, p:number} | boolean}
     */
    #isCircleToBoundariesCollision(x, y, r) {
        const mapObjects = this.stageData.getRawBoundaries(),
            ellipseB = this.stageData.getEllipseBoundaries(),
            pointB = this.stageData.getPointBoundaries(),
            [mapOffsetX, mapOffsetY] = this.stageData.worldOffset,
            xWithOffset = x - mapOffsetX,
            yWithOffset = y - mapOffsetY,
            len = this.stageData.boundariesLen,
            eLen = this.stageData.ellipseBLen,
            pLen = this.stageData.pointBLen;

        for (let i = 0; i < len; i+=4) {
            const x1 = mapObjects[i],
                y1 = mapObjects[i + 1],
                x2 = mapObjects[i + 2],
                y2 = mapObjects[i + 3];

            if (x1 === 0 && y1 === 0 && x2 === 0 && y2 === 0) {
                continue;
            } else {
                const intersect = (0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.isCircleLineIntersect)(xWithOffset, yWithOffset, r, {x1, y1, x2, y2});
                
                if (intersect) {
                    //console.log("rotation: ", rotation);
                    //console.log("polygon: ", polygonWithOffsetAndRotation);
                    //console.log("intersect: ", intersect);
                    return intersect;
                }
            }
        }
        if (eLen > 0) {
            for (let i = 0; i < eLen; i+=4) {
                const ellipse = [ellipseB[i], ellipseB[i+1], ellipseB[i+2], ellipseB[i+3]],
                    intersect = (0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.isEllipseCircleIntersect)(ellipse, {x:xWithOffset, y:yWithOffset, r});
                if (intersect) {
                    //console.log("rotation: ", rotation);
                    //console.log("polygon: ", polygonWithOffsetAndRotation);
                    //console.log("intersect: ", intersect);
                    return intersect;
                }
            }
        }
        
        if (pLen > 0) {
            for (let i = 0; i < pLen; i+=2) {
                const xP = pointB[i],
                    yP = pointB[i + 1],
                    intersect = (0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.isPointCircleIntersect)(xP, yP, {x:xWithOffset, y:yWithOffset, r});
                if (intersect) {
                    //console.log("rotation: ", rotation);
                    //console.log("polygon: ", polygonWithOffsetAndRotation);
                    //console.log("intersect: ", intersect);
                    return intersect;
                }
            }
        }
        return false;
    }

    /**
     * @param {number} x
     * @param {number} y
     * @param {Array<Array<number>>} polygon
     * @param {number} rotation
     * @returns {{x:number, y:number, p:number} | boolean}
     */
    #isPolygonToBoundariesCollision(x, y, polygon, rotation) {
        const mapObjects = this.stageData.getRawBoundaries(),
            ellipseB = this.stageData.getEllipseBoundaries(),
            pointB = this.stageData.getPointBoundaries(),
            [mapOffsetX, mapOffsetY] = this.stageData.worldOffset,
            xWithOffset = x - mapOffsetX,
            yWithOffset = y - mapOffsetY,
            polygonWithOffsetAndRotation = polygon.map((vertex) => (this.#calculateShiftedVertexPos(vertex, xWithOffset, yWithOffset, rotation))),
            len = this.stageData.boundariesLen,
            eLen = this.stageData.ellipseBLen,
            pLen = this.stageData.pointBLen;

        for (let i = 0; i < len; i+=4) {
            const x1 = mapObjects[i],
                y1 = mapObjects[i + 1],
                x2 = mapObjects[i + 2],
                y2 = mapObjects[i + 3];

            if (x1 === 0 && y1 === 0 && x2 === 0 && y2 === 0) {
                continue;
            } else {
                const intersect = (0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.isPolygonLineIntersect)(polygonWithOffsetAndRotation, {x1, y1, x2, y2});
                if (intersect) {
                    //console.log("rotation: ", rotation);
                    //console.log("polygon: ", polygonWithOffsetAndRotation);
                    //console.log("intersect: ", intersect);
                    return intersect;
                }
            }
        }
        if (eLen > 0) {
            for (let i = 0; i < eLen; i+=4) {
                const ellipse = [ellipseB[i], ellipseB[i+1], ellipseB[i+2], ellipseB[i+3]],
                    intersect = (0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.isEllipsePolygonIntersect)(ellipse, polygonWithOffsetAndRotation);
                if (intersect) {
                    //console.log("rotation: ", rotation);
                    //console.log("polygon: ", polygonWithOffsetAndRotation);
                    //console.log("intersect: ", intersect);
                    return intersect;
                }
            }
        }
        
        if (pLen > 0) {
            for (let i = 0; i < pLen; i+=2) {
                const x = pointB[i],
                    y = pointB[i+1],
                    intersect = (0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.isPointPolygonIntersect)(x, y, polygonWithOffsetAndRotation);
                if (intersect) {
                //console.log("rotation: ", rotation);
                //console.log("polygon: ", polygonWithOffsetAndRotation);
                //console.log("intersect: ", intersect);
                    return intersect;
                }
            }
        }
        return false;
    }
    //****************** End Collisions ****************//

    #setCanvasSize() {
        const canvasWidth = this.systemSettings.canvasMaxSize.width && (this.systemSettings.canvasMaxSize.width < window.innerWidth) ? this.systemSettings.canvasMaxSize.width : window.innerWidth,
            canvasHeight = this.systemSettings.canvasMaxSize.height && (this.systemSettings.canvasMaxSize.height < window.innerHeight) ? this.systemSettings.canvasMaxSize.height : window.innerHeight;
        this.stageData._setCanvasDimensions(canvasWidth, canvasHeight);
    }
}

/***/ }),

/***/ "./node_modules/jsge/src/base/GameStageData.js":
/*!*****************************************************!*\
  !*** ./node_modules/jsge/src/base/GameStageData.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GameStageData: () => (/* binding */ GameStageData)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "./node_modules/jsge/src/constants.js");
/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Exception.js */ "./node_modules/jsge/src/base/Exception.js");
/* harmony import */ var _2d_DrawTiledLayer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./2d/DrawTiledLayer.js */ "./node_modules/jsge/src/base/2d/DrawTiledLayer.js");
/* harmony import */ var _2d_DrawImageObject_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./2d/DrawImageObject.js */ "./node_modules/jsge/src/base/2d/DrawImageObject.js");
/* harmony import */ var _2d_DrawCircleObject_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./2d/DrawCircleObject.js */ "./node_modules/jsge/src/base/2d/DrawCircleObject.js");
/* harmony import */ var _2d_DrawConusObject_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./2d/DrawConusObject.js */ "./node_modules/jsge/src/base/2d/DrawConusObject.js");
/* harmony import */ var _2d_DrawLineObject_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./2d/DrawLineObject.js */ "./node_modules/jsge/src/base/2d/DrawLineObject.js");
/* harmony import */ var _2d_DrawPolygonObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./2d/DrawPolygonObject.js */ "./node_modules/jsge/src/base/2d/DrawPolygonObject.js");
/* harmony import */ var _2d_DrawRectObject_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./2d/DrawRectObject.js */ "./node_modules/jsge/src/base/2d/DrawRectObject.js");
/* harmony import */ var _2d_DrawTextObject_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./2d/DrawTextObject.js */ "./node_modules/jsge/src/base/2d/DrawTextObject.js");











/**
 * A storage for stage data, such as gameObjects,
 * boundaries, worldDimensions and offset
 * @see {@link GameStage} a part of GameStage
 * @hideconstructor
 */
class GameStageData {
    /**
     * @type {number}
     */
    #worldWidth;
    #worldHeight;
    /**
     * @type {number}
     */
    #viewWidth;
    /**
     * @type {number}
     */
    #viewHeight;
    /**
     * @type {number}
     */
    #xOffset = 0;
    /**
     * @type {number}
     */
    #yOffset = 0;
    /**
     * @type {number}
     */
    #centerX = 0;
    /**
     * @type {number}
     */
    #centerY = 0;
    /**
     * @type {number}
     */
    #rotate = 0;
    /**
     * @type {number}
     */
    #maxBoundariesSize = 0;
    /**
     * @type {number}
     */
    #maxEllipseBoundSize = 0;
    /**
     * @type {number}
     */
    #maxPointBSize = 0;
    /**
     * Points to next empty cell
     * @type {number}
     */
    #bPointer = 0;
    /**
     * Points to next empty cell
     * @type {number}
     */
    #pPointer = 0;
    /**
     * Points to next empty cell
     * @type {number}
     */
    #ePointer = 0;
    /**
     * current screen boundaries, recalculated every render cycles
     * stored as floatArray, 
     * each 4 cells, represent a line with coords x1,y1,x2,y2
     * @type {Float32Array}
     */
    #boundaries;
    /**
     * ellipse boundaries
     * stored as floatArray, 
     * each 4 cells, represent am ellipse with cords centerX, centerY, radiusX, radiusY
     * @type {Float32Array}
     */
    #ellipseBoundaries;
    /**
     * point boundaries
     * stored as floatArray, 
     * each 2 cells, represent a point with coords x1,y1
     * @type {Float32Array}
     */
    #pointBoundaries;
    /**
     * whole world boundaries, calculated once on prepare stage
     * @type {Array<Array<number>>}
     */
    #wholeWorldBoundaries;
    /**
     * @type {Array<DrawImageObject | DrawCircleObject | DrawConusObject | DrawLineObject | DrawPolygonObject | DrawRectObject | DrawTextObject | DrawTiledLayer>}
     */
    #renderObjects = [];
    /**
     * @type {Array<DrawImageObject | DrawCircleObject | DrawConusObject | DrawLineObject | DrawPolygonObject | DrawRectObject | DrawTextObject | DrawTiledLayer>}
     */
    #pendingRenderObjects = [];

    /**
     * @type {boolean}
     */
    #isOffsetTurnedOff;
    /**
     * @deprecated
     * @type {boolean}
     */
    #isWorldBoundariesEnabled = false;

    /**
     * @type {Array<number>}
     */
    #debugObjectBoundaries = [];
    /**
     * 
     * @type {boolean}
     */
    #isDebugObjectBoundaries = false;

    constructor(gameOptions) {
        //this.#boundaries = new Float32Array(this.#maxBoundariesSize);
        //this.#ellipseBoundaries = new Float32Array(this.#maxBoundariesSize);
        //this.#pointBoundaries = new Float32Array(this.#maxBoundariesSize);
    }

    /**
     * 
     * @returns {boolean}
     */
    isOffsetTurnedOff() {
        return this.#isOffsetTurnedOff;
    }
    set mapRotate(value) {
        this.#rotate = value;
    }

    /**
     * Add a Boundaries line
     * @param {{x1:number,y1:number,x2:number, y2:number}} boundaries 
     */
    #addBoundaries(boundaries) {
        this._addBoundaryLine(boundaries.x1,boundaries.y1, boundaries.x2, boundaries.y2);
    }

    /**
     * Add array of boundaries lines
     * @param {Array<Array<number>>} boundaries 
     * @ignore
     */
    _addImageDebugBoundaries(boundaries) {
        const len = boundaries.length;
        for (let i = 0; i < len; i++) {
            this.#debugObjectBoundaries.push(...boundaries[i]);
        }
    }

    _enableDebugObjectBoundaries() {
        this.#isDebugObjectBoundaries = true;
    }
    /**
     * Add array of boundaries lines
     * @param {Array<Array<number>>} boundaries 
     * @ignore
     */
    _addBoundariesArray(boundaries) {
        const len = boundaries.length;
        for (let i = 0; i < len; i++) {
            const boundary = boundaries[i];
            this._addBoundaryLine(boundary[0], boundary[1], boundary[2], boundary[3]);
        }
    }

    _addBoundaryLine(x1, y1, x2, y2) {
        this.#boundaries[this.#bPointer] = x1;
        this.#bPointer++;
        this.#boundaries[this.#bPointer] = y1;
        this.#bPointer++;
        this.#boundaries[this.#bPointer] = x2;
        this.#bPointer++;
        this.#boundaries[this.#bPointer] = y2;
        this.#bPointer++;
    }

    _addEllipseBoundary(w, h, x, y) {
        this.#ellipseBoundaries[this.#ePointer] = w;
        this.#ePointer++;
        this.#ellipseBoundaries[this.#ePointer] = h;
        this.#ePointer++;
        this.#ellipseBoundaries[this.#ePointer] = x;
        this.#ePointer++;
        this.#ellipseBoundaries[this.#ePointer] = y;
        this.#ePointer++;
    }

    _addPointBoundary(x,y) {
        this.#pointBoundaries[this.#pPointer] = x;
        this.#pPointer++;
        this.#pointBoundaries[this.#pPointer] = y;
        this.#pPointer++;
    }

    _removeBoundaryLine(startPos) {
        this.#boundaries[startPos] = 0;
        this.#boundaries[startPos + 1] = 0;
        this.#boundaries[startPos + 2] = 0;
        this.#boundaries[startPos + 3] = 0;
    }

    /**
     * Clear map boundaries
     * @ignore
     */
    _clearBoundaries() {
        this.#boundaries.fill(0);
        this.#ellipseBoundaries.fill(0);
        this.#pointBoundaries.fill(0);
        
        this.#bPointer = 0;
        this.#ePointer = 0;
        this.#pPointer = 0;
        if (this.#isDebugObjectBoundaries) {
            this.#debugObjectBoundaries = [];
        }
    }

    _initiateBoundariesData() {
        this.#boundaries = new Float32Array(this.#maxBoundariesSize);
        this.#ellipseBoundaries = new Float32Array(this.#maxEllipseBoundSize);
        this.#pointBoundaries = new Float32Array(this.#maxPointBSize);
    }

    /**
     * 
     * @param {number} bSize
     * @param {number} eSize - ellipse boundaries size
     * @param {number} pSize - points boundaries size
     * @ignore
     */
    _setMaxBoundariesSize(bSize, eSize = 0, pSize = 0) {
        this.#maxBoundariesSize = bSize;
        this.#maxEllipseBoundSize = eSize;
        this.#maxPointBSize = pSize;
    }

    /**
     * 
     * @param {number} width 
     * @param {number} height 
     * @ignore
     */
    _setWorldDimensions(width, height) {
        this.#worldWidth = width;
        this.#worldHeight = height;
    }

    /**
     * 
     * @param {number} width 
     * @param {number} height 
     * @ignore
     */
    _setCanvasDimensions(width, height) {
        this.#viewWidth = width;
        this.#viewHeight = height;
    }

    /**
     * Set map borders
     * @ignore
     */
    _setMapBoundaries() {
        const [w, h] = [this.#worldWidth, this.#worldHeight],
            [offsetX, offsetY] = [this.#xOffset, this.#yOffset],
            wOffset = w - offsetX,
            hOffset = h -offsetY;
        if (!w || !h) {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.WORLD_DIMENSIONS_NOT_SET, "Can't set map boundaries.");
        }
        this.#addBoundaries({x1: 0, y1: 0, x2: wOffset, y2: 0});
        this.#addBoundaries({x1: wOffset, y1: 0, x2: wOffset, y2: hOffset});
        this.#addBoundaries({x1: wOffset, y1: hOffset, x2: 0, y2: hOffset});
        this.#addBoundaries({x1: 0, y1: hOffset, x2: 0, y2: 0});
    }

    /**
     * @ignore
     */
    _setWholeWorldMapBoundaries() {
        const [w, h] = [this.#worldWidth, this.#worldHeight];
        if (!w || !h) {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.WORLD_DIMENSIONS_NOT_SET, "Can't set map boundaries.");
        }
        this.#wholeWorldBoundaries.push([0, 0, w, 0]);
        this.#wholeWorldBoundaries.push([w, 0, w, h]);
        this.#wholeWorldBoundaries.push([w, h, 0, h]);
        this.#wholeWorldBoundaries.push([0, h, 0, 0]);
    }

    /**
     * Merge same boundaries
     * !not used
     * @ignore
     * @deprecated
     */
    _mergeBoundaries(isWholeMapBoundaries = false) {
        const boundaries = isWholeMapBoundaries ? this.getWholeWorldBoundaries() : this.getBoundaries(),
            boundariesSet = new Set(boundaries);

        for (const line of boundariesSet.values()) {
            const lineX1 = line[0],
                lineY1 = line[1],
                lineX2 = line[2],
                lineY2 = line[3];
            for (const line2 of boundariesSet.values()) {
                const line2X1 = line2[0],
                    line2Y1 = line2[1],
                    line2X2 = line2[2],
                    line2Y2 = line2[3];
                if (lineX1 === line2X2 && lineY1 === line2Y2 &&
                    lineX2 === line2X1 && lineY2 === line2Y1) {
                    //remove double lines
                    boundariesSet.delete(line);
                    boundariesSet.delete(line2);
                }
                if (lineX2 === line2X1 && lineY2 === line2Y1 && (lineX1 === line2X2 || lineY1 === line2Y2)) {
                    //merge lines
                    line2[0] = lineX1;
                    line2[1] = lineY1;
                    boundariesSet.delete(line);
                }
            }
        }
        if (isWholeMapBoundaries) {
            this.#boundaries = Array.from(boundariesSet);
        } else {
            this.#wholeWorldBoundaries = Array.from(boundariesSet);
        }
        boundariesSet.clear();
    }

    /**
     * @ignore
     * @param {Array<Array<number>>} boundaries 
     */
    _setWholeMapBoundaries(boundaries) {
        this.#wholeWorldBoundaries.push(...boundaries);
    }

    /**
     * @deprecated
     * @ignore
     */
    _enableMapBoundaries() {
        this.#isWorldBoundariesEnabled = true;
    }

    /**
     * @ignore
     */
    _sortRenderObjectsBySortIndex() {
        this.#renderObjects.sort((obj1, obj2) => obj1.sortIndex - obj2.sortIndex);
    }

    _processPendingRenderObjects() {
        if (this.#pendingRenderObjects.length > 0) {
            this.#renderObjects.push(...this.#pendingRenderObjects);
            this._sortRenderObjectsBySortIndex();
            this.#pendingRenderObjects = [];
        }
    }

    /**
     * @ignore
     */
    set _renderObject(object) {
        this.#pendingRenderObjects.push(object);
    } 

    /**
     * @ignore
     */
    set _renderObjects(objects) {
        objects.forEach(object => {
            this._renderObject = object;
        });
    } 

    /**
     * current screen boundaries, 
     * this method is for backward capability with jsge@1.4.4
     * recommended to use getRawBoundaries()
     * @returns {Array<Array<number>>}
     */
    getBoundaries() {
        const boundaries = this.#boundaries, 
            len = this.#bPointer;

        let bTempArray = [],
            bArray = [];
        
        for (let i = 0; i < len; i++) {
            const element = boundaries[i];
            bTempArray.push(element);
            if (((i + 1) % 4) === 0) {
                bArray.push(bTempArray);
                bTempArray = [];
            }
        }
        return bArray;
    }

    /**
     * current screen boundaries
     * polygon boundaries from Tiled and Tiled boundaries layers are merged here
     * each 4 cells, represent a line with coords x1,y1,x2,y2
     * @returns {Float32Array}
     */
    getRawBoundaries() {
        return this.#boundaries;
    }

    /**
     * ellipse boundaries from Tiled,
     * stored as floatArray, 
     * each 4 cells, represent am ellipse with cords centerX, centerY, radiusX, radiusY
     * @returns {Float32Array}
     */
    getEllipseBoundaries() {
        return this.#ellipseBoundaries;
    }

    /**
     * point boundaries from Tiled,
     * stored as floatArray, 
     * each 2 cells, represent a point with coords x1,y1
     * @returns {Float32Array}
     */
    getPointBoundaries() {
        return this.#pointBoundaries;
    }

    getWholeWorldBoundaries() {
        return this.#wholeWorldBoundaries;
    }

    getDebugObjectBoundaries() {
        return this.#debugObjectBoundaries;
    }

    /**
     * @deprecated
     */
    get isWorldBoundariesEnabled() {
        return this.#isWorldBoundariesEnabled;
    }
    /**
     * Current canvas dimensions
     * @returns {Array<number>}
     */
    get canvasDimensions() {
        return [this.#viewWidth, this.#viewHeight];
    }

    /**
     * Current game world dimensions
     * @returns {Array<number>}
     */
    get worldDimensions() {
        return [this.#worldWidth, this.#worldHeight];
    }
    
    /**
     * Current word x/y offset
     * @returns {Array<number>}
     */
    get worldOffset() {
        return [this.#xOffset, this.#yOffset];
    }

    /**
     * Current focus point
     * @returns {Array<number>}
     */
    get mapCenter() {
        return [this.#centerX, this.#centerY];
    }

    /**
     * @returns {number}
     */
    get mapRotate() {
        return this.#rotate;
    }

    /**
     * Tiled polygon and Tiled layer boundaries length
     * @returns {number}
     */
    get boundariesLen() {
        return this.#bPointer;
    }

    /**
     * Tiled ellipse boundaries length
     * @returns {number}
     */
    get ellipseBLen() {
        return this.#ePointer;
    }

    /**
     * Tiled point length
     * @returns {number}
     */
    get pointBLen() {
        return this.#pPointer;
    }

    /**
     * @method
     * @param {number} x 
     * @param {number} y 
     */
    centerCameraPosition = (x, y) => {
        let [mapOffsetX, mapOffsetY] = this.worldOffset;
        const [canvasWidth, canvasHeight] = this.canvasDimensions,
            [mapWidth, mapHeight] = this.worldDimensions,
            halfScreenWidth = canvasWidth/2,
            halfScreenHeight = canvasHeight/2,
            currentCenterX = halfScreenWidth - mapOffsetX,
            currentCenterY = halfScreenHeight - mapOffsetY;
        if (currentCenterX < x) {
            if (x < mapWidth - halfScreenWidth) {
                const newXOffset = x - halfScreenWidth;
                if (newXOffset >= 0)
                    this.#xOffset = Math.round(newXOffset);
            } else if (mapWidth > canvasWidth) {
                const newXOffset = mapWidth - canvasWidth;
                this.#xOffset = Math.round(newXOffset);
            }
        }
        if (currentCenterY < y) {
            if (y < mapHeight - halfScreenHeight) {
                const newYOffset = y - halfScreenHeight;
                if (newYOffset >= 0)
                    this.#yOffset = Math.round(newYOffset);
            } else if (mapHeight > canvasHeight) {
                const newYOffset = mapHeight - canvasHeight;
                this.#yOffset = Math.round(newYOffset);
            }
        }

        this.#centerX = x;
        this.#centerY = y;
        //Logger.debug("center camera position, offset: ", this.worldOffset);
        //Logger.debug("center: ", this.mapCenter);   
    };

    personRotatedCenterCamera = (x, y, rotationAngle) => {
        console.log("new centering algorithm");
        /*
        let [mapOffsetX, mapOffsetY] = this.worldOffset;
        const [canvasWidth, canvasHeight] = this.canvasDimensions,
            [mapWidth, mapHeight] = this.worldDimensions,
            halfScreenWidth = canvasWidth/2,
            halfScreenHeight = canvasHeight/2,
            currentCenterX = halfScreenWidth - mapOffsetX,
            currentCenterY = halfScreenHeight - mapOffsetY;
        if (currentCenterX < x) {
            if (x < mapWidth - halfScreenWidth) {
                const newXOffset = x - halfScreenWidth;
                if (newXOffset >= 0)
                    this.#xOffset = Math.round(newXOffset);
            } else if (mapWidth > canvasWidth) {
                const newXOffset = mapWidth - canvasWidth;
                this.#xOffset = Math.round(newXOffset);
            }
        }
        if (currentCenterY < y) {
            if (y < mapHeight - halfScreenHeight) {
                const newYOffset = y - halfScreenHeight;
                if (newYOffset >= 0)
                    this.#yOffset = Math.round(newYOffset);
            } else if (mapHeight > canvasHeight) {
                const newYOffset = mapHeight - canvasHeight;
                this.#yOffset = Math.round(newYOffset);
            }
        }

        this.#centerX = x;
        this.#centerY = y;
        Logger.debug("center camera position, offset: ", this.worldOffset);
        Logger.debug("center: ", this.mapCenter);   
        */
    };

    /**
     * a getter to retrieve all attached renderObjects
     */
    get renderObjects() {
        return this.#renderObjects;
    }

    /**
     * Retrieve specific objects instances
     * @param {Object} instance - drawObjectInstance to retrieve 
     * @returns {Array<Object>}
     */
    getObjectsByInstance(instance) {
        return this.#renderObjects.filter((object) => object instanceof instance);
    }

    /**
     * Used to remove all render objects,
     * Designed for restart the stage
     */
    cleanUp() {
        this.#renderObjects = [];
        this.#pendingRenderObjects = [];
        this._clearBoundaries();
    }
}

/***/ }),

/***/ "./node_modules/jsge/src/base/IExtension.js":
/*!**************************************************!*\
  !*** ./node_modules/jsge/src/base/IExtension.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IExtension: () => (/* binding */ IExtension)
/* harmony export */ });
/* harmony import */ var _ISystem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ISystem.js */ "./node_modules/jsge/src/base/ISystem.js");


/**
 * Class for creating modules
 * Accessed via ISystem.extensionInterface
 */
class IExtension {
    /**
     * @type {ISystem}
     */
    #systemReference;
    /**
     * @hideconstructor
     */
    constructor(iSystem) {
        this.#systemReference = iSystem;
    }
    /**
     * Is used for registering new Object in DrawObjectFactory, \
     * registered method could be then called with this.draw[createInstanceKey]
     * @param {string} createInstanceKey - a key for calling method from DrawObjectFactory
     * @param {function} createInstanceMethod - method 
     */
    registerDrawObject(createInstanceKey, createInstanceMethod) {
        this.#systemReference.drawObjectFactory._registerNewObjectMethod(createInstanceKey, createInstanceMethod);
    }

    /**
     * Used to register a new draw program
     * @param {string} programName
     * @param {string} vertexShader - raw vertex shader program
     * @param {string} fragmentShader - raw fragment shader program 
     * @param {Array<string>} uVars - program uniform variables names
     * @param {Array<string>} aVars - program attribute variables names
     * @returns {Promise<void>}
     */
    registerAndCompileWebGlProgram(programName, vertexShader, fragmentShader, uVars, aVars) {
        return this.#systemReference.iRender._registerAndCompileWebGlProgram(programName, vertexShader, fragmentShader, uVars, aVars);
    }

    /**
     * Inject method to render.init stage. Should be Promise based.
     * @param {function():Promise<void>} method 
     * @returns {void}
     */
    registerRenderInit(method) {
        this.#systemReference.iRender._registerRenderInit(method);
    }

    /**
     * Register render method for class.
     * @param {string} objectClassName - object name registered to DrawObjectFactory
     * @param {function(renderObject, gl, pageData, program, vars):Promise<any[]>} objectRenderMethod - should be promise based returns vertices number and draw program
     * @param {string} objectWebGlDrawProgram - a webgl program name previously registered with iExtension.registerAndCompileWebGlProgram()
     */
    registerObjectRender(objectClassName, objectRenderMethod, objectWebGlDrawProgram) {
        this.#systemReference.iRender._registerObjectRender(objectClassName, objectRenderMethod, objectWebGlDrawProgram);
    }
}

/***/ }),

/***/ "./node_modules/jsge/src/base/INetwork.js":
/*!************************************************!*\
  !*** ./node_modules/jsge/src/base/INetwork.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   INetwork: () => (/* binding */ INetwork)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "./node_modules/jsge/src/constants.js");
/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Exception.js */ "./node_modules/jsge/src/base/Exception.js");
/* harmony import */ var _Logger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Logger.js */ "./node_modules/jsge/src/base/Logger.js");
/* harmony import */ var _Events_SystemEvent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Events/SystemEvent.js */ "./node_modules/jsge/src/base/Events/SystemEvent.js");




//import { Socket } from "socket.io-client";

/**
 * Represents Socket connection
 * 
 * From 1.4.4 disabled by default,
 * to enable, set settings.network.enabled to true
 */
class INetwork extends EventTarget {
    /**
     * @type {Object}
     */
    #systemSettings;
    /**
     * @type {Socket}
     */
    #socket;

    /**
     * @hideconstructor
     */
    constructor(systemSettings) {
        super();
        if (!systemSettings) {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.CREATE_INSTANCE_ERROR, "systemSettings should be passed to class instance");
        }
        this.#systemSettings = systemSettings;
    }

    init() {
        __webpack_require__.e(/*! import() */ "vendors-node_modules_socket_io-client_build_esm_index_js").then(__webpack_require__.bind(__webpack_require__, /*! socket.io-client */ "./node_modules/socket.io-client/build/esm/index.js")).then((module) => {
            this.#socket = module.io(this.#systemSettings.network.address, {withCredentials: true});
            
            this.#registerSocketListeners();
        });
    }

    /**
     * @returns {boolean}
     */
    get isServerConnected () {
        if (this.#socket && this.#socket.connected) {
            return true;
        } else {
            return false;
        }
    }
    
    get playerId() {
        return this.#socket.id;
    }

    sendGatherRoomsInfo() {
        this.#socket.emit(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.CLIENT_SERVER.ROOMS_INFO_REQUEST);
    }

    sendCreateOrJoinRoom(roomName, map) {
        this.#socket.emit(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.CLIENT_SERVER.CREATE_OR_JOIN, roomName , map);
    }

    sendMessage(message) {
        this.#socket.emit(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.CLIENT_SERVER.CLIENT_MESSAGE, message);
    }

    #onConnect = () => {
        _Logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.debug("connected, socket id: " + this.#socket.id);
        this.dispatchEvent(new Event(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.CONNECTION_STATUS_CHANGED));
    };

    #onDisconnect = (reason) => {
        _Logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.debug("server disconnected, reason: " + reason);
        this.dispatchEvent(new Event(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.CONNECTION_STATUS_CHANGED));
    };

    #onData = (event) => {
        console.warn("server data: ", event);
    };

    #onMessage = (message) => {
        _Logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.debug("received new message from server: " + message);
        this.dispatchEvent(new _Events_SystemEvent_js__WEBPACK_IMPORTED_MODULE_3__.SystemEvent(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.SERVER_MESSAGE, message));
    };

    #onRoomsInfo = (rooms) => {
        _Logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.debug("received roomsInfo " + rooms);
        this.dispatchEvent(new _Events_SystemEvent_js__WEBPACK_IMPORTED_MODULE_3__.SystemEvent(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.ROOMS_INFO, rooms));
    };

    #onCreateNewRoom = (room, map) => {
        _Logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.debug("CLIENT SOCKET: Created room  " + room);
        this.dispatchEvent(new _Events_SystemEvent_js__WEBPACK_IMPORTED_MODULE_3__.SystemEvent(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.CREATED, {room, map}));
    };

    #onRoomIsFull = (room) => {
        _Logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.debug("CLIENT SOCKET: Room is full, can't join: " + room);
        this.dispatchEvent(new _Events_SystemEvent_js__WEBPACK_IMPORTED_MODULE_3__.SystemEvent(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.FULL, {room}));
    };

    #onJoinedToRoom = (room, map) => {
        _Logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.debug("CLIENT SOCKET: Joined to room: " + room, ", map: ", map);
        this.dispatchEvent(new _Events_SystemEvent_js__WEBPACK_IMPORTED_MODULE_3__.SystemEvent(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.JOINED, {room, map}));
    };

    #onUnjoinedFromRoom = (playerId) => {
        this.dispatchEvent(new _Events_SystemEvent_js__WEBPACK_IMPORTED_MODULE_3__.SystemEvent(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.DISCONNECTED, {playerId}));
    };

    #registerSocketListeners() {
        this.#socket.on("connect", this.#onConnect);
        this.#socket.on("disconnect", this.#onDisconnect);
        this.#socket.on("data", this.#onData);

        this.#socket.on("roomsInfo", this.#onRoomsInfo);
    
        this.#socket.on("created", this.#onCreateNewRoom);
    
        this.#socket.on("full", this.#onRoomIsFull);
    
        this.#socket.on("joined", this.#onJoinedToRoom);
    
        this.#socket.on("log", function(array) {
            console.log.apply(console, array);
        });
    
        this.#socket.on("message", this.#onMessage);
    
        this.#socket.on("removed", function(message) {
            console.log("removed message");
            console.log(message);
        });

        this.#socket.on("disconnected", this.#onUnjoinedFromRoom);

        addEventListener("beforeunload", this.#disconnect);
    }

    #disconnect = () => {
        this.#socket.disconnect();
    };
}

/***/ }),

/***/ "./node_modules/jsge/src/base/IRender.js":
/*!***********************************************!*\
  !*** ./node_modules/jsge/src/base/IRender.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IRender: () => (/* binding */ IRender)
/* harmony export */ });
/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Exception.js */ "./node_modules/jsge/src/base/Exception.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "./node_modules/jsge/src/constants.js");
/* harmony import */ var _WebGl_WebGlEngine_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WebGl/WebGlEngine.js */ "./node_modules/jsge/src/base/WebGl/WebGlEngine.js");
/* harmony import */ var _configs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../configs.js */ "./node_modules/jsge/src/configs.js");
/* harmony import */ var _GameStageData_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GameStageData.js */ "./node_modules/jsge/src/base/GameStageData.js");
/* harmony import */ var _modules_assetsm_src_AssetsManager_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../modules/assetsm/src/AssetsManager.js */ "./node_modules/jsge/modules/assetsm/src/AssetsManager.js");
/* harmony import */ var _WebGl_ImagesDrawProgram_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./WebGl/ImagesDrawProgram.js */ "./node_modules/jsge/src/base/WebGl/ImagesDrawProgram.js");
/* harmony import */ var _WebGl_PrimitivesDrawProgram_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./WebGl/PrimitivesDrawProgram.js */ "./node_modules/jsge/src/base/WebGl/PrimitivesDrawProgram.js");
/* harmony import */ var _WebGl_ImagesDrawProgramM_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./WebGl/ImagesDrawProgramM.js */ "./node_modules/jsge/src/base/WebGl/ImagesDrawProgramM.js");
/* harmony import */ var _RenderLoop_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./RenderLoop.js */ "./node_modules/jsge/src/base/RenderLoop.js");






//import { calculateBufferData } from "../wa/release.js";






/**
 * IRender class controls the render(start/stop/speed) 
 * And drawObjects(animations, removing, and rendering)
 * @see {@link GameStage} a part of GameStage
 * @hideconstructor
 */
class IRender {
    /**
     * @type {HTMLCanvasElement}
     */
    #canvas;
    /**
     * @type {WebGLRenderingContext | null}
     */
    #drawContext;
    /**
     * @type {WebGlEngine}
     */
    #webGlEngine;
    /**
     * @type {GameStageData | null}
     */
    #currentGameStageData;

    /**
     * ISystem.systemSettings
     * @type {SystemSettings}
     */
    #systemSettingsReference;
    /**
     * A reference to the systemInterface.iLoader
     * @type {AssetsManager}
     */
    #loaderReference;
    

    #renderLoopInstance;
    /**
     * @type {boolean}
     */
    #isBoundariesPrecalculations = false;

    /**
     * @type {Array<function():Promise<void>>}
     */
    #initPromises = [];
    /**
     * @type {EventTarget}
     */
    #emitter = new EventTarget();
    constructor(systemSettings, iLoader, canvasContainer) {
        
        this.#canvas = document.createElement("canvas");
        canvasContainer.appendChild(this.#canvas);
        this.#drawContext = this.#canvas.getContext("webgl", {stencil: true});

        this.#systemSettingsReference = systemSettings;
        this.#loaderReference = iLoader;

        this.#isBoundariesPrecalculations = this.systemSettings.gameOptions.render.boundaries.wholeWorldPrecalculations;

        this.#webGlEngine = new _WebGl_WebGlEngine_js__WEBPACK_IMPORTED_MODULE_2__.WebGlEngine(this.#drawContext, this.#systemSettingsReference.gameOptions, this.iLoader);
        
        this._registerRenderInit(this.#webGlEngine._initiateJsRender);
        if (this.systemSettings.gameOptions.optimization === _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONST.OPTIMIZATION.WEB_ASSEMBLY.NATIVE_WAT ||
            this.systemSettings.gameOptions.optimization === _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONST.OPTIMIZATION.WEB_ASSEMBLY.ASSEMBLY_SCRIPT) {
            this._registerRenderInit(this.#webGlEngine._initiateWasm);
        }

        this._registerRenderInit(this.fixCanvasSize);
        this._registerRenderInit(
            () => this._registerAndCompileWebGlProgram(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONST.WEBGL.DRAW_PROGRAMS.IMAGES, _WebGl_ImagesDrawProgram_js__WEBPACK_IMPORTED_MODULE_6__.imgVertexShader, _WebGl_ImagesDrawProgram_js__WEBPACK_IMPORTED_MODULE_6__.imgFragmentShader, _WebGl_ImagesDrawProgram_js__WEBPACK_IMPORTED_MODULE_6__.imgUniforms, _WebGl_ImagesDrawProgram_js__WEBPACK_IMPORTED_MODULE_6__.imgAttributes)
        );
        this._registerRenderInit(
            () => this._registerAndCompileWebGlProgram(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES, _WebGl_PrimitivesDrawProgram_js__WEBPACK_IMPORTED_MODULE_7__.primitivesVertexShader, _WebGl_PrimitivesDrawProgram_js__WEBPACK_IMPORTED_MODULE_7__.primitivesFragmentShader, _WebGl_PrimitivesDrawProgram_js__WEBPACK_IMPORTED_MODULE_7__.primitivesUniforms, _WebGl_PrimitivesDrawProgram_js__WEBPACK_IMPORTED_MODULE_7__.primitivesAttributes)
        );
        this._registerRenderInit(
            () => this._registerAndCompileWebGlProgram(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONST.WEBGL.DRAW_PROGRAMS.IMAGES_M, _WebGl_ImagesDrawProgramM_js__WEBPACK_IMPORTED_MODULE_8__.imgMVertexShader, _WebGl_ImagesDrawProgramM_js__WEBPACK_IMPORTED_MODULE_8__.imgMFragmentShader, _WebGl_ImagesDrawProgramM_js__WEBPACK_IMPORTED_MODULE_8__.imgMUniforms, _WebGl_ImagesDrawProgramM_js__WEBPACK_IMPORTED_MODULE_8__.imgMAttributes)
        );
        this._registerRenderInit(this.#webGlEngine._initWebGlAttributes);
    }

    _webGlEngine() {
        return this.#webGlEngine;
    }
    /**
     * 
     * @param {string} eventName 
     * @param {*} listener 
     * @param {*=} options 
     */
    addEventListener = (eventName, listener, options) => {
        this.#emitter.addEventListener(eventName, listener, options);
    };

    /**
     * 
     * @param {string} eventName 
     * @param {*} listener 
     * @param {*=} options 
     */
    removeEventListener = (eventName, listener, options) => {
        this.#emitter.removeEventListener(eventName, listener, options);
    };

    get stageData() {
        return this.#currentGameStageData;
    }

    get systemSettings() {
        return this.#systemSettingsReference;
    }

    get iLoader() {
        return this.#loaderReference;
    }

    get canvas() {
        return this.#canvas;
    }

    get drawContext() {
        return this.#drawContext;
    }

    /**
     * 
     * @param {string} eventName
     * @param  {...any} eventParams
     */
    emit = (eventName, ...eventParams) => {
        const event = new Event(eventName);
        event.data = [...eventParams];
        this.#emitter.dispatchEvent(event);
    };

    /**
     * Determines if all added files was loaded or not
     * @returns {boolean}
     */
    isAllFilesLoaded = () => {
        return this.iLoader.filesWaitingForUpload === 0;
    };

    /**
     * 
     * @returns {boolean}
     */
    _isRenderActive() {
        return this.#renderLoopInstance ? this.#renderLoopInstance._isActive : false;
    }

    initiateContext = (stageData) => {
        return Promise.all(this.#initPromises.map(method => method(stageData)));
    };


    /****************************
     *  Extend functionality
     ****************************/
    /**
     * @ignore
     * @param {string} programName
     * @param {string} vertexShader - raw vertex shader program
     * @param {string} fragmentShader - raw fragment shader program 
     * @param {Array<string>} uVars - program uniform variables names
     * @param {Array<string>} aVars - program attribute variables names
     * @returns {Promise<void>}
     */
    _registerAndCompileWebGlProgram(programName, vertexShader, fragmentShader, uVars, aVars) {
        this.#webGlEngine._registerAndCompileWebGlProgram(programName, vertexShader, fragmentShader, uVars, aVars);
        return Promise.resolve();
    }

    /**
     * @ignore
     * @param {function(GameStageData):Promise<void>} method 
     * @returns {void}
     */
    _registerRenderInit(method) {
        this.#initPromises.push(method);
        //} else {
        //    Exception(ERROR_CODES.UNEXPECTED_METHOD_TYPE, "registerRenderInit() accept only Promise based methods!");
        //}
    }

    /**
     * @ignore
     * @param {string} objectClassName - object name registered to DrawObjectFactory
     * @param {function(renderObject, gl, pageData, program, vars):Promise<any[]>} objectRenderMethod - should be promise based returns vertices number and draw program
     * @param {string=} objectWebGlDrawProgram 
     */
    _registerObjectRender(objectClassName, objectRenderMethod, objectWebGlDrawProgram) {
        this.#webGlEngine._registerObjectRender(objectClassName, objectRenderMethod, objectWebGlDrawProgram);
    }

    /****************************
     *  End of Extend functionality
     ****************************/

    setCanvasSize(width, height) {
        this.#canvas.width = width;
        this.#canvas.height = height;
        if (this.#webGlEngine) {
            this.#webGlEngine._fixCanvasSize(width, height);
        }
    }

    fixCanvasSize = () => {
        const settings = this.systemSettings, 
            canvasWidth = settings.canvasMaxSize.width && (settings.canvasMaxSize.width < window.innerWidth) ? settings.canvasMaxSize.width : window.innerWidth,
            canvasHeight = settings.canvasMaxSize.height && (settings.canvasMaxSize.height < window.innerHeight) ? settings.canvasMaxSize.height : window.innerHeight;
        this.setCanvasSize(canvasWidth, canvasHeight);
        return Promise.resolve();
    };

    _createBoundariesPrecalculations() {
        //const promises = [];
        //for (const layer of this.#renderLayers) {
        //    promises.push(this.#layerBoundariesPrecalculation(layer).catch((err) => {
        //        Exception(ERROR_CODES.UNHANDLED_PREPARE_EXCEPTION, err);
        //    }));
        //}
        //return promises;
    }

    //#clearTileMapPromises() {
    //    this.#bindTileMapPromises = [];
    //}

    /**
     * @ignore
     * @param {GameStageData} stageData 
     */
    _startRender = async (/*time*/stageData) => {
        this.fixCanvasSize();
        this.#currentGameStageData = stageData;
        switch (this.systemSettings.gameOptions.library) {
        case _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONST.LIBRARY.WEBGL:
            await this.#prepareViews();
            this.#renderLoopInstance = new _RenderLoop_js__WEBPACK_IMPORTED_MODULE_9__.RenderLoop(this.systemSettings, stageData, this._webGlEngine());
            // delegate render loop events
            this.#renderLoopInstance.addEventListener(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONST.EVENTS.SYSTEM.RENDER.START, () => this.emit(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONST.EVENTS.SYSTEM.RENDER.START));
            this.#renderLoopInstance.addEventListener(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONST.EVENTS.SYSTEM.RENDER.END, () => this.emit(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONST.EVENTS.SYSTEM.RENDER.END));

            this.#renderLoopInstance._start();
            break;
        }
    };

    /**
     * @ignore
     */
    _stopRender = () => {
        this.#renderLoopInstance.removeEventListener(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONST.EVENTS.SYSTEM.RENDER.START, this.emit(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONST.EVENTS.SYSTEM.RENDER.START));
        this.#renderLoopInstance.removeEventListener(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONST.EVENTS.SYSTEM.RENDER.END, this.emit(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONST.EVENTS.SYSTEM.RENDER.END));

        this.#renderLoopInstance._stop();
        this.#renderLoopInstance = undefined;

    };
    /**
     * 
     * @returns {Promise<void>}
     */
    #prepareViews() {
        return new Promise((resolve, reject) => {
            let viewPromises = [];
            const isBoundariesPrecalculations = this.#isBoundariesPrecalculations;
            viewPromises.push(this.initiateContext(this.#currentGameStageData));
            if (isBoundariesPrecalculations) {
                console.warn("isBoundariesPrecalculations() is turned off");
                //for (const view of this.#views.values()) {
                //viewPromises.push(this.#iRender._createBoundariesPrecalculations());
                //}
            }
            Promise.allSettled(viewPromises).then((drawingResults) => {
                drawingResults.forEach((result) => {
                    if (result.status === "rejected") {
                        const error = result.reason;
                        (0,_Exception_js__WEBPACK_IMPORTED_MODULE_0__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.WARNING_CODES.UNHANDLED_DRAW_ISSUE, error);
                        reject(error);
                    }
                });
                resolve();
            });
        });
    }
}

/***/ }),

/***/ "./node_modules/jsge/src/base/ISystem.js":
/*!***********************************************!*\
  !*** ./node_modules/jsge/src/base/ISystem.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ISystem: () => (/* binding */ ISystem)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "./node_modules/jsge/src/constants.js");
/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Exception.js */ "./node_modules/jsge/src/base/Exception.js");
/* harmony import */ var _INetwork_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./INetwork.js */ "./node_modules/jsge/src/base/INetwork.js");
/* harmony import */ var _ISystemAudio_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ISystemAudio.js */ "./node_modules/jsge/src/base/ISystemAudio.js");
/* harmony import */ var _configs_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../configs.js */ "./node_modules/jsge/src/configs.js");
/* harmony import */ var _modules_assetsm_src_AssetsManager_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../modules/assetsm/src/AssetsManager.js */ "./node_modules/jsge/modules/assetsm/src/AssetsManager.js");
/* harmony import */ var _DrawObjectFactory_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DrawObjectFactory.js */ "./node_modules/jsge/src/base/DrawObjectFactory.js");
/* harmony import */ var _GameStage_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./GameStage.js */ "./node_modules/jsge/src/base/GameStage.js");
/* harmony import */ var _IRender_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./IRender.js */ "./node_modules/jsge/src/base/IRender.js");
/* harmony import */ var _IExtension_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./IExtension.js */ "./node_modules/jsge/src/base/IExtension.js");











/**
 * Public interface for a System<br>
 * Can be used to start/stop GameStage render, <br>
 * And provides access to SystemSettings, INetwork and ISystemAudio <br>
 * IRender, DrawObjectFactory, AssetsManager and external modules
 * accessible via GameStage.iSystem and System.system
 * @see {@link System} a part of System class instance
 * @see {@link GameStage} a part of GameStage class instance
 */
class ISystem {
    /**
     * @type {Object}
     */
    #systemSettings;
    /**
     * @type {IExtension}
     */
    #iExtension;
    /**
     * @type {INetwork | null}
     */
    #systemServerConnection;
    /**
     * @type {ISystemAudio}
     */
    #systemAudioInterface;
    /**
     * @type {AssetsManager}
     */
    #iLoader = new _modules_assetsm_src_AssetsManager_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
    /**
     * @type {IRender}
     */
    #iRender;
    /**
     * @type {DrawObjectFactory}
     */
    #drawObjectFactory = new _DrawObjectFactory_js__WEBPACK_IMPORTED_MODULE_6__.DrawObjectFactory(this.#iLoader);
    
    #modules = new Map();
    /**
     * @type {Map<string, Object>}
     */
    #registeredStagesReference;
    /**
     * @type {EventTarget}
     */
    #emitter = new EventTarget();
    /**
     * @hideconstructor
     */
    constructor(systemSettings, registeredStages, canvasContainer) {
        if (!systemSettings) {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.CREATE_INSTANCE_ERROR, "systemSettings should be passed to class instance");
        }
        this.#systemSettings = systemSettings;
        
        this.#systemAudioInterface = new _ISystemAudio_js__WEBPACK_IMPORTED_MODULE_3__.ISystemAudio(this.iLoader);
        this.#systemServerConnection = systemSettings.network.enabled ? new _INetwork_js__WEBPACK_IMPORTED_MODULE_2__.INetwork(systemSettings) : null;
        this.#iRender = new _IRender_js__WEBPACK_IMPORTED_MODULE_8__.IRender(this.systemSettings, this.iLoader, canvasContainer);
        this.#iExtension = new _IExtension_js__WEBPACK_IMPORTED_MODULE_9__.IExtension(this);
        this.#registeredStagesReference = registeredStages;
        // broadcast render events
        this.#iRender.addEventListener(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.SYSTEM.RENDER.START, () => this.emit(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.SYSTEM.RENDER.START));
        this.#iRender.addEventListener(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.SYSTEM.RENDER.END, () => this.emit(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.SYSTEM.RENDER.END));
    }

    /**
     * 
     * @param {string} eventName
     * @param  {...any} eventParams
     */
    emit = (eventName, ...eventParams) => {
        const event = new Event(eventName);
        event.data = [...eventParams];
        this.#emitter.dispatchEvent(event);
    };

    /**
     * 
     * @param {string} eventName 
     * @param {*} listener 
     * @param {*=} options 
     */
    addEventListener = (eventName, listener, options) => {
        this.#emitter.addEventListener(eventName, listener, options);
    };

    /**
     * 
     * @param {string} eventName 
     * @param {*} listener 
     * @param {*=} options 
     */
    removeEventListener = (eventName, listener, options) => {
        this.#emitter.removeEventListener(eventName, listener, options);
    };
    
    /**
     * @returns { INetwork | null }
     */
    get iNetwork () {
        return this.#systemServerConnection;
    }

    /**
     * @returns { SystemSettings }
     */
    get systemSettings() {
        return this.#systemSettings;
    }

    /**
     * @returns { ISystemAudio }
     */
    get audio() {
        return this.#systemAudioInterface;
    }

    /**
     * @returns {AssetsManager}
     */
    get iLoader() {
        return this.#iLoader;
    }

    /**
     * @returns {IRender}
     */
    get iRender() {
        return this.#iRender;
    }

    /**
     * @returns {DrawObjectFactory}
     */
    get drawObjectFactory() {
        return this.#drawObjectFactory;
    }

    /**
     * @returns {IExtension}
     */
    get iExtension() {
        return this.#iExtension;
    }
    /**
     * @returns {Map<string, Object>}
     */
    get modules() {
        return this.#modules;
    }

    /**
     * 
     * @param {string} moduleKey 
     * @param {Object} moduleClass 
     * @param  {...any} args 
     * @returns {Object}
     */
    installModule = (moduleKey, moduleClass, ...args) => {
        const moduleInstance = new moduleClass(this, ...args);
        if (this.#modules.has(moduleKey)) {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.MODULE_ALREADY_INSTALLED, "module " + moduleKey + " is already installed");
            return this.#modules.get(moduleKey);
        } else {
            this.#modules.set(moduleKey, moduleInstance);
        }
        return moduleInstance;
    };

    /**
     * @method
     * @param {string} gameStageName
     * @param {Object} [options] - options
     */
    startGameStage = (gameStageName, options) => {
        if (this.#registeredStagesReference.has(gameStageName)) {
            if (this.#iRender._isRenderActive() === true) {
                this.#iRender._stopRender();
                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.ANOTHER_STAGE_ACTIVE, " Can't start the stage " + gameStageName + " while, another stage is active");
            } else {
                const stage = this.#registeredStagesReference.get(gameStageName),
                    pageData = stage.stageData;
                this.#drawObjectFactory._attachPageData(pageData);
                if (stage.isInitiated === false) {
                    stage._init();
                }
                //stage._attachCanvasToContainer(this.#canvasContainer);
                stage._start(options);
                pageData._processPendingRenderObjects();
                this.emit(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.SYSTEM.START_PAGE);
                this.#iRender._startRender(pageData);
            }
            
        } else {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.VIEW_NOT_EXIST, "Stage " + gameStageName + " is not registered!");
        }
    };

    /**
     * @method
     * @param {string} gameStageName
     */
    stopGameStage = (gameStageName) => {
        if (this.#registeredStagesReference.has(gameStageName)) {
            this.emit(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.SYSTEM.STOP_PAGE);
            this.drawObjectFactory._detachPageData();
            this.#iRender._stopRender();
            this.#registeredStagesReference.get(gameStageName)._stop();
        } else {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.STAGE_NOT_EXIST, "GameStage " + gameStageName + " is not registered!");
        }
    };
}

/***/ }),

/***/ "./node_modules/jsge/src/base/ISystemAudio.js":
/*!****************************************************!*\
  !*** ./node_modules/jsge/src/base/ISystemAudio.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ISystemAudio: () => (/* binding */ ISystemAudio)
/* harmony export */ });
/* harmony import */ var _modules_assetsm_src_AssetsManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../modules/assetsm/src/AssetsManager.js */ "./node_modules/jsge/modules/assetsm/src/AssetsManager.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "./node_modules/jsge/src/constants.js");
/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Exception.js */ "./node_modules/jsge/src/base/Exception.js");




/**
 * An audio interface, <br>
 * controls all application audio,<br>
 * holds and retrieves audio, changes volume<br> 
 * accessible via GameStage.audio
 * @see {@link GameStage} a part of GameStage
 * @hideconstructor
 */
class ISystemAudio {
    #volume = 0.5;
    #audio = new Map();
    /**
     * @type {AssetsManager}
     */
    #loaderReference;

    constructor(iLoader) {
        this.#loaderReference = iLoader;
    }

    /**
     * Original track
     * @param {string} name 
     * @returns {HTMLAudioElement | null}
     */
    getAudio = (name) => {
        const audio = this.#audio.get(name);
        if (audio === null) {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.WARNING_CODES.AUDIO_NOT_LOADED, "Audio with key " + name + " exists, but not actually loaded");
            return audio;
        }
        if (audio) {
            return audio;
        } else {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.WARNING_CODES.AUDIO_NOT_REGISTERED, "");
            return null;
        }
    };

    /**
     * Clone of original track
     * @param {string} name 
     * @returns {HTMLAudioElement | null}
     */
    getAudioCloned = (name) => {
        const audio = this.#audio.get(name);
        if (audio === null) {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.WARNING_CODES.AUDIO_NOT_LOADED, "Audio with key " + name + " exists, but not actually loaded");
            return audio;
        }
        if (audio) {
            const audioCloned = audio.cloneNode();
            audioCloned.volume = this.#volume;
            return audioCloned;
        } else {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.WARNING_CODES.AUDIO_NOT_REGISTERED);
            return null;
        }
    };

    set volume(value) {
        this.#volume = value;
        this.#updateTracksVolumes(value);
    }
    /**
     * Used to set or get audio volume, 
     * value should be from 0 to 1
     * @returns {number}
     */
    get volume() {
        return this.#volume;
    }

    #updateTracksVolumes(value) {
        for (const track of this.#audio.values()) {
            if (track) {
                track.volume = value;
            }
        }
    }

    /**
     * Register audio in the iSystem
     * @param {string} name
     */
    registerAudio(name) {
        let mediaElement = this.#loaderReference.getAudio(name);
        this.#audio.set(name, mediaElement);
    }
}

/***/ }),

/***/ "./node_modules/jsge/src/base/Logger.js":
/*!**********************************************!*\
  !*** ./node_modules/jsge/src/base/Logger.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Logger: () => (/* binding */ Logger)
/* harmony export */ });
/* harmony import */ var _configs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../configs.js */ "./node_modules/jsge/src/configs.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "./node_modules/jsge/src/constants.js");



class Logger {
    static debug(...args) {
        if (_configs_js__WEBPACK_IMPORTED_MODULE_0__.SystemSettings.mode === _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONST.MODE.DEBUG)
            args.forEach(message => console.log(message));
    }
}

/***/ }),

/***/ "./node_modules/jsge/src/base/RenderLoop.js":
/*!**************************************************!*\
  !*** ./node_modules/jsge/src/base/RenderLoop.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RenderLoop: () => (/* binding */ RenderLoop)
/* harmony export */ });
/* harmony import */ var _configs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../configs.js */ "./node_modules/jsge/src/configs.js");
/* harmony import */ var _GameStageData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameStageData.js */ "./node_modules/jsge/src/base/GameStageData.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.js */ "./node_modules/jsge/src/constants.js");
/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Exception.js */ "./node_modules/jsge/src/base/Exception.js");
/* harmony import */ var _2d_DrawTiledLayer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./2d/DrawTiledLayer.js */ "./node_modules/jsge/src/base/2d/DrawTiledLayer.js");
/* harmony import */ var _2d_DrawImageObject_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./2d/DrawImageObject.js */ "./node_modules/jsge/src/base/2d/DrawImageObject.js");
/* harmony import */ var _2d_DrawCircleObject_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./2d/DrawCircleObject.js */ "./node_modules/jsge/src/base/2d/DrawCircleObject.js");
/* harmony import */ var _2d_DrawConusObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./2d/DrawConusObject.js */ "./node_modules/jsge/src/base/2d/DrawConusObject.js");
/* harmony import */ var _2d_DrawLineObject_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./2d/DrawLineObject.js */ "./node_modules/jsge/src/base/2d/DrawLineObject.js");
/* harmony import */ var _2d_DrawPolygonObject_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./2d/DrawPolygonObject.js */ "./node_modules/jsge/src/base/2d/DrawPolygonObject.js");
/* harmony import */ var _2d_DrawRectObject_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./2d/DrawRectObject.js */ "./node_modules/jsge/src/base/2d/DrawRectObject.js");
/* harmony import */ var _2d_DrawTextObject_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./2d/DrawTextObject.js */ "./node_modules/jsge/src/base/2d/DrawTextObject.js");
/* harmony import */ var _WebGl_WebGlEngine_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./WebGl/WebGlEngine.js */ "./node_modules/jsge/src/base/WebGl/WebGlEngine.js");
/* harmony import */ var _RenderLoopDebug_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./RenderLoopDebug.js */ "./node_modules/jsge/src/base/RenderLoopDebug.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../index.js */ "./node_modules/jsge/src/index.js");


















/**
 * Class represents the render loop,
 * on each time stage start, a new RenderLoop class instance created,
 * after stage stop, RenderLoop stops and its instance removed
 * @see {@link IRender} a part of iRender
 * @hideconstructor
 */
class RenderLoop {
    /**
     * @type {boolean}
     */
    #isActive;
    /**
     * @type {boolean}
     */
    #isCleared;
    /**
     * @type {RenderLoopDebug}
     */
    #renderLoopDebug;
    #fpsAverageCountTimer;
    /**
     * 
     * @type {GameStageData} 
     */
    #stageData;
    /**
     * @type { WebGlEngine }
     */
    #webGlEngine;
    /**
     * 
     * @type {SystemSettings}
     */
    #systemSettings;
    /**
     * @type {EventTarget}
     */
    #emitter = new EventTarget();
    constructor(systemSettings, stageData, WebGlEngine) {
        this.#systemSettings = systemSettings;
        this.#stageData = stageData;
        this.#renderLoopDebug = new _RenderLoopDebug_js__WEBPACK_IMPORTED_MODULE_13__.RenderLoopDebug(this.#systemSettings.gameOptions.render.cyclesTimeCalc.averageFPStime);
        this.#webGlEngine = WebGlEngine;

        this.#webGlEngine._initDrawCallsDebug(this.renderLoopDebug);
        
        if (this.#systemSettings.gameOptions.render.cyclesTimeCalc.check === _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONST.OPTIMIZATION.CYCLE_TIME_CALC.AVERAGES) {
            this.#fpsAverageCountTimer = setInterval(() => this.#countFPSaverage(), this.#systemSettings.gameOptions.render.cyclesTimeCalc.averageFPStime);
        }
    }

    /**
     * @returns { GameStageData }
     */
    get stageData() {
        return this.#stageData;
    }

    /**
     * @returns { RenderLoopDebug }
     */
    get renderLoopDebug() {
        return this.#renderLoopDebug;
    }
    
    /**
     * @ignore
     */
    set _isCleared(value) {
        this.#isCleared = value;
    }

    /**
     * @ignore
     */
    get _isCleared() {
        return this.#isCleared;
    }

    _start() {
        this.#isActive = true;
        requestAnimationFrame(this.#runRenderLoop);
    }

    _stop() {
        this.#isActive = false;
        this.#stageData = null;
        this.renderLoopDebug.cleanupTempVars();
        clearInterval(this.#fpsAverageCountTimer);
        //this.#fpsAverageCountTimer = null;
    }

    /**
     * 
     * @param {Number} drawTimestamp - end time of previous frame's rendering 
     */
    #runRenderLoop = (drawTimestamp) => {
        if (!this.#isActive) {
            return;
        }
        
        const currentDrawTime = this.renderLoopDebug.currentDrawTime(drawTimestamp);
        this.renderLoopDebug.prevDrawTime = drawTimestamp;
        
        const timeStart = performance.now(),
            isCyclesTimeCalcCheckCurrent = this.#systemSettings.gameOptions.render.cyclesTimeCalc.check === _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONST.OPTIMIZATION.CYCLE_TIME_CALC.CURRENT;
            
        this.emit(_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONST.EVENTS.SYSTEM.RENDER.START);
        this.#stageData._clearBoundaries();
        this.#clearContext();
        
        this.render().then(() => {
            const currentRenderTime = performance.now() - timeStart,
                //r_time_less = minCycleTime - currentRenderTime,
                wait_time = 0, //       ?
                cycleTime = currentRenderTime + wait_time;
                
            if (isCyclesTimeCalcCheckCurrent) {
                console.log("current draw take: ", (currentDrawTime), " ms");
                console.log("current render() time: ", currentRenderTime);
                console.log("draw calls: ", this.renderLoopDebug.drawCalls);
                console.log("vertices draw: ", this.renderLoopDebug.verticesDraw);
            } else {
                this.renderLoopDebug.tempRCircleT = currentDrawTime;
                this.renderLoopDebug.incrementTempRCircleTPointer();
            }

            this.emit(_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONST.EVENTS.SYSTEM.RENDER.END);

            if (this.#isActive) {
                setTimeout(() => requestAnimationFrame(this.#runRenderLoop), wait_time);
            }
        }).catch((errors) => {
            if (errors.forEach) {
                errors.forEach((err) => {
                    (0,_Exception_js__WEBPACK_IMPORTED_MODULE_3__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_2__.WARNING_CODES.UNHANDLED_DRAW_ISSUE, err);
                });
            } else {
                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_3__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_2__.WARNING_CODES.UNHANDLED_DRAW_ISSUE, errors.message);
            }
            this._stop();
        });
    };

    /**
     * @returns {Promise<void>}
     */
    async render() {
        const renderObjects = this.#stageData.renderObjects;
            
        let errors = [],
            isErrors = false,
            len = renderObjects.length,
            renderObjectsPromises = new Array(len);

        if (len !== 0) {
            //this.#checkCollisions(view.renderObjects);
            for (let i = 0; i < len; i++) {
                const object = renderObjects[i];
                if (object.isRemoved) {
                    renderObjects.splice(i, 1);
                    i--;
                    len--;
                    continue;
                }
                if ("hasAnimations" in object && object.hasAnimations) {
                    object._processActiveAnimations();
                }
                const promise = await this.#drawRenderObject(object)
                    .catch((err) => Promise.reject(err));
                renderObjectsPromises[i] = promise;
            }
            if (this.#systemSettings.gameOptions.debug.boundaries.drawLayerBoundaries) {
                renderObjectsPromises.push(this.#drawBoundariesWebGl()
                    .catch((err) => Promise.reject(err))); 
            }
        }
        const bindResults = await Promise.allSettled(renderObjectsPromises);
        bindResults.forEach((result) => {
            if (result.status === "rejected") {
                Promise.reject(result.reason);
                isErrors = true;
                errors.push(result.reason);
            }
        });
            
        this._isCleared = false;
        if (isErrors === false) {
            this.#stageData._processPendingRenderObjects();
            return Promise.resolve();
        } else {
            return Promise.reject(errors);
        }
    }

    /**
     * 
     * @param {string} eventName 
     * @param {*} listener 
     * @param {*=} options 
     */
    addEventListener = (eventName, listener, options) => {
        this.#emitter.addEventListener(eventName, listener, options);
    };

    /**
     * 
     * @param {string} eventName 
     * @param {*} listener 
     * @param {*=} options 
     */
    removeEventListener = (eventName, listener, options) => {
        this.#emitter.removeEventListener(eventName, listener, options);
    };

    /**
     * 
     * @param {string} eventName
     * @param  {...any} eventParams
     */
    emit = (eventName, ...eventParams) => {
        const event = new Event(eventName);
        event.data = [...eventParams];
        this.#emitter.dispatchEvent(event);
    };

    /**
     * @ignore
     * @param {DrawImageObject | DrawCircleObject | DrawConusObject | DrawLineObject | DrawPolygonObject | DrawRectObject | DrawTextObject | DrawTiledLayer} renderObject 
     * @returns {Promise<void>}
     */
    #drawRenderObject(renderObject) {
        return this.#webGlEngine._preRender()
            .then(() => this.#isActive ? this.#webGlEngine._drawRenderObject(renderObject, this.stageData) : Promise.resolve())
            .then((args) => this.#webGlEngine._postRender(args));
    }

    #clearContext() {
        this.#webGlEngine._clearView();
    }

    /**
     * 
     * @returns {Promise<void>}
     */
    #drawBoundariesWebGl() {
        return new Promise((resolve) => {
            const b = this.stageData.getRawBoundaries(),
                eB = this.stageData.getEllipseBoundaries(),
                pB = this.stageData.getPointBoundaries(),
                bDebug = this.stageData.getDebugObjectBoundaries(),
                len = this.stageData.boundariesLen,
                eLen = this.stageData.ellipseBLen,
                pLen = this.stageData.pointBLen,
                bDebugLen = this.#systemSettings.gameOptions.debug.boundaries.drawObjectBoundaries ? bDebug.length : 0;
        
            if (len)
                this.#webGlEngine._drawLines(b, this.#systemSettings.gameOptions.debug.boundaries.boundariesColor, this.#systemSettings.gameOptions.debug.boundaries.boundariesWidth);
            this.renderLoopDebug.incrementDrawCallsCounter();
            if (eLen) {
                //draw ellipse boundaries
                for (let i = 0; i < eLen; i+=4) {
                    const x = eB[i],
                        y = eB[i+1],
                        radX = eB[i+2],
                        radY = eB[i+3],
                        vertices = _index_js__WEBPACK_IMPORTED_MODULE_14__.utils.calculateEllipseVertices(x, y, radX, radY);
                    this.#webGlEngine._drawPolygon({x: 0, y: 0, vertices, isOffsetTurnedOff: true}, this.stageData);
                    this.renderLoopDebug.incrementDrawCallsCounter();
                    //this.#webGlEngine._drawLines(vertices, this.systemSettings.gameOptions.debug.boundaries.boundariesColor, this.systemSettings.gameOptions.debug.boundaries.boundariesWidth);
                }
            }
            if (pLen) {
                //draw point boundaries
                for (let i = 0; i < pLen; i+=2) {
                    const x = pB[i],
                        y = pB[i+1],
                        vertices = [x,y, x+1,y+1];

                    this.#webGlEngine._drawLines(vertices, this.#systemSettings.gameOptions.debug.boundaries.boundariesColor, this.#systemSettings.gameOptions.debug.boundaries.boundariesWidth);
                    this.renderLoopDebug.incrementDrawCallsCounter();
                }
            }
            if (bDebugLen > 0) {
                this.#webGlEngine._drawLines(bDebug, this.#systemSettings.gameOptions.debug.boundaries.boundariesColor, this.#systemSettings.gameOptions.debug.boundaries.boundariesWidth);
            }
            resolve();
        });
    }

    
    /**
     * 
     * @param {DrawTiledLayer} renderLayer 
     * @returns {Promise<void>}
     */
    #layerBoundariesPrecalculation(renderLayer) {
        return new Promise((resolve, reject) => {
            /*
            if (renderLayer.setBoundaries) {
                const tilemap = this.#iLoader.getTileMap(renderLayer.tileMapKey),
                    tilesets = tilemap.tilesets,
                    layerData = tilemap.layers.find((layer) => layer.name === renderLayer.layerKey),
                    { tileheight:dtheight, tilewidth:dtwidth } = tilemap,
                    tilewidth = dtwidth,
                    tileheight = dtheight,
                    [ settingsWorldWidth, settingsWorldHeight ] = this.stageData.worldDimensions;
                
                let boundaries = [];

                if (!layerData) {
                    Warning(WARNING_CODES.NOT_FOUND, "check tilemap and layers name");
                    reject();
                }
                
                for (let i = 0; i < tilesets.length; i++) {
                    const layerCols = layerData.width,
                        layerRows = layerData.height,
                        worldW = tilewidth * layerCols,
                        worldH = tileheight * layerRows;

                    if (worldW !== settingsWorldWidth || worldH !== settingsWorldHeight) {
                        Warning(WARNING_CODES.UNEXPECTED_WORLD_SIZE, " World size from tilemap is different than settings one, fixing...");
                        this.stageData._setWorldDimensions(worldW, worldH);
                    }
                    
                    if (renderLayer.setBoundaries && this.#systemSettings.gameOptions.render.boundaries.mapBoundariesEnabled) {
                        this.stageData._setWholeWorldMapBoundaries();
                    }

                    //calculate boundaries
                    let mapIndex = 0;

                    for (let row = 0; row < layerRows; row++) {
                        for (let col = 0; col < layerCols; col++) {
                            let tile = layerData.data[mapIndex],
                                mapPosX = col * tilewidth,
                                mapPosY = row * tileheight;
                            if (tile !== 0) {
                                tile -= 1;
                                
                                boundaries.push([mapPosX, mapPosY, mapPosX + tilewidth, mapPosY]);
                                boundaries.push([mapPosX + tilewidth, mapPosY, mapPosX + tilewidth, mapPosY + tileheight]);
                                boundaries.push([mapPosX + tilewidth, mapPosY + tileheight, mapPosX, mapPosY + tileheight]);
                                boundaries.push([mapPosX, mapPosY + tileheight, mapPosX, mapPosY ]);
    
                            }
                            mapIndex++;
                        }
                    }
                }
                this.stageData._setWholeMapBoundaries(boundaries);
                this.stageData._mergeBoundaries(true);
                resolve();
            } else {
                resolve();
            }*/
        });
    }

    #countFPSaverage() {
        const timeLeft = this.#systemSettings.gameOptions.render.cyclesTimeCalc.averageFPStime,
            steps = this.renderLoopDebug.tempRCircleTPointer;
        let fullTime = 0;
        for (let i = 0; i < steps; i++) {
            const timeStep = this.renderLoopDebug.tempRCircleT[i];
            fullTime += timeStep;
        }
        console.log("FPS average for", timeLeft/1000, "sec, is ", (1000 / (fullTime / steps)).toFixed(2));
        console.log("Last loop info:");
        console.log("Webgl draw calls: ", this.renderLoopDebug.drawCalls);
        console.log("Vertices draw: ", this.renderLoopDebug.verticesDraw);
        // cleanup
        this.renderLoopDebug.cleanupTempVars();
    }
}

/***/ }),

/***/ "./node_modules/jsge/src/base/RenderLoopDebug.js":
/*!*******************************************************!*\
  !*** ./node_modules/jsge/src/base/RenderLoopDebug.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RenderLoopDebug: () => (/* binding */ RenderLoopDebug)
/* harmony export */ });
/**
 * Debug info fro RenderLoop
 * @see {@link RenderLoop} a part of RenderLoop
 * @hideconstructor
 */
class RenderLoopDebug {
    /**
     * @type {number}
     */
    #verticesNum = 0;
    /**
     * @type {number}
     */
    #drawCalls = 0;
    /**
     * @type {number}
     */
    #prevDrawTime = 0;
    /**
     * @type {Float32Array}
     */
    #tempRCircleT;
    /**
     * @type {number}
     */
    #tempRCircleTPointer = 0;
    /**
     * @type {NodeJS.Timeout | null}
     */
    constructor(averageFPStime) {
        this.#tempRCircleT = new Float32Array(averageFPStime);
    }

    get drawCalls() {
        return this.#drawCalls;
    }

    get verticesDraw() {
        return this.#verticesNum;
    }

    /**
     * @returns {Float32Array}
     */
    get tempRCircleT() {
        return this.#tempRCircleT;
    }

    get tempRCircleTPointer() {
        return this.#tempRCircleTPointer;
    }

    /**
     * @param {number} time
     */
    set tempRCircleT(time) {
        this.#tempRCircleT[this.#tempRCircleTPointer] = time;
    }

    set prevDrawTime(drawTime) {
        this.#prevDrawTime = drawTime;
    }

    currentDrawTime(drawTimestamp) {
        return drawTimestamp - this.#prevDrawTime;
    }

    incrementTempRCircleTPointer() {
        this.#tempRCircleTPointer++;
    }

    incrementDrawCallsCounter() {
        this.#drawCalls+=1;
    }

    set verticesDraw(vertices) {
        this.#verticesNum += vertices;
    }

    cleanupDebugInfo() {
        this.#verticesNum = 0;
        this.#drawCalls = 0;
    }

    cleanupDrawCallsCounter() {
        this.#drawCalls = 0;
    }

    cleanupTempVars() {
        this.#tempRCircleT.fill(0);
        this.#tempRCircleTPointer = 0;
    }
}

/***/ }),

/***/ "./node_modules/jsge/src/base/System.js":
/*!**********************************************!*\
  !*** ./node_modules/jsge/src/base/System.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   System: () => (/* binding */ System)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "./node_modules/jsge/src/constants.js");
/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Exception.js */ "./node_modules/jsge/src/base/Exception.js");
/* harmony import */ var _GameStage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GameStage.js */ "./node_modules/jsge/src/base/GameStage.js");
/* harmony import */ var _ISystem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ISystem.js */ "./node_modules/jsge/src/base/ISystem.js");
/* harmony import */ var _configs_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../configs.js */ "./node_modules/jsge/src/configs.js");
/* harmony import */ var _design_LoadingStage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../design/LoadingStage.js */ "./node_modules/jsge/src/design/LoadingStage.js");








const loadingPageName = "loadingPage";
/**
 * A main app class, <br>
 * Holder class for GameStage,<br>
 * can register new GameStages,<br>
 * init and preload data for them,<br>
 */
class System {
    /**
     * @type {Map<string, Object>}
     */
    #registeredStages;
    /**
     * @type {ISystem}
     */
    #iSystem;
    /**
     * @param {SystemSettings} iSystemSettings - holds iSystem settings
     * @param {HTMLElement | null} [canvasContainer = null] - If it is not passed, iSystem will create div element and attach it to body
     */
    constructor(iSystemSettings, canvasContainer) {
        if (!iSystemSettings) {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.CREATE_INSTANCE_ERROR, "iSystemSettings should be passed to class instance");
        }
        this.#registeredStages = new Map();

        if (!canvasContainer) {
            canvasContainer = document.createElement("div");
            document.body.appendChild(canvasContainer);
        }

        this.#iSystem = new _ISystem_js__WEBPACK_IMPORTED_MODULE_3__.ISystem(iSystemSettings, this.#registeredStages, canvasContainer);

        this.#addPreloadStage();
    }

    /**
     * @returns {ISystem}
     */
    get iSystem() {
        return this.#iSystem;
    }
    
    /**
     * A main factory method for create GameStage instances, <br>
     * register them in a System and call GameStage.register() stage
     * @param {string} screenPageName
     * @param {Object} extendedGameStage - extended GameStage class(not an instance!)
     */
    registerStage(screenPageName, extendedGameStage) {
        if (screenPageName && typeof screenPageName === "string" && screenPageName.trim().length > 0) {
            const stageInstance = new extendedGameStage();
            stageInstance._register(screenPageName, this.iSystem);
            this.#registeredStages.set(screenPageName, stageInstance);
        } else {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.CREATE_INSTANCE_ERROR, "valid class name should be provided");
        }
    }

    /**
     * Preloads assets for all registered pages
     * @return {Promise<void>}
     */
    preloadAllData() {
        return this.#iSystem.iLoader.preload();
    }

    #addPreloadStage() {
        this.registerStage(loadingPageName, _design_LoadingStage_js__WEBPACK_IMPORTED_MODULE_5__.LoadingStage);

        this.#iSystem.iLoader.addEventListener("loadstart", this.#loadStart);
        this.#iSystem.iLoader.addEventListener("progress", this.#loadProgress);
        this.#iSystem.iLoader.addEventListener("load", this.#loadComplete);
    }

    #loadStart = (event) => {
        this.#iSystem.startGameStage(loadingPageName, { total: event.total });
    };

    #loadProgress = (event) => {
        const uploaded = event.loaded,
            left = event.total,
            loadingPage = this.#registeredStages.get(loadingPageName);
            
        loadingPage._progress(uploaded, left);
    };

    #loadComplete = () => {
        this.#iSystem.stopGameStage(loadingPageName);
    };
}

/***/ }),

/***/ "./node_modules/jsge/src/base/Temp/ImageTempStorage.js":
/*!*************************************************************!*\
  !*** ./node_modules/jsge/src/base/Temp/ImageTempStorage.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ImageTempStorage: () => (/* binding */ ImageTempStorage)
/* harmony export */ });
/**
 * storing current WebGLTexture
 */
class ImageTempStorage {
    /**
     * @type {Number}
     */
    #textureIndex;
    /**
     * @type {WebGLTexture}
     */
    #texture;
    /**
     * @type {boolean}
     */
    #isTextureRecalculated = true;
    constructor(texture, textureIndex = 0) {
        this.#texture = texture;
        this.#textureIndex = textureIndex;
    }

    get _isTextureRecalculated() {
        return this.#isTextureRecalculated;
    }

    set _isTextureRecalculated(value) {
        this.#isTextureRecalculated = value;
    }

    get _texture() {
        return this.#texture;
    }

    set _texture(value) {
        this.#texture = value;
    }

    get _textureIndex() {
        return this.#textureIndex;
    }
}

/***/ }),

/***/ "./node_modules/jsge/src/base/Temp/TiledLayerTempStorage.js":
/*!******************************************************************!*\
  !*** ./node_modules/jsge/src/base/Temp/TiledLayerTempStorage.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TiledLayerTempStorage: () => (/* binding */ TiledLayerTempStorage)
/* harmony export */ });
/**
 * storing vectors and textures for DrawTiledLayer
 */
class TiledLayerTempStorage {
    /**
     * @type {Array}
     */
    #vectors;
    /**
     * @type {Array}
     */
    #textures;
    /**
     * @type {Int32Array}
     */
    #boundariesTempIndexes;
    /**
     * @type {number}
     */
    #bufferSize = 0;
    /**
     * @param {number} cells 
     **/
    #cells = 0;
    /**
     * @param {number} nonEmptyCells 
     */
    #nonEmptyCells = 0;
    constructor(cells, nonEmptyCells) {
        this._initiateStorageData(cells, nonEmptyCells);
    }

    get cells() {
        return this.#cells;
    }

    get vectors() {
        return this.#vectors;
    }

    get textures() {
        return this.#textures;
    }

    get _bTempIndexes() {
        return this.#boundariesTempIndexes;
    }

    get bufferSize() {
        return this.#bufferSize;
    }

    _initiateStorageData(cellsSize, emptyCells) {
        this.#cells = cellsSize;
        this.#nonEmptyCells = emptyCells ? emptyCells : cellsSize;
        if (this.#nonEmptyCells > cellsSize) {
            this.#nonEmptyCells  = cellsSize;
        }
        this.#bufferSize = this.#nonEmptyCells * 12;

        this.#vectors = new Array(this.#bufferSize);
        this.#textures = new Array(this.#bufferSize);
        this.#boundariesTempIndexes = new Int32Array(this.#cells * 4);
    }
}

/***/ }),

/***/ "./node_modules/jsge/src/base/WebGl/ImagesDrawProgram.js":
/*!***************************************************************!*\
  !*** ./node_modules/jsge/src/base/WebGl/ImagesDrawProgram.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   imgAttributes: () => (/* binding */ imgAttributes),
/* harmony export */   imgFragmentShader: () => (/* binding */ imgFragmentShader),
/* harmony export */   imgUniforms: () => (/* binding */ imgUniforms),
/* harmony export */   imgVertexShader: () => (/* binding */ imgVertexShader)
/* harmony export */ });
const imgVertexShader =  `
    attribute vec2 a_texCoord;

    attribute vec2 a_position;

    uniform vec2 u_translation;
    uniform float u_rotation;
    uniform vec2 u_scale;

    uniform vec2 u_resolution;

    varying vec2 v_texCoord;

    void main(void) {
        float c = cos(u_rotation);
        float s = sin(u_rotation);

        mat3 translationMatrix1 = mat3(
            1, 0, 0,
            0, 1, 0,
            u_translation.x, u_translation.y, 1
        );

        mat3 translationMatrix2 = mat3(
            1, 0, 0,
            0, 1, 0,
            -u_translation.x, -u_translation.y, 1
        );
        
        mat3 rotationMatrix = mat3(
            c, s, 0,
            -s, c, 0,
            0, 0, 1
        );

        mat3 scalingMatrix = mat3(
            u_scale.x, 0, 0,
            0, u_scale.y, 0,
            0, 0, 1
        );

        mat3 matrix = translationMatrix1 * rotationMatrix * translationMatrix2 * scalingMatrix;
    
        vec2 position = (matrix * vec3(a_position, 1)).xy;

        vec2 clipSpace = position / u_resolution * 2.0 - 1.0;

        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        
        v_texCoord = a_texCoord;
    }`;
const imgFragmentShader = `
    precision mediump float;

    uniform sampler2D u_image;

    //texCoords passed in from the vertex shader
    varying vec2 v_texCoord;
    void main() {
        vec4 color = texture2D(u_image, v_texCoord);
        gl_FragColor = color;
    }`;
const imgUniforms = ["u_translation", "u_rotation", "u_scale", "u_resolution","u_image"];
const imgAttributes = ["a_position", "a_texCoord"];



/***/ }),

/***/ "./node_modules/jsge/src/base/WebGl/ImagesDrawProgramM.js":
/*!****************************************************************!*\
  !*** ./node_modules/jsge/src/base/WebGl/ImagesDrawProgramM.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   imgMAttributes: () => (/* binding */ imgMAttributes),
/* harmony export */   imgMFragmentShader: () => (/* binding */ imgMFragmentShader),
/* harmony export */   imgMUniforms: () => (/* binding */ imgMUniforms),
/* harmony export */   imgMVertexShader: () => (/* binding */ imgMVertexShader)
/* harmony export */ });
const imgMVertexShader =  `
    attribute vec2 a_texCoord;

    attribute vec2 a_position;

    uniform vec2 u_resolution;

    varying vec2 v_texCoord;

    void main(void) {
        vec2 clipSpace = a_position / u_resolution * 2.0 - 1.0;
        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        v_texCoord = a_texCoord;
    }`;

const imgMFragmentShader = `
    precision mediump float;

    uniform sampler2D u_image;

    //texCoords passed in from the vertex shader
    varying vec2 v_texCoord;
    void main() {
        vec4 color = texture2D(u_image, v_texCoord);
        gl_FragColor = color;
    }`;
const imgMUniforms = ["u_resolution", "u_image"];
const imgMAttributes = ["a_position", "a_texCoord"];



/***/ }),

/***/ "./node_modules/jsge/src/base/WebGl/PrimitivesDrawProgram.js":
/*!*******************************************************************!*\
  !*** ./node_modules/jsge/src/base/WebGl/PrimitivesDrawProgram.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   primitivesAttributes: () => (/* binding */ primitivesAttributes),
/* harmony export */   primitivesFragmentShader: () => (/* binding */ primitivesFragmentShader),
/* harmony export */   primitivesUniforms: () => (/* binding */ primitivesUniforms),
/* harmony export */   primitivesVertexShader: () => (/* binding */ primitivesVertexShader)
/* harmony export */ });
const primitivesVertexShader =  `
    precision mediump float;

    attribute vec2 a_position;

    uniform vec2 u_translation;
    uniform float u_rotation;
    uniform vec2 u_scale;

    uniform vec2 u_resolution;

    void main(void) {
        float c = cos(u_rotation);
        float s = sin(u_rotation);

        mat3 translationMatrix1 = mat3(
            1, 0, 0,
            0, 1, 0,
            u_translation.x, u_translation.y, 1
        );
        
        mat3 rotationMatrix = mat3(
            c, s, 0,
            -s, c, 0,
            0, 0, 1
        );

        mat3 scalingMatrix = mat3(
            u_scale.x, 0, 0,
            0, u_scale.y, 0,
            0, 0, 1
        );
        
        mat3 matrix = translationMatrix1 * rotationMatrix * scalingMatrix;

        vec2 position = (matrix * vec3(a_position, 1)).xy;

        vec2 clipSpace = position / u_resolution * 2.0 - 1.0;

        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
    }
`;
const primitivesFragmentShader = `
    precision mediump float;

    uniform vec4 u_color;
    uniform float u_fade_min; 
    uniform float u_fade_max;
    uniform vec2 u_resolution;
    uniform vec2 u_translation;

    void main(void) {
        vec4 p = u_color;
        if (u_fade_min > 0.0) {
            vec2 fix_tr = vec2(u_translation.x, u_resolution.y - u_translation.y); 
            float distance = distance(fix_tr.xy, gl_FragCoord.xy);
            if (u_fade_min <= distance && distance <= u_fade_max) {
                float percent = ((distance - u_fade_max) / (u_fade_min - u_fade_max)) * 100.0;
                p.a = u_color.a * (percent / 100.0);
            }
        }

        gl_FragColor = p;
    }
`;
const primitivesUniforms = ["u_translation", "u_rotation", "u_scale", "u_resolution", "u_fade_min", "u_fade_max", "u_color"];
const primitivesAttributes = ["a_position"];



/***/ }),

/***/ "./node_modules/jsge/src/base/WebGl/WebGlEngine.js":
/*!*********************************************************!*\
  !*** ./node_modules/jsge/src/base/WebGl/WebGlEngine.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebGlEngine: () => (/* binding */ WebGlEngine)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./node_modules/jsge/src/constants.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils.js */ "./node_modules/jsge/src/utils.js");
/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Exception.js */ "./node_modules/jsge/src/base/Exception.js");
/* harmony import */ var _GameStageData_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../GameStageData.js */ "./node_modules/jsge/src/base/GameStageData.js");
/* harmony import */ var _Temp_ImageTempStorage_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Temp/ImageTempStorage.js */ "./node_modules/jsge/src/base/Temp/ImageTempStorage.js");
/* harmony import */ var _2d_DrawTiledLayer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../2d/DrawTiledLayer.js */ "./node_modules/jsge/src/base/2d/DrawTiledLayer.js");
/* harmony import */ var _2d_DrawCircleObject_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../2d/DrawCircleObject.js */ "./node_modules/jsge/src/base/2d/DrawCircleObject.js");
/* harmony import */ var _2d_DrawConusObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../2d/DrawConusObject.js */ "./node_modules/jsge/src/base/2d/DrawConusObject.js");
/* harmony import */ var _2d_DrawLineObject_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../2d/DrawLineObject.js */ "./node_modules/jsge/src/base/2d/DrawLineObject.js");
/* harmony import */ var _2d_DrawPolygonObject_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../2d/DrawPolygonObject.js */ "./node_modules/jsge/src/base/2d/DrawPolygonObject.js");
/* harmony import */ var _2d_DrawRectObject_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../2d/DrawRectObject.js */ "./node_modules/jsge/src/base/2d/DrawRectObject.js");
/* harmony import */ var _2d_DrawTextObject_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../2d/DrawTextObject.js */ "./node_modules/jsge/src/base/2d/DrawTextObject.js");
/* harmony import */ var _modules_assetsm_src_AssetsManager_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../../modules/assetsm/src/AssetsManager.js */ "./node_modules/jsge/modules/assetsm/src/AssetsManager.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../index.js */ "./node_modules/jsge/src/index.js");

















class WebGlEngine {
    /**
     * @type {WebGLRenderingContext}
     */
    #gl;
    /**
     * @type {number}
     */
    #MAX_TEXTURES;
    /**
     * @type {boolean}
     */
    #debug;
    /**
     * @type {Object}
     */
    #gameOptions;
    /**
     * @type {AssetsManager}
     */
    #loaderReference;
    /**
     * @type {WebGLBuffer | null}
     */
    #positionBuffer;
    /**
     * @type {WebGLBuffer | null}
     */
    #texCoordBuffer;
    /**
     * @type {Array<number> | null}
     */
    #currentVertices = null;
    /**
     * @type {Array<number> | null}
     */
    #currentTextures = null;
    /**
     * @type {Map<string, WebGLProgram>}
     */
    #registeredWebGlPrograms = new Map();
    /**
     * @type {Map<string, Object<string, WebGLUniformLocation | number>>}
     */
    #webGlProgramsVarsLocations = new Map();
    /**
     * @type {Map<string, {method: Function, webglProgramName: string}>}
     */
    #registeredRenderObjects = new Map();

    /**
     * @type {boolean}
     */
    #loopDebug;

    constructor(context, gameOptions, iLoader) {
        if (!context || !(context instanceof WebGLRenderingContext)) {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.UNEXPECTED_INPUT_PARAMS, " context parameter should be specified and equal to WebGLRenderingContext");
        }
        
        this.#gl = context;
        this.#gameOptions = gameOptions;
        this.#loaderReference = iLoader;
        this.#debug = gameOptions.debug.checkWebGlErrors;
        this.#MAX_TEXTURES = context.getParameter(context.MAX_TEXTURE_IMAGE_UNITS);
        this.#positionBuffer = context.createBuffer();
        this.#texCoordBuffer = context.createBuffer();

        this._registerObjectRender(_2d_DrawTextObject_js__WEBPACK_IMPORTED_MODULE_11__.DrawTextObject.name, this._bindText, _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WEBGL.DRAW_PROGRAMS.IMAGES_M);
        this._registerObjectRender(_2d_DrawRectObject_js__WEBPACK_IMPORTED_MODULE_10__.DrawRectObject.name, this._bindPrimitives, _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES);
        this._registerObjectRender(_2d_DrawPolygonObject_js__WEBPACK_IMPORTED_MODULE_9__.DrawPolygonObject.name, this._bindPrimitives, _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES);
        this._registerObjectRender(_2d_DrawCircleObject_js__WEBPACK_IMPORTED_MODULE_6__.DrawCircleObject.name, this._bindConus, _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES);
        this._registerObjectRender(_2d_DrawConusObject_js__WEBPACK_IMPORTED_MODULE_7__.DrawConusObject.name, this._bindConus, _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES);
        this._registerObjectRender(_2d_DrawTiledLayer_js__WEBPACK_IMPORTED_MODULE_5__.DrawTiledLayer.name, this._bindTileImages, _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WEBGL.DRAW_PROGRAMS.IMAGES_M);
        this._registerObjectRender(_2d_DrawLineObject_js__WEBPACK_IMPORTED_MODULE_8__.DrawLineObject.name, this._bindLine, _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES);
        this._registerObjectRender(_constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.IMAGE, this._bindImage, _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WEBGL.DRAW_PROGRAMS.IMAGES_M);
    }

    getProgram(name) {
        return this.#registeredWebGlPrograms.get(name);
    }

    getProgramVarLocations(name) {
        return this.#webGlProgramsVarsLocations.get(name);
    }

    _fixCanvasSize(width, height) {
        this.#gl.viewport(0, 0, width, height);
    }
    _initiateJsRender = (stageData) => {
        return new Promise((resolve, reject) => {
            const tileLayers = stageData.getObjectsByInstance(_2d_DrawTiledLayer_js__WEBPACK_IMPORTED_MODULE_5__.DrawTiledLayer),
                [ settingsWorldWidth, settingsWorldHeight ] = stageData.worldDimensions;

            // count max possible boundaries sizes
            let maxBSize = 0,
                maxESize = 0,
                maxPSize = 0,
                maxWorldW = 0,
                maxWorldH = 0;

            tileLayers.forEach(tiledLayer => {
                const setBoundaries = tiledLayer.setBoundaries,
                    layerData = tiledLayer.layerData,
                    tilemap = tiledLayer.tilemap,
                    tilesets = tiledLayer.tilesets,
                    { tileheight:dtheight, tilewidth:dtwidth } = tilemap,
                    tilewidth = dtwidth,
                    tileheight = dtheight;

                for (let i = 0; i < tilesets.length; i++) {
                    const layerCols = layerData.width,
                        layerRows = layerData.height,
                        worldW = tilewidth * layerCols,
                        worldH = tileheight * layerRows;
                        
                    const polygonBondMax = layerData.polygonBoundariesLen,
                        ellipseBondMax = layerData.ellipseBoundariesLen,
                        pointBondMax = layerData.pointBoundariesLen; 
    
                    if (maxWorldW < worldW) {
                        maxWorldW = worldW;
                    }
                    if (maxWorldH < worldH) {
                        maxWorldH = worldH;
                    }
                    
                    if (setBoundaries) {
                        maxBSize += polygonBondMax;
                        maxESize += ellipseBondMax;
                        maxPSize += pointBondMax;
    
                        // boundaries cleanups every draw cycles, we need to set world boundaries again
                        
                    }
                }
            });

            if (maxWorldW !== 0 && maxWorldH !== 0 && (maxWorldW !== settingsWorldWidth || maxWorldH !== settingsWorldHeight)) {
                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.UNEXPECTED_WORLD_SIZE, " World size from tilemap is different than settings one, fixing...");
                stageData._setWorldDimensions(maxWorldW, maxWorldH);
            }

            if (this.#gameOptions.render.boundaries.mapBoundariesEnabled) {
                maxBSize+=16; //4 sides * 4 cords x1,y1,x2,y,2
            }
            stageData._setMaxBoundariesSize(maxBSize, maxESize, maxPSize);
            stageData._initiateBoundariesData();

            resolve(true);
        });

    };
    _initWebGlAttributes = () => {
        const gl = this.#gl;
        gl.enable(gl.BLEND);
        gl.enable(gl.STENCIL_TEST);
        gl.stencilFunc(gl.ALWAYS, 1, 0xFF);
        //if stencil test and depth test pass we replace the initial value
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
        return Promise.resolve();
    };

    /**
     * 
     * @returns {Promise<void>}
     */
    _initiateWasm = (stageData) => {
        const url = this.#gameOptions.optimization === _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.OPTIMIZATION.WEB_ASSEMBLY.NATIVE_WAT ? this.#gameOptions.optimizationWASMUrl : this.#gameOptions.optimizationAssemblyUrl;
        return new Promise((resolve, reject) => {
            this.layerData = new WebAssembly.Memory({
                initial:1000 // 6.4MiB x 10 = 64MiB(~67,1Mb)
            });
            this.layerDataFloat32 = new Float32Array(this.layerData.buffer);
            const importObject = {
                env: {
                    memory: this.layerData,
                    logi: console.log,
                    logf: console.log
                }
            };

            fetch(url)
                .then((response) => response.arrayBuffer())
                .then((module) => WebAssembly.instantiate(module, importObject))
                .then((obj) => {
                    this.calculateBufferData = obj.instance.exports.calculateBufferData;
                    resolve();
                });
        });
    };

    _initDrawCallsDebug(debugObjReference) {
        this.#loopDebug = debugObjReference;
    }

    /**
     * 
     * @returns {void}
     */
    _clearView() {
        const gl = this.#gl;
        this.#loopDebug.cleanupDebugInfo();
        //cleanup buffer, is it required?
        //gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.clearColor(0, 0, 0, 0);// shouldn't be gl.clearColor(0, 0, 0, 1); ?
        // Clear the color buffer with specified clear color
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
    }
    
    /**
     * 
     * @returns {Promise<any>}
     */
    _render(verticesNumber, primitiveType, offset = 0) {
        this.#gl.drawArrays(primitiveType, offset, verticesNumber);
        // set blend to default
        return Promise.resolve(verticesNumber);
    }

    /**
     * 
     * @returns {Promise<void>}
     */
    _preRender() {
        return new Promise((resolve, reject) => {
            const gl = this.#gl,
                err = this.#debug ? gl.getError() : 0;
            if (err !== 0) {
                console.error(err);
                throw new Error("Error num: " + err);
            } else {
                resolve();
            }
        });
    }

    /**
     * 
     * @returns {Promise<void>}
     */
    _postRender(inputData) {
        let verticesNumber = inputData;

        // A workaround for backward capability in 1.5.n
        if (Array.isArray(verticesNumber)) {
            const [vertices, primitiveType] = inputData;
            
            this.#gl.drawArrays(primitiveType, 0, vertices);
            verticesNumber = vertices;
        }

        return new Promise((resolve, reject) => {
            const gl = this.#gl;

            if (verticesNumber !== 0) {
                this.#loopDebug.incrementDrawCallsCounter();
                this.#loopDebug.verticesDraw = verticesNumber;
            }

            gl.stencilFunc(gl.ALWAYS, 1, 0xFF);

            if (this.#gameOptions.debug.delayBetweenObjectRender) {
                setTimeout(() => {
                    resolve();
                }, 1000);
            } else {
                resolve();
            }
        });
    }

    /*************************************
     * Register and compile programs
     ************************************/

    /**
     * 
     * @param {string} programName
     * @param {string} vertexShader - raw vertex shader program
     * @param {string} fragmentShader - raw fragment shader program 
     * @param {Array<string>} uVars - program uniform variables names
     * @param {Array<string>} aVars - program attribute variables names
     * @returns {Promise<void>}
     */
    _registerAndCompileWebGlProgram(programName, vertexShader, fragmentShader, uVars, aVars) {
        const program = this.#compileWebGlProgram(vertexShader, fragmentShader),
            varsLocations = this.#getProgramVarsLocations(program, uVars, aVars);
        this.#registeredWebGlPrograms.set(programName, program);
        this.#webGlProgramsVarsLocations.set(programName, varsLocations);

        return Promise.resolve();
    }

    /**
     * @returns {WebGLProgram}
     */
    #compileWebGlProgram (vertexShader, fragmentShader) {
        const gl = this.#gl,
            program = gl.createProgram();

        if (program) {
            const compVertexShader = this.#compileShader(gl, vertexShader, gl.VERTEX_SHADER);
            if (compVertexShader) {
                gl.attachShader(program, compVertexShader);
            } else {
                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.WEBGL_ERROR, "#compileShader(vertexShaderSource) is null");
            }

            const compFragmentShader = this.#compileShader(gl, fragmentShader, gl.FRAGMENT_SHADER);
            if (compFragmentShader) {
                gl.attachShader(program, compFragmentShader);
            } else {
                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.WEBGL_ERROR, "#compileShader(fragmentShaderSource) is null");
            }

            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                const info = gl.getProgramInfoLog(program);
                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.WEBGL_ERROR, `Could not compile WebGL program. \n\n${info}`);
            }
        } else {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.WEBGL_ERROR, "gl.createProgram() is null");
        }
        return program;
    }

    /**
     * 
     * @param {WebGLProgram} program
     * @param {Array<string>} uVars - uniform variables
     * @param {Array<string>} aVars - attributes variables
     * @returns {Object<string, WebGLUniformLocation | number>} - uniform or attribute
     */
    #getProgramVarsLocations(program, uVars, aVars) {
        const gl = this.#gl;
        let locations = {};
        uVars.forEach(elementName => {
            locations[elementName] = gl.getUniformLocation(program, elementName);
        });
        aVars.forEach(elementName => {
            locations[elementName] = gl.getAttribLocation(program, elementName);
        });
        return locations;
    }

    #compileShader(gl, shaderSource, shaderType) {
        const shader = gl.createShader(shaderType);
        if (shader) {
            gl.shaderSource(shader, shaderSource);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                const info = gl.getShaderInfoLog(shader);
                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.WEBGL_ERROR, "Couldn't compile webGl program. \n\n" + info);
            }
        } else {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.WEBGL_ERROR, `gl.createShader(${shaderType}) is null`);
        }
        return shader;
    }
    /*------------------------------------
     * End of Register and compile programs
     -------------------------------------*/

    /**********************************
     * Predefined Drawing programs
     **********************************/
    _bindPrimitives = (renderObject, gl, pageData, program, vars) => {
        const [ xOffset, yOffset ] = renderObject.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset,
            x = renderObject.x - xOffset,
            y = renderObject.y - yOffset,
            scale = [1, 1],
            rotation = renderObject.rotation,
            blend = renderObject.blendFunc ? renderObject.blendFunc : [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA],
            { 
                u_translation: translationLocation,
                u_rotation: rotationRotation,
                u_scale: scaleLocation,
                u_resolution: resolutionUniformLocation,
                u_color: colorUniformLocation,
                a_position: positionAttributeLocation,
                u_fade_min: fadeMinLocation
            } = vars;
            
        let verticesNumber = 0;
        gl.useProgram(program);
        // set the resolution
        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
        gl.uniform2f(translationLocation, x, y);
        gl.uniform2f(scaleLocation, scale[0], scale[1]);
        gl.uniform1f(rotationRotation, rotation);
        gl.uniform1f(fadeMinLocation, 0);
        
        gl.enableVertexAttribArray(positionAttributeLocation);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);

        switch (renderObject.type) {
        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.RECTANGLE:
            this.#setSingleRectangle(renderObject.width, renderObject.height);
            verticesNumber += 6;
            break;
        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.TEXT:
            break;
        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.CIRCLE: {
            const coords = renderObject.vertices;
            gl.bufferData(gl.ARRAY_BUFFER, 
                new Float32Array(coords), gl.STATIC_DRAW);
            verticesNumber += coords.length / 2;
            break;
        }
        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.DRAW_TYPE.POLYGON: {
            const triangles = this.#triangulatePolygon(renderObject.vertices);
            this.#bindPolygon(triangles);
            const len = triangles.length;
            if (len % 3 !== 0) {
                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.POLYGON_VERTICES_NOT_CORRECT, `polygons ${renderObject.id}, vertices are not correct, skip drawing`);
                return Promise.reject();
            }
            verticesNumber += len / 2;
            break;
        }
        }
        //Tell the attribute how to get data out of positionBuffer
        const size = 2,
            type = gl.FLOAT, // data is 32bit floats
            normalize = false,
            stride = 0, // move forward size * sizeof(type) each iteration to get next position
            offset = 0; // start of beginning of the buffer
        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

        const colorArray = this.#rgbaToArray(renderObject.bgColor);
        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);
        
        if (blend) {
            gl.blendFunc(blend[0], blend[1]);
        }
        
        if (renderObject.isMaskAttached) {
            gl.stencilFunc(gl.EQUAL, renderObject._maskId, 0xFF);
        } else if (renderObject._isMask) {
            gl.stencilFunc(gl.ALWAYS, renderObject.id, 0xFF);
        }
        return this._render(verticesNumber, gl.TRIANGLES);
    };
    _bindConus = (renderObject, gl, pageData, program, vars) => {
        const [ xOffset, yOffset ] = renderObject.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset,
            x = renderObject.x - xOffset,
            y = renderObject.y - yOffset,
            scale = [1, 1],
            rotation = renderObject.rotation,
            { 
                u_translation: translationLocation,
                u_rotation: rotationRotation,
                u_scale: scaleLocation,
                u_resolution: resolutionUniformLocation,
                u_color: colorUniformLocation,
                a_position: positionAttributeLocation,
                u_fade_max: fadeMaxLocation,
                u_fade_min: fadeMinLocation
            } = vars,
            coords = renderObject.vertices,
            fillStyle = renderObject.bgColor,
            fade_min = renderObject.fade_min,
            fadeLen = renderObject.radius,
            blend = renderObject.blendFunc ? renderObject.blendFunc : [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
        let verticesNumber = 0;

        gl.useProgram(program);
        
        // set the resolution
        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
        gl.uniform2f(translationLocation, x, y);
        gl.uniform2f(scaleLocation, scale[0], scale[1]);
        gl.uniform1f(rotationRotation, rotation);
        gl.uniform1f(fadeMinLocation, fade_min);
        gl.uniform1f(fadeMaxLocation, fadeLen);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);

        gl.bufferData(gl.ARRAY_BUFFER, 
            new Float32Array(coords), gl.STATIC_DRAW);

        gl.enableVertexAttribArray(positionAttributeLocation);
        //Tell the attribute how to get data out of positionBuffer
        const size = 2,
            type = gl.FLOAT, // data is 32bit floats
            normalize = false,
            stride = 0, // move forward size * sizeof(type) each iteration to get next position
            offset = 0; // start of beginning of the buffer
        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

        verticesNumber += coords.length / 2;

        if (blend) {
            gl.blendFunc(blend[0], blend[1]);
        }

        const colorArray = this.#rgbaToArray(fillStyle);

        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);
        
        if (renderObject.isMaskAttached) {
            gl.stencilFunc(gl.EQUAL, renderObject._maskId, 0xFF);
        } else if (renderObject._isMask) {
            gl.stencilFunc(gl.ALWAYS, renderObject.id, 0xFF);
        }
        
        return this._render(verticesNumber, gl.TRIANGLE_FAN);
    };

    _bindText = (renderObject, gl, pageData, program, vars) => {
        const { u_translation: translationLocation,
            u_rotation: rotationRotation,
            u_scale: scaleLocation,
            u_resolution: resolutionUniformLocation,
            a_position: positionAttributeLocation,
            a_texCoord: texCoordLocation,
            u_image: u_imageLocation } = vars;

        const {width:boxWidth, height:boxHeight} = renderObject.boundariesBox,
            image_name = renderObject.text,
            [ xOffset, yOffset ] = renderObject.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset,
            x = renderObject.x - xOffset,
            y = renderObject.y - yOffset - boxHeight,
            blend = renderObject.blendFunc ? renderObject.blendFunc : [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

        const rotation = renderObject.rotation || 0,
            scale = [1, 1];
        const vecX1 = x,
            vecY1 = y,
            vecX2 = vecX1 + boxWidth,
            vecY2 = vecY1 + boxHeight;

        const verticesBufferData = [
            vecX1, vecY1,
            vecX2, vecY1,
            vecX1, vecY2,
            vecX1, vecY2,
            vecX2, vecY1,
            vecX2, vecY2
        ],
        texturesBufferData = [
            0, 0,
            1, 0,
            0, 1,
            0, 1,
            1, 0,
            1, 1
        ];
        let verticesNumber = 0;

        gl.useProgram(program);
        // set the resolution
        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
        gl.uniform2f(translationLocation, x, y);
        gl.uniform2f(scaleLocation, scale[0], scale[1]);
        gl.uniform1f(rotationRotation, rotation);
        
        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesBufferData), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(positionAttributeLocation);
        //Tell the attribute how to get data out of positionBuffer
        const size = 2,
            type = gl.FLOAT, // data is 32bit floats
            normalize = false,
            stride = 0, // move forward size * sizeof(type) each iteration to get next position
            offset = 0; // start of beginning of the buffer
        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

        //textures buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, this.#texCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texturesBufferData), gl.STATIC_DRAW);

        gl.enableVertexAttribArray(texCoordLocation);
        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
        
        verticesNumber += 6;
        // remove box
        // fix text edges
        gl.blendFunc(blend[0], blend[1]);
        //
        //var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
        
        let textureStorage = renderObject._textureStorage;
        if (!textureStorage) {
            //const activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
            textureStorage = new _Temp_ImageTempStorage_js__WEBPACK_IMPORTED_MODULE_4__.ImageTempStorage(gl.createTexture());
            renderObject._textureStorage = textureStorage;
        }
        if (textureStorage._isTextureRecalculated === true) {
            this.#updateTextWebGlTexture(gl, textureStorage._texture, renderObject._textureCanvas);
            textureStorage._isTextureRecalculated = false;
        } else {
            this.#bindTexture(gl, textureStorage._texture);
        }
        gl.uniform1i(u_imageLocation, textureStorage._textureIndex);
        gl.depthMask(false);
        return this._render(verticesNumber, gl.TRIANGLES);
        
    };

    _bindImage = (renderObject, gl, pageData, program, vars) => {
        const [ xOffset, yOffset ] = renderObject.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset,
            x = renderObject.x - xOffset,
            y = renderObject.y - yOffset;

        if (renderObject.vertices && this.#gameOptions.debug.boundaries.drawObjectBoundaries) {
            pageData._enableDebugObjectBoundaries();
            pageData._addImageDebugBoundaries(_index_js__WEBPACK_IMPORTED_MODULE_13__.utils.calculateLinesVertices(x, y, renderObject.rotation, renderObject.vertices));
        }
        
        const {
            u_resolution: resolutionUniformLocation,
            a_position: positionAttributeLocation,
            a_texCoord: texCoordLocation,
            u_image: u_imageLocation } = vars;

        if (!renderObject.image) {
            const image = this.#loaderReference.getImage(renderObject.key);
            if (!image) {
                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.CANT_GET_THE_IMAGE, "iLoader can't get the image with key: " + renderObject.key);
            } else {
                renderObject.image = image;
            }
        }
        const atlasImage = renderObject.image,
              animationIndex = renderObject.imageIndex,
              shapeMaskId = renderObject._maskId,
              spacing = renderObject.spacing,
              margin = renderObject.margin,
              blend = renderObject.blendFunc ? renderObject.blendFunc : [gl.ONE, gl.ONE_MINUS_SRC_ALPHA],
              scale = [1, 1];
        
        let imageX = margin,
            imageY = margin,
            colNum = 0,
            rowNum = 0;

        if (animationIndex !== 0) {
            const imageColsNumber = (atlasImage.width + spacing - (2*margin)) / (renderObject.width + spacing);
            colNum = animationIndex % imageColsNumber;
            rowNum = Math.floor(animationIndex / imageColsNumber);
            imageX = colNum * renderObject.width + (colNum * spacing) + margin,
            imageY = rowNum * renderObject.height + (rowNum * spacing) + margin;
        }

        // transform, scale and rotate should be done in js side
        //gl.uniform2f(translationLocation, x, y);
        //gl.uniform2f(scaleLocation, scale[0], scale[1]);
        //gl.uniform1f(rotationRotation, renderObject.rotation);
        // multiple matrices:
        const c = Math.cos(renderObject.rotation),
              s = Math.sin(renderObject.rotation),
              translationMatrix = [
                  1, 0, x,
                  0, 1, y,
                  0, 0, 1],
              rotationMatrix = [
                  c, -s, 0,
                  s, c, 0,
                  0, 0, 1
              ],
              scaleMatrix = [
                  scale[0], 0, 0,
                  0, scale[1], 0,
                  0, 0, 1
              ];
        const matMultiply = _index_js__WEBPACK_IMPORTED_MODULE_13__.utils.mat3Multiply(_index_js__WEBPACK_IMPORTED_MODULE_13__.utils.mat3Multiply(translationMatrix, rotationMatrix), scaleMatrix);

        const posX = 0 - renderObject.width / 2,
              posY = 0 - renderObject.height / 2;

        const vecX1 = posX,
              vecY1 = posY,
              vecX2 = vecX1 + renderObject.width,
              vecY2 = vecY1 + renderObject.height,
              texX1 = 1 / atlasImage.width * imageX,
              texY1 = 1 / atlasImage.height * imageY,
              texX2 = texX1 + (1 / atlasImage.width * renderObject.width),
              texY2 = texY1 + (1 / atlasImage.height * renderObject.height);
        //console.log("mat1: ", matMult1);
        //console.log("mat2: ", matMult2);
        //console.log("x1y1: ", x1y1);
        const vectorsD =  [
            vecX1, vecY1,
            vecX2, vecY1,
            vecX1, vecY2,
            vecX1, vecY2,
            vecX2, vecY1,
            vecX2, vecY2
        ];
        const vectors = _index_js__WEBPACK_IMPORTED_MODULE_13__.utils.mat3MultiplyPosCoords(matMultiply, vectorsD),
        textures = [
            texX1, texY1,
            texX2, texY1,
            texX1, texY2,
            texX1, texY2,
            texX2, texY1,
            texX2, texY2
        ];
        
        //vec2 position = (u_transformMat * vec3(a_position, 1)).xy;
        //console.log("translation x: ", x, " y: ", y);
        //console.log("scale x: ", scale[0], " y: ", scale[1]);
        //console.log("rotation: ", renderObject.rotation);
        // Determine could we merge next drawObject or not
        // 1. Find next object
        const nextObject = this.getNextRenderObject(renderObject, pageData);
        // 2. Is it have same texture and draw program?
        if (nextObject && this._canImageObjectsMerge(renderObject, nextObject)) {
            //
            if (this.#currentVertices === null) {
                this.#currentVertices = vectors;
                this.#currentTextures = textures;
                return Promise.resolve(0);
            } else {
                this.#currentVertices.push(...vectors);
                this.#currentTextures.push(...textures);
                return Promise.resolve(0);
            }
        } else {
            
            gl.useProgram(program);
            // set the resolution
            gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
            // bind data and call draw
            if (this.#currentVertices === null) {
                this.#currentVertices = vectors;
                this.#currentTextures = textures;
            } else {
                this.#currentVertices.push(...vectors);
                this.#currentTextures.push(...textures);
            }
            
            gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.#currentVertices), gl.STATIC_DRAW);

            const verticesNumber = this.#currentVertices.length / 2;
            gl.enableVertexAttribArray(positionAttributeLocation);
            //Tell the attribute how to get data out of positionBuffer
            const size = 2,
                type = gl.FLOAT, // data is 32bit floats
                normalize = false,
                stride = 0, // move forward size * sizeof(type) each iteration to get next position
                offset = 0; // start of beginning of the buffer
            gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

            //textures buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, this.#texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.#currentTextures), gl.STATIC_DRAW);

            gl.enableVertexAttribArray(texCoordLocation);
            gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

            let textureStorage = renderObject._textureStorage;
            if (!textureStorage) {
                textureStorage = new _Temp_ImageTempStorage_js__WEBPACK_IMPORTED_MODULE_4__.ImageTempStorage(gl.createTexture());
                renderObject._textureStorage = textureStorage;
            } 
            if (textureStorage._isTextureRecalculated === true) {
                this.#updateWebGlTexture(gl, textureStorage._texture, renderObject.image);
                textureStorage._isTextureRecalculated = false;
            } else {
                this.#bindTexture(gl, textureStorage._texture);
            }    

            gl.uniform1i(u_imageLocation, textureStorage._textureIndex);
            // make image transparent parts transparent
            gl.blendFunc(blend[0], blend[1]);
            if (shapeMaskId) {
                gl.stencilFunc(gl.EQUAL, shapeMaskId, 0xFF);
                //gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
            }
            this.#currentVertices = null;
            this.#currentTextures = null;
            return this._render(verticesNumber, gl.TRIANGLES);
        }
    };

    /**
     * 
     * @param {*} obj1 
     * @param {*} obj2
     * @returns {boolean} 
     */
    _canImageObjectsMerge = (obj1, obj2) => {
        const registeredO1 = this.#registeredRenderObjects.get(obj1.constructor.name) || this.#registeredRenderObjects.get(obj1.type),
            registeredO2 = this.#registeredRenderObjects.get(obj2.constructor.name) || this.#registeredRenderObjects.get(obj2.type);
        if ((registeredO1.webglProgramName === registeredO2.webglProgramName)
            && (obj1.type === obj2.type)
            && (obj1.image === obj2.image)
            && (obj2.isRemoved === false)) {
                return true;
        } else {
            return false;
        }
    }

    /**
     * 
     * @param {*} obj1 
     * @param {*} obj2 
     * @returns {boolean}
     */
    _canMergeNextTileObject = (obj1, obj2) => {
        if ((obj2 instanceof _2d_DrawTiledLayer_js__WEBPACK_IMPORTED_MODULE_5__.DrawTiledLayer) 
            && (obj1.tilesetImages.length === 1) 
            && (obj2.tilesetImages.length === 1) 
            && (obj1.tilesetImages[0] === obj2.tilesetImages[0])
            && (obj2.isRemoved === false)) {
                return true;
        } else {
            return false;
        }
    }

    _canTextBeMerged = (obj1, obj2) => {
        const registeredO1 = this.#registeredRenderObjects.get(obj1.constructor.name) || this.#registeredRenderObjects.get(obj1.type),
            registeredO2 = this.#registeredRenderObjects.get(obj2.constructor.name) || this.#registeredRenderObjects.get(obj2.type);
        if ((registeredO1.webglProgramName === registeredO2.webglProgramName) 
            && (obj1.type === obj2.type)
            && (obj2.isRemoved === false)) {
                return true;
        } else {
            return false;
        }
    }
    _bindTileImages = async(renderLayer, gl, pageData, program, vars) => {
        const { u_translation: translationLocation,
            u_rotation: rotationRotation,
            u_scale: scaleLocation,
            u_resolution: resolutionUniformLocation,
            a_position: positionAttributeLocation,
            a_texCoord: texCoordLocation,
            u_image: u_imageLocation } = vars;

        gl.useProgram(program);
        /**
         * @type {Array<any> | null}
         */
        let renderLayerData = null;
        switch (this.#gameOptions.optimization) {
            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.OPTIMIZATION.NATIVE_JS.NOT_OPTIMIZED:
                renderLayerData = await this.#prepareRenderLayerOld(renderLayer, pageData);
                break;
            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.OPTIMIZATION.WEB_ASSEMBLY.ASSEMBLY_SCRIPT:
            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.OPTIMIZATION.WEB_ASSEMBLY.NATIVE_WAT:
                renderLayerData = await this.#prepareRenderLayerWM(renderLayer, pageData);
                break;
            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.OPTIMIZATION.NATIVE_JS.OPTIMIZED:
            default:
                renderLayerData = await this.#prepareRenderLayer(renderLayer, pageData);
        }
        
        const translation = [0, 0],
              scale = [1, 1],
              rotation = renderLayer.rotation || 0,
              drawMask = ["ONE", "ONE_MINUS_SRC_ALPHA"],
              shapeMaskId = renderLayer._maskId;

        /*
        const c = Math.cos(renderLayer.rotation || 0),
              s = Math.sin(renderLayer.rotation || 0),
              translationMatrix = [
                  1, 0, translation[0],
                  0, 1, translation[1],
                  0, 0, 1],
              rotationMatrix = [
                  c, -s, 0,
                  s, c, 0,
                  0, 0, 1
              ],
              scaleMatrix = [
                  scale[0], 0, 0,
                  0, scale[1], 0,
                  0, 0, 1
              ];
        const matMultiply = utils.mat3Multiply(utils.mat3Multiply(translationMatrix, rotationMatrix), scaleMatrix);
        for (let i = 0; i < renderLayerData.length; i++) {
            renderLayerData[i][0] = utils.mat3MultiplyPosCoords(matMultiply, renderLayerData[i][0]);
        }*/
        //console.log("mat1: ", matMult1);
        //console.log("mat2: ", matMult2);
        /*
        const x1y1 = utils.mat3MultiplyVector(matMultiply, [vecX1, vecY1, 1]),
              x2y1 = utils.mat3MultiplyVector(matMultiply, [vecX2, vecY1, 1]),
              x1y2 = utils.mat3MultiplyVector(matMultiply, [vecX1, vecY2, 1]),
              x2y2 = utils.mat3MultiplyVector(matMultiply, [vecX2, vecY2, 1]);
        */
        const nextObject = this.getNextRenderObject(renderLayer, pageData);
              
        if (this._canMergeNextTileObject(renderLayer, nextObject)) {
            if (this.#currentVertices === null) {
                this.#currentVertices = renderLayerData[0][0];
                this.#currentTextures = renderLayerData[0][1];
                return Promise.resolve(0);
            } else {
                this.#currentVertices.push(...renderLayerData[0][0]);
                this.#currentTextures.push(...renderLayerData[0][1]);
                return Promise.resolve(0);
            }
        } else {
            let verticesNumber = 0,
                isTextureBind = false,
                renderLayerDataLen = renderLayerData.length;
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.enableVertexAttribArray(texCoordLocation);

            // set the resolution
            gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
            //gl.uniform2f(translationLocation,translation[0], translation[1]);
            //gl.uniform2f(scaleLocation, scale[0], scale[1]);
            //gl.uniform1f(rotationRotation, rotation);

            // MULTIPLE_IMAGE_TILESET drawing, no merging possible
            if (renderLayerDataLen > 1) {
                for (let i = 0; i < renderLayerDataLen; i++) {
                    const data = renderLayerData[i],
                        vectors = data[0],
                        textures = data[1],
                        image_name = data[2],
                        image = data[3];
                    // if layer use multiple tilesets
                    // the issue is: when we add some layer data to the temp arrays, and then
                    // process empty layer, it actually skips the draw with this check
                    if (vectors.length > 0 && textures.length > 0) {
                        // need to have additional draw call for each new texture added
                        // probably it could be combined in one draw call if multiple textures 
                        // could be used in one draw call
                        if (isTextureBind) {
                            await this._render(verticesNumber, gl.TRIANGLES);
                        }
                        
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vectors), gl.STATIC_DRAW);
    
                        //Tell the attribute how to get data out of positionBuffer
                        const size = 2,
                            type = gl.FLOAT, // data is 32bit floats
                            normalize = false,
                            stride = 0, // move forward size * sizeof(type) each iteration to get next position
                            offset = 0;  // verticesNumber * 4; // start of beginning of the buffer
                        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);
    
                        //textures buffer
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.#texCoordBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textures), gl.STATIC_DRAW);
    
                        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, offset);
    
                        let textureStorage = renderLayer._textureStorages[i];
                        
                        if (!textureStorage) {
                            textureStorage = new _Temp_ImageTempStorage_js__WEBPACK_IMPORTED_MODULE_4__.ImageTempStorage(gl.createTexture(), i);
                            renderLayer._setTextureStorage(i, textureStorage);
                        }
                        if (textureStorage._isTextureRecalculated === true) {
                            this.#updateWebGlTexture(gl, textureStorage._texture, image, textureStorage._textureIndex);
                            textureStorage._isTextureRecalculated = false;
                        } else {
                            //console.log("bind texture");
                            this.#bindTexture(gl, textureStorage._texture, textureStorage._textureIndex);
                        }
                        gl.uniform1i(u_imageLocation, textureStorage._textureIndex);
                        gl.blendFunc(gl[drawMask[0]], gl[drawMask[1]]);
                        
                        verticesNumber = vectors.length / 2;
                        if (shapeMaskId) {
                            gl.stencilFunc(gl.EQUAL, shapeMaskId, 0xFF);
                        }
                        isTextureBind = true;
                    }
                }
            // Single image tileset draw, with merging
            } else {
                const data = renderLayerData[0],
                    vectors = data[0],
                    textures = data[1],
                    image_name = data[2],
                    image = data[3];
                // if layer use multiple tilesets
                // the issue is: when we add some layer data to the temp arrays, and then
                // process empty layer, it actually skips the draw with this check
                if (this.#currentVertices === null) {
                    this.#currentVertices = vectors;
                    this.#currentTextures = textures;
                } else {
                    this.#currentVertices.push(...vectors);
                    this.#currentTextures.push(...textures);
                }
                
                gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.#currentVertices), gl.STATIC_DRAW);

                //Tell the attribute how to get data out of positionBuffer
                const size = 2,
                    type = gl.FLOAT, // data is 32bit floats
                    normalize = false,
                    stride = 0, // move forward size * sizeof(type) each iteration to get next position
                    offset = 0;  // verticesNumber * 4; // start of beginning of the buffer
                gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

                //textures buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, this.#texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.#currentTextures), gl.STATIC_DRAW);

                gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, offset);

                let textureStorage = renderLayer._textureStorages[0];
                
                if (!textureStorage) {
                    textureStorage = new _Temp_ImageTempStorage_js__WEBPACK_IMPORTED_MODULE_4__.ImageTempStorage(gl.createTexture(), 0);
                    renderLayer._setTextureStorage(0, textureStorage);
                }
                if (textureStorage._isTextureRecalculated === true) {
                    this.#updateWebGlTexture(gl, textureStorage._texture, image, textureStorage._textureIndex);
                    textureStorage._isTextureRecalculated = false;
                } else {
                    //console.log("bind texture");
                    this.#bindTexture(gl, textureStorage._texture, textureStorage._textureIndex);
                }
                gl.uniform1i(u_imageLocation, textureStorage._textureIndex);
                gl.blendFunc(gl[drawMask[0]], gl[drawMask[1]]);
                
                verticesNumber = this.#currentVertices.length / 2;
                if (shapeMaskId) {
                    gl.stencilFunc(gl.EQUAL, shapeMaskId, 0xFF);
                }
                this.#currentVertices = null;
                this.#currentTextures = null;
            }
            
            renderLayerData = null;
            return this._render(verticesNumber, gl.TRIANGLES);
        }
    };

    _drawPolygon(renderObject, pageData) {
        const [ xOffset, yOffset ] = renderObject.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset,
            x = renderObject.x - xOffset,
            y = renderObject.y - yOffset,
            rotation = renderObject.rotation || 0,
            vertices = renderObject.vertices,
            color =  this.#gameOptions.debug.boundaries.boundariesColor;
        const program = this.getProgram(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES);
        const { u_translation: translationLocation,
                u_rotation: rotationRotation,
                u_scale: scaleLocation,
                u_resolution: resolutionUniformLocation,
                u_color: colorUniformLocation,
                a_position: positionAttributeLocation,
                u_fade_max: fadeMaxLocation,
                u_fade_min: fadeMinLocation
            } = this.getProgramVarLocations(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES),
            gl = this.#gl;

        let verticesNumber = 0;
        gl.useProgram(program);
        // set the resolution
        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);

        gl.uniform2f(translationLocation, x, y);
        gl.uniform2f(scaleLocation, 1, 1);
        gl.uniform1f(rotationRotation, rotation);
        gl.uniform1f(fadeMinLocation, 0);

        gl.enableVertexAttribArray(positionAttributeLocation);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);

        const triangles = this.#triangulatePolygon(vertices);

        const polygonVerticesNum = triangles.length;
        if (polygonVerticesNum % 3 !== 0) {
            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.POLYGON_VERTICES_NOT_CORRECT, "polygon boundaries vertices are not correct, skip drawing");
            return;
        }
        this.#bindPolygon(triangles);
        verticesNumber += polygonVerticesNum / 2;
        //Tell the attribute how to get data out of positionBuffer
        const size = 2,
            type = gl.FLOAT, // data is 32bit floats
            normalize = false,
            stride = 0, // move forward size * sizeof(type) each iteration to get next position
            offset = 0; // start of beginning of the buffer
        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

        const colorArray = this.#rgbaToArray(color);
        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);

        this._render(verticesNumber, gl.TRIANGLES);
    }

    _bindLine = (renderObject, gl, pageData, program, vars) => {
        const [ xOffset, yOffset ] = renderObject.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset,
            x = renderObject.x - xOffset,
            y = renderObject.y - yOffset,
            scale = [1, 1],
            rotation = renderObject.rotation,
            { 
                u_translation: translationLocation,
                u_rotation: rotationRotation,
                u_scale: scaleLocation,
                u_resolution: resolutionUniformLocation,
                u_color: colorUniformLocation,
                a_position: positionAttributeLocation,
                u_fade_max: fadeMaxLocation,
                u_fade_min: fadeMinLocation
            } = vars,
            coords = renderObject.vertices,
            fillStyle = renderObject.bgColor,
            fade_min = renderObject.fade_min,
            fadeLen = renderObject.radius,
            lineWidth = this.#gameOptions.debug.boundaries.boundariesWidth;
        let verticesNumber = 0;

        gl.useProgram(program);
        // set the resolution
        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);

        gl.uniform2f(translationLocation, x, y);
        gl.uniform2f(scaleLocation, 1, 1);
        gl.uniform1f(rotationRotation, rotation);
        gl.uniform1f(fadeMinLocation, 0);

        gl.enableVertexAttribArray(positionAttributeLocation);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);

        gl.bufferData(
            gl.ARRAY_BUFFER, 
            new Float32Array(coords),
            gl.STATIC_DRAW);

        verticesNumber += coords.length / 2;
        //Tell the attribute how to get data out of positionBuffer
        const size = 2,
            type = gl.FLOAT, // data is 32bit floats
            normalize = false,
            stride = 0, // move forward size * sizeof(type) each iteration to get next position
            offset = 0; // start of beginning of the buffer
        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

        const colorArray = this.#rgbaToArray(fillStyle);
        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);
        
        gl.lineWidth(lineWidth);

        return this._render(0, gl.LINES);
    };
    
    _drawLines(linesArray, color, lineWidth = 1, rotation = 0, translation = [0, 0]) {
        const program = this.getProgram(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES);
        const { u_translation: translationLocation,
                u_rotation: rotationRotation,
                u_scale: scaleLocation,
                u_resolution: resolutionUniformLocation,
                u_color: colorUniformLocation,
                a_position: positionAttributeLocation,
                u_fade_max: fadeMaxLocation,
                u_fade_min: fadeMinLocation
            } = this.getProgramVarLocations(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES),
            gl = this.#gl;

        let verticesNumber = 0;
        gl.useProgram(program);
        // set the resolution
        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);

        gl.uniform2f(translationLocation, translation[0], translation[1]);
        gl.uniform2f(scaleLocation, 1, 1);
        gl.uniform1f(rotationRotation, rotation);
        gl.uniform1f(fadeMinLocation, 0);

        gl.enableVertexAttribArray(positionAttributeLocation);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);

        gl.bufferData(
            gl.ARRAY_BUFFER, 
            (linesArray instanceof Float32Array ? linesArray : new Float32Array(linesArray)),
            gl.STATIC_DRAW);

        verticesNumber += linesArray.length / 2;
        //Tell the attribute how to get data out of positionBuffer
        const size = 2,
            type = gl.FLOAT, // data is 32bit floats
            normalize = false,
            stride = 0, // move forward size * sizeof(type) each iteration to get next position
            offset = 0; // start of beginning of the buffer
        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

        const colorArray = this.#rgbaToArray(color);
        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);
        
        gl.lineWidth(lineWidth);
        
        this._render(verticesNumber, gl.LINES);
    }

    /**
     * @ignore
     * @param {string} objectType - object name registered to DrawObjectFactory | object type registered to DrawObjectFactory
     * @param {function(renderObject, gl, pageData, program, vars):Promise<any>} objectRenderMethod - should be promise based returns vertices number and draw program
     * @param {string=} objectWebGlDrawProgram 
     */
    _registerObjectRender(objectType, objectRenderMethod, objectWebGlDrawProgram) {
        this.#registeredRenderObjects.set(objectType, {method: objectRenderMethod, webglProgramName: objectWebGlDrawProgram});
    }

    _drawRenderObject(renderObject, pageData) {
        const name = renderObject.constructor.name,
            registeredRenderObject = this.#registeredRenderObjects.get(name) || this.#registeredRenderObjects.get(renderObject.type);
        if (registeredRenderObject) {
            const name = registeredRenderObject.webglProgramName,
                program = name ? this.getProgram(name) : null,
                vars = name ? this.getProgramVarLocations(name) : null;

            return registeredRenderObject.method(renderObject, this.#gl, pageData, program, vars);
        } else {
            console.warn("no registered draw object method for " + name + " skip draw");
            return Promise.resolve();
        }
    }
    /**
     * 
     * @param {DrawTiledLayer} renderLayer 
     * @param {GameStageData} pageData
     * @returns {Promise<Array<Array>>}
     */
    #prepareRenderLayer(renderLayer, pageData) {
        const INDEX_TOP_LINE = 0,
            INDEX_RIGHT_LINE = 1,
            INDEX_BOTTOM_LINE = 2,
            INDEX_LEFT_LINE = 3;

        const INDEX_X1 = 0,
            INDEX_Y1 = 1,
            INDEX_X2 = 2,
            INDEX_Y2 = 3;
        return new Promise((resolve, reject) => {
            const tilemap = renderLayer.tilemap,
                tilesets = renderLayer.tilesets,
                tilesetImages = renderLayer.tilesetImages,
                layerData = renderLayer.layerData,
                { tileheight:dtheight, tilewidth:dtwidth } = tilemap,
                tilewidth = dtwidth,
                tileheight = dtheight,
                [ canvasW, canvasH ] = pageData.canvasDimensions,
                [ xOffset, yOffset ] = renderLayer.isOffsetTurnedOff === true ? [0, 0] : pageData.worldOffset,
                boundariesCalculations = this.#gameOptions.render.boundaries.realtimeCalculations,
                setBoundaries = renderLayer.setBoundaries,
                tileImagesData = [];

            if (!layerData) {
                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.NOT_FOUND, "check tilemap and layers name");
                reject();
            }

            if (this.#gameOptions.render.boundaries.mapBoundariesEnabled) {
                pageData._setMapBoundaries();
            }
            
            for (let i = 0; i < tilesets.length; i++) {
                
                const tilesetData = tilesets[i],
                    firstgid = tilesets[i].firstgid,
                    nextTileset = tilesets[i + 1],
                    nextgid = nextTileset ? nextTileset.firstgid : 1_000_000_000, // a workaround to avoid multiple conditions
                    tilesetwidth = tilesetData.tilewidth,
                    tilesetheight = tilesetData.tileheight,
                    tileoffsetX = tilesetData.tileoffset ? tilesetData.tileoffset.x : 0,
                    tileoffsetY = tilesetData.tileoffset ? tilesetData.tileoffset.y : 0,
                    atlasImage = tilesetImages[i],
                    //atlasWidth = atlasImage.width,
                    //atlasHeight = atlasImage.height,
                    atlasWidth = tilesetData.imagewidth,
                    atlasHeight = tilesetData.imageheight,
                    //atlasRows = atlasHeight / tileheight,
                    atlasColumns = tilesetData.columns,
                    layerCols = layerData.width,
                    layerRows = layerData.height,
                    worldW = tilewidth * layerCols,
                    worldH = tileheight * layerRows,
                    moduloTop = yOffset % tileheight,
                    moduleLeft = xOffset % tilewidth,
                    skipRowsTop = yOffset !== 0 ? Math.floor(yOffset / tileheight) : 0,
                    skipColsLeft = xOffset !== 0 ? Math.floor(xOffset / tilewidth) : 0,
                    // sometimes canvasW/H may be bigger than world itself
                    screenRows = worldH > canvasH ? Math.ceil(canvasH / tileheight) + 1 : layerRows,
                    screenCols = worldW > canvasW ? Math.ceil(canvasW / tilewidth) + 1 : layerCols,
                    screenCells = screenRows * screenCols,
                    skipColsRight = layerCols - screenCols - skipColsLeft,
                    cellSpacing = typeof tilesetData.spacing === "number" ? tilesetData.spacing : 0,
                    cellMargin = typeof tilesetData.margin === "number" ? tilesetData.margin : 0,
                    hasAnimations = tilesetData._hasAnimations;
                    //console.log("non empty: ", layerData.nonEmptyCells);
                    // additional property which is set in DrawTiledLayer
                const hasBoundaries = tilesetData._hasBoundaries,
                    tilesetBoundaries = tilesetData._boundaries,
                    layerTilesetData = tilesets[i]._temp;

                if (layerTilesetData.cells !== screenCells) {
                    layerTilesetData._initiateStorageData(screenCells);
                }
                let v = layerTilesetData.vectors,
                    t = layerTilesetData.textures,
                    filledSize = 0;
                    
                //v.fill(0);
                //t.fill(0);
                v = [];
                t = [];
                let boundariesRowsIndexes = layerTilesetData._bTempIndexes;
                const fullRowCellsNum = screenCols * 4;
                
                let mapIndex = skipRowsTop * layerCols;
                for (let row = 0; row < screenRows; row++) {
                    mapIndex += skipColsLeft;
                    for (let col = 0; col < screenCols; col++) {
                        let tile = layerData.data[mapIndex];

                        if ((tile >= firstgid) && (tile < nextgid)) {
                            const mapPosX = col * dtwidth - moduleLeft + tileoffsetX,
                                // this fix is used to draw items with height different that the actual tilecell height
                                posYFix = tilesetheight - dtheight,
                                mapPosY = row * dtheight - posYFix - moduloTop + tileoffsetY;

                            // actual tile index
                            tile -= firstgid;
                            // switch if animations are set
                            if (hasAnimations) {
                                const activeTile = tilesetData._animations.get(tile);
                                if (typeof activeTile !== "undefined") {
                                    tile = activeTile;
                                }   
                            }

                            // calculate map position and atlas position
                            const colNum = tile % atlasColumns,
                                rowNum = Math.floor(tile / atlasColumns),
                                atlasPosX = colNum * tilesetwidth + (colNum * cellSpacing) + cellMargin,
                                atlasPosY = rowNum * tilesetheight + (rowNum * cellSpacing) + cellMargin,
                                vecX1 = mapPosX,
                                vecY1 = mapPosY,
                                vecX2 = mapPosX + tilesetwidth,
                                vecY2 = mapPosY + tilesetheight,
                                texX1 = (1 / atlasWidth) * atlasPosX,
                                texY1 = (1 / atlasHeight) * atlasPosY,
                                texX2 = texX1 + (1 / atlasWidth * tilesetwidth),
                                texY2 = texY1 + (1 / atlasHeight * tilesetheight);

                            // 0 vecX1
                            v[filledSize] = vecX1;
                            t[filledSize] = texX1;

                            // 1 vecY1
                            filledSize++;
                            v[filledSize] = vecY1;
                            t[filledSize] = texY1;
                            
                            // 2 vecX2
                            filledSize++;
                            v[filledSize] = vecX2;
                            t[filledSize] = texX2;

                            // 3 vecY1
                            filledSize++;
                            v[filledSize] = vecY1;
                            t[filledSize] = texY1;

                            // 4 vecX1
                            filledSize++;
                            v[filledSize] = vecX1;
                            t[filledSize] = texX1;

                            // 5 vecY2
                            filledSize++;
                            v[filledSize] = vecY2;
                            t[filledSize] = texY2;

                            // 6 vecX1
                            filledSize++;
                            v[filledSize] = vecX1;
                            t[filledSize] = texX1;

                            // 7 vecY2
                            filledSize++;
                            v[filledSize] = vecY2;
                            t[filledSize] = texY2;

                            // 8 vecX2
                            filledSize++;
                            v[filledSize] = vecX2;
                            t[filledSize] = texX2;

                            // 9 vecY1
                            filledSize++;
                            v[filledSize] = vecY1;
                            t[filledSize] = texY1;

                            // 10 vecX2, 
                            filledSize++;
                            v[filledSize] = vecX2;
                            t[filledSize] = texX2;

                            // 11 vecY2
                            filledSize++;
                            v[filledSize] = vecY2;
                            t[filledSize] = texY2;

                            filledSize++;
                        
                            if (setBoundaries) {
                                // if boundary is set in tilesetData
                                let isBoundaryPreset = false;
                                if (hasBoundaries && tilesetBoundaries.size > 0) {
                                    const tilesetBoundary = tilesetBoundaries.get(tile);
                                    if (tilesetBoundary) {
                                        isBoundaryPreset = true;
                                        const objectGroup = tilesetBoundary,
                                            objects = objectGroup.objects;
                                            
                                        objects.forEach((object) => {
                                            const baseX = mapPosX + object.x, 
                                                baseY = mapPosY + object.y,
                                                rotation = object.rotation;
                                            if (rotation !== 0) {
                                                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)("tilesetData.tiles.rotation property is not supported yet");
                                            }
                                            if (object.polygon) {
                                                object.polygon.forEach(
                                                    (point, idx) => {
                                                        const next = object.polygon[idx + 1];
                                                        if (next) {
                                                            pageData._addBoundaryLine(point.x + baseX, point.y + baseY, next.x + baseX, next.y + baseY);
                                                        } else {
                                                            // last point -> link to the first
                                                            const first = object.polygon[0];
                                                            pageData._addBoundaryLine(point.x + baseX, point.y + baseY, first.x + baseX, first.y + baseY);
                                                        }
                                                    });
                                            } else if (object.point) {
                                                // x/y coordinate
                                                pageData._addPointBoundary(baseX, baseY);
                                            } else if (object.ellipse) {
                                                const radX = object.width / 2,
                                                    radY = object.height / 2;
                                                    
                                                pageData._addEllipseBoundary(baseX + radX, baseY + radY, radX, radY);
                                            } else {
                                                // object is rect
                                                const width = object.width,
                                                    height = object.height,
                                                    x2 = width + baseX,
                                                    y2 = height + baseY;

                                                //boundaries.push([baseX, baseY, x2, baseY]);
                                                pageData._addBoundaryLine(baseX, baseY, x2, baseY);

                                                //boundaries.push([x2, baseY, x2, y2]);
                                                pageData._addBoundaryLine(x2, baseY, x2, y2);

                                                //boundaries.push([x2, y2, baseX, y2]);
                                                pageData._addBoundaryLine(x2, y2, baseX, y2);

                                                //boundaries.push([baseX, y2, baseX, baseY]);
                                                pageData._addBoundaryLine(baseX, y2, baseX, baseY);
                                            }
                                        });
                                    }

                                // extract rect boundary for the whole tile
                                }
                                if (isBoundaryPreset === false) {
                                    const boundaries = pageData.getRawBoundaries();

                                    let rightLine = [ mapPosX + tilesetwidth, mapPosY, mapPosX + tilesetwidth, mapPosY + tilesetheight ],
                                        bottomLine = [ mapPosX + tilesetwidth, mapPosY + tilesetheight, mapPosX, mapPosY + tilesetheight ],
                                        topLine = [ mapPosX, mapPosY, mapPosX + tilesetwidth, mapPosY],
                                        leftLine = [ mapPosX, mapPosY + tilesetheight, mapPosX, mapPosY ];
                                    
                                    // top cell7
                                    if (row !== 0) {
                                        const topCellFirstIndex =  (row - 1) * fullRowCellsNum + (col * 4),
                                            bottomTopLeftFirstIndex = boundariesRowsIndexes[topCellFirstIndex + INDEX_BOTTOM_LINE];
                                        if (bottomTopLeftFirstIndex) {
                                            //remove double lines from top
                                            const bottomTopCellX1 = boundaries[bottomTopLeftFirstIndex];
                                            if (bottomTopCellX1) {
                                                const bottomTopCellY1 = boundaries[bottomTopLeftFirstIndex + INDEX_Y1],
                                                    bottomTopCellX2 = boundaries[bottomTopLeftFirstIndex + INDEX_X2],
                                                    bottomTopCellY2 = boundaries[bottomTopLeftFirstIndex + INDEX_Y2],
                                                    topX1 = topLine[INDEX_X1],
                                                    topY1 = topLine[INDEX_Y1],
                                                    topX2 = topLine[INDEX_X2],
                                                    topY2 = topLine[INDEX_Y2];
                                                
                                                if (topX1 === bottomTopCellX2 && topY1 === bottomTopCellY2 &&
                                                    topX2 === bottomTopCellX1 && topY2 === bottomTopCellY1) {
                                                    pageData._removeBoundaryLine(bottomTopLeftFirstIndex);
                                                    topLine = undefined;
                                                }
                                            }

                                            // merge line from top right
                                            const rightTopRightFirstIndex = boundariesRowsIndexes[ topCellFirstIndex + INDEX_RIGHT_LINE],
                                                rightTopCellX1 = boundaries[rightTopRightFirstIndex];
                                            if (rightTopCellX1) {
                                                const rightTopCellY1 = boundaries[rightTopRightFirstIndex + INDEX_Y1],
                                                    rightTopCellX2 = boundaries[rightTopRightFirstIndex + INDEX_X2],
                                                    rightX1 = boundaries[rightTopRightFirstIndex + INDEX_X1],
                                                    rightX2 = boundaries[rightTopRightFirstIndex + INDEX_X2];
                                                if (rightTopCellX1 === rightX2 && rightTopCellX2 === rightX1) {
                                                    pageData._removeBoundaryLine(rightTopRightFirstIndex);
                                                    rightLine[INDEX_X1] = rightTopCellX1;
                                                    rightLine[INDEX_Y1] = rightTopCellY1;
                                                }
                                            }
                                            // merge line from top left
                                            const leftTopRightFirstIndex =  boundariesRowsIndexes[topCellFirstIndex + INDEX_LEFT_LINE],
                                                leftTopCellX1 = boundaries[leftTopRightFirstIndex];
                                            if (leftTopCellX1) {
                                                const leftTopCellX2 = boundaries[leftTopRightFirstIndex + INDEX_X2],
                                                    leftTopCellY2 = boundaries[leftTopRightFirstIndex + INDEX_Y2],
                                                    leftX1 = leftLine[INDEX_X1],
                                                    leftX2 = leftLine[INDEX_X2];
                                                if (leftTopCellX1 === leftX2 && leftTopCellX2 === leftX1) {
                                                    pageData._removeBoundaryLine(leftTopRightFirstIndex);
                                                    leftLine[INDEX_X2] = leftTopCellX2;
                                                    leftLine[INDEX_Y2] = leftTopCellY2;
                                                }
                                            }
                                        }
                                    }
                                    // leftCell
                                    if (col !== 0) {
                                        
                                        const leftCell = row * fullRowCellsNum + ((col - 1) * 4),
                                            topLeftFirstCellIndex = boundariesRowsIndexes[leftCell];
                                        if (topLeftFirstCellIndex) {

                                            //remove double lines from left
                                            const rightLeftCellIndex = boundariesRowsIndexes[leftCell + INDEX_RIGHT_LINE],
                                                rightLeftX1 = boundaries[rightLeftCellIndex],
                                                rightLeftCellX1 = rightLeftX1,
                                                rightLeftCellY1 = boundaries[rightLeftCellIndex + INDEX_Y1],
                                                rightLeftCellX2 = boundaries[rightLeftCellIndex + INDEX_X2],
                                                rightLeftCellY2 = boundaries[rightLeftCellIndex + INDEX_Y2],
                                                leftX1 = leftLine[INDEX_X1],
                                                leftY1 = leftLine[INDEX_Y1],
                                                leftX2 = leftLine[INDEX_X2],
                                                leftY2 = leftLine[INDEX_Y2];

                                            if (leftX1 === rightLeftCellX2 && leftY1 === rightLeftCellY2 &&
                                                leftX2 === rightLeftCellX1 && leftY2 === rightLeftCellY1) {
                                                pageData._removeBoundaryLine(rightLeftCellIndex);
                                                leftLine = undefined;
                                            }

                                            //merge long lines from left top
                                            const topLeftCellX1 = boundaries[topLeftFirstCellIndex];
                                            if (topLeftCellX1 && topLine) {
                                                const topLeftCellY1 = boundaries[topLeftFirstCellIndex + INDEX_Y1],
                                                    topLeftCellY2 = boundaries[topLeftFirstCellIndex + INDEX_Y2],
                                                    topY1 = topLine[INDEX_Y1],
                                                    topY2 = topLine[INDEX_Y2];
                                                if (topLeftCellY1 === topY2 && topLeftCellY2 === topY1 ) {
                                                    pageData._removeBoundaryLine(topLeftFirstCellIndex);
                                                    topLine[INDEX_X1] = topLeftCellX1;
                                                    topLine[INDEX_Y1] = topLeftCellY1;
                                                }
                                            }

                                            // merge long lines from left bottom
                                            const bottomLeftFirstCellIndex = boundariesRowsIndexes[leftCell + INDEX_BOTTOM_LINE],
                                                bottomLeftCellX1 = boundaries[bottomLeftFirstCellIndex];
                                            if (bottomLeftCellX1) {
                                                const bottomLeftCellY1 = boundaries[bottomLeftFirstCellIndex + INDEX_Y1],
                                                    bottomLeftCellX2 = boundaries[bottomLeftFirstCellIndex + INDEX_X2],
                                                    bottomLeftCellY2 = boundaries[bottomLeftFirstCellIndex + INDEX_Y2],
                                                    bottomY1 = bottomLine[INDEX_Y1],
                                                    bottomY2 = bottomLine[INDEX_Y2];
                                                if (bottomLeftCellY1 === bottomY2 && bottomLeftCellY2 === bottomY1 ) {
                                                    pageData._removeBoundaryLine(bottomLeftFirstCellIndex);
                                                    //opposite direction
                                                    bottomLine[INDEX_X2] = bottomLeftCellX2;
                                                    bottomLine[INDEX_Y2] = bottomLeftCellY2;
                                                }
                                            }

                                        }
                                    }
                                    const currentCellIndex = row * fullRowCellsNum + (col * 4);
                                    if (topLine) {
                                        pageData._addBoundaryLine(topLine[0], topLine[1], topLine[2], topLine[3]);
                                        boundariesRowsIndexes[currentCellIndex + INDEX_TOP_LINE] = pageData.boundariesLen - 4;
                                    }
                                    pageData._addBoundaryLine(rightLine[0], rightLine[1], rightLine[2], rightLine[3]);
                                    boundariesRowsIndexes[currentCellIndex + INDEX_RIGHT_LINE] = pageData.boundariesLen - 4;
                                    pageData._addBoundaryLine(bottomLine[0], bottomLine[1], bottomLine[2], bottomLine[3]);
                                    boundariesRowsIndexes[currentCellIndex + INDEX_BOTTOM_LINE] = pageData.boundariesLen - 4;
                                    if (leftLine) {
                                        pageData._addBoundaryLine(leftLine[0], leftLine[1], leftLine[2], leftLine[3]);
                                        boundariesRowsIndexes[currentCellIndex + INDEX_LEFT_LINE] = pageData.boundariesLen - 4;
                                    }
                                    
                                }
                            }
                        }
                        mapIndex++;
                    }
                    mapIndex += skipColsRight;
                }
                //console.log(boundariesRowsIndexes);
                //this.#bindTileImages(verticesBufferData, texturesBufferData, atlasImage, tilesetData.name, renderLayer._maskId);
                tileImagesData.push([v, t, tilesetData.name, atlasImage]);
                //cleanup
                boundariesRowsIndexes.fill(0);
            }
            
            resolve(tileImagesData);
        });
    }

    #prepareRenderLayerOld(renderLayer, pageData) {
        return new Promise((resolve, reject) => {
            const tilemap = renderLayer.tilemap,
                tilesets = renderLayer.tilesets,
                tilesetImages = renderLayer.tilesetImages,
                layerData = renderLayer.layerData,
                { tileheight:dtheight, tilewidth:dtwidth } = tilemap,
                [ xOffset, yOffset ] = renderLayer.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset;
            
            let tileImagesData = [];
            if (!layerData) {
                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.NOT_FOUND, "check tilemap and layers name");
                reject();
            }

            if (this.#gameOptions.render.boundaries.mapBoundariesEnabled) {
                pageData._setMapBoundaries();
            }

            for (let i = 0; i <= tilesets.length - 1; i++) {
                const tilesetData = tilesets[i],
                    firstgid = tilesets[i].firstgid,
                    nextTileset = tilesets[i + 1],
                    nextgid = nextTileset ? nextTileset.firstgid : 1_000_000_000, // a workaround to avoid multiple conditions
                    //tilesetImages = this.iLoader.getTilesetImageArray(tilesetData.name),
                    tilesetwidth = tilesetData.tilewidth,
                    tilesetheight = tilesetData.tileheight,
                    //atlasRows = tilesetData.imageheight / tileheight,
                    //atlasColumns = tilesetData.imagewidth / tilewidth,
                    atlasColumns = tilesetData.columns,
                    layerCols = layerData.width,
                    layerRows = layerData.height,
                    atlasImage = tilesetImages[i],
                    atlasWidth = tilesetData.imagewidth,
                    atlasHeight = tilesetData.imageheight,
                    cellSpacing = typeof tilesetData.spacing === "number" ? tilesetData.spacing : 0,
                    cellMargin = typeof tilesetData.margin === "number" ? tilesetData.margin : 0,
                    layerTilesetData = tilesets[i]._temp;
                
                let mapIndex = 0,
                    v = layerTilesetData.vectors,
                    t = layerTilesetData.textures,
                    filledSize = 0;
                
                //v.fill(0);
                //t.fill(0);
                v = [];
                t = [];
                for (let row = 0; row < layerRows; row++) {
                    for (let col = 0; col < layerCols; col++) {
                        let tile = layerData.data[mapIndex];
                        
                        if (tile >= firstgid && (tile < nextgid)) {

                            tile -= firstgid;
                            const colNum = tile % atlasColumns,
                                rowNum = Math.floor(tile / atlasColumns),
                                atlasPosX = colNum * tilesetwidth + (colNum * cellSpacing) + cellMargin,
                                atlasPosY = rowNum * tilesetheight + (rowNum * cellSpacing) + cellMargin,
                                vecX1 = col * dtwidth - xOffset,
                                vecY1 = row * dtheight - yOffset,
                                vecX2 = vecX1 + tilesetwidth,
                                vecY2 = vecY1 + tilesetheight,
                                texX1 = 1 / atlasWidth * atlasPosX,
                                texY1 = 1 / atlasHeight * atlasPosY,
                                texX2 = texX1 + (1 / atlasWidth * tilesetwidth),
                                texY2 = texY1 + (1 / atlasHeight * tilesetheight);
                             
                            // 0 vecX1
                            v[filledSize] = vecX1;
                            t[filledSize] = texX1;

                            // 1 vecY1
                            filledSize++;
                            v[filledSize] = vecY1;
                            t[filledSize] = texY1;
                            
                            // 2 vecX2
                            filledSize++;
                            v[filledSize] = vecX2;
                            t[filledSize] = texX2;

                            // 3 vecY1
                            filledSize++;
                            v[filledSize] = vecY1;
                            t[filledSize] = texY1;

                            // 4 vecX1
                            filledSize++;
                            v[filledSize] = vecX1;
                            t[filledSize] = texX1;

                            // 5 vecY2
                            filledSize++;
                            v[filledSize] = vecY2;
                            t[filledSize] = texY2;

                            // 6 vecX1
                            filledSize++;
                            v[filledSize] = vecX1;
                            t[filledSize] = texX1;

                            // 7 vecY2
                            filledSize++;
                            v[filledSize] = vecY2;
                            t[filledSize] = texY2;

                            // 8 vecX2
                            filledSize++;
                            v[filledSize] = vecX2;
                            t[filledSize] = texX2;

                            // 9 vecY1
                            filledSize++;
                            v[filledSize] = vecY1;
                            t[filledSize] = texY1;

                            // 10 vecX2, 
                            filledSize++;
                            v[filledSize] = vecX2;
                            t[filledSize] = texX2;

                            // 11 vecY2
                            filledSize++;
                            v[filledSize] = vecY2;
                            t[filledSize] = texY2;

                            filledSize++;
                            
                        }
                        mapIndex++;
                    }
                }
                tileImagesData.push([v, t, tilesetData.name, atlasImage]);
            }
            resolve(tileImagesData);
        });
    }

    /**
     * 
     * @param {DrawTiledLayer} renderLayer 
     * @param {GameStageData} pageData
     * @returns {Promise<Array<any>}
     */
    #prepareRenderLayerWM = (renderLayer, pageData) => {
        return new Promise((resolve, reject) => {
            const tilemap = renderLayer.tilemap,
                tilesets = renderLayer.tilesets,
                tilesetImages = renderLayer.tilesetImages,
                layerData = renderLayer.layerData,
                { tileheight:dtheight, tilewidth:dtwidth } = tilemap,
                tilewidth = dtwidth,
                tileheight = dtheight,
                offsetDataItemsFullNum = layerData.data.length,
                offsetDataItemsFilteredNum = layerData.data.filter((item) => item !== 0).length,
                setBoundaries = false, //renderLayer.setBoundaries,
                [ settingsWorldWidth, settingsWorldHeight ] = pageData.worldDimensions,
                //[ canvasW, canvasH ] = this.stageData.drawDimensions,
                [ xOffset, yOffset ] = renderLayer.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset;
            const tileImagesData = [];
            // clear data
            // this.layerDataFloat32.fill(0);
            // set data for webgl processing
            this.layerDataFloat32.set(layerData.data);
            if (!layerData) {
                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.NOT_FOUND, "check tilemap and layers name");
                reject();
            }

            if (this.#gameOptions.render.boundaries.mapBoundariesEnabled) {
                pageData._setMapBoundaries();
            }
            
            for (let i = 0; i < tilesets.length; i++) {
                const tilesetData = tilesets[i],
                    firstgid = tilesets[i].firstgid,
                    nextTileset = tilesets[i + 1],
                    nextgid = nextTileset ? nextTileset.firstgid : 1_000_000_000, // a workaround to avoid multiple conditions
                    //tilesetImages = this.iLoader.getTilesetImageArray(tilesetData.name),
                    tilesetwidth = tilesetData.tilewidth,
                    tilesetheight = tilesetData.tileheight,
                    //atlasRows = tilesetData.imageheight / tileheight,
                    atlasColumns = tilesetData.columns,
                    layerCols = layerData.width,
                    layerRows = layerData.height,
                    //visibleCols = Math.ceil(canvasW / tilewidth),
                    //visibleRows = Math.ceil(canvasH / tileheight),
                    //offsetCols = layerCols - visibleCols,
                    //offsetRows = layerRows - visibleRows,
                    worldW = tilewidth * layerCols,
                    worldH = tileheight * layerRows,
                    atlasImage = tilesetImages[i],
                    atlasWidth = tilesetData.imagewidth,
                    atlasHeight = tilesetData.imageheight,
                    items = layerRows * layerCols,
                    dataCellSizeBytes = 4,
                    vectorCoordsItemsNum = 12,
                    texturesCoordsItemsNum = 12,
                    vectorDataItemsNum = offsetDataItemsFilteredNum * vectorCoordsItemsNum,
                    texturesDataItemsNum = offsetDataItemsFilteredNum * texturesCoordsItemsNum,
                    cellSpacing = typeof tilesetData.spacing === "number" ? tilesetData.spacing : 0,
                    cellMargin = typeof tilesetData.margin === "number" ? tilesetData.margin : 0;
                
                const itemsProcessed = this.calculateBufferData(dataCellSizeBytes, offsetDataItemsFullNum, vectorDataItemsNum, layerRows, layerCols, dtwidth, dtheight, tilesetwidth, tilesetheight, atlasColumns, atlasWidth, atlasHeight, xOffset, yOffset, firstgid, nextgid, cellSpacing, setBoundaries);
                
                const verticesBufferData = itemsProcessed > 0 ? this.layerDataFloat32.slice(offsetDataItemsFullNum, vectorDataItemsNum + offsetDataItemsFullNum) : [],
                    texturesBufferData = itemsProcessed > 0 ? this.layerDataFloat32.slice(vectorDataItemsNum + offsetDataItemsFullNum, vectorDataItemsNum + texturesDataItemsNum + offsetDataItemsFullNum) : [];
                    
                tileImagesData.push([Array.from(verticesBufferData), Array.from(texturesBufferData), tilesetData.name, atlasImage]);
            }
            resolve(tileImagesData);
        });
    };

    /**
     * 
     * @param {string} rgbaColor 
     * @returns {number[]}
     */
    #rgbaToArray (rgbaColor) {
        return rgbaColor.replace("rgba(", "").replace(")", "").split(",").map((/** @param {string} */item) => Number(item.trim()));
    }

    #triangulatePolygon(vertices) {
        const triangulatedPolygon = new Float32Array(vertices.length * vertices.length),
            pointer = 0;
            
        const [triangulated, len] = this.#triangulate(vertices, triangulatedPolygon, pointer);
        
        const sliced = triangulated.slice(0, len);
        
        return sliced;
    }

    /**
     * 
     * @param {Array<Array<number>>} polygonVertices 
     * @param {Float32Array} triangulatedPolygon 
     * @returns {Array}
     */
    #triangulate (polygonVertices, triangulatedPolygon, pointer) {
        const len = polygonVertices.length,
            vectorsCS = (a, b, c) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.crossProduct)({x:c[0] - a[0], y: c[1] - a[1]}, {x:b[0] - a[0], y: b[1] - a[1]});

        if (len <= 3) {
            polygonVertices.forEach(vertex => {
                triangulatedPolygon[pointer] = vertex[0];
                pointer++;
                triangulatedPolygon[pointer] = vertex[1];
                pointer++;
            });
            return [triangulatedPolygon, pointer];
        }
        const verticesSortedByY = [...polygonVertices].sort((curr, next) => next[1] - curr[1]);
        const topVertexIndex = polygonVertices.indexOf(verticesSortedByY[0]),
            startVertexIndex = topVertexIndex !== len - 1 ? topVertexIndex + 1 : 0;
        
        let processedVertices = polygonVertices,
            processedVerticesLen = processedVertices.length,
            skipCount = 0,
            i = startVertexIndex;
        
        while(processedVertices.length > 2) {
            // if overflowed, start from beginning
            const currLen = processedVertices.length;
            if (i >= currLen) {
                i -= currLen;
            }
    
            const prevVertex = i === 0 ? processedVertices[currLen - 1] : processedVertices[i - 1],
                currentVertex = processedVertices[i],
                nextVertex = currLen === i + 1 ? processedVertices[0] : processedVertices[i + 1];
    
            
            const cs = vectorsCS(prevVertex, currentVertex, nextVertex);
    
            if (cs < 0) {
                triangulatedPolygon[pointer] = prevVertex[0];
                pointer++;
                triangulatedPolygon[pointer] = prevVertex[1];
                pointer++;
                triangulatedPolygon[pointer] = currentVertex[0];
                pointer++;
                triangulatedPolygon[pointer] = currentVertex[1];
                pointer++;
                triangulatedPolygon[pointer] = nextVertex[0];
                pointer++;
                triangulatedPolygon[pointer] = nextVertex[1];
                pointer++;
                processedVertices = processedVertices.filter((val, index) => index !== i);
            } else {
                skipCount += 1;
                if (skipCount > processedVerticesLen) {
                    // sometimes fails
                    (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.TRIANGULATE_ISSUE, "Can't extract all triangles vertices.");
                    return [triangulatedPolygon, pointer];
                }
                i++;
            }
            // if (cs < 0): it's jumping over next vertex, maybe not a good solution? Moving up
            // i++;
        }
        
        return [triangulatedPolygon, pointer];
    }

    #bindPolygon(vertices) {
        this.#gl.bufferData(
            this.#gl.ARRAY_BUFFER, 
            new Float32Array(vertices),
            this.#gl.STATIC_DRAW);
    }

    #setSingleRectangle(width, height) {
        const x1 = 0,
            x2 = 0 + width,
            y1 = 0,
            y2 = 0 + height;
        this.#gl.bufferData(this.#gl.ARRAY_BUFFER, 
            new Float32Array([
                x1, y1,
                x2, y1,
                x1, y2,
                x1, y2,
                x2, y1,
                x2, y2]), this.#gl.STATIC_DRAW);
    }
    /*------------------------------------
     * End of Predefined Drawing programs
     -------------------------------------*/

    /**-----------------------------------
     * Textures
     ------------------------------------*/
    #updateWebGlTexture(gl, texture, textureImage, textureNum = 0, useMipMaps = false) {
        this.#bindTexture(gl, texture, textureNum);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImage);
        // LINEAR filtering is better for images and tiles, but for texts it produces a small blur
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        // for textures not power of 2 (texts for example)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, useMipMaps ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
    }

    #updateTextWebGlTexture(gl, texture, textureImage, textureNum = 0) {
        this.#bindTexture(gl, texture, textureNum);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImage);
        // LINEAR filtering is better for images and tiles, but for texts it produces a small blur
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        // for textures not power of 2 (texts for example)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    }

    #bindTexture(gl, texture, textureNum = 0) {
        gl.activeTexture(gl.TEXTURE0 + textureNum);
        gl.bindTexture(gl.TEXTURE_2D, texture);
    }

    #removeTexture(gl, texture) {
        gl.deleteTexture(texture);
    }
    /*------------------------------------
     * End Textures
    --------------------------------------*/

    isPowerOfTwo(value) {
        return (value & (value - 1)) === 0;
    }

    nextHighestPowerOfTwo(x) {
        --x;
        for (var i = 1; i < 32; i <<= 1) {
            x = x | x >> i;
        }
        return x + 1;
    }

    getNextRenderObject = (renderObject, pageData) => {
        const objectIndex = pageData.renderObjects.indexOf(renderObject),
            nextObject = pageData.renderObjects[objectIndex + 1];
        return nextObject;
    }

    #glTextureIndex = (activeTexture) => {
        return activeTexture - 33984;
    }
}

/***/ }),

/***/ "./node_modules/jsge/src/configs.js":
/*!******************************************!*\
  !*** ./node_modules/jsge/src/configs.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SystemSettings: () => (/* binding */ SystemSettings)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./node_modules/jsge/src/constants.js");

/**
 * Settings object, should be passed as a parameter to System.constructor().
 */
class SystemSettings {
    /**
     * @hideconstructor
     */
    constructor(){}
    /**
     * DEBUG/PRODUCTION, for debug mode system Logger will show debug information in the console
     */
    static mode = _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.MODE.DEBUG;

    static gameOptions = {
        // no other variants only WEBGL for now
        library: _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.LIBRARY.WEBGL,
        optimization: _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.OPTIMIZATION.NATIVE_JS.OPTIMIZED,
        optimizationWASMUrl: "./src/wa/calculateBufferDataWat.wasm",
        optimizationAssemblyUrl: "/src/wa/calculateBufferDataAssembly.wasm",
        loadingScreen: {
            backgroundColor:  "rgba(128, 128, 128, 0.6)",
            loadingBarBg: "rgba(128, 128, 128, 1)",
            loadingBarProgress: "rgba(128, 128, 128, 0.2)",
        },
        render: {
            minCycleTime: 16.666, // is turned off from 1.5.3
            cyclesTimeCalc: {
                check: _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.OPTIMIZATION.CYCLE_TIME_CALC.AVERAGES,
                averageFPStime: 10000
            },
            boundaries: {
                mapBoundariesEnabled: true,
                realtimeCalculations: true,
                wholeWorldPrecalculations: false
            },
            
        },
        debug: {
            checkWebGlErrors: false,
            debugMobileTouch: false,
            boundaries: {
                drawLayerBoundaries: false,
                drawObjectBoundaries: false,
                boundariesColor: "rgba(224, 12, 21, 0.6)",
                boundariesWidth: 2
            },
            delayBetweenObjectRender: false, // 1 sec delay for debug proposes
        }
    };
    

    static network = {
        // disable INetwork by default
        enabled: false,
        address: "https://gameserver.reslc.ru:9009",
        gatherRoomsInfoInterval: 5000
    };

    static canvasMaxSize = {
        width: 1800,
        height: 1800
    };

    static worldSize = {
        width: 960,
        height: 960
    };

    static defaultCanvasKey = "default";

    static customSettings = {};
}

/***/ }),

/***/ "./node_modules/jsge/src/constants.js":
/*!********************************************!*\
  !*** ./node_modules/jsge/src/constants.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CONST: () => (/* binding */ CONST),
/* harmony export */   DRAW_TYPE: () => (/* binding */ DRAW_TYPE),
/* harmony export */   ERROR_CODES: () => (/* binding */ ERROR_CODES),
/* harmony export */   WARNING_CODES: () => (/* binding */ WARNING_CODES)
/* harmony export */ });
const CONST = {
    MODE: {
        DEBUG: "DEBUG",
        PRODUCTION: "PRODUCTION"
    },
    SCREENS: {},
    AUDIO: {},
    CONNECTION_STATUS: {
        DISCONNECTED: "disconnected",
        CONNECTED: "connected",
        CONNECTION_LOST: "connection lost"
    },
    EVENTS: {
        SYSTEM: {
            START_PAGE:"START_PAGE",
            STOP_PAGE: "STOP_PAGE",
            RENDER: {
                START: "start",
                END: "end"
            }
        },
        GAME: {
            BOUNDARIES_COLLISION: "BOUNDARIES_COLLISION",
            OBJECTS_COLLISION: "OBJECTS_COLLISION"
        },
        WEBSOCKET: {
            SERVER_CLIENT: {
                CONNECTION_STATUS_CHANGED: "CONNECTION_STATUS_CHANGED",
                ROOMS_INFO: "roomsInfo",
                CREATED: "created",
                JOINED: "joined",
                FULL: "full",
                DISCONNECTED: "disconnected",
                SERVER_MESSAGE: "message",
                RESTARTED: "restarted",
            },
            CLIENT_SERVER: {
                ROOMS_INFO_REQUEST: "gatherRoomsInfo",
                CREATE_OR_JOIN: "create or join",
                RESTART_REQUEST: "restart",
                CLIENT_MESSAGE: "message"
            }
        }
    },
    WEBGL: {
        DRAW_PROGRAMS: {
            PRIMITIVES: "drawPrimitives",
            IMAGES: "drawImages",
            IMAGES_M: "drawImagesMerge"
        }
    },
    LAYERS: {
        DEFAULT: "default-view-layer",
        BOUNDARIES: "boundaries-view-layer"
    },
    GAME_OPTIONS: {},
    LIBRARY: {
        WEBGL: "webgl"
    },
    OPTIMIZATION: {
        CYCLE_TIME_CALC: {
            AVERAGES: "AVERAGES",
            CURRENT: "CURRENT"
        },
        NATIVE_JS: {
            NOT_OPTIMIZED: "NOT_OPTIMIZED",
            OPTIMIZED: "OPTIMIZED"
        },
        WEB_ASSEMBLY: {
            ASSEMBLY_SCRIPT: "ASSEMBLY_SCRIPT",
            NATIVE_WAT: "WASM"
        }
    }
};
/** @enum {string} */
const DRAW_TYPE = {
    RECTANGLE: "rect",
    CONUS: "conus",
    CIRCLE: "circle",
    POLYGON: "polygon",
    LINE: "line",
    TEXT: "text",
    IMAGE: "image"
};

const ERROR_CODES = {
    CREATE_INSTANCE_ERROR: "CREATE_INSTANCE_ERROR",
    STAGE_NOT_EXIST: "STAGE_NOT_EXIST",
    ELEMENT_NOT_EXIST: "ELEMENT_NOT_EXIST",
    FILE_NOT_EXIST: "FILE_NOT_EXIST",
    CANT_GET_THE_IMAGE: "CANT_GET_THE_IMAGE",
    UNEXPECTED_INPUT_PARAMS: "UNEXPECTED_INPUT_PARAMS",
    UNHANDLED_EXCEPTION: "UNHANDLED_EXCEPTION",
    CANVAS_KEY_NOT_SPECIFIED: "CANVAS_KEY_NOT_SPECIFIED",
    CANVAS_WITH_KEY_NOT_EXIST: "CANVAS_WITH_KEY_NOT_EXIST",
    WRONG_TYPE_ERROR: "WRONG_TYPE_ERROR",
    UNEXPECTED_WS_MESSAGE: "UNEXPECTED_WS_MESSAGE",
    UNEXPECTED_PLAYER_ID: "UNEXPECTED_PLAYER_ID",
    UNEXPECTED_BULLET_ID: "UNEXPECTED_BULLET_ID",
    UNEXPECTED_EVENT_NAME: "UNEXPECTED_EVENT_NAME",
    WEBGL_ERROR: "WEBGL_ERROR",
    DRAW_PREPARE_ERROR: "DRAW_PREPARE_ERROR",
    ANOTHER_STAGE_ACTIVE: "ANOTHER_STAGE_ACTIVE",
    UNEXPECTED_TILE_ID: "UNEXPECTED_TILE_ID",
    UNEXPECTED_TOUCH_AREA: "UNEXPECTED TOUCH AREA",
    UNEXPECTED_METHOD_TYPE: "UNEXPECTED METHOD TYPE"
};

const WARNING_CODES =  {
    MULTIPLE_IMAGE_TILESET: "MULTIPLE_IMAGE_TILESET",
    FILE_LOADING_ISSUE: "FILE_LOADING_ISSUE",
    ASSETS_NOT_READY: "ASSETS_NOT_READY",
    NOT_FOUND: "NOT_FOUND",
    NOT_TESTED: "NOT_TESTED",
    WORLD_DIMENSIONS_NOT_SET: "WORLD_DIMENSIONS_NOT_SET",
    INCORRECT_RENDER_TYPE: "INCORRECT_RENDER_TYPE",
    UNHANDLED_DRAW_ISSUE: "UNHANDLED_DRAW_ISSUE",
    UNEXPECTED_WORLD_SIZE: "UNEXPECTED_WORLD_SIZE",
    AUDIO_ALREADY_REGISTERED: "AUDIO_ALREADY_REGISTERED",
    AUDIO_NOT_REGISTERED: "AUDIO_NOT_REGISTERED",
    AUDIO_NOT_LOADED: "AUDIO_NOT_LOADED",
    UNKNOWN_DRAW_OBJECT: "UNKNOWN_DRAW_OBJECT",
    METHOD_NOT_IMPLEMENTED: "METHOD_NOT_IMPLEMENTED",
    POLYGON_VERTICES_NOT_CORRECT: "POLYGON_VERTICES_NOT_CORRECT",
    MODULE_ALREADY_INSTALLED: "MODULE_ALREADY_INSTALLED",
    DEPRECATED_PARAMETER: "DEPRECATED_PARAMETER",
    NEW_BEHAVIOR_INTRODUCED: "NEW_BEHAVIOR_INTRODUCED",
    TEXTURE_IMAGE_TEMP_OVERFLOW: "TEXTURE_IMAGE_TEMP_OVERFLOW",
    TRIANGULATE_ISSUE: "TRIANGULATE_ISSUE"
};

/***/ }),

/***/ "./node_modules/jsge/src/design/LoadingStage.js":
/*!******************************************************!*\
  !*** ./node_modules/jsge/src/design/LoadingStage.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LoadingStage: () => (/* binding */ LoadingStage)
/* harmony export */ });
/* harmony import */ var _base_GameStage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/GameStage.js */ "./node_modules/jsge/src/base/GameStage.js");


class LoadingStage extends _base_GameStage_js__WEBPACK_IMPORTED_MODULE_0__.GameStage {
    #total = 0;
    #loaded = 0;
    #barWidth = 0;
    register() {
        //this.iLoader.addImage(logoKey, "./images/icon.png");
    }

    init() {
        const [w, h] = this.stageData.canvasDimensions,
            barWidth = w/3,
            barHeight = 20;
        //this.logo = this.draw.image(w/2, h/2, 300, 200, logoKey);
        this.background = this.draw.rect(0, 0, w, h, this.systemSettings.gameOptions.loadingScreen.backgroundColor);  
        this.loadingBarBg = this.draw.rect(w/2 - (barWidth/2), h/2 - (barHeight/2), barWidth, barHeight, this.systemSettings.gameOptions.loadingScreen.loadingBarBg);
        this.loadingBarProgress = this.draw.rect(w/2 - (barWidth/2), h/2 - (barHeight/2), barWidth, barHeight, this.systemSettings.gameOptions.loadingScreen.loadingBarProgress);
        this.text = this.draw.text(w/2 - 20, h/2 - 2 * barHeight, "JsGE", "24px sans-serif", "black");
        this.#barWidth = barWidth;
    }

    _progress = (loaded) => {
        const widthPart = this.#barWidth / this.#total;

        this.#loaded = loaded;
        const newWidth = widthPart * this.#loaded;
        // sometimes additional items are added to queue in load process
        // to avoid bar width overflow additional check added below:
        const applyWidth = loaded > this.#total ? this.#barWidth : newWidth;

        this.loadingBarProgress.width = applyWidth;
    };

    start(options) {
        this.#total = options.total;
    }

    // a workaround for checking upload progress before render
    //get iLoader() {
    //    return ({filesWaitingForUpload:0});
    //}
} 

/***/ }),

/***/ "./node_modules/jsge/src/index.js":
/*!****************************************!*\
  !*** ./node_modules/jsge/src/index.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CONST: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_6__.CONST),
/* harmony export */   DrawImageObject: () => (/* reexport safe */ _base_2d_DrawImageObject_js__WEBPACK_IMPORTED_MODULE_2__.DrawImageObject),
/* harmony export */   GameStage: () => (/* reexport safe */ _base_GameStage_js__WEBPACK_IMPORTED_MODULE_1__.GameStage),
/* harmony export */   ISystemAudio: () => (/* reexport safe */ _base_ISystemAudio_js__WEBPACK_IMPORTED_MODULE_3__.ISystemAudio),
/* harmony export */   Primitives: () => (/* reexport module object */ _base_2d_Primitives_js__WEBPACK_IMPORTED_MODULE_4__),
/* harmony export */   System: () => (/* reexport safe */ _base_System_js__WEBPACK_IMPORTED_MODULE_0__.System),
/* harmony export */   SystemSettings: () => (/* reexport safe */ _configs_js__WEBPACK_IMPORTED_MODULE_5__.SystemSettings),
/* harmony export */   utils: () => (/* reexport module object */ _utils_js__WEBPACK_IMPORTED_MODULE_7__)
/* harmony export */ });
/* harmony import */ var _base_System_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base/System.js */ "./node_modules/jsge/src/base/System.js");
/* harmony import */ var _base_GameStage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base/GameStage.js */ "./node_modules/jsge/src/base/GameStage.js");
/* harmony import */ var _base_2d_DrawImageObject_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base/2d/DrawImageObject.js */ "./node_modules/jsge/src/base/2d/DrawImageObject.js");
/* harmony import */ var _base_ISystemAudio_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base/ISystemAudio.js */ "./node_modules/jsge/src/base/ISystemAudio.js");
/* harmony import */ var _base_2d_Primitives_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./base/2d/Primitives.js */ "./node_modules/jsge/src/base/2d/Primitives.js");
/* harmony import */ var _configs_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./configs.js */ "./node_modules/jsge/src/configs.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constants.js */ "./node_modules/jsge/src/constants.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils.js */ "./node_modules/jsge/src/utils.js");












/***/ }),

/***/ "./node_modules/jsge/src/utils.js":
/*!****************************************!*\
  !*** ./node_modules/jsge/src/utils.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   angle_2points: () => (/* binding */ angle_2points),
/* harmony export */   angle_3points: () => (/* binding */ angle_3points),
/* harmony export */   calculateEllipseVertices: () => (/* binding */ calculateEllipseVertices),
/* harmony export */   calculateLinesVertices: () => (/* binding */ calculateLinesVertices),
/* harmony export */   countClosestTraversal: () => (/* binding */ countClosestTraversal),
/* harmony export */   countClosestTraversal2: () => (/* binding */ countClosestTraversal2),
/* harmony export */   countDistance: () => (/* binding */ countDistance),
/* harmony export */   crossProduct: () => (/* binding */ crossProduct),
/* harmony export */   dotProduct: () => (/* binding */ dotProduct),
/* harmony export */   dotProductWithAngle: () => (/* binding */ dotProductWithAngle),
/* harmony export */   generateUniqId: () => (/* binding */ generateUniqId),
/* harmony export */   isCircleLineIntersect: () => (/* binding */ isCircleLineIntersect),
/* harmony export */   isEllipseCircleIntersect: () => (/* binding */ isEllipseCircleIntersect),
/* harmony export */   isEllipseLineIntersect: () => (/* binding */ isEllipseLineIntersect),
/* harmony export */   isEllipsePolygonIntersect: () => (/* binding */ isEllipsePolygonIntersect),
/* harmony export */   isLineShorter: () => (/* binding */ isLineShorter),
/* harmony export */   isMobile: () => (/* binding */ isMobile),
/* harmony export */   isPointCircleIntersect: () => (/* binding */ isPointCircleIntersect),
/* harmony export */   isPointInsidePolygon: () => (/* binding */ isPointInsidePolygon),
/* harmony export */   isPointLineIntersect: () => (/* binding */ isPointLineIntersect),
/* harmony export */   isPointOnTheLine: () => (/* binding */ isPointOnTheLine),
/* harmony export */   isPointPolygonIntersect: () => (/* binding */ isPointPolygonIntersect),
/* harmony export */   isPointRectIntersect: () => (/* binding */ isPointRectIntersect),
/* harmony export */   isPolygonLineIntersect: () => (/* binding */ isPolygonLineIntersect),
/* harmony export */   isSafari: () => (/* binding */ isSafari),
/* harmony export */   mat3Multiply: () => (/* binding */ mat3Multiply),
/* harmony export */   mat3MultiplyPosCoords: () => (/* binding */ mat3MultiplyPosCoords),
/* harmony export */   mat3MultiplyVector: () => (/* binding */ mat3MultiplyVector),
/* harmony export */   pointToCircleDistance: () => (/* binding */ pointToCircleDistance),
/* harmony export */   randomFromArray: () => (/* binding */ randomFromArray),
/* harmony export */   verticesArrayToArrayNumbers: () => (/* binding */ verticesArrayToArrayNumbers)
/* harmony export */ });
/* harmony import */ var _base_2d_Primitives_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base/2d/Primitives.js */ "./node_modules/jsge/src/base/2d/Primitives.js");


function isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent) ;
}

function isSafari() {
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}

function pointToCircleDistance(x, y, circle) {
    const pointToCircleCenterDistance = new _base_2d_Primitives_js__WEBPACK_IMPORTED_MODULE_0__.Vector(x, y, circle.x, circle.y).length;
    return pointToCircleCenterDistance - circle.r;
}

function countClosestTraversal(line, sight) {
    const x1 = sight.x1,
        y1 = sight.y1,
        x2 = sight.x2,
        y2 = sight.y2;
    const x3 = line.x1,
        y3 = line.y1,
        x4 = line.x2,
        y4 = line.y2;

    const r_px = x1,
        r_py = y1,
        r_dx = x2-x1,
        r_dy = y2-y1;

    const s_px = x3,
        s_py = y3,
        s_dx = x4-x3,
        s_dy = y4-y3;

    const r_mag = Math.sqrt(r_dx*r_dx+r_dy*r_dy),
        s_mag = Math.sqrt(s_dx*s_dx+s_dy*s_dy);
    if(r_dx/r_mag==s_dx/s_mag && r_dy/r_mag==s_dy/s_mag){
        return null;
    }

    const T2 = (r_dx*(s_py-r_py) + r_dy*(r_px-s_px))/(s_dx*r_dy - s_dy*r_dx),
        T1 = (s_px+s_dx*T2-r_px)/r_dx;

    if(T1<0 || isNaN(T1)) return null;
    if(T2<0 || T2>1) return null;

    return {
        x: r_px+r_dx*T1,
        y: r_py+r_dy*T1,
        p: T1
    };
}

/**
 * 
 * @param {{x1:number, y1:number, x2:number, y2:number}} line1 
 * @param {{x1:number, y1:number, x2:number, y2:number}} line2 
 * @returns {{x:number, y:number, p:number} | undefined}
 * @ignore
 */
function countClosestTraversal2(line1, line2) {
    const x1 = line2.x1,
        y1 = line2.y1,
        x2 = line2.x2,
        y2 = line2.y2;
    const x3 = line1.x1,
        y3 = line1.y1,
        x4 = line1.x2,
        y4 = line1.y2;

    const det = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    // lines are parallel, or coincident
    if (det === 0){
        return;
    }
    let x = ((x1*y2 - y1*x2) * (x3 - x4) - (x1 - x2) * (x3*y4 - y3*x4)) / det;
    let y = ((x1*y2 - y1*x2) * (y3 - y4) - (y1 - y2) * (x3*y4 - y3*x4)) / det;
    const point = {x, y};
    
    if (isPointOnTheLine(point, line1, 0.0000000000001) && isPointOnTheLine(point, line2, 0.0000000000001)) {
        const p = Math.sqrt(Math.pow((x - x1), 2) + Math.pow((y - y1), 2));
        return {x, y, p};
    } else {
        return;
    }
}

function angle_2points(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
}

function angle_3points(a, b, c) {
    const x1 = a.x - b.x,
        x2 = c.x - b.x,
        y1 = a.y - b.y,
        y2 = c.y - b.y,
        d1 = Math.sqrt(x1 * x1 + y1 * y1),
        d2 = Math.sqrt(x2 * x2 + y2 * y2);
    //console.log("angle: ", (Math.acos((x1* x2 + y1 * y2) / (d1 * d2))* 180) / Math.PI);
    return Math.acos((x1* x2 + y1 * y2) / (d1 * d2));
}

function dotProductWithAngle(lenA, lenB, angle) {
    return lenA * lenB * Math.cos(angle);
}

function dotProduct(vec1, vec2) {
    return vec1.x * vec2.x + vec1.y * vec2.y;
}

function crossProduct(a, b) {
    return (a.x * b.y - b.x * a.y);
}

function isPointOnTheLine(point, line, m_error = 0) {
    return  (
        ((point.x >= (line.x1 - m_error)) && (point.x <= (line.x2 + m_error))) || 
                ((point.x <= (line.x1 + m_error)) && (point.x >= (line.x2 - m_error)))
    ) && (
        ((point.y >= (line.y1 - m_error)) && (point.y <= (line.y2 + m_error))) || 
                ((point.y <= (line.y1 + m_error)) && (point.y >= (line.y2 - m_error)))
    );
}

function countDistance(obj1, obj2) {
    return new _base_2d_Primitives_js__WEBPACK_IMPORTED_MODULE_0__.Vector(obj1.x, obj1.y, obj2.x, obj2.y).length;
}

function isLineShorter(line1, line2) {
    return (new _base_2d_Primitives_js__WEBPACK_IMPORTED_MODULE_0__.Vector(line1.x1, line1.y1, line1.x2, line1.y2)).length < (new _base_2d_Primitives_js__WEBPACK_IMPORTED_MODULE_0__.Vector(line2.x1, line2.y1, line2.x2, line2.y2)).length;
}

function isPointLineIntersect(point, line) {
    const lineL = new _base_2d_Primitives_js__WEBPACK_IMPORTED_MODULE_0__.Vector(line.x1, line.y1, line.x2, line.y2).length,
        lengthAB = new _base_2d_Primitives_js__WEBPACK_IMPORTED_MODULE_0__.Vector(line.x1, line.y1, point.x, point.y).length + new _base_2d_Primitives_js__WEBPACK_IMPORTED_MODULE_0__.Vector(line.x2, line.y2, point.x, point.y).length;

    if (lengthAB <= lineL + 0.2) {
        //console.log("point to line intersect. line len: " + lineL + ", line AB len: " + lengthAB);
        return true;
    }
    return false;
}

/**
 * 
 * @param {Array<Array<number>>} polygon 
 * @param {{x1:number, y1:number, x2:number, y2:number}} line 
 * @returns {{x:number, y:number, p:number} | null}
 * @ignore
 */
function isPolygonLineIntersect(polygon, line) {
    const len = polygon.length;
    for (let i = 0; i < len; i+=1) {
        let curr = polygon[i],
            next = polygon[i+1];
        //if next item not exist and current is not first
        if (!next) {
            // if current vertex is not the first one
            if (!(curr[0] === polygon[0][0] && curr[1] === polygon[0][1])) {
                next = polygon[0];
            } else {
                continue;
            }
        }
        const edge = { x1: curr[0], y1: curr[1], x2: next[0], y2: next[1] };
        const intersection = countClosestTraversal2(edge, line);
        if (intersection) {
            return intersection;
        }
    }
    if (polygon[len-1][0] !== polygon[0][0] && polygon[len-1][1] !== polygon[0][1]) {
        //check one last item
        const curr = polygon[len - 1],
            next = polygon[0];
        const edge = { x1: curr[0], y1: curr[1], x2: next[0], y2: next[1] };
        const intersection = countClosestTraversal2(edge, line);
        if (intersection) {
            return intersection;
        }
    }
    return null;
}

function isPointPolygonIntersect(x, y, polygon) {
    const len = polygon.length;
    
    for (let i = 0; i < len; i+=1) {
        let vertex1 = polygon[i],
            vertex2 = polygon[i + 1];

        // if last vertex, set vertex2 as the first
        if (!vertex2) {
            vertex2 = polygon[0];
        }

        if (isPointLineIntersect({x,y}, {x1: vertex1[0], y1: vertex1[1], x2: vertex2[0], y2: vertex2[1]})) {
            return true;
        }
    }
    return false;
}

function isPointInsidePolygon(x, y, polygon) {
    const len = polygon.length;
    let intersections = 0;

    for (let i = 0; i < len; i++) {
        let vertex1 = polygon[i],
            vertex2 = polygon[i + 1] ? polygon[i + 1] : polygon[0],
            x1 = vertex1[0],
            y1 = vertex1[1],
            x2 = vertex2[0],
            y2 = vertex2[1];
            
        if (y < y1 !== y < y2 && 
            x < (x2 - x1) * (y - y1) / (y2 - y1) + x1) {
            intersections++;
        }
    }
    
    if (intersections > 0) {
        if (intersections % 2 === 0) {
            return false;
        } else {
            return true;
        }
    } else {
        return false;
    }
}

function isPointRectIntersect(x, y, rect) {
    if (x >= rect.x && x <= rect.width + rect.x && y >= rect.y && y <= rect.y + rect.height) {
        return true;
    } else {
        return false;
    }
}

/**
 * 
 * @param {number} x 
 * @param {number} y 
 * @param {{x:number, y:number, r:number}} circle 
 * @returns {boolean}
 */
function isPointCircleIntersect(x, y, circle) {
    const radius = circle.r,
        lineToCircleCenter = new _base_2d_Primitives_js__WEBPACK_IMPORTED_MODULE_0__.Vector(x, y, circle.x, circle.y),
        pointCircleLineLength = lineToCircleCenter.length;
        
    if (pointCircleLineLength < radius)
        return true;
    else
        return false;
}

function isCircleLineIntersect(x, y, r, line) {
    const x1 = line.x1,
        y1 = line.y1,
        x2 = line.x2,
        y2 = line.y2,
        vec1 = {x: x1 - x, y: y1-y}, //new Vector(x, y, x1, y1),
        vec2 = {x: x2 - x, y: y2-y}, //new Vector(x, y, x2, y2),
        vec3 = {x: x2 - x1, y: y2-y1}, //new Vector(x1 ,y1, x2, y2),
        vec4 = {x: x1 - x2, y: y1-y2}, //new Vector(x2, y2, x1, y1),
        vec3Len = Math.sqrt(Math.pow(vec3.x, 2) + Math.pow(vec3.y, 2)),//vec3.length,
        dotP1 = dotProduct(vec1, vec4),
        dotP2 = dotProduct(vec2, vec3);
        // checks if the line is inside the circle,
        // max_dist = Math.max(vec1Len, vec2Len);
    let min_dist;
    
    if (dotP1 > 0 && dotP2 > 0) {
        min_dist = crossProduct(vec1,vec2)/vec3Len;
        if (min_dist < 0) {
            min_dist *= -1;
        }
    } else {
        min_dist = Math.min(vec1.length, vec2.length);
    }
    
    if (min_dist <= r) { // && max_dist >= r) {
        return true;
    } else {
        return false;
    } 
}

/**
 * 
 * @param {Array<number>} ellipse - x,y,radX,radY
 * @param {Array<Array<number>>} line [x1,y1],[x2,y2]
 */
function isEllipseLineIntersect(ellipse, line) {
    const x = ellipse[0],
        y = ellipse[1],
        radX = ellipse[2],
        radY = ellipse[3],
        x1 = line[0][0],
        y1 = line[0][1],
        x2 = line[1][0],
        y2 = line[1][1],
        lineAToElCenter = { x: x - x1, y: y - y1 }, //new Vector(x, y, x1, y1),
        lineBToElCenter = { x: x - x2, y: y - y2 }, //new Vector(x, y, x2, y2),
        lineAToElCenterLen = Math.sqrt(Math.pow(lineAToElCenter.x, 2) + Math.pow(lineAToElCenter.y, 2)),
        lineBToElCenterLen = Math.sqrt(Math.pow(lineBToElCenter.x, 2) + Math.pow(lineBToElCenter.y, 2)),
        lineToCenterLenMin = Math.min(lineAToElCenterLen, lineBToElCenterLen),
        ellipseMax = Math.max(radX, radY);
        
    if (lineToCenterLenMin > ellipseMax) {
        return false;
    }
    
    const traversalLine = lineToCenterLenMin === lineAToElCenterLen ? lineAToElCenter : lineBToElCenter,
        angleToAxisX = Math.atan2(traversalLine.y, traversalLine.x);
    
    const intersectX = Math.cos(angleToAxisX) * radX,
        intersectY = Math.sin(angleToAxisX) * radY,
        lineToCenter = { x: 0 - intersectX, y: 0 - intersectY },
        intersectLineLen = Math.sqrt(Math.pow(lineToCenter.x, 2) + Math.pow(lineToCenter.y, 2));
    //console.log("lenToCheck: ", lenToCheck);
    //console.log("x: ", intersectX);
    if (lineToCenterLenMin > intersectLineLen) {
        return false;
    }
    return true;
}

/**
 * 
 * @param {Array<number>} ellipse - x,y,radX,radY
 * @param {{x:number, y:number, r:number}} circle
 * @returns {{x:number, y:number, p:number} | boolean}
 */
function isEllipseCircleIntersect(ellipse, circle) {
    const ellipseX = ellipse[0],
        ellipseY = ellipse[1],
        ellipseToCircleLine = { x: ellipseX - circle.x, y: ellipseY - circle.y },
        len = Math.sqrt(Math.pow(ellipseToCircleLine.x, 2) + Math.pow(ellipseToCircleLine.y, 2)),
        maxRad = Math.max(ellipse[2], ellipse[3]);
    // no collisions for sure
    if (len > (maxRad + circle.r)) {
        return false;
    } else {
        // check possible collision
        const angle = angle_2points(ellipseX, ellipseY, circle.x, circle.y),
            traversalX = ellipseX + (ellipse[2] * Math.cos(angle)),
            traversalY =  ellipseY + (ellipse[3] * Math.sin(angle)),
            vecTrX = ellipseX - traversalX,
            vecTrY = ellipseY - traversalY,
            traversalLen = Math.sqrt(Math.pow(vecTrX, 2) + Math.pow(vecTrY, 2)) + circle.r;
        if (len <= traversalLen) {
            return {x: vecTrX, y: vecTrY, p:1};
        } else {
            return false;
        }
    }
    
}

/**
 * 
 * @param {Array<number>} ellipse - x,y,radX,radY
 * @param {Array<Array<number>>} polygon - x,y
 * @returns {boolean}
 */
function isEllipsePolygonIntersect(ellipse, polygon) {
    const len = polygon.length;

    for (let i = 0; i < len; i+=1) {
        let vertex1 = polygon[i],
            vertex2 = polygon[i + 1];

        // if last vertex, set vertex2 as the first
        if (!vertex2) {
            vertex2 = polygon[0];
        }

        if (isEllipseLineIntersect(ellipse, [vertex1, vertex2])) {
            return true;
        }
    }
    return false;
}

function generateUniqId() {
    return Math.round(Math.random() * 1000000); 
}

function randomFromArray(array) {
    return array[Math.floor(Math.random()*array.length)];
}

function verticesArrayToArrayNumbers(array) {
    const len = array.length,
        numbers = [];
    for (let i = 0; i < len; i++) {
        const vertex = array[i];
        numbers.push([vertex.x, vertex.y]);
    }
    return numbers;
}

/**
 * 
 * @param {Array<Array<number>>} arrayDots
 * @returns {Array<Array<number>>} 
 */
function calculateLinesVertices(x = 0, y = 0, r, arrayDots) {
    const len = arrayDots.length;
    let arrayLines = Array(len),
        arrayDotsIterator = 0;
        
    for (let i = 0; i < len; i++) {
        const dot1 = arrayDots[i];
        let dot2 = arrayDots[i+1];
        if (!dot2) {
            dot2 = arrayDots[0];
        }
        const x1 = dot1[0],
            y1 = dot1[1],
            x2 = dot2[0],
            y2 = dot2[1];

        const x1R = x1 * Math.cos(r) - y1 * Math.sin(r),
            y1R = x1 * Math.sin(r) + y1 * Math.cos(r),
            x2R = x2 * Math.cos(r) - y2 * Math.sin(r),
            y2R = x2 * Math.sin(r) + y2 * Math.cos(r);
        const line = [x1R + x, y1R + y, x2R + x, y2R + y];
        
        arrayLines[arrayDotsIterator] = line;
        arrayDotsIterator++;
    }
    return arrayLines;
}

/**
 * @param {number} x
 * @param {number} y
 * @param {number} radiusX
 * @param {number} radiusY
 * @param {number} [angle = 2 * Math.PI]
 * @param {number} [step = Math.PI/12] 
 * @returns {Array<Array<number>>}
 */
function calculateEllipseVertices(x = 0, y = 0, radiusX, radiusY, angle = 2*Math.PI, step = Math.PI/8) {
    let ellipsePolygonCoords = [];

    for (let r = 0; r <= angle; r += step) {
        let x2 = Math.cos(r) * radiusX + x,
            y2 = Math.sin(r) * radiusY + y;

        ellipsePolygonCoords.push([x2, y2]);
    }

    return ellipsePolygonCoords;
}

/**
 * 
 * @param { Array<number> } mat1 
 * @param { Array<number> } mat2 
 * @returns { Array<number> }
 */
function mat3Multiply(mat1, mat2) {
    let matResult = [];
    for (let resultIdx = 0; resultIdx < 9; resultIdx += 3) {
        let resultIndex = resultIdx;
        
        for (let i = 0; i < 3; i++) {
            let resultVal = 0,
                k = i;
                
            for (let j = 0; j < 3; j++) {
                const mat1Val = mat1[resultIdx + j],
                    mat2Val = mat2[k];

                resultVal += (mat1Val * mat2Val);
                k+=3;
            }
            matResult[resultIndex] = resultVal;
            resultIndex++;
        }
    }
    return matResult;
}

/**
 * 
 * @param {Array<number>} mat3 [a, b, c,
 *                              d. e, f,
 *                              g, h, i]
 * @param {Array<number>} vec3 [x1, y1]
 * @returns {Array<number>} [a * x1 + b * y1 + c * 1,  d * x1 + e * y1 + f * 1]
 */
function mat3MultiplyVector (mat3, vec3) {
    let result = [];
    let resultIndex = 0;
    for (let rowStartIdx = 0; rowStartIdx < 6; rowStartIdx += 3) {
        let resultVal = 0;
        const stopInt = rowStartIdx + 3;
        let vecIdx = 0;
        for (let rowIdx = rowStartIdx; rowIdx < stopInt; rowIdx++) {
            const matVal = mat3[rowIdx],
                vecVal = vec3[vecIdx] || 1; // z1 coord
            resultVal += (matVal * vecVal);
            vecIdx++;
        }
        result[resultIndex] = resultVal;
        resultIndex++;
    }
    return result;
}

/**
 * 
 * @param {Array<number>} mat3 [a, b, c,
 *                              d. e, f,
 *                              g, h, i]
 * @param {Array<number>} vec3 [x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2, ...]
 * @returns {Array<number>} [a*x1 + b*y1 + c*1, d*y1 + e*y1 + f*1, ...]
 */
function mat3MultiplyPosCoords (mat3, vec3) {
    const vec3Len = vec3.length;
    let result = [];
    let resultIndex = 0;
    for (let nPair = 0; nPair < vec3Len; nPair += 2) {
        for (let rowStartIdx = 0; rowStartIdx < 6; rowStartIdx += 3) {
            let resultVal = 0;
            const stopInt = rowStartIdx + 3;
            let vecIdx = nPair;
            let iteration = 1;
            for (let rowIdx = rowStartIdx; rowIdx < stopInt; rowIdx++) {
                const matVal = mat3[rowIdx],
                    vecVal = iteration === 3 ? 1 : vec3[vecIdx]; // 3: z1 = 1 coord
                resultVal += (matVal * vecVal);
                vecIdx++;
                iteration++;
            }
            result[resultIndex] = resultVal;
            resultIndex++;
        }
    }
    return result;
}



/***/ }),

/***/ "./node_modules/proxy-compare/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/proxy-compare/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   affectedToPathList: () => (/* binding */ affectedToPathList),
/* harmony export */   createProxy: () => (/* binding */ createProxy),
/* harmony export */   getUntracked: () => (/* binding */ getUntracked),
/* harmony export */   isChanged: () => (/* binding */ isChanged),
/* harmony export */   markToTrack: () => (/* binding */ markToTrack),
/* harmony export */   replaceNewProxy: () => (/* binding */ replaceNewProxy),
/* harmony export */   trackMemo: () => (/* binding */ trackMemo)
/* harmony export */ });
/* eslint @typescript-eslint/no-explicit-any: off */
// symbols
const TRACK_MEMO_SYMBOL = Symbol();
const GET_ORIGINAL_SYMBOL = Symbol();
// properties
const AFFECTED_PROPERTY = 'a';
const IS_TARGET_COPIED_PROPERTY = 'f';
const PROXY_PROPERTY = 'p';
const PROXY_CACHE_PROPERTY = 'c';
const TARGET_CACHE_PROPERTY = 't';
const HAS_KEY_PROPERTY = 'h';
const ALL_OWN_KEYS_PROPERTY = 'w';
const HAS_OWN_KEY_PROPERTY = 'o';
const KEYS_PROPERTY = 'k';
// function to create a new bare proxy
let newProxy = (target, handler) => new Proxy(target, handler);
// get object prototype
const getProto = Object.getPrototypeOf;
const objectsToTrack = new WeakMap();
// check if obj is a plain object or an array
const isObjectToTrack = (obj) => obj &&
    (objectsToTrack.has(obj)
        ? objectsToTrack.get(obj)
        : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);
// check if it is object
const isObject = (x) => typeof x === 'object' && x !== null;
// Properties that are both non-configurable and non-writable will break
// the proxy get trap when we try to return a recursive/child compare proxy
// from them. We can avoid this by making a copy of the target object with
// all descriptors marked as configurable, see `copyTargetObject`.
// See: https://github.com/dai-shi/proxy-compare/pull/8
const needsToCopyTargetObject = (obj) => Object.values(Object.getOwnPropertyDescriptors(obj)).some((descriptor) => !descriptor.configurable && !descriptor.writable);
// Make a copy with all descriptors marked as configurable.
const copyTargetObject = (obj) => {
    if (Array.isArray(obj)) {
        // Arrays need a special way to copy
        return Array.from(obj);
    }
    // For non-array objects, we create a new object keeping the prototype
    // with changing all configurable options (otherwise, proxies will complain)
    const descriptors = Object.getOwnPropertyDescriptors(obj);
    Object.values(descriptors).forEach((desc) => {
        desc.configurable = true;
    });
    return Object.create(getProto(obj), descriptors);
};
const createProxyHandler = (origObj, isTargetCopied) => {
    const state = {
        [IS_TARGET_COPIED_PROPERTY]: isTargetCopied,
    };
    let trackObject = false; // for trackMemo
    const recordUsage = (type, key) => {
        if (!trackObject) {
            let used = state[AFFECTED_PROPERTY].get(origObj);
            if (!used) {
                used = {};
                state[AFFECTED_PROPERTY].set(origObj, used);
            }
            if (type === ALL_OWN_KEYS_PROPERTY) {
                used[ALL_OWN_KEYS_PROPERTY] = true;
            }
            else {
                let set = used[type];
                if (!set) {
                    set = new Set();
                    used[type] = set;
                }
                set.add(key);
            }
        }
    };
    const recordObjectAsUsed = () => {
        trackObject = true;
        state[AFFECTED_PROPERTY].delete(origObj);
    };
    const handler = {
        get(target, key) {
            if (key === GET_ORIGINAL_SYMBOL) {
                return origObj;
            }
            recordUsage(KEYS_PROPERTY, key);
            return createProxy(Reflect.get(target, key), state[AFFECTED_PROPERTY], state[PROXY_CACHE_PROPERTY], state[TARGET_CACHE_PROPERTY]);
        },
        has(target, key) {
            if (key === TRACK_MEMO_SYMBOL) {
                recordObjectAsUsed();
                return true;
            }
            recordUsage(HAS_KEY_PROPERTY, key);
            return Reflect.has(target, key);
        },
        getOwnPropertyDescriptor(target, key) {
            recordUsage(HAS_OWN_KEY_PROPERTY, key);
            return Reflect.getOwnPropertyDescriptor(target, key);
        },
        ownKeys(target) {
            recordUsage(ALL_OWN_KEYS_PROPERTY);
            return Reflect.ownKeys(target);
        },
    };
    if (isTargetCopied) {
        handler.set = handler.deleteProperty = () => false;
    }
    return [handler, state];
};
const getOriginalObject = (obj) => 
// unwrap proxy
obj[GET_ORIGINAL_SYMBOL] ||
    // otherwise
    obj;
/**
 * Create a proxy.
 *
 * This function will create a proxy at top level and proxy nested objects as you access them,
 * in order to keep track of which properties were accessed via get/has proxy handlers:
 *
 * NOTE: Printing of WeakMap is hard to inspect and not very readable
 * for this purpose you can use the `affectedToPathList` helper.
 *
 * @param {object} obj - Object that will be wrapped on the proxy.
 * @param {WeakMap<object, unknown>} affected -
 * WeakMap that will hold the tracking of which properties in the proxied object were accessed.
 * @param {WeakMap<object, unknown>} [proxyCache] -
 * WeakMap that will help keep referential identity for proxies.
 * @returns {Proxy<object>} - Object wrapped in a proxy.
 *
 * @example
 * import { createProxy } from 'proxy-compare';
 *
 * const original = { a: "1", c: "2", d: { e: "3" } };
 * const affected = new WeakMap();
 * const proxy = createProxy(original, affected);
 *
 * proxy.a // Will mark as used and track its value.
 * // This will update the affected WeakMap with original as key
 * // and a Set with "a"
 *
 * proxy.d // Will mark "d" as accessed to track and proxy itself ({ e: "3" }).
 * // This will update the affected WeakMap with original as key
 * // and a Set with "d"
 */
const createProxy = (obj, affected, proxyCache, targetCache) => {
    if (!isObjectToTrack(obj))
        return obj;
    let targetAndCopied = targetCache && targetCache.get(obj);
    if (!targetAndCopied) {
        const target = getOriginalObject(obj);
        if (needsToCopyTargetObject(target)) {
            targetAndCopied = [target, copyTargetObject(target)];
        }
        else {
            targetAndCopied = [target];
        }
        targetCache === null || targetCache === void 0 ? void 0 : targetCache.set(obj, targetAndCopied);
    }
    const [target, copiedTarget] = targetAndCopied;
    let handlerAndState = proxyCache && proxyCache.get(target);
    if (!handlerAndState ||
        handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget) {
        handlerAndState = createProxyHandler(target, !!copiedTarget);
        handlerAndState[1][PROXY_PROPERTY] = newProxy(copiedTarget || target, handlerAndState[0]);
        if (proxyCache) {
            proxyCache.set(target, handlerAndState);
        }
    }
    handlerAndState[1][AFFECTED_PROPERTY] = affected;
    handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache;
    handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache;
    return handlerAndState[1][PROXY_PROPERTY];
};
const isAllOwnKeysChanged = (prevObj, nextObj) => {
    const prevKeys = Reflect.ownKeys(prevObj);
    const nextKeys = Reflect.ownKeys(nextObj);
    return (prevKeys.length !== nextKeys.length ||
        prevKeys.some((k, i) => k !== nextKeys[i]));
};
/**
 * Compare changes on objects.
 *
 * This will compare the affected properties on tracked objects inside the proxy
 * to check if there were any changes made to it,
 * by default if no property was accessed on the proxy it will attempt to do a
 * reference equality check for the objects provided (Object.is(a, b)). If you access a property
 * on the proxy, then isChanged will only compare the affected properties.
 *
 * @param {object} prevObj - The previous object to compare.
 * @param {object} nextObj - Object to compare with the previous one.
 * @param {WeakMap<object, unknown>} affected -
 * WeakMap that holds the tracking of which properties in the proxied object were accessed.
 * @param {WeakMap<object, unknown>} [cache] -
 * WeakMap that holds a cache of the comparisons for better performance with repetitive comparisons,
 * and to avoid infinite loop with circular structures.
 * @returns {boolean} - Boolean indicating if the affected property on the object has changed.
 *
 * @example
 * import { createProxy, isChanged } from 'proxy-compare';
 *
 * const obj = { a: "1", c: "2", d: { e: "3" } };
 * const affected = new WeakMap();
 *
 * const proxy = createProxy(obj, affected);
 *
 * proxy.a
 *
 * isChanged(obj, { a: "1" }, affected) // false
 *
 * proxy.a = "2"
 *
 * isChanged(obj, { a: "1" }, affected) // true
 */
const isChanged = (prevObj, nextObj, affected, cache, // for object with cycles
isEqual = Object.is) => {
    if (isEqual(prevObj, nextObj)) {
        return false;
    }
    if (!isObject(prevObj) || !isObject(nextObj))
        return true;
    const used = affected.get(getOriginalObject(prevObj));
    if (!used)
        return true;
    if (cache) {
        const hit = cache.get(prevObj);
        if (hit === nextObj) {
            return false;
        }
        // for object with cycles
        cache.set(prevObj, nextObj);
    }
    let changed = null;
    for (const key of used[HAS_KEY_PROPERTY] || []) {
        changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);
        if (changed)
            return changed;
    }
    if (used[ALL_OWN_KEYS_PROPERTY] === true) {
        changed = isAllOwnKeysChanged(prevObj, nextObj);
        if (changed)
            return changed;
    }
    else {
        for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {
            const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);
            const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);
            changed = hasPrev !== hasNext;
            if (changed)
                return changed;
        }
    }
    for (const key of used[KEYS_PROPERTY] || []) {
        changed = isChanged(prevObj[key], nextObj[key], affected, cache, isEqual);
        if (changed)
            return changed;
    }
    if (changed === null)
        throw new Error('invalid used');
    return changed;
};
// explicitly track object with memo
const trackMemo = (obj) => {
    if (isObjectToTrack(obj)) {
        return TRACK_MEMO_SYMBOL in obj;
    }
    return false;
};
/**
 * Unwrap proxy to get the original object.
 *
 * Used to retrieve the original object used to create the proxy instance with `createProxy`.
 *
 * @param {Proxy<object>} obj -  The proxy wrapper of the originial object.
 * @returns {object | null} - Return either the unwrapped object if exists.
 *
 * @example
 * import { createProxy, getUntracked } from 'proxy-compare';
 *
 * const original = { a: "1", c: "2", d: { e: "3" } };
 * const affected = new WeakMap();
 *
 * const proxy = createProxy(original, affected);
 * const originalFromProxy = getUntracked(proxy)
 *
 * Object.is(original, originalFromProxy) // true
 * isChanged(original, originalFromProxy, affected) // false
 */
const getUntracked = (obj) => {
    if (isObjectToTrack(obj)) {
        return obj[GET_ORIGINAL_SYMBOL] || null;
    }
    return null;
};
/**
 * Mark object to be tracked.
 *
 * This function marks an object that will be passed into `createProxy`
 * as marked to track or not. By default only Array and Object are marked to track,
 * so this is useful for example to mark a class instance to track or to mark a object
 * to be untracked when creating your proxy.
 *
 * @param obj - Object to mark as tracked or not.
 * @param mark - Boolean indicating whether you want to track this object or not.
 * @returns - No return.
 *
 * @example
 * import { createProxy, markToTrack, isChanged } from 'proxy-compare';
 *
 * const nested = { e: "3" }
 *
 * markToTrack(nested, false)
 *
 * const original = { a: "1", c: "2", d: nested };
 * const affected = new WeakMap();
 *
 * const proxy = createProxy(original, affected);
 *
 * proxy.d.e
 *
 * isChanged(original, { d: { e: "3" } }, affected) // true
 */
const markToTrack = (obj, mark = true) => {
    objectsToTrack.set(obj, mark);
};
/**
 * Convert `affected` to path list
 *
 * `affected` is a weak map which is not printable.
 * This function is can convert it to printable path list.
 * It's for debugging purpose.
 *
 * @param obj - An object that is used with `createProxy`.
 * @param affected - A weak map that is used with `createProxy`.
 * @param onlyWithValues - An optional boolean to exclude object getters.
 * @returns - An array of paths.
 */
const affectedToPathList = (obj, affected, onlyWithValues) => {
    const list = [];
    const seen = new WeakSet();
    const walk = (x, path) => {
        var _a, _b, _c;
        if (seen.has(x)) {
            // for object with cycles
            return;
        }
        if (isObject(x)) {
            seen.add(x);
        }
        const used = isObject(x) && affected.get(getOriginalObject(x));
        if (used) {
            (_a = used[HAS_KEY_PROPERTY]) === null || _a === void 0 ? void 0 : _a.forEach((key) => {
                const segment = `:has(${String(key)})`;
                list.push(path ? [...path, segment] : [segment]);
            });
            if (used[ALL_OWN_KEYS_PROPERTY] === true) {
                const segment = ':ownKeys';
                list.push(path ? [...path, segment] : [segment]);
            }
            else {
                (_b = used[HAS_OWN_KEY_PROPERTY]) === null || _b === void 0 ? void 0 : _b.forEach((key) => {
                    const segment = `:hasOwn(${String(key)})`;
                    list.push(path ? [...path, segment] : [segment]);
                });
            }
            (_c = used[KEYS_PROPERTY]) === null || _c === void 0 ? void 0 : _c.forEach((key) => {
                if (!onlyWithValues ||
                    'value' in (Object.getOwnPropertyDescriptor(x, key) || {})) {
                    walk(x[key], path ? [...path, key] : [key]);
                }
            });
        }
        else if (path) {
            list.push(path);
        }
    };
    walk(obj);
    return list;
};
/**
 * replace newProxy function.
 *
 * This can be used if you want to use proxy-polyfill.
 * Note that proxy-polyfill can't polyfill everything.
 * Use it at your own risk.
 */
const replaceNewProxy = (fn) => {
    newProxy = fn;
};


/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom-client.development.js":
/*!********************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom-client.development.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * @license React
 * react-dom-client.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/

 true &&
  (function () {
    function findHook(fiber, id) {
      for (fiber = fiber.memoizedState; null !== fiber && 0 < id; )
        (fiber = fiber.next), id--;
      return fiber;
    }
    function copyWithSetImpl(obj, path, index, value) {
      if (index >= path.length) return value;
      var key = path[index],
        updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
      return updated;
    }
    function copyWithRename(obj, oldPath, newPath) {
      if (oldPath.length !== newPath.length)
        console.warn("copyWithRename() expects paths of the same length");
      else {
        for (var i = 0; i < newPath.length - 1; i++)
          if (oldPath[i] !== newPath[i]) {
            console.warn(
              "copyWithRename() expects paths to be the same except for the deepest key"
            );
            return;
          }
        return copyWithRenameImpl(obj, oldPath, newPath, 0);
      }
    }
    function copyWithRenameImpl(obj, oldPath, newPath, index) {
      var oldKey = oldPath[index],
        updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      index + 1 === oldPath.length
        ? ((updated[newPath[index]] = updated[oldKey]),
          isArrayImpl(updated)
            ? updated.splice(oldKey, 1)
            : delete updated[oldKey])
        : (updated[oldKey] = copyWithRenameImpl(
            obj[oldKey],
            oldPath,
            newPath,
            index + 1
          ));
      return updated;
    }
    function copyWithDeleteImpl(obj, path, index) {
      var key = path[index],
        updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      if (index + 1 === path.length)
        return (
          isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key],
          updated
        );
      updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
      return updated;
    }
    function shouldSuspendImpl() {
      return !1;
    }
    function shouldErrorImpl() {
      return null;
    }
    function warnForMissingKey() {}
    function warnInvalidHookAccess() {
      console.error(
        "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
      );
    }
    function warnInvalidContextAccess() {
      console.error(
        "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
      );
    }
    function noop$2() {}
    function setToSortedString(set) {
      var array = [];
      set.forEach(function (value) {
        array.push(value);
      });
      return array.sort().join(", ");
    }
    function createFiber(tag, pendingProps, key, mode) {
      return new FiberNode(tag, pendingProps, key, mode);
    }
    function scheduleRoot(root, element) {
      root.context === emptyContextObject &&
        (updateContainerImpl(root.current, 2, element, root, null, null),
        flushSyncWork$1());
    }
    function scheduleRefresh(root, update) {
      if (null !== resolveFamily) {
        var staleFamilies = update.staleFamilies;
        update = update.updatedFamilies;
        flushPendingEffects();
        scheduleFibersWithFamiliesRecursively(
          root.current,
          update,
          staleFamilies
        );
        flushSyncWork$1();
      }
    }
    function setRefreshHandler(handler) {
      resolveFamily = handler;
    }
    function isValidContainer(node) {
      return !(
        !node ||
        (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType)
      );
    }
    function getNearestMountedFiber(fiber) {
      var node = fiber,
        nearestMounted = fiber;
      if (fiber.alternate) for (; node.return; ) node = node.return;
      else {
        fiber = node;
        do
          (node = fiber),
            0 !== (node.flags & 4098) && (nearestMounted = node.return),
            (fiber = node.return);
        while (fiber);
      }
      return 3 === node.tag ? nearestMounted : null;
    }
    function getSuspenseInstanceFromFiber(fiber) {
      if (13 === fiber.tag) {
        var suspenseState = fiber.memoizedState;
        null === suspenseState &&
          ((fiber = fiber.alternate),
          null !== fiber && (suspenseState = fiber.memoizedState));
        if (null !== suspenseState) return suspenseState.dehydrated;
      }
      return null;
    }
    function assertIsMounted(fiber) {
      if (getNearestMountedFiber(fiber) !== fiber)
        throw Error("Unable to find node on an unmounted component.");
    }
    function findCurrentFiberUsingSlowPath(fiber) {
      var alternate = fiber.alternate;
      if (!alternate) {
        alternate = getNearestMountedFiber(fiber);
        if (null === alternate)
          throw Error("Unable to find node on an unmounted component.");
        return alternate !== fiber ? null : fiber;
      }
      for (var a = fiber, b = alternate; ; ) {
        var parentA = a.return;
        if (null === parentA) break;
        var parentB = parentA.alternate;
        if (null === parentB) {
          b = parentA.return;
          if (null !== b) {
            a = b;
            continue;
          }
          break;
        }
        if (parentA.child === parentB.child) {
          for (parentB = parentA.child; parentB; ) {
            if (parentB === a) return assertIsMounted(parentA), fiber;
            if (parentB === b) return assertIsMounted(parentA), alternate;
            parentB = parentB.sibling;
          }
          throw Error("Unable to find node on an unmounted component.");
        }
        if (a.return !== b.return) (a = parentA), (b = parentB);
        else {
          for (var didFindChild = !1, _child = parentA.child; _child; ) {
            if (_child === a) {
              didFindChild = !0;
              a = parentA;
              b = parentB;
              break;
            }
            if (_child === b) {
              didFindChild = !0;
              b = parentA;
              a = parentB;
              break;
            }
            _child = _child.sibling;
          }
          if (!didFindChild) {
            for (_child = parentB.child; _child; ) {
              if (_child === a) {
                didFindChild = !0;
                a = parentB;
                b = parentA;
                break;
              }
              if (_child === b) {
                didFindChild = !0;
                b = parentB;
                a = parentA;
                break;
              }
              _child = _child.sibling;
            }
            if (!didFindChild)
              throw Error(
                "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
              );
          }
        }
        if (a.alternate !== b)
          throw Error(
            "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
          );
      }
      if (3 !== a.tag)
        throw Error("Unable to find node on an unmounted component.");
      return a.stateNode.current === a ? fiber : alternate;
    }
    function findCurrentHostFiberImpl(node) {
      var tag = node.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
      for (node = node.child; null !== node; ) {
        tag = findCurrentHostFiberImpl(node);
        if (null !== tag) return tag;
        node = node.sibling;
      }
      return null;
    }
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable)
        return null;
      maybeIterable =
        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
        maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type)
        return type.$$typeof === REACT_CLIENT_REFERENCE
          ? null
          : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if ("object" === typeof type)
        switch (
          ("number" === typeof type.tag &&
            console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ),
          type.$$typeof)
        ) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return (type.displayName || "Context") + ".Provider";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type ||
              ((type = innerType.displayName || innerType.name || ""),
              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
            return type;
          case REACT_MEMO_TYPE:
            return (
              (innerType = type.displayName || null),
              null !== innerType
                ? innerType
                : getComponentNameFromType(type.type) || "Memo"
            );
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {}
        }
      return null;
    }
    function getComponentNameFromOwner(owner) {
      return "number" === typeof owner.tag
        ? getComponentNameFromFiber(owner)
        : "string" === typeof owner.name
          ? owner.name
          : null;
    }
    function getComponentNameFromFiber(fiber) {
      var type = fiber.type;
      switch (fiber.tag) {
        case 31:
          return "Activity";
        case 24:
          return "Cache";
        case 9:
          return (type._context.displayName || "Context") + ".Consumer";
        case 10:
          return (type.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return (
            (fiber = type.render),
            (fiber = fiber.displayName || fiber.name || ""),
            type.displayName ||
              ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef")
          );
        case 7:
          return "Fragment";
        case 26:
        case 27:
        case 5:
          return type;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return getComponentNameFromType(type);
        case 8:
          return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 14:
        case 15:
          if ("function" === typeof type)
            return type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          break;
        case 29:
          type = fiber._debugInfo;
          if (null != type)
            for (var i = type.length - 1; 0 <= i; i--)
              if ("string" === typeof type[i].name) return type[i].name;
          if (null !== fiber.return)
            return getComponentNameFromFiber(fiber.return);
      }
      return null;
    }
    function createCursor(defaultValue) {
      return { current: defaultValue };
    }
    function pop(cursor, fiber) {
      0 > index$jscomp$0
        ? console.error("Unexpected pop.")
        : (fiber !== fiberStack[index$jscomp$0] &&
            console.error("Unexpected Fiber popped."),
          (cursor.current = valueStack[index$jscomp$0]),
          (valueStack[index$jscomp$0] = null),
          (fiberStack[index$jscomp$0] = null),
          index$jscomp$0--);
    }
    function push(cursor, value, fiber) {
      index$jscomp$0++;
      valueStack[index$jscomp$0] = cursor.current;
      fiberStack[index$jscomp$0] = fiber;
      cursor.current = value;
    }
    function requiredContext(c) {
      null === c &&
        console.error(
          "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
        );
      return c;
    }
    function pushHostContainer(fiber, nextRootInstance) {
      push(rootInstanceStackCursor, nextRootInstance, fiber);
      push(contextFiberStackCursor, fiber, fiber);
      push(contextStackCursor, null, fiber);
      var nextRootContext = nextRootInstance.nodeType;
      switch (nextRootContext) {
        case 9:
        case 11:
          nextRootContext = 9 === nextRootContext ? "#document" : "#fragment";
          nextRootInstance = (nextRootInstance =
            nextRootInstance.documentElement)
            ? (nextRootInstance = nextRootInstance.namespaceURI)
              ? getOwnHostContext(nextRootInstance)
              : HostContextNamespaceNone
            : HostContextNamespaceNone;
          break;
        default:
          if (
            ((nextRootContext = nextRootInstance.tagName),
            (nextRootInstance = nextRootInstance.namespaceURI))
          )
            (nextRootInstance = getOwnHostContext(nextRootInstance)),
              (nextRootInstance = getChildHostContextProd(
                nextRootInstance,
                nextRootContext
              ));
          else
            switch (nextRootContext) {
              case "svg":
                nextRootInstance = HostContextNamespaceSvg;
                break;
              case "math":
                nextRootInstance = HostContextNamespaceMath;
                break;
              default:
                nextRootInstance = HostContextNamespaceNone;
            }
      }
      nextRootContext = nextRootContext.toLowerCase();
      nextRootContext = updatedAncestorInfoDev(null, nextRootContext);
      nextRootContext = {
        context: nextRootInstance,
        ancestorInfo: nextRootContext
      };
      pop(contextStackCursor, fiber);
      push(contextStackCursor, nextRootContext, fiber);
    }
    function popHostContainer(fiber) {
      pop(contextStackCursor, fiber);
      pop(contextFiberStackCursor, fiber);
      pop(rootInstanceStackCursor, fiber);
    }
    function getHostContext() {
      return requiredContext(contextStackCursor.current);
    }
    function pushHostContext(fiber) {
      null !== fiber.memoizedState &&
        push(hostTransitionProviderCursor, fiber, fiber);
      var context = requiredContext(contextStackCursor.current);
      var type = fiber.type;
      var nextContext = getChildHostContextProd(context.context, type);
      type = updatedAncestorInfoDev(context.ancestorInfo, type);
      nextContext = { context: nextContext, ancestorInfo: type };
      context !== nextContext &&
        (push(contextFiberStackCursor, fiber, fiber),
        push(contextStackCursor, nextContext, fiber));
    }
    function popHostContext(fiber) {
      contextFiberStackCursor.current === fiber &&
        (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
      hostTransitionProviderCursor.current === fiber &&
        (pop(hostTransitionProviderCursor, fiber),
        (HostTransitionContext._currentValue = NotPendingTransition));
    }
    function typeName(value) {
      return (
        ("function" === typeof Symbol &&
          Symbol.toStringTag &&
          value[Symbol.toStringTag]) ||
        value.constructor.name ||
        "Object"
      );
    }
    function willCoercionThrow(value) {
      try {
        return testStringCoercion(value), !1;
      } catch (e) {
        return !0;
      }
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkAttributeStringCoercion(value, attributeName) {
      if (willCoercionThrow(value))
        return (
          console.error(
            "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
            attributeName,
            typeName(value)
          ),
          testStringCoercion(value)
        );
    }
    function checkCSSPropertyStringCoercion(value, propName) {
      if (willCoercionThrow(value))
        return (
          console.error(
            "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
            propName,
            typeName(value)
          ),
          testStringCoercion(value)
        );
    }
    function checkFormFieldValueStringCoercion(value) {
      if (willCoercionThrow(value))
        return (
          console.error(
            "Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",
            typeName(value)
          ),
          testStringCoercion(value)
        );
    }
    function injectInternals(internals) {
      if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
      var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (hook.isDisabled) return !0;
      if (!hook.supportsFiber)
        return (
          console.error(
            "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
          ),
          !0
        );
      try {
        (rendererID = hook.inject(internals)), (injectedHook = hook);
      } catch (err) {
        console.error("React instrumentation encountered an error: %s.", err);
      }
      return hook.checkDCE ? !0 : !1;
    }
    function setIsStrictModeForDevtools(newIsStrictMode) {
      "function" === typeof log$1 &&
        unstable_setDisableYieldValue(newIsStrictMode);
      if (injectedHook && "function" === typeof injectedHook.setStrictMode)
        try {
          injectedHook.setStrictMode(rendererID, newIsStrictMode);
        } catch (err) {
          hasLoggedError ||
            ((hasLoggedError = !0),
            console.error(
              "React instrumentation encountered an error: %s",
              err
            ));
        }
    }
    function injectProfilingHooks(profilingHooks) {
      injectedProfilingHooks = profilingHooks;
    }
    function markCommitStopped() {
      null !== injectedProfilingHooks &&
        "function" === typeof injectedProfilingHooks.markCommitStopped &&
        injectedProfilingHooks.markCommitStopped();
    }
    function markComponentRenderStarted(fiber) {
      null !== injectedProfilingHooks &&
        "function" ===
          typeof injectedProfilingHooks.markComponentRenderStarted &&
        injectedProfilingHooks.markComponentRenderStarted(fiber);
    }
    function markComponentRenderStopped() {
      null !== injectedProfilingHooks &&
        "function" ===
          typeof injectedProfilingHooks.markComponentRenderStopped &&
        injectedProfilingHooks.markComponentRenderStopped();
    }
    function markRenderStarted(lanes) {
      null !== injectedProfilingHooks &&
        "function" === typeof injectedProfilingHooks.markRenderStarted &&
        injectedProfilingHooks.markRenderStarted(lanes);
    }
    function markRenderStopped() {
      null !== injectedProfilingHooks &&
        "function" === typeof injectedProfilingHooks.markRenderStopped &&
        injectedProfilingHooks.markRenderStopped();
    }
    function markStateUpdateScheduled(fiber, lane) {
      null !== injectedProfilingHooks &&
        "function" === typeof injectedProfilingHooks.markStateUpdateScheduled &&
        injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
    }
    function clz32Fallback(x) {
      x >>>= 0;
      return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;
    }
    function getLabelForLane(lane) {
      if (lane & 1) return "SyncHydrationLane";
      if (lane & 2) return "Sync";
      if (lane & 4) return "InputContinuousHydration";
      if (lane & 8) return "InputContinuous";
      if (lane & 16) return "DefaultHydration";
      if (lane & 32) return "Default";
      if (lane & 128) return "TransitionHydration";
      if (lane & 4194048) return "Transition";
      if (lane & 62914560) return "Retry";
      if (lane & 67108864) return "SelectiveHydration";
      if (lane & 134217728) return "IdleHydration";
      if (lane & 268435456) return "Idle";
      if (lane & 536870912) return "Offscreen";
      if (lane & 1073741824) return "Deferred";
    }
    function getHighestPriorityLanes(lanes) {
      var pendingSyncLanes = lanes & 42;
      if (0 !== pendingSyncLanes) return pendingSyncLanes;
      switch (lanes & -lanes) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return lanes & 4194048;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return lanes & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return (
            console.error(
              "Should have found matching lanes. This is a bug in React."
            ),
            lanes
          );
      }
    }
    function getNextLanes(root, wipLanes, rootHasPendingCommit) {
      var pendingLanes = root.pendingLanes;
      if (0 === pendingLanes) return 0;
      var nextLanes = 0,
        suspendedLanes = root.suspendedLanes,
        pingedLanes = root.pingedLanes;
      root = root.warmLanes;
      var nonIdlePendingLanes = pendingLanes & 134217727;
      0 !== nonIdlePendingLanes
        ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),
          0 !== pendingLanes
            ? (nextLanes = getHighestPriorityLanes(pendingLanes))
            : ((pingedLanes &= nonIdlePendingLanes),
              0 !== pingedLanes
                ? (nextLanes = getHighestPriorityLanes(pingedLanes))
                : rootHasPendingCommit ||
                  ((rootHasPendingCommit = nonIdlePendingLanes & ~root),
                  0 !== rootHasPendingCommit &&
                    (nextLanes =
                      getHighestPriorityLanes(rootHasPendingCommit)))))
        : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),
          0 !== nonIdlePendingLanes
            ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))
            : 0 !== pingedLanes
              ? (nextLanes = getHighestPriorityLanes(pingedLanes))
              : rootHasPendingCommit ||
                ((rootHasPendingCommit = pendingLanes & ~root),
                0 !== rootHasPendingCommit &&
                  (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
      return 0 === nextLanes
        ? 0
        : 0 !== wipLanes &&
            wipLanes !== nextLanes &&
            0 === (wipLanes & suspendedLanes) &&
            ((suspendedLanes = nextLanes & -nextLanes),
            (rootHasPendingCommit = wipLanes & -wipLanes),
            suspendedLanes >= rootHasPendingCommit ||
              (32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)))
          ? wipLanes
          : nextLanes;
    }
    function checkIfRootIsPrerendering(root, renderLanes) {
      return (
        0 ===
        (root.pendingLanes &
          ~(root.suspendedLanes & ~root.pingedLanes) &
          renderLanes)
      );
    }
    function computeExpirationTime(lane, currentTime) {
      switch (lane) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return currentTime + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return currentTime + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return (
            console.error(
              "Should have found matching lanes. This is a bug in React."
            ),
            -1
          );
      }
    }
    function claimNextTransitionLane() {
      var lane = nextTransitionLane;
      nextTransitionLane <<= 1;
      0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
      return lane;
    }
    function claimNextRetryLane() {
      var lane = nextRetryLane;
      nextRetryLane <<= 1;
      0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
      return lane;
    }
    function createLaneMap(initial) {
      for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
      return laneMap;
    }
    function markRootUpdated$1(root, updateLane) {
      root.pendingLanes |= updateLane;
      268435456 !== updateLane &&
        ((root.suspendedLanes = 0),
        (root.pingedLanes = 0),
        (root.warmLanes = 0));
    }
    function markRootFinished(
      root,
      finishedLanes,
      remainingLanes,
      spawnedLane,
      updatedLanes,
      suspendedRetryLanes
    ) {
      var previouslyPendingLanes = root.pendingLanes;
      root.pendingLanes = remainingLanes;
      root.suspendedLanes = 0;
      root.pingedLanes = 0;
      root.warmLanes = 0;
      root.expiredLanes &= remainingLanes;
      root.entangledLanes &= remainingLanes;
      root.errorRecoveryDisabledLanes &= remainingLanes;
      root.shellSuspendCounter = 0;
      var entanglements = root.entanglements,
        expirationTimes = root.expirationTimes,
        hiddenUpdates = root.hiddenUpdates;
      for (
        remainingLanes = previouslyPendingLanes & ~remainingLanes;
        0 < remainingLanes;

      ) {
        var index = 31 - clz32(remainingLanes),
          lane = 1 << index;
        entanglements[index] = 0;
        expirationTimes[index] = -1;
        var hiddenUpdatesForLane = hiddenUpdates[index];
        if (null !== hiddenUpdatesForLane)
          for (
            hiddenUpdates[index] = null, index = 0;
            index < hiddenUpdatesForLane.length;
            index++
          ) {
            var update = hiddenUpdatesForLane[index];
            null !== update && (update.lane &= -536870913);
          }
        remainingLanes &= ~lane;
      }
      0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
      0 !== suspendedRetryLanes &&
        0 === updatedLanes &&
        0 !== root.tag &&
        (root.suspendedLanes |=
          suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
    }
    function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
      root.pendingLanes |= spawnedLane;
      root.suspendedLanes &= ~spawnedLane;
      var spawnedLaneIndex = 31 - clz32(spawnedLane);
      root.entangledLanes |= spawnedLane;
      root.entanglements[spawnedLaneIndex] =
        root.entanglements[spawnedLaneIndex] |
        1073741824 |
        (entangledLanes & 4194090);
    }
    function markRootEntangled(root, entangledLanes) {
      var rootEntangledLanes = (root.entangledLanes |= entangledLanes);
      for (root = root.entanglements; rootEntangledLanes; ) {
        var index = 31 - clz32(rootEntangledLanes),
          lane = 1 << index;
        (lane & entangledLanes) | (root[index] & entangledLanes) &&
          (root[index] |= entangledLanes);
        rootEntangledLanes &= ~lane;
      }
    }
    function getBumpedLaneForHydrationByLane(lane) {
      switch (lane) {
        case 2:
          lane = 1;
          break;
        case 8:
          lane = 4;
          break;
        case 32:
          lane = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          lane = 128;
          break;
        case 268435456:
          lane = 134217728;
          break;
        default:
          lane = 0;
      }
      return lane;
    }
    function addFiberToLanesMap(root, fiber, lanes) {
      if (isDevToolsPresent)
        for (root = root.pendingUpdatersLaneMap; 0 < lanes; ) {
          var index = 31 - clz32(lanes),
            lane = 1 << index;
          root[index].add(fiber);
          lanes &= ~lane;
        }
    }
    function movePendingFibersToMemoized(root, lanes) {
      if (isDevToolsPresent)
        for (
          var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap,
            memoizedUpdaters = root.memoizedUpdaters;
          0 < lanes;

        ) {
          var index = 31 - clz32(lanes);
          root = 1 << index;
          index = pendingUpdatersLaneMap[index];
          0 < index.size &&
            (index.forEach(function (fiber) {
              var alternate = fiber.alternate;
              (null !== alternate && memoizedUpdaters.has(alternate)) ||
                memoizedUpdaters.add(fiber);
            }),
            index.clear());
          lanes &= ~root;
        }
    }
    function lanesToEventPriority(lanes) {
      lanes &= -lanes;
      return 0 !== DiscreteEventPriority && DiscreteEventPriority < lanes
        ? 0 !== ContinuousEventPriority && ContinuousEventPriority < lanes
          ? 0 !== (lanes & 134217727)
            ? DefaultEventPriority
            : IdleEventPriority
          : ContinuousEventPriority
        : DiscreteEventPriority;
    }
    function resolveUpdatePriority() {
      var updatePriority = ReactDOMSharedInternals.p;
      if (0 !== updatePriority) return updatePriority;
      updatePriority = window.event;
      return void 0 === updatePriority
        ? DefaultEventPriority
        : getEventPriority(updatePriority.type);
    }
    function runWithPriority(priority, fn) {
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        return (ReactDOMSharedInternals.p = priority), fn();
      } finally {
        ReactDOMSharedInternals.p = previousPriority;
      }
    }
    function detachDeletedInstance(node) {
      delete node[internalInstanceKey];
      delete node[internalPropsKey];
      delete node[internalEventHandlersKey];
      delete node[internalEventHandlerListenersKey];
      delete node[internalEventHandlesSetKey];
    }
    function getClosestInstanceFromNode(targetNode) {
      var targetInst = targetNode[internalInstanceKey];
      if (targetInst) return targetInst;
      for (var parentNode = targetNode.parentNode; parentNode; ) {
        if (
          (targetInst =
            parentNode[internalContainerInstanceKey] ||
            parentNode[internalInstanceKey])
        ) {
          parentNode = targetInst.alternate;
          if (
            null !== targetInst.child ||
            (null !== parentNode && null !== parentNode.child)
          )
            for (
              targetNode = getParentSuspenseInstance(targetNode);
              null !== targetNode;

            ) {
              if ((parentNode = targetNode[internalInstanceKey]))
                return parentNode;
              targetNode = getParentSuspenseInstance(targetNode);
            }
          return targetInst;
        }
        targetNode = parentNode;
        parentNode = targetNode.parentNode;
      }
      return null;
    }
    function getInstanceFromNode(node) {
      if (
        (node = node[internalInstanceKey] || node[internalContainerInstanceKey])
      ) {
        var tag = node.tag;
        if (
          5 === tag ||
          6 === tag ||
          13 === tag ||
          26 === tag ||
          27 === tag ||
          3 === tag
        )
          return node;
      }
      return null;
    }
    function getNodeFromInstance(inst) {
      var tag = inst.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag)
        return inst.stateNode;
      throw Error("getNodeFromInstance: Invalid argument.");
    }
    function getResourcesFromRoot(root) {
      var resources = root[internalRootNodeResourcesKey];
      resources ||
        (resources = root[internalRootNodeResourcesKey] =
          { hoistableStyles: new Map(), hoistableScripts: new Map() });
      return resources;
    }
    function markNodeAsHoistable(node) {
      node[internalHoistableMarker] = !0;
    }
    function registerTwoPhaseEvent(registrationName, dependencies) {
      registerDirectEvent(registrationName, dependencies);
      registerDirectEvent(registrationName + "Capture", dependencies);
    }
    function registerDirectEvent(registrationName, dependencies) {
      registrationNameDependencies[registrationName] &&
        console.error(
          "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
          registrationName
        );
      registrationNameDependencies[registrationName] = dependencies;
      var lowerCasedName = registrationName.toLowerCase();
      possibleRegistrationNames[lowerCasedName] = registrationName;
      "onDoubleClick" === registrationName &&
        (possibleRegistrationNames.ondblclick = registrationName);
      for (
        registrationName = 0;
        registrationName < dependencies.length;
        registrationName++
      )
        allNativeEvents.add(dependencies[registrationName]);
    }
    function checkControlledValueProps(tagName, props) {
      hasReadOnlyValue[props.type] ||
        props.onChange ||
        props.onInput ||
        props.readOnly ||
        props.disabled ||
        null == props.value ||
        ("select" === tagName
          ? console.error(
              "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
            )
          : console.error(
              "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
            ));
      props.onChange ||
        props.readOnly ||
        props.disabled ||
        null == props.checked ||
        console.error(
          "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
        );
    }
    function isAttributeNameSafe(attributeName) {
      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
        return !0;
      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
        return !1;
      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
        return (validatedAttributeNameCache[attributeName] = !0);
      illegalAttributeNameCache[attributeName] = !0;
      console.error("Invalid attribute name: `%s`", attributeName);
      return !1;
    }
    function getValueForAttributeOnCustomComponent(node, name, expected) {
      if (isAttributeNameSafe(name)) {
        if (!node.hasAttribute(name)) {
          switch (typeof expected) {
            case "symbol":
            case "object":
              return expected;
            case "function":
              return expected;
            case "boolean":
              if (!1 === expected) return expected;
          }
          return void 0 === expected ? void 0 : null;
        }
        node = node.getAttribute(name);
        if ("" === node && !0 === expected) return !0;
        checkAttributeStringCoercion(expected, name);
        return node === "" + expected ? expected : node;
      }
    }
    function setValueForAttribute(node, name, value) {
      if (isAttributeNameSafe(name))
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
              node.removeAttribute(name);
              return;
            case "boolean":
              var prefix = name.toLowerCase().slice(0, 5);
              if ("data-" !== prefix && "aria-" !== prefix) {
                node.removeAttribute(name);
                return;
              }
          }
          checkAttributeStringCoercion(value, name);
          node.setAttribute(name, "" + value);
        }
    }
    function setValueForKnownAttribute(node, name, value) {
      if (null === value) node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node.removeAttribute(name);
            return;
        }
        checkAttributeStringCoercion(value, name);
        node.setAttribute(name, "" + value);
      }
    }
    function setValueForNamespacedAttribute(node, namespace, name, value) {
      if (null === value) node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node.removeAttribute(name);
            return;
        }
        checkAttributeStringCoercion(value, name);
        node.setAttributeNS(namespace, name, "" + value);
      }
    }
    function disabledLog() {}
    function disableLogs() {
      if (0 === disabledDepth) {
        prevLog = console.log;
        prevInfo = console.info;
        prevWarn = console.warn;
        prevError = console.error;
        prevGroup = console.group;
        prevGroupCollapsed = console.groupCollapsed;
        prevGroupEnd = console.groupEnd;
        var props = {
          configurable: !0,
          enumerable: !0,
          value: disabledLog,
          writable: !0
        };
        Object.defineProperties(console, {
          info: props,
          log: props,
          warn: props,
          error: props,
          group: props,
          groupCollapsed: props,
          groupEnd: props
        });
      }
      disabledDepth++;
    }
    function reenableLogs() {
      disabledDepth--;
      if (0 === disabledDepth) {
        var props = { configurable: !0, enumerable: !0, writable: !0 };
        Object.defineProperties(console, {
          log: assign({}, props, { value: prevLog }),
          info: assign({}, props, { value: prevInfo }),
          warn: assign({}, props, { value: prevWarn }),
          error: assign({}, props, { value: prevError }),
          group: assign({}, props, { value: prevGroup }),
          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
          groupEnd: assign({}, props, { value: prevGroupEnd })
        });
      }
      0 > disabledDepth &&
        console.error(
          "disabledDepth fell below zero. This is a bug in React. Please file an issue."
        );
    }
    function describeBuiltInComponentFrame(name) {
      if (void 0 === prefix)
        try {
          throw Error();
        } catch (x) {
          var match = x.stack.trim().match(/\n( *(at )?)/);
          prefix = (match && match[1]) || "";
          suffix =
            -1 < x.stack.indexOf("\n    at")
              ? " (<anonymous>)"
              : -1 < x.stack.indexOf("@")
                ? "@unknown:0:0"
                : "";
        }
      return "\n" + prefix + name + suffix;
    }
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry) return "";
      var frame = componentFrameCache.get(fn);
      if (void 0 !== frame) return frame;
      reentry = !0;
      frame = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var previousDispatcher = null;
      previousDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = null;
      disableLogs();
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function () {
            try {
              if (construct) {
                var Fake = function () {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function () {
                    throw Error();
                  }
                });
                if ("object" === typeof Reflect && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    var control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$0) {
                    control = x$0;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$1) {
                  control = x$1;
                }
                (Fake = fn()) &&
                  "function" === typeof Fake.catch &&
                  Fake.catch(function () {});
              }
            } catch (sample) {
              if (sample && control && "string" === typeof sample.stack)
                return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName =
          "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name"
        );
        namePropDescriptor &&
          namePropDescriptor.configurable &&
          Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
        var _RunInRootFrame$Deter =
            RunInRootFrame.DetermineComponentFrameRoot(),
          sampleStack = _RunInRootFrame$Deter[0],
          controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split("\n"),
            controlLines = controlStack.split("\n");
          for (
            _RunInRootFrame$Deter = namePropDescriptor = 0;
            namePropDescriptor < sampleLines.length &&
            !sampleLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            );

          )
            namePropDescriptor++;
          for (
            ;
            _RunInRootFrame$Deter < controlLines.length &&
            !controlLines[_RunInRootFrame$Deter].includes(
              "DetermineComponentFrameRoot"
            );

          )
            _RunInRootFrame$Deter++;
          if (
            namePropDescriptor === sampleLines.length ||
            _RunInRootFrame$Deter === controlLines.length
          )
            for (
              namePropDescriptor = sampleLines.length - 1,
                _RunInRootFrame$Deter = controlLines.length - 1;
              1 <= namePropDescriptor &&
              0 <= _RunInRootFrame$Deter &&
              sampleLines[namePropDescriptor] !==
                controlLines[_RunInRootFrame$Deter];

            )
              _RunInRootFrame$Deter--;
          for (
            ;
            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;
            namePropDescriptor--, _RunInRootFrame$Deter--
          )
            if (
              sampleLines[namePropDescriptor] !==
              controlLines[_RunInRootFrame$Deter]
            ) {
              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                do
                  if (
                    (namePropDescriptor--,
                    _RunInRootFrame$Deter--,
                    0 > _RunInRootFrame$Deter ||
                      sampleLines[namePropDescriptor] !==
                        controlLines[_RunInRootFrame$Deter])
                  ) {
                    var _frame =
                      "\n" +
                      sampleLines[namePropDescriptor].replace(
                        " at new ",
                        " at "
                      );
                    fn.displayName &&
                      _frame.includes("<anonymous>") &&
                      (_frame = _frame.replace("<anonymous>", fn.displayName));
                    "function" === typeof fn &&
                      componentFrameCache.set(fn, _frame);
                    return _frame;
                  }
                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
              }
              break;
            }
        }
      } finally {
        (reentry = !1),
          (ReactSharedInternals.H = previousDispatcher),
          reenableLogs(),
          (Error.prepareStackTrace = frame);
      }
      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "")
        ? describeBuiltInComponentFrame(sampleLines)
        : "";
      "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
      return sampleLines;
    }
    function formatOwnerStack(error) {
      var prevPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      error = error.stack;
      Error.prepareStackTrace = prevPrepareStackTrace;
      error.startsWith("Error: react-stack-top-frame\n") &&
        (error = error.slice(29));
      prevPrepareStackTrace = error.indexOf("\n");
      -1 !== prevPrepareStackTrace &&
        (error = error.slice(prevPrepareStackTrace + 1));
      prevPrepareStackTrace = error.indexOf("react-stack-bottom-frame");
      -1 !== prevPrepareStackTrace &&
        (prevPrepareStackTrace = error.lastIndexOf(
          "\n",
          prevPrepareStackTrace
        ));
      if (-1 !== prevPrepareStackTrace)
        error = error.slice(0, prevPrepareStackTrace);
      else return "";
      return error;
    }
    function describeFiber(fiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return describeBuiltInComponentFrame(fiber.type);
        case 16:
          return describeBuiltInComponentFrame("Lazy");
        case 13:
          return describeBuiltInComponentFrame("Suspense");
        case 19:
          return describeBuiltInComponentFrame("SuspenseList");
        case 0:
        case 15:
          return describeNativeComponentFrame(fiber.type, !1);
        case 11:
          return describeNativeComponentFrame(fiber.type.render, !1);
        case 1:
          return describeNativeComponentFrame(fiber.type, !0);
        case 31:
          return describeBuiltInComponentFrame("Activity");
        default:
          return "";
      }
    }
    function getStackByFiberInDevAndProd(workInProgress) {
      try {
        var info = "";
        do {
          info += describeFiber(workInProgress);
          var debugInfo = workInProgress._debugInfo;
          if (debugInfo)
            for (var i = debugInfo.length - 1; 0 <= i; i--) {
              var entry = debugInfo[i];
              if ("string" === typeof entry.name) {
                var JSCompiler_temp_const = info,
                  env = entry.env;
                var JSCompiler_inline_result = describeBuiltInComponentFrame(
                  entry.name + (env ? " [" + env + "]" : "")
                );
                info = JSCompiler_temp_const + JSCompiler_inline_result;
              }
            }
          workInProgress = workInProgress.return;
        } while (workInProgress);
        return info;
      } catch (x) {
        return "\nError generating stack: " + x.message + "\n" + x.stack;
      }
    }
    function describeFunctionComponentFrameWithoutLineNumber(fn) {
      return (fn = fn ? fn.displayName || fn.name : "")
        ? describeBuiltInComponentFrame(fn)
        : "";
    }
    function getCurrentFiberOwnerNameInDevOrNull() {
      if (null === current) return null;
      var owner = current._debugOwner;
      return null != owner ? getComponentNameFromOwner(owner) : null;
    }
    function getCurrentFiberStackInDev() {
      if (null === current) return "";
      var workInProgress = current;
      try {
        var info = "";
        6 === workInProgress.tag && (workInProgress = workInProgress.return);
        switch (workInProgress.tag) {
          case 26:
          case 27:
          case 5:
            info += describeBuiltInComponentFrame(workInProgress.type);
            break;
          case 13:
            info += describeBuiltInComponentFrame("Suspense");
            break;
          case 19:
            info += describeBuiltInComponentFrame("SuspenseList");
            break;
          case 31:
            info += describeBuiltInComponentFrame("Activity");
            break;
          case 30:
          case 0:
          case 15:
          case 1:
            workInProgress._debugOwner ||
              "" !== info ||
              (info += describeFunctionComponentFrameWithoutLineNumber(
                workInProgress.type
              ));
            break;
          case 11:
            workInProgress._debugOwner ||
              "" !== info ||
              (info += describeFunctionComponentFrameWithoutLineNumber(
                workInProgress.type.render
              ));
        }
        for (; workInProgress; )
          if ("number" === typeof workInProgress.tag) {
            var fiber = workInProgress;
            workInProgress = fiber._debugOwner;
            var debugStack = fiber._debugStack;
            workInProgress &&
              debugStack &&
              ("string" !== typeof debugStack &&
                (fiber._debugStack = debugStack = formatOwnerStack(debugStack)),
              "" !== debugStack && (info += "\n" + debugStack));
          } else if (null != workInProgress.debugStack) {
            var ownerStack = workInProgress.debugStack;
            (workInProgress = workInProgress.owner) &&
              ownerStack &&
              (info += "\n" + formatOwnerStack(ownerStack));
          } else break;
        var JSCompiler_inline_result = info;
      } catch (x) {
        JSCompiler_inline_result =
          "\nError generating stack: " + x.message + "\n" + x.stack;
      }
      return JSCompiler_inline_result;
    }
    function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
      var previousFiber = current;
      setCurrentFiber(fiber);
      try {
        return null !== fiber && fiber._debugTask
          ? fiber._debugTask.run(
              callback.bind(null, arg0, arg1, arg2, arg3, arg4)
            )
          : callback(arg0, arg1, arg2, arg3, arg4);
      } finally {
        setCurrentFiber(previousFiber);
      }
      throw Error(
        "runWithFiberInDEV should never be called in production. This is a bug in React."
      );
    }
    function setCurrentFiber(fiber) {
      ReactSharedInternals.getCurrentStack =
        null === fiber ? null : getCurrentFiberStackInDev;
      isRendering = !1;
      current = fiber;
    }
    function getToStringValue(value) {
      switch (typeof value) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return value;
        case "object":
          return checkFormFieldValueStringCoercion(value), value;
        default:
          return "";
      }
    }
    function isCheckable(elem) {
      var type = elem.type;
      return (
        (elem = elem.nodeName) &&
        "input" === elem.toLowerCase() &&
        ("checkbox" === type || "radio" === type)
      );
    }
    function trackValueOnNode(node) {
      var valueField = isCheckable(node) ? "checked" : "value",
        descriptor = Object.getOwnPropertyDescriptor(
          node.constructor.prototype,
          valueField
        );
      checkFormFieldValueStringCoercion(node[valueField]);
      var currentValue = "" + node[valueField];
      if (
        !node.hasOwnProperty(valueField) &&
        "undefined" !== typeof descriptor &&
        "function" === typeof descriptor.get &&
        "function" === typeof descriptor.set
      ) {
        var get = descriptor.get,
          set = descriptor.set;
        Object.defineProperty(node, valueField, {
          configurable: !0,
          get: function () {
            return get.call(this);
          },
          set: function (value) {
            checkFormFieldValueStringCoercion(value);
            currentValue = "" + value;
            set.call(this, value);
          }
        });
        Object.defineProperty(node, valueField, {
          enumerable: descriptor.enumerable
        });
        return {
          getValue: function () {
            return currentValue;
          },
          setValue: function (value) {
            checkFormFieldValueStringCoercion(value);
            currentValue = "" + value;
          },
          stopTracking: function () {
            node._valueTracker = null;
            delete node[valueField];
          }
        };
      }
    }
    function track(node) {
      node._valueTracker || (node._valueTracker = trackValueOnNode(node));
    }
    function updateValueIfChanged(node) {
      if (!node) return !1;
      var tracker = node._valueTracker;
      if (!tracker) return !0;
      var lastValue = tracker.getValue();
      var value = "";
      node &&
        (value = isCheckable(node)
          ? node.checked
            ? "true"
            : "false"
          : node.value);
      node = value;
      return node !== lastValue ? (tracker.setValue(node), !0) : !1;
    }
    function getActiveElement(doc) {
      doc = doc || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof doc) return null;
      try {
        return doc.activeElement || doc.body;
      } catch (e) {
        return doc.body;
      }
    }
    function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
      return value.replace(
        escapeSelectorAttributeValueInsideDoubleQuotesRegex,
        function (ch) {
          return "\\" + ch.charCodeAt(0).toString(16) + " ";
        }
      );
    }
    function validateInputProps(element, props) {
      void 0 === props.checked ||
        void 0 === props.defaultChecked ||
        didWarnCheckedDefaultChecked ||
        (console.error(
          "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
          getCurrentFiberOwnerNameInDevOrNull() || "A component",
          props.type
        ),
        (didWarnCheckedDefaultChecked = !0));
      void 0 === props.value ||
        void 0 === props.defaultValue ||
        didWarnValueDefaultValue$1 ||
        (console.error(
          "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
          getCurrentFiberOwnerNameInDevOrNull() || "A component",
          props.type
        ),
        (didWarnValueDefaultValue$1 = !0));
    }
    function updateInput(
      element,
      value,
      defaultValue,
      lastDefaultValue,
      checked,
      defaultChecked,
      type,
      name
    ) {
      element.name = "";
      null != type &&
      "function" !== typeof type &&
      "symbol" !== typeof type &&
      "boolean" !== typeof type
        ? (checkAttributeStringCoercion(type, "type"), (element.type = type))
        : element.removeAttribute("type");
      if (null != value)
        if ("number" === type) {
          if ((0 === value && "" === element.value) || element.value != value)
            element.value = "" + getToStringValue(value);
        } else
          element.value !== "" + getToStringValue(value) &&
            (element.value = "" + getToStringValue(value));
      else
        ("submit" !== type && "reset" !== type) ||
          element.removeAttribute("value");
      null != value
        ? setDefaultValue(element, type, getToStringValue(value))
        : null != defaultValue
          ? setDefaultValue(element, type, getToStringValue(defaultValue))
          : null != lastDefaultValue && element.removeAttribute("value");
      null == checked &&
        null != defaultChecked &&
        (element.defaultChecked = !!defaultChecked);
      null != checked &&
        (element.checked =
          checked &&
          "function" !== typeof checked &&
          "symbol" !== typeof checked);
      null != name &&
      "function" !== typeof name &&
      "symbol" !== typeof name &&
      "boolean" !== typeof name
        ? (checkAttributeStringCoercion(name, "name"),
          (element.name = "" + getToStringValue(name)))
        : element.removeAttribute("name");
    }
    function initInput(
      element,
      value,
      defaultValue,
      checked,
      defaultChecked,
      type,
      name,
      isHydrating
    ) {
      null != type &&
        "function" !== typeof type &&
        "symbol" !== typeof type &&
        "boolean" !== typeof type &&
        (checkAttributeStringCoercion(type, "type"), (element.type = type));
      if (null != value || null != defaultValue) {
        if (
          !(
            ("submit" !== type && "reset" !== type) ||
            (void 0 !== value && null !== value)
          )
        )
          return;
        defaultValue =
          null != defaultValue ? "" + getToStringValue(defaultValue) : "";
        value = null != value ? "" + getToStringValue(value) : defaultValue;
        isHydrating || value === element.value || (element.value = value);
        element.defaultValue = value;
      }
      checked = null != checked ? checked : defaultChecked;
      checked =
        "function" !== typeof checked &&
        "symbol" !== typeof checked &&
        !!checked;
      element.checked = isHydrating ? element.checked : !!checked;
      element.defaultChecked = !!checked;
      null != name &&
        "function" !== typeof name &&
        "symbol" !== typeof name &&
        "boolean" !== typeof name &&
        (checkAttributeStringCoercion(name, "name"), (element.name = name));
    }
    function setDefaultValue(node, type, value) {
      ("number" === type && getActiveElement(node.ownerDocument) === node) ||
        node.defaultValue === "" + value ||
        (node.defaultValue = "" + value);
    }
    function validateOptionProps(element, props) {
      null == props.value &&
        ("object" === typeof props.children && null !== props.children
          ? React.Children.forEach(props.children, function (child) {
              null == child ||
                "string" === typeof child ||
                "number" === typeof child ||
                "bigint" === typeof child ||
                didWarnInvalidChild ||
                ((didWarnInvalidChild = !0),
                console.error(
                  "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
                ));
            })
          : null == props.dangerouslySetInnerHTML ||
            didWarnInvalidInnerHTML ||
            ((didWarnInvalidInnerHTML = !0),
            console.error(
              "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
            )));
      null == props.selected ||
        didWarnSelectedSetOnOption ||
        (console.error(
          "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
        ),
        (didWarnSelectedSetOnOption = !0));
    }
    function getDeclarationErrorAddendum() {
      var ownerName = getCurrentFiberOwnerNameInDevOrNull();
      return ownerName
        ? "\n\nCheck the render method of `" + ownerName + "`."
        : "";
    }
    function updateOptions(node, multiple, propValue, setDefaultSelected) {
      node = node.options;
      if (multiple) {
        multiple = {};
        for (var i = 0; i < propValue.length; i++)
          multiple["$" + propValue[i]] = !0;
        for (propValue = 0; propValue < node.length; propValue++)
          (i = multiple.hasOwnProperty("$" + node[propValue].value)),
            node[propValue].selected !== i && (node[propValue].selected = i),
            i && setDefaultSelected && (node[propValue].defaultSelected = !0);
      } else {
        propValue = "" + getToStringValue(propValue);
        multiple = null;
        for (i = 0; i < node.length; i++) {
          if (node[i].value === propValue) {
            node[i].selected = !0;
            setDefaultSelected && (node[i].defaultSelected = !0);
            return;
          }
          null !== multiple || node[i].disabled || (multiple = node[i]);
        }
        null !== multiple && (multiple.selected = !0);
      }
    }
    function validateSelectProps(element, props) {
      for (element = 0; element < valuePropNames.length; element++) {
        var propName = valuePropNames[element];
        if (null != props[propName]) {
          var propNameIsArray = isArrayImpl(props[propName]);
          props.multiple && !propNameIsArray
            ? console.error(
                "The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",
                propName,
                getDeclarationErrorAddendum()
              )
            : !props.multiple &&
              propNameIsArray &&
              console.error(
                "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",
                propName,
                getDeclarationErrorAddendum()
              );
        }
      }
      void 0 === props.value ||
        void 0 === props.defaultValue ||
        didWarnValueDefaultValue ||
        (console.error(
          "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
        ),
        (didWarnValueDefaultValue = !0));
    }
    function validateTextareaProps(element, props) {
      void 0 === props.value ||
        void 0 === props.defaultValue ||
        didWarnValDefaultVal ||
        (console.error(
          "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
          getCurrentFiberOwnerNameInDevOrNull() || "A component"
        ),
        (didWarnValDefaultVal = !0));
      null != props.children &&
        null == props.value &&
        console.error(
          "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
        );
    }
    function updateTextarea(element, value, defaultValue) {
      if (
        null != value &&
        ((value = "" + getToStringValue(value)),
        value !== element.value && (element.value = value),
        null == defaultValue)
      ) {
        element.defaultValue !== value && (element.defaultValue = value);
        return;
      }
      element.defaultValue =
        null != defaultValue ? "" + getToStringValue(defaultValue) : "";
    }
    function initTextarea(element, value, defaultValue, children) {
      if (null == value) {
        if (null != children) {
          if (null != defaultValue)
            throw Error(
              "If you supply `defaultValue` on a <textarea>, do not pass children."
            );
          if (isArrayImpl(children)) {
            if (1 < children.length)
              throw Error("<textarea> can only have at most one child.");
            children = children[0];
          }
          defaultValue = children;
        }
        null == defaultValue && (defaultValue = "");
        value = defaultValue;
      }
      defaultValue = getToStringValue(value);
      element.defaultValue = defaultValue;
      children = element.textContent;
      children === defaultValue &&
        "" !== children &&
        null !== children &&
        (element.value = children);
    }
    function findNotableNode(node, indent) {
      return void 0 === node.serverProps &&
        0 === node.serverTail.length &&
        1 === node.children.length &&
        3 < node.distanceFromLeaf &&
        node.distanceFromLeaf > 15 - indent
        ? findNotableNode(node.children[0], indent)
        : node;
    }
    function indentation(indent) {
      return "  " + "  ".repeat(indent);
    }
    function added(indent) {
      return "+ " + "  ".repeat(indent);
    }
    function removed(indent) {
      return "- " + "  ".repeat(indent);
    }
    function describeFiberType(fiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return fiber.type;
        case 16:
          return "Lazy";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 0:
        case 15:
          return (fiber = fiber.type), fiber.displayName || fiber.name || null;
        case 11:
          return (
            (fiber = fiber.type.render), fiber.displayName || fiber.name || null
          );
        case 1:
          return (fiber = fiber.type), fiber.displayName || fiber.name || null;
        default:
          return null;
      }
    }
    function describeTextNode(content, maxLength) {
      return needsEscaping.test(content)
        ? ((content = JSON.stringify(content)),
          content.length > maxLength - 2
            ? 8 > maxLength
              ? '{"..."}'
              : "{" + content.slice(0, maxLength - 7) + '..."}'
            : "{" + content + "}")
        : content.length > maxLength
          ? 5 > maxLength
            ? '{"..."}'
            : content.slice(0, maxLength - 3) + "..."
          : content;
    }
    function describeTextDiff(clientText, serverProps, indent) {
      var maxLength = 120 - 2 * indent;
      if (null === serverProps)
        return added(indent) + describeTextNode(clientText, maxLength) + "\n";
      if ("string" === typeof serverProps) {
        for (
          var firstDiff = 0;
          firstDiff < serverProps.length &&
          firstDiff < clientText.length &&
          serverProps.charCodeAt(firstDiff) ===
            clientText.charCodeAt(firstDiff);
          firstDiff++
        );
        firstDiff > maxLength - 8 &&
          10 < firstDiff &&
          ((clientText = "..." + clientText.slice(firstDiff - 8)),
          (serverProps = "..." + serverProps.slice(firstDiff - 8)));
        return (
          added(indent) +
          describeTextNode(clientText, maxLength) +
          "\n" +
          removed(indent) +
          describeTextNode(serverProps, maxLength) +
          "\n"
        );
      }
      return (
        indentation(indent) + describeTextNode(clientText, maxLength) + "\n"
      );
    }
    function objectName(object) {
      return Object.prototype.toString
        .call(object)
        .replace(/^\[object (.*)\]$/, function (m, p0) {
          return p0;
        });
    }
    function describeValue(value, maxLength) {
      switch (typeof value) {
        case "string":
          return (
            (value = JSON.stringify(value)),
            value.length > maxLength
              ? 5 > maxLength
                ? '"..."'
                : value.slice(0, maxLength - 4) + '..."'
              : value
          );
        case "object":
          if (null === value) return "null";
          if (isArrayImpl(value)) return "[...]";
          if (value.$$typeof === REACT_ELEMENT_TYPE)
            return (maxLength = getComponentNameFromType(value.type))
              ? "<" + maxLength + ">"
              : "<...>";
          var name = objectName(value);
          if ("Object" === name) {
            name = "";
            maxLength -= 2;
            for (var propName in value)
              if (value.hasOwnProperty(propName)) {
                var jsonPropName = JSON.stringify(propName);
                jsonPropName !== '"' + propName + '"' &&
                  (propName = jsonPropName);
                maxLength -= propName.length - 2;
                jsonPropName = describeValue(
                  value[propName],
                  15 > maxLength ? maxLength : 15
                );
                maxLength -= jsonPropName.length;
                if (0 > maxLength) {
                  name += "" === name ? "..." : ", ...";
                  break;
                }
                name +=
                  ("" === name ? "" : ",") + propName + ":" + jsonPropName;
              }
            return "{" + name + "}";
          }
          return name;
        case "function":
          return (maxLength = value.displayName || value.name)
            ? "function " + maxLength
            : "function";
        default:
          return String(value);
      }
    }
    function describePropValue(value, maxLength) {
      return "string" !== typeof value || needsEscaping.test(value)
        ? "{" + describeValue(value, maxLength - 2) + "}"
        : value.length > maxLength - 2
          ? 5 > maxLength
            ? '"..."'
            : '"' + value.slice(0, maxLength - 5) + '..."'
          : '"' + value + '"';
    }
    function describeExpandedElement(type, props, rowPrefix) {
      var remainingRowLength = 120 - rowPrefix.length - type.length,
        properties = [],
        propName;
      for (propName in props)
        if (props.hasOwnProperty(propName) && "children" !== propName) {
          var propValue = describePropValue(
            props[propName],
            120 - rowPrefix.length - propName.length - 1
          );
          remainingRowLength -= propName.length + propValue.length + 2;
          properties.push(propName + "=" + propValue);
        }
      return 0 === properties.length
        ? rowPrefix + "<" + type + ">\n"
        : 0 < remainingRowLength
          ? rowPrefix + "<" + type + " " + properties.join(" ") + ">\n"
          : rowPrefix +
            "<" +
            type +
            "\n" +
            rowPrefix +
            "  " +
            properties.join("\n" + rowPrefix + "  ") +
            "\n" +
            rowPrefix +
            ">\n";
    }
    function describePropertiesDiff(clientObject, serverObject, indent) {
      var properties = "",
        remainingServerProperties = assign({}, serverObject),
        propName;
      for (propName in clientObject)
        if (clientObject.hasOwnProperty(propName)) {
          delete remainingServerProperties[propName];
          var maxLength = 120 - 2 * indent - propName.length - 2,
            clientPropValue = describeValue(clientObject[propName], maxLength);
          serverObject.hasOwnProperty(propName)
            ? ((maxLength = describeValue(serverObject[propName], maxLength)),
              (properties +=
                added(indent) + propName + ": " + clientPropValue + "\n"),
              (properties +=
                removed(indent) + propName + ": " + maxLength + "\n"))
            : (properties +=
                added(indent) + propName + ": " + clientPropValue + "\n");
        }
      for (var _propName in remainingServerProperties)
        remainingServerProperties.hasOwnProperty(_propName) &&
          ((clientObject = describeValue(
            remainingServerProperties[_propName],
            120 - 2 * indent - _propName.length - 2
          )),
          (properties +=
            removed(indent) + _propName + ": " + clientObject + "\n"));
      return properties;
    }
    function describeElementDiff(type, clientProps, serverProps, indent) {
      var content = "",
        serverPropNames = new Map();
      for (propName$jscomp$0 in serverProps)
        serverProps.hasOwnProperty(propName$jscomp$0) &&
          serverPropNames.set(
            propName$jscomp$0.toLowerCase(),
            propName$jscomp$0
          );
      if (1 === serverPropNames.size && serverPropNames.has("children"))
        content += describeExpandedElement(
          type,
          clientProps,
          indentation(indent)
        );
      else {
        for (var _propName2 in clientProps)
          if (
            clientProps.hasOwnProperty(_propName2) &&
            "children" !== _propName2
          ) {
            var maxLength$jscomp$0 =
                120 - 2 * (indent + 1) - _propName2.length - 1,
              serverPropName = serverPropNames.get(_propName2.toLowerCase());
            if (void 0 !== serverPropName) {
              serverPropNames.delete(_propName2.toLowerCase());
              var propName$jscomp$0 = clientProps[_propName2];
              serverPropName = serverProps[serverPropName];
              var clientPropValue = describePropValue(
                propName$jscomp$0,
                maxLength$jscomp$0
              );
              maxLength$jscomp$0 = describePropValue(
                serverPropName,
                maxLength$jscomp$0
              );
              "object" === typeof propName$jscomp$0 &&
              null !== propName$jscomp$0 &&
              "object" === typeof serverPropName &&
              null !== serverPropName &&
              "Object" === objectName(propName$jscomp$0) &&
              "Object" === objectName(serverPropName) &&
              (2 < Object.keys(propName$jscomp$0).length ||
                2 < Object.keys(serverPropName).length ||
                -1 < clientPropValue.indexOf("...") ||
                -1 < maxLength$jscomp$0.indexOf("..."))
                ? (content +=
                    indentation(indent + 1) +
                    _propName2 +
                    "={{\n" +
                    describePropertiesDiff(
                      propName$jscomp$0,
                      serverPropName,
                      indent + 2
                    ) +
                    indentation(indent + 1) +
                    "}}\n")
                : ((content +=
                    added(indent + 1) +
                    _propName2 +
                    "=" +
                    clientPropValue +
                    "\n"),
                  (content +=
                    removed(indent + 1) +
                    _propName2 +
                    "=" +
                    maxLength$jscomp$0 +
                    "\n"));
            } else
              content +=
                indentation(indent + 1) +
                _propName2 +
                "=" +
                describePropValue(clientProps[_propName2], maxLength$jscomp$0) +
                "\n";
          }
        serverPropNames.forEach(function (propName) {
          if ("children" !== propName) {
            var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
            content +=
              removed(indent + 1) +
              propName +
              "=" +
              describePropValue(serverProps[propName], maxLength) +
              "\n";
          }
        });
        content =
          "" === content
            ? indentation(indent) + "<" + type + ">\n"
            : indentation(indent) +
              "<" +
              type +
              "\n" +
              content +
              indentation(indent) +
              ">\n";
      }
      type = serverProps.children;
      clientProps = clientProps.children;
      if (
        "string" === typeof type ||
        "number" === typeof type ||
        "bigint" === typeof type
      ) {
        serverPropNames = "";
        if (
          "string" === typeof clientProps ||
          "number" === typeof clientProps ||
          "bigint" === typeof clientProps
        )
          serverPropNames = "" + clientProps;
        content += describeTextDiff(serverPropNames, "" + type, indent + 1);
      } else if (
        "string" === typeof clientProps ||
        "number" === typeof clientProps ||
        "bigint" === typeof clientProps
      )
        content =
          null == type
            ? content + describeTextDiff("" + clientProps, null, indent + 1)
            : content + describeTextDiff("" + clientProps, void 0, indent + 1);
      return content;
    }
    function describeSiblingFiber(fiber, indent) {
      var type = describeFiberType(fiber);
      if (null === type) {
        type = "";
        for (fiber = fiber.child; fiber; )
          (type += describeSiblingFiber(fiber, indent)),
            (fiber = fiber.sibling);
        return type;
      }
      return indentation(indent) + "<" + type + ">\n";
    }
    function describeNode(node, indent) {
      var skipToNode = findNotableNode(node, indent);
      if (
        skipToNode !== node &&
        (1 !== node.children.length || node.children[0] !== skipToNode)
      )
        return (
          indentation(indent) + "...\n" + describeNode(skipToNode, indent + 1)
        );
      skipToNode = "";
      var debugInfo = node.fiber._debugInfo;
      if (debugInfo)
        for (var i = 0; i < debugInfo.length; i++) {
          var serverComponentName = debugInfo[i].name;
          "string" === typeof serverComponentName &&
            ((skipToNode +=
              indentation(indent) + "<" + serverComponentName + ">\n"),
            indent++);
        }
      debugInfo = "";
      i = node.fiber.pendingProps;
      if (6 === node.fiber.tag)
        (debugInfo = describeTextDiff(i, node.serverProps, indent)), indent++;
      else if (
        ((serverComponentName = describeFiberType(node.fiber)),
        null !== serverComponentName)
      )
        if (void 0 === node.serverProps) {
          debugInfo = indent;
          var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2,
            content = "";
          for (propName in i)
            if (i.hasOwnProperty(propName) && "children" !== propName) {
              var propValue = describePropValue(i[propName], 15);
              maxLength -= propName.length + propValue.length + 2;
              if (0 > maxLength) {
                content += " ...";
                break;
              }
              content += " " + propName + "=" + propValue;
            }
          debugInfo =
            indentation(debugInfo) +
            "<" +
            serverComponentName +
            content +
            ">\n";
          indent++;
        } else
          null === node.serverProps
            ? ((debugInfo = describeExpandedElement(
                serverComponentName,
                i,
                added(indent)
              )),
              indent++)
            : "string" === typeof node.serverProps
              ? console.error(
                  "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
                )
              : ((debugInfo = describeElementDiff(
                  serverComponentName,
                  i,
                  node.serverProps,
                  indent
                )),
                indent++);
      var propName = "";
      i = node.fiber.child;
      for (
        serverComponentName = 0;
        i && serverComponentName < node.children.length;

      )
        (maxLength = node.children[serverComponentName]),
          maxLength.fiber === i
            ? ((propName += describeNode(maxLength, indent)),
              serverComponentName++)
            : (propName += describeSiblingFiber(i, indent)),
          (i = i.sibling);
      i &&
        0 < node.children.length &&
        (propName += indentation(indent) + "...\n");
      i = node.serverTail;
      null === node.serverProps && indent--;
      for (node = 0; node < i.length; node++)
        (serverComponentName = i[node]),
          (propName =
            "string" === typeof serverComponentName
              ? propName +
                (removed(indent) +
                  describeTextNode(serverComponentName, 120 - 2 * indent) +
                  "\n")
              : propName +
                describeExpandedElement(
                  serverComponentName.type,
                  serverComponentName.props,
                  removed(indent)
                ));
      return skipToNode + debugInfo + propName;
    }
    function describeDiff(rootNode) {
      try {
        return "\n\n" + describeNode(rootNode, 0);
      } catch (x) {
        return "";
      }
    }
    function describeAncestors(ancestor, child, props) {
      for (var fiber = child, node = null, distanceFromLeaf = 0; fiber; )
        fiber === ancestor && (distanceFromLeaf = 0),
          (node = {
            fiber: fiber,
            children: null !== node ? [node] : [],
            serverProps:
              fiber === child ? props : fiber === ancestor ? null : void 0,
            serverTail: [],
            distanceFromLeaf: distanceFromLeaf
          }),
          distanceFromLeaf++,
          (fiber = fiber.return);
      return null !== node ? describeDiff(node).replaceAll(/^[+-]/gm, ">") : "";
    }
    function updatedAncestorInfoDev(oldInfo, tag) {
      var ancestorInfo = assign({}, oldInfo || emptyAncestorInfoDev),
        info = { tag: tag };
      -1 !== inScopeTags.indexOf(tag) &&
        ((ancestorInfo.aTagInScope = null),
        (ancestorInfo.buttonTagInScope = null),
        (ancestorInfo.nobrTagInScope = null));
      -1 !== buttonScopeTags.indexOf(tag) &&
        (ancestorInfo.pTagInButtonScope = null);
      -1 !== specialTags.indexOf(tag) &&
        "address" !== tag &&
        "div" !== tag &&
        "p" !== tag &&
        ((ancestorInfo.listItemTagAutoclosing = null),
        (ancestorInfo.dlItemTagAutoclosing = null));
      ancestorInfo.current = info;
      "form" === tag && (ancestorInfo.formTag = info);
      "a" === tag && (ancestorInfo.aTagInScope = info);
      "button" === tag && (ancestorInfo.buttonTagInScope = info);
      "nobr" === tag && (ancestorInfo.nobrTagInScope = info);
      "p" === tag && (ancestorInfo.pTagInButtonScope = info);
      "li" === tag && (ancestorInfo.listItemTagAutoclosing = info);
      if ("dd" === tag || "dt" === tag)
        ancestorInfo.dlItemTagAutoclosing = info;
      "#document" === tag || "html" === tag
        ? (ancestorInfo.containerTagInScope = null)
        : ancestorInfo.containerTagInScope ||
          (ancestorInfo.containerTagInScope = info);
      null !== oldInfo ||
      ("#document" !== tag && "html" !== tag && "body" !== tag)
        ? !0 === ancestorInfo.implicitRootScope &&
          (ancestorInfo.implicitRootScope = !1)
        : (ancestorInfo.implicitRootScope = !0);
      return ancestorInfo;
    }
    function isTagValidWithParent(tag, parentTag, implicitRootScope) {
      switch (parentTag) {
        case "select":
          return (
            "hr" === tag ||
            "option" === tag ||
            "optgroup" === tag ||
            "script" === tag ||
            "template" === tag ||
            "#text" === tag
          );
        case "optgroup":
          return "option" === tag || "#text" === tag;
        case "option":
          return "#text" === tag;
        case "tr":
          return (
            "th" === tag ||
            "td" === tag ||
            "style" === tag ||
            "script" === tag ||
            "template" === tag
          );
        case "tbody":
        case "thead":
        case "tfoot":
          return (
            "tr" === tag ||
            "style" === tag ||
            "script" === tag ||
            "template" === tag
          );
        case "colgroup":
          return "col" === tag || "template" === tag;
        case "table":
          return (
            "caption" === tag ||
            "colgroup" === tag ||
            "tbody" === tag ||
            "tfoot" === tag ||
            "thead" === tag ||
            "style" === tag ||
            "script" === tag ||
            "template" === tag
          );
        case "head":
          return (
            "base" === tag ||
            "basefont" === tag ||
            "bgsound" === tag ||
            "link" === tag ||
            "meta" === tag ||
            "title" === tag ||
            "noscript" === tag ||
            "noframes" === tag ||
            "style" === tag ||
            "script" === tag ||
            "template" === tag
          );
        case "html":
          if (implicitRootScope) break;
          return "head" === tag || "body" === tag || "frameset" === tag;
        case "frameset":
          return "frame" === tag;
        case "#document":
          if (!implicitRootScope) return "html" === tag;
      }
      switch (tag) {
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return (
            "h1" !== parentTag &&
            "h2" !== parentTag &&
            "h3" !== parentTag &&
            "h4" !== parentTag &&
            "h5" !== parentTag &&
            "h6" !== parentTag
          );
        case "rp":
        case "rt":
          return -1 === impliedEndTags.indexOf(parentTag);
        case "caption":
        case "col":
        case "colgroup":
        case "frameset":
        case "frame":
        case "tbody":
        case "td":
        case "tfoot":
        case "th":
        case "thead":
        case "tr":
          return null == parentTag;
        case "head":
          return implicitRootScope || null === parentTag;
        case "html":
          return (
            (implicitRootScope && "#document" === parentTag) ||
            null === parentTag
          );
        case "body":
          return (
            (implicitRootScope &&
              ("#document" === parentTag || "html" === parentTag)) ||
            null === parentTag
          );
      }
      return !0;
    }
    function findInvalidAncestorForTag(tag, ancestorInfo) {
      switch (tag) {
        case "address":
        case "article":
        case "aside":
        case "blockquote":
        case "center":
        case "details":
        case "dialog":
        case "dir":
        case "div":
        case "dl":
        case "fieldset":
        case "figcaption":
        case "figure":
        case "footer":
        case "header":
        case "hgroup":
        case "main":
        case "menu":
        case "nav":
        case "ol":
        case "p":
        case "section":
        case "summary":
        case "ul":
        case "pre":
        case "listing":
        case "table":
        case "hr":
        case "xmp":
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return ancestorInfo.pTagInButtonScope;
        case "form":
          return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
        case "li":
          return ancestorInfo.listItemTagAutoclosing;
        case "dd":
        case "dt":
          return ancestorInfo.dlItemTagAutoclosing;
        case "button":
          return ancestorInfo.buttonTagInScope;
        case "a":
          return ancestorInfo.aTagInScope;
        case "nobr":
          return ancestorInfo.nobrTagInScope;
      }
      return null;
    }
    function findAncestor(parent, tagName) {
      for (; parent; ) {
        switch (parent.tag) {
          case 5:
          case 26:
          case 27:
            if (parent.type === tagName) return parent;
        }
        parent = parent.return;
      }
      return null;
    }
    function validateDOMNesting(childTag, ancestorInfo) {
      ancestorInfo = ancestorInfo || emptyAncestorInfoDev;
      var parentInfo = ancestorInfo.current;
      ancestorInfo = (parentInfo = isTagValidWithParent(
        childTag,
        parentInfo && parentInfo.tag,
        ancestorInfo.implicitRootScope
      )
        ? null
        : parentInfo)
        ? null
        : findInvalidAncestorForTag(childTag, ancestorInfo);
      ancestorInfo = parentInfo || ancestorInfo;
      if (!ancestorInfo) return !0;
      var ancestorTag = ancestorInfo.tag;
      ancestorInfo = String(!!parentInfo) + "|" + childTag + "|" + ancestorTag;
      if (didWarn[ancestorInfo]) return !1;
      didWarn[ancestorInfo] = !0;
      var ancestor = (ancestorInfo = current)
          ? findAncestor(ancestorInfo.return, ancestorTag)
          : null,
        ancestorDescription =
          null !== ancestorInfo && null !== ancestor
            ? describeAncestors(ancestor, ancestorInfo, null)
            : "",
        tagDisplayName = "<" + childTag + ">";
      parentInfo
        ? ((parentInfo = ""),
          "table" === ancestorTag &&
            "tr" === childTag &&
            (parentInfo +=
              " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."),
          console.error(
            "In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s",
            tagDisplayName,
            ancestorTag,
            parentInfo,
            ancestorDescription
          ))
        : console.error(
            "In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s",
            tagDisplayName,
            ancestorTag,
            ancestorDescription
          );
      ancestorInfo &&
        ((childTag = ancestorInfo.return),
        null === ancestor ||
          null === childTag ||
          (ancestor === childTag &&
            childTag._debugOwner === ancestorInfo._debugOwner) ||
          runWithFiberInDEV(ancestor, function () {
            console.error(
              "<%s> cannot contain a nested %s.\nSee this log for the ancestor stack trace.",
              ancestorTag,
              tagDisplayName
            );
          }));
      return !1;
    }
    function validateTextNesting(childText, parentTag, implicitRootScope) {
      if (implicitRootScope || isTagValidWithParent("#text", parentTag, !1))
        return !0;
      implicitRootScope = "#text|" + parentTag;
      if (didWarn[implicitRootScope]) return !1;
      didWarn[implicitRootScope] = !0;
      var ancestor = (implicitRootScope = current)
        ? findAncestor(implicitRootScope, parentTag)
        : null;
      implicitRootScope =
        null !== implicitRootScope && null !== ancestor
          ? describeAncestors(
              ancestor,
              implicitRootScope,
              6 !== implicitRootScope.tag ? { children: null } : null
            )
          : "";
      /\S/.test(childText)
        ? console.error(
            "In HTML, text nodes cannot be a child of <%s>.\nThis will cause a hydration error.%s",
            parentTag,
            implicitRootScope
          )
        : console.error(
            "In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\nThis will cause a hydration error.%s",
            parentTag,
            implicitRootScope
          );
      return !1;
    }
    function setTextContent(node, text) {
      if (text) {
        var firstChild = node.firstChild;
        if (
          firstChild &&
          firstChild === node.lastChild &&
          3 === firstChild.nodeType
        ) {
          firstChild.nodeValue = text;
          return;
        }
      }
      node.textContent = text;
    }
    function camelize(string) {
      return string.replace(hyphenPattern, function (_, character) {
        return character.toUpperCase();
      });
    }
    function setValueForStyle(style, styleName, value) {
      var isCustomProperty = 0 === styleName.indexOf("--");
      isCustomProperty ||
        (-1 < styleName.indexOf("-")
          ? (warnedStyleNames.hasOwnProperty(styleName) &&
              warnedStyleNames[styleName]) ||
            ((warnedStyleNames[styleName] = !0),
            console.error(
              "Unsupported style property %s. Did you mean %s?",
              styleName,
              camelize(styleName.replace(msPattern, "ms-"))
            ))
          : badVendoredStyleNamePattern.test(styleName)
            ? (warnedStyleNames.hasOwnProperty(styleName) &&
                warnedStyleNames[styleName]) ||
              ((warnedStyleNames[styleName] = !0),
              console.error(
                "Unsupported vendor-prefixed style property %s. Did you mean %s?",
                styleName,
                styleName.charAt(0).toUpperCase() + styleName.slice(1)
              ))
            : !badStyleValueWithSemicolonPattern.test(value) ||
              (warnedStyleValues.hasOwnProperty(value) &&
                warnedStyleValues[value]) ||
              ((warnedStyleValues[value] = !0),
              console.error(
                'Style property values shouldn\'t contain a semicolon. Try "%s: %s" instead.',
                styleName,
                value.replace(badStyleValueWithSemicolonPattern, "")
              )),
        "number" === typeof value &&
          (isNaN(value)
            ? warnedForNaNValue ||
              ((warnedForNaNValue = !0),
              console.error(
                "`NaN` is an invalid value for the `%s` css style property.",
                styleName
              ))
            : isFinite(value) ||
              warnedForInfinityValue ||
              ((warnedForInfinityValue = !0),
              console.error(
                "`Infinity` is an invalid value for the `%s` css style property.",
                styleName
              ))));
      null == value || "boolean" === typeof value || "" === value
        ? isCustomProperty
          ? style.setProperty(styleName, "")
          : "float" === styleName
            ? (style.cssFloat = "")
            : (style[styleName] = "")
        : isCustomProperty
          ? style.setProperty(styleName, value)
          : "number" !== typeof value ||
              0 === value ||
              unitlessNumbers.has(styleName)
            ? "float" === styleName
              ? (style.cssFloat = value)
              : (checkCSSPropertyStringCoercion(value, styleName),
                (style[styleName] = ("" + value).trim()))
            : (style[styleName] = value + "px");
    }
    function setValueForStyles(node, styles, prevStyles) {
      if (null != styles && "object" !== typeof styles)
        throw Error(
          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
        );
      styles && Object.freeze(styles);
      node = node.style;
      if (null != prevStyles) {
        if (styles) {
          var expandedUpdates = {};
          if (prevStyles)
            for (var key in prevStyles)
              if (prevStyles.hasOwnProperty(key) && !styles.hasOwnProperty(key))
                for (
                  var longhands = shorthandToLonghand[key] || [key], i = 0;
                  i < longhands.length;
                  i++
                )
                  expandedUpdates[longhands[i]] = key;
          for (var _key in styles)
            if (
              styles.hasOwnProperty(_key) &&
              (!prevStyles || prevStyles[_key] !== styles[_key])
            )
              for (
                key = shorthandToLonghand[_key] || [_key], longhands = 0;
                longhands < key.length;
                longhands++
              )
                expandedUpdates[key[longhands]] = _key;
          _key = {};
          for (var key$jscomp$0 in styles)
            for (
              key = shorthandToLonghand[key$jscomp$0] || [key$jscomp$0],
                longhands = 0;
              longhands < key.length;
              longhands++
            )
              _key[key[longhands]] = key$jscomp$0;
          key$jscomp$0 = {};
          for (var _key2 in expandedUpdates)
            if (
              ((key = expandedUpdates[_key2]),
              (longhands = _key[_key2]) &&
                key !== longhands &&
                ((i = key + "," + longhands), !key$jscomp$0[i]))
            ) {
              key$jscomp$0[i] = !0;
              i = console;
              var value = styles[key];
              i.error.call(
                i,
                "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
                null == value || "boolean" === typeof value || "" === value
                  ? "Removing"
                  : "Updating",
                key,
                longhands
              );
            }
        }
        for (var styleName in prevStyles)
          !prevStyles.hasOwnProperty(styleName) ||
            (null != styles && styles.hasOwnProperty(styleName)) ||
            (0 === styleName.indexOf("--")
              ? node.setProperty(styleName, "")
              : "float" === styleName
                ? (node.cssFloat = "")
                : (node[styleName] = ""));
        for (var _styleName in styles)
          (_key2 = styles[_styleName]),
            styles.hasOwnProperty(_styleName) &&
              prevStyles[_styleName] !== _key2 &&
              setValueForStyle(node, _styleName, _key2);
      } else
        for (expandedUpdates in styles)
          styles.hasOwnProperty(expandedUpdates) &&
            setValueForStyle(node, expandedUpdates, styles[expandedUpdates]);
    }
    function isCustomElement(tagName) {
      if (-1 === tagName.indexOf("-")) return !1;
      switch (tagName) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    function getAttributeAlias(name) {
      return aliases.get(name) || name;
    }
    function validateProperty$1(tagName, name) {
      if (
        hasOwnProperty.call(warnedProperties$1, name) &&
        warnedProperties$1[name]
      )
        return !0;
      if (rARIACamel$1.test(name)) {
        tagName = "aria-" + name.slice(4).toLowerCase();
        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
        if (null == tagName)
          return (
            console.error(
              "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
              name
            ),
            (warnedProperties$1[name] = !0)
          );
        if (name !== tagName)
          return (
            console.error(
              "Invalid ARIA attribute `%s`. Did you mean `%s`?",
              name,
              tagName
            ),
            (warnedProperties$1[name] = !0)
          );
      }
      if (rARIA$1.test(name)) {
        tagName = name.toLowerCase();
        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
        if (null == tagName) return (warnedProperties$1[name] = !0), !1;
        name !== tagName &&
          (console.error(
            "Unknown ARIA attribute `%s`. Did you mean `%s`?",
            name,
            tagName
          ),
          (warnedProperties$1[name] = !0));
      }
      return !0;
    }
    function validateProperties$2(type, props) {
      var invalidProps = [],
        key;
      for (key in props)
        validateProperty$1(type, key) || invalidProps.push(key);
      props = invalidProps
        .map(function (prop) {
          return "`" + prop + "`";
        })
        .join(", ");
      1 === invalidProps.length
        ? console.error(
            "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          )
        : 1 < invalidProps.length &&
          console.error(
            "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          );
    }
    function validateProperty(tagName, name, value, eventRegistry) {
      if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
        return !0;
      var lowerCasedName = name.toLowerCase();
      if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
        return (
          console.error(
            "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
          ),
          (warnedProperties[name] = !0)
        );
      if (
        "function" === typeof value &&
        (("form" === tagName && "action" === name) ||
          ("input" === tagName && "formAction" === name) ||
          ("button" === tagName && "formAction" === name))
      )
        return !0;
      if (null != eventRegistry) {
        tagName = eventRegistry.possibleRegistrationNames;
        if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
          return !0;
        eventRegistry = tagName.hasOwnProperty(lowerCasedName)
          ? tagName[lowerCasedName]
          : null;
        if (null != eventRegistry)
          return (
            console.error(
              "Invalid event handler property `%s`. Did you mean `%s`?",
              name,
              eventRegistry
            ),
            (warnedProperties[name] = !0)
          );
        if (EVENT_NAME_REGEX.test(name))
          return (
            console.error(
              "Unknown event handler property `%s`. It will be ignored.",
              name
            ),
            (warnedProperties[name] = !0)
          );
      } else if (EVENT_NAME_REGEX.test(name))
        return (
          INVALID_EVENT_NAME_REGEX.test(name) &&
            console.error(
              "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
              name
            ),
          (warnedProperties[name] = !0)
        );
      if (rARIA.test(name) || rARIACamel.test(name)) return !0;
      if ("innerhtml" === lowerCasedName)
        return (
          console.error(
            "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
          ),
          (warnedProperties[name] = !0)
        );
      if ("aria" === lowerCasedName)
        return (
          console.error(
            "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
          ),
          (warnedProperties[name] = !0)
        );
      if (
        "is" === lowerCasedName &&
        null !== value &&
        void 0 !== value &&
        "string" !== typeof value
      )
        return (
          console.error(
            "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
            typeof value
          ),
          (warnedProperties[name] = !0)
        );
      if ("number" === typeof value && isNaN(value))
        return (
          console.error(
            "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
            name
          ),
          (warnedProperties[name] = !0)
        );
      if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
        if (
          ((lowerCasedName = possibleStandardNames[lowerCasedName]),
          lowerCasedName !== name)
        )
          return (
            console.error(
              "Invalid DOM property `%s`. Did you mean `%s`?",
              name,
              lowerCasedName
            ),
            (warnedProperties[name] = !0)
          );
      } else if (name !== lowerCasedName)
        return (
          console.error(
            "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
            name,
            lowerCasedName
          ),
          (warnedProperties[name] = !0)
        );
      switch (name) {
        case "dangerouslySetInnerHTML":
        case "children":
        case "style":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          return !0;
        case "innerText":
        case "textContent":
          return !0;
      }
      switch (typeof value) {
        case "boolean":
          switch (name) {
            case "autoFocus":
            case "checked":
            case "multiple":
            case "muted":
            case "selected":
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
            case "capture":
            case "download":
            case "inert":
              return !0;
            default:
              lowerCasedName = name.toLowerCase().slice(0, 5);
              if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
                return !0;
              value
                ? console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                    value,
                    name,
                    name,
                    value,
                    name
                  )
                : console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                    value,
                    name,
                    name,
                    value,
                    name,
                    name,
                    name
                  );
              return (warnedProperties[name] = !0);
          }
        case "function":
        case "symbol":
          return (warnedProperties[name] = !0), !1;
        case "string":
          if ("false" === value || "true" === value) {
            switch (name) {
              case "checked":
              case "selected":
              case "multiple":
              case "muted":
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
              case "inert":
                break;
              default:
                return !0;
            }
            console.error(
              "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
              value,
              name,
              "false" === value
                ? "The browser will interpret it as a truthy value."
                : 'Although this works, it will not work as expected if you pass the string "false".',
              name,
              value
            );
            warnedProperties[name] = !0;
          }
      }
      return !0;
    }
    function warnUnknownProperties(type, props, eventRegistry) {
      var unknownProps = [],
        key;
      for (key in props)
        validateProperty(type, key, props[key], eventRegistry) ||
          unknownProps.push(key);
      props = unknownProps
        .map(function (prop) {
          return "`" + prop + "`";
        })
        .join(", ");
      1 === unknownProps.length
        ? console.error(
            "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          )
        : 1 < unknownProps.length &&
          console.error(
            "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          );
    }
    function sanitizeURL(url) {
      return isJavaScriptProtocol.test("" + url)
        ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
        : url;
    }
    function getEventTarget(nativeEvent) {
      nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
      nativeEvent.correspondingUseElement &&
        (nativeEvent = nativeEvent.correspondingUseElement);
      return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
    }
    function restoreStateOfTarget(target) {
      var internalInstance = getInstanceFromNode(target);
      if (internalInstance && (target = internalInstance.stateNode)) {
        var props = target[internalPropsKey] || null;
        a: switch (
          ((target = internalInstance.stateNode), internalInstance.type)
        ) {
          case "input":
            updateInput(
              target,
              props.value,
              props.defaultValue,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name
            );
            internalInstance = props.name;
            if ("radio" === props.type && null != internalInstance) {
              for (props = target; props.parentNode; ) props = props.parentNode;
              checkAttributeStringCoercion(internalInstance, "name");
              props = props.querySelectorAll(
                'input[name="' +
                  escapeSelectorAttributeValueInsideDoubleQuotes(
                    "" + internalInstance
                  ) +
                  '"][type="radio"]'
              );
              for (
                internalInstance = 0;
                internalInstance < props.length;
                internalInstance++
              ) {
                var otherNode = props[internalInstance];
                if (otherNode !== target && otherNode.form === target.form) {
                  var otherProps = otherNode[internalPropsKey] || null;
                  if (!otherProps)
                    throw Error(
                      "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
                    );
                  updateInput(
                    otherNode,
                    otherProps.value,
                    otherProps.defaultValue,
                    otherProps.defaultValue,
                    otherProps.checked,
                    otherProps.defaultChecked,
                    otherProps.type,
                    otherProps.name
                  );
                }
              }
              for (
                internalInstance = 0;
                internalInstance < props.length;
                internalInstance++
              )
                (otherNode = props[internalInstance]),
                  otherNode.form === target.form &&
                    updateValueIfChanged(otherNode);
            }
            break a;
          case "textarea":
            updateTextarea(target, props.value, props.defaultValue);
            break a;
          case "select":
            (internalInstance = props.value),
              null != internalInstance &&
                updateOptions(target, !!props.multiple, internalInstance, !1);
        }
      }
    }
    function batchedUpdates$1(fn, a, b) {
      if (isInsideEventHandler) return fn(a, b);
      isInsideEventHandler = !0;
      try {
        var JSCompiler_inline_result = fn(a);
        return JSCompiler_inline_result;
      } finally {
        if (
          ((isInsideEventHandler = !1),
          null !== restoreTarget || null !== restoreQueue)
        )
          if (
            (flushSyncWork$1(),
            restoreTarget &&
              ((a = restoreTarget),
              (fn = restoreQueue),
              (restoreQueue = restoreTarget = null),
              restoreStateOfTarget(a),
              fn))
          )
            for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
      }
    }
    function getListener(inst, registrationName) {
      var stateNode = inst.stateNode;
      if (null === stateNode) return null;
      var props = stateNode[internalPropsKey] || null;
      if (null === props) return null;
      stateNode = props[registrationName];
      a: switch (registrationName) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (props = !props.disabled) ||
            ((inst = inst.type),
            (props = !(
              "button" === inst ||
              "input" === inst ||
              "select" === inst ||
              "textarea" === inst
            )));
          inst = !props;
          break a;
        default:
          inst = !1;
      }
      if (inst) return null;
      if (stateNode && "function" !== typeof stateNode)
        throw Error(
          "Expected `" +
            registrationName +
            "` listener to be a function, instead got a value of `" +
            typeof stateNode +
            "` type."
        );
      return stateNode;
    }
    function getData() {
      if (fallbackText) return fallbackText;
      var start,
        startValue = startText,
        startLength = startValue.length,
        end,
        endValue = "value" in root ? root.value : root.textContent,
        endLength = endValue.length;
      for (
        start = 0;
        start < startLength && startValue[start] === endValue[start];
        start++
      );
      var minEnd = startLength - start;
      for (
        end = 1;
        end <= minEnd &&
        startValue[startLength - end] === endValue[endLength - end];
        end++
      );
      return (fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0));
    }
    function getEventCharCode(nativeEvent) {
      var keyCode = nativeEvent.keyCode;
      "charCode" in nativeEvent
        ? ((nativeEvent = nativeEvent.charCode),
          0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))
        : (nativeEvent = keyCode);
      10 === nativeEvent && (nativeEvent = 13);
      return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
    }
    function functionThatReturnsTrue() {
      return !0;
    }
    function functionThatReturnsFalse() {
      return !1;
    }
    function createSyntheticEvent(Interface) {
      function SyntheticBaseEvent(
        reactName,
        reactEventType,
        targetInst,
        nativeEvent,
        nativeEventTarget
      ) {
        this._reactName = reactName;
        this._targetInst = targetInst;
        this.type = reactEventType;
        this.nativeEvent = nativeEvent;
        this.target = nativeEventTarget;
        this.currentTarget = null;
        for (var propName in Interface)
          Interface.hasOwnProperty(propName) &&
            ((reactName = Interface[propName]),
            (this[propName] = reactName
              ? reactName(nativeEvent)
              : nativeEvent[propName]));
        this.isDefaultPrevented = (
          null != nativeEvent.defaultPrevented
            ? nativeEvent.defaultPrevented
            : !1 === nativeEvent.returnValue
        )
          ? functionThatReturnsTrue
          : functionThatReturnsFalse;
        this.isPropagationStopped = functionThatReturnsFalse;
        return this;
      }
      assign(SyntheticBaseEvent.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0;
          var event = this.nativeEvent;
          event &&
            (event.preventDefault
              ? event.preventDefault()
              : "unknown" !== typeof event.returnValue &&
                (event.returnValue = !1),
            (this.isDefaultPrevented = functionThatReturnsTrue));
        },
        stopPropagation: function () {
          var event = this.nativeEvent;
          event &&
            (event.stopPropagation
              ? event.stopPropagation()
              : "unknown" !== typeof event.cancelBubble &&
                (event.cancelBubble = !0),
            (this.isPropagationStopped = functionThatReturnsTrue));
        },
        persist: function () {},
        isPersistent: functionThatReturnsTrue
      });
      return SyntheticBaseEvent;
    }
    function modifierStateGetter(keyArg) {
      var nativeEvent = this.nativeEvent;
      return nativeEvent.getModifierState
        ? nativeEvent.getModifierState(keyArg)
        : (keyArg = modifierKeyToProp[keyArg])
          ? !!nativeEvent[keyArg]
          : !1;
    }
    function getEventModifierState() {
      return modifierStateGetter;
    }
    function isFallbackCompositionEnd(domEventName, nativeEvent) {
      switch (domEventName) {
        case "keyup":
          return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
        case "keydown":
          return nativeEvent.keyCode !== START_KEYCODE;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function getDataFromCustomEvent(nativeEvent) {
      nativeEvent = nativeEvent.detail;
      return "object" === typeof nativeEvent && "data" in nativeEvent
        ? nativeEvent.data
        : null;
    }
    function getNativeBeforeInputChars(domEventName, nativeEvent) {
      switch (domEventName) {
        case "compositionend":
          return getDataFromCustomEvent(nativeEvent);
        case "keypress":
          if (nativeEvent.which !== SPACEBAR_CODE) return null;
          hasSpaceKeypress = !0;
          return SPACEBAR_CHAR;
        case "textInput":
          return (
            (domEventName = nativeEvent.data),
            domEventName === SPACEBAR_CHAR && hasSpaceKeypress
              ? null
              : domEventName
          );
        default:
          return null;
      }
    }
    function getFallbackBeforeInputChars(domEventName, nativeEvent) {
      if (isComposing)
        return "compositionend" === domEventName ||
          (!canUseCompositionEvent &&
            isFallbackCompositionEnd(domEventName, nativeEvent))
          ? ((domEventName = getData()),
            (fallbackText = startText = root = null),
            (isComposing = !1),
            domEventName)
          : null;
      switch (domEventName) {
        case "paste":
          return null;
        case "keypress":
          if (
            !(
              nativeEvent.ctrlKey ||
              nativeEvent.altKey ||
              nativeEvent.metaKey
            ) ||
            (nativeEvent.ctrlKey && nativeEvent.altKey)
          ) {
            if (nativeEvent.char && 1 < nativeEvent.char.length)
              return nativeEvent.char;
            if (nativeEvent.which)
              return String.fromCharCode(nativeEvent.which);
          }
          return null;
        case "compositionend":
          return useFallbackCompositionData && "ko" !== nativeEvent.locale
            ? null
            : nativeEvent.data;
        default:
          return null;
      }
    }
    function isTextInputElement(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return "input" === nodeName
        ? !!supportedInputTypes[elem.type]
        : "textarea" === nodeName
          ? !0
          : !1;
    }
    function isEventSupported(eventNameSuffix) {
      if (!canUseDOM) return !1;
      eventNameSuffix = "on" + eventNameSuffix;
      var isSupported = eventNameSuffix in document;
      isSupported ||
        ((isSupported = document.createElement("div")),
        isSupported.setAttribute(eventNameSuffix, "return;"),
        (isSupported = "function" === typeof isSupported[eventNameSuffix]));
      return isSupported;
    }
    function createAndAccumulateChangeEvent(
      dispatchQueue,
      inst,
      nativeEvent,
      target
    ) {
      restoreTarget
        ? restoreQueue
          ? restoreQueue.push(target)
          : (restoreQueue = [target])
        : (restoreTarget = target);
      inst = accumulateTwoPhaseListeners(inst, "onChange");
      0 < inst.length &&
        ((nativeEvent = new SyntheticEvent(
          "onChange",
          "change",
          null,
          nativeEvent,
          target
        )),
        dispatchQueue.push({ event: nativeEvent, listeners: inst }));
    }
    function runEventInBatch(dispatchQueue) {
      processDispatchQueue(dispatchQueue, 0);
    }
    function getInstIfValueChanged(targetInst) {
      var targetNode = getNodeFromInstance(targetInst);
      if (updateValueIfChanged(targetNode)) return targetInst;
    }
    function getTargetInstForChangeEvent(domEventName, targetInst) {
      if ("change" === domEventName) return targetInst;
    }
    function stopWatchingForValueChange() {
      activeElement$1 &&
        (activeElement$1.detachEvent("onpropertychange", handlePropertyChange),
        (activeElementInst$1 = activeElement$1 = null));
    }
    function handlePropertyChange(nativeEvent) {
      if (
        "value" === nativeEvent.propertyName &&
        getInstIfValueChanged(activeElementInst$1)
      ) {
        var dispatchQueue = [];
        createAndAccumulateChangeEvent(
          dispatchQueue,
          activeElementInst$1,
          nativeEvent,
          getEventTarget(nativeEvent)
        );
        batchedUpdates$1(runEventInBatch, dispatchQueue);
      }
    }
    function handleEventsForInputEventPolyfill(
      domEventName,
      target,
      targetInst
    ) {
      "focusin" === domEventName
        ? (stopWatchingForValueChange(),
          (activeElement$1 = target),
          (activeElementInst$1 = targetInst),
          activeElement$1.attachEvent("onpropertychange", handlePropertyChange))
        : "focusout" === domEventName && stopWatchingForValueChange();
    }
    function getTargetInstForInputEventPolyfill(domEventName) {
      if (
        "selectionchange" === domEventName ||
        "keyup" === domEventName ||
        "keydown" === domEventName
      )
        return getInstIfValueChanged(activeElementInst$1);
    }
    function getTargetInstForClickEvent(domEventName, targetInst) {
      if ("click" === domEventName) return getInstIfValueChanged(targetInst);
    }
    function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
      if ("input" === domEventName || "change" === domEventName)
        return getInstIfValueChanged(targetInst);
    }
    function is(x, y) {
      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
    }
    function shallowEqual(objA, objB) {
      if (objectIs(objA, objB)) return !0;
      if (
        "object" !== typeof objA ||
        null === objA ||
        "object" !== typeof objB ||
        null === objB
      )
        return !1;
      var keysA = Object.keys(objA),
        keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) return !1;
      for (keysB = 0; keysB < keysA.length; keysB++) {
        var currentKey = keysA[keysB];
        if (
          !hasOwnProperty.call(objB, currentKey) ||
          !objectIs(objA[currentKey], objB[currentKey])
        )
          return !1;
      }
      return !0;
    }
    function getLeafNode(node) {
      for (; node && node.firstChild; ) node = node.firstChild;
      return node;
    }
    function getNodeForCharacterOffset(root, offset) {
      var node = getLeafNode(root);
      root = 0;
      for (var nodeEnd; node; ) {
        if (3 === node.nodeType) {
          nodeEnd = root + node.textContent.length;
          if (root <= offset && nodeEnd >= offset)
            return { node: node, offset: offset - root };
          root = nodeEnd;
        }
        a: {
          for (; node; ) {
            if (node.nextSibling) {
              node = node.nextSibling;
              break a;
            }
            node = node.parentNode;
          }
          node = void 0;
        }
        node = getLeafNode(node);
      }
    }
    function containsNode(outerNode, innerNode) {
      return outerNode && innerNode
        ? outerNode === innerNode
          ? !0
          : outerNode && 3 === outerNode.nodeType
            ? !1
            : innerNode && 3 === innerNode.nodeType
              ? containsNode(outerNode, innerNode.parentNode)
              : "contains" in outerNode
                ? outerNode.contains(innerNode)
                : outerNode.compareDocumentPosition
                  ? !!(outerNode.compareDocumentPosition(innerNode) & 16)
                  : !1
        : !1;
    }
    function getActiveElementDeep(containerInfo) {
      containerInfo =
        null != containerInfo &&
        null != containerInfo.ownerDocument &&
        null != containerInfo.ownerDocument.defaultView
          ? containerInfo.ownerDocument.defaultView
          : window;
      for (
        var element = getActiveElement(containerInfo.document);
        element instanceof containerInfo.HTMLIFrameElement;

      ) {
        try {
          var JSCompiler_inline_result =
            "string" === typeof element.contentWindow.location.href;
        } catch (err) {
          JSCompiler_inline_result = !1;
        }
        if (JSCompiler_inline_result) containerInfo = element.contentWindow;
        else break;
        element = getActiveElement(containerInfo.document);
      }
      return element;
    }
    function hasSelectionCapabilities(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return (
        nodeName &&
        (("input" === nodeName &&
          ("text" === elem.type ||
            "search" === elem.type ||
            "tel" === elem.type ||
            "url" === elem.type ||
            "password" === elem.type)) ||
          "textarea" === nodeName ||
          "true" === elem.contentEditable)
      );
    }
    function constructSelectEvent(
      dispatchQueue,
      nativeEvent,
      nativeEventTarget
    ) {
      var doc =
        nativeEventTarget.window === nativeEventTarget
          ? nativeEventTarget.document
          : 9 === nativeEventTarget.nodeType
            ? nativeEventTarget
            : nativeEventTarget.ownerDocument;
      mouseDown ||
        null == activeElement ||
        activeElement !== getActiveElement(doc) ||
        ((doc = activeElement),
        "selectionStart" in doc && hasSelectionCapabilities(doc)
          ? (doc = { start: doc.selectionStart, end: doc.selectionEnd })
          : ((doc = (
              (doc.ownerDocument && doc.ownerDocument.defaultView) ||
              window
            ).getSelection()),
            (doc = {
              anchorNode: doc.anchorNode,
              anchorOffset: doc.anchorOffset,
              focusNode: doc.focusNode,
              focusOffset: doc.focusOffset
            })),
        (lastSelection && shallowEqual(lastSelection, doc)) ||
          ((lastSelection = doc),
          (doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect")),
          0 < doc.length &&
            ((nativeEvent = new SyntheticEvent(
              "onSelect",
              "select",
              null,
              nativeEvent,
              nativeEventTarget
            )),
            dispatchQueue.push({ event: nativeEvent, listeners: doc }),
            (nativeEvent.target = activeElement))));
    }
    function makePrefixMap(styleProp, eventName) {
      var prefixes = {};
      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
      prefixes["Webkit" + styleProp] = "webkit" + eventName;
      prefixes["Moz" + styleProp] = "moz" + eventName;
      return prefixes;
    }
    function getVendorPrefixedEventName(eventName) {
      if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
      if (!vendorPrefixes[eventName]) return eventName;
      var prefixMap = vendorPrefixes[eventName],
        styleProp;
      for (styleProp in prefixMap)
        if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
          return (prefixedEventNames[eventName] = prefixMap[styleProp]);
      return eventName;
    }
    function registerSimpleEvent(domEventName, reactName) {
      topLevelEventsToReactNames.set(domEventName, reactName);
      registerTwoPhaseEvent(reactName, [domEventName]);
    }
    function createCapturedValueAtFiber(value, source) {
      if ("object" === typeof value && null !== value) {
        var existing = CapturedStacks.get(value);
        if (void 0 !== existing) return existing;
        source = {
          value: value,
          source: source,
          stack: getStackByFiberInDevAndProd(source)
        };
        CapturedStacks.set(value, source);
        return source;
      }
      return {
        value: value,
        source: source,
        stack: getStackByFiberInDevAndProd(source)
      };
    }
    function finishQueueingConcurrentUpdates() {
      for (
        var endIndex = concurrentQueuesIndex,
          i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);
        i < endIndex;

      ) {
        var fiber = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var queue = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var update = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var lane = concurrentQueues[i];
        concurrentQueues[i++] = null;
        if (null !== queue && null !== update) {
          var pending = queue.pending;
          null === pending
            ? (update.next = update)
            : ((update.next = pending.next), (pending.next = update));
          queue.pending = update;
        }
        0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
      }
    }
    function enqueueUpdate$1(fiber, queue, update, lane) {
      concurrentQueues[concurrentQueuesIndex++] = fiber;
      concurrentQueues[concurrentQueuesIndex++] = queue;
      concurrentQueues[concurrentQueuesIndex++] = update;
      concurrentQueues[concurrentQueuesIndex++] = lane;
      concurrentlyUpdatedLanes |= lane;
      fiber.lanes |= lane;
      fiber = fiber.alternate;
      null !== fiber && (fiber.lanes |= lane);
    }
    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
      enqueueUpdate$1(fiber, queue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function enqueueConcurrentRenderForLane(fiber, lane) {
      enqueueUpdate$1(fiber, null, null, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
      sourceFiber.lanes |= lane;
      var alternate = sourceFiber.alternate;
      null !== alternate && (alternate.lanes |= lane);
      for (var isHidden = !1, parent = sourceFiber.return; null !== parent; )
        (parent.childLanes |= lane),
          (alternate = parent.alternate),
          null !== alternate && (alternate.childLanes |= lane),
          22 === parent.tag &&
            ((sourceFiber = parent.stateNode),
            null === sourceFiber ||
              sourceFiber._visibility & OffscreenVisible ||
              (isHidden = !0)),
          (sourceFiber = parent),
          (parent = parent.return);
      return 3 === sourceFiber.tag
        ? ((parent = sourceFiber.stateNode),
          isHidden &&
            null !== update &&
            ((isHidden = 31 - clz32(lane)),
            (sourceFiber = parent.hiddenUpdates),
            (alternate = sourceFiber[isHidden]),
            null === alternate
              ? (sourceFiber[isHidden] = [update])
              : alternate.push(update),
            (update.lane = lane | 536870912)),
          parent)
        : null;
    }
    function getRootForUpdatedFiber(sourceFiber) {
      if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
        throw (
          ((nestedPassiveUpdateCount = nestedUpdateCount = 0),
          (rootWithPassiveNestedUpdates = rootWithNestedUpdates = null),
          Error(
            "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
          ))
        );
      nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT &&
        ((nestedPassiveUpdateCount = 0),
        (rootWithPassiveNestedUpdates = null),
        console.error(
          "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
        ));
      null === sourceFiber.alternate &&
        0 !== (sourceFiber.flags & 4098) &&
        warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
      for (var node = sourceFiber, parent = node.return; null !== parent; )
        null === node.alternate &&
          0 !== (node.flags & 4098) &&
          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber),
          (node = parent),
          (parent = node.return);
      return 3 === node.tag ? node.stateNode : null;
    }
    function resolveFunctionForHotReloading(type) {
      if (null === resolveFamily) return type;
      var family = resolveFamily(type);
      return void 0 === family ? type : family.current;
    }
    function resolveForwardRefForHotReloading(type) {
      if (null === resolveFamily) return type;
      var family = resolveFamily(type);
      return void 0 === family
        ? null !== type &&
          void 0 !== type &&
          "function" === typeof type.render &&
          ((family = resolveFunctionForHotReloading(type.render)),
          type.render !== family)
          ? ((family = { $$typeof: REACT_FORWARD_REF_TYPE, render: family }),
            void 0 !== type.displayName &&
              (family.displayName = type.displayName),
            family)
          : type
        : family.current;
    }
    function isCompatibleFamilyForHotReloading(fiber, element) {
      if (null === resolveFamily) return !1;
      var prevType = fiber.elementType;
      element = element.type;
      var needsCompareFamilies = !1,
        $$typeofNextType =
          "object" === typeof element && null !== element
            ? element.$$typeof
            : null;
      switch (fiber.tag) {
        case 1:
          "function" === typeof element && (needsCompareFamilies = !0);
          break;
        case 0:
          "function" === typeof element
            ? (needsCompareFamilies = !0)
            : $$typeofNextType === REACT_LAZY_TYPE &&
              (needsCompareFamilies = !0);
          break;
        case 11:
          $$typeofNextType === REACT_FORWARD_REF_TYPE
            ? (needsCompareFamilies = !0)
            : $$typeofNextType === REACT_LAZY_TYPE &&
              (needsCompareFamilies = !0);
          break;
        case 14:
        case 15:
          $$typeofNextType === REACT_MEMO_TYPE
            ? (needsCompareFamilies = !0)
            : $$typeofNextType === REACT_LAZY_TYPE &&
              (needsCompareFamilies = !0);
          break;
        default:
          return !1;
      }
      return needsCompareFamilies &&
        ((fiber = resolveFamily(prevType)),
        void 0 !== fiber && fiber === resolveFamily(element))
        ? !0
        : !1;
    }
    function markFailedErrorBoundaryForHotReloading(fiber) {
      null !== resolveFamily &&
        "function" === typeof WeakSet &&
        (null === failedBoundaries && (failedBoundaries = new WeakSet()),
        failedBoundaries.add(fiber));
    }
    function scheduleFibersWithFamiliesRecursively(
      fiber,
      updatedFamilies,
      staleFamilies
    ) {
      var alternate = fiber.alternate,
        child = fiber.child,
        sibling = fiber.sibling,
        tag = fiber.tag,
        type = fiber.type,
        candidateType = null;
      switch (tag) {
        case 0:
        case 15:
        case 1:
          candidateType = type;
          break;
        case 11:
          candidateType = type.render;
      }
      if (null === resolveFamily)
        throw Error("Expected resolveFamily to be set during hot reload.");
      var needsRender = !1;
      type = !1;
      null !== candidateType &&
        ((candidateType = resolveFamily(candidateType)),
        void 0 !== candidateType &&
          (staleFamilies.has(candidateType)
            ? (type = !0)
            : updatedFamilies.has(candidateType) &&
              (1 === tag ? (type = !0) : (needsRender = !0))));
      null !== failedBoundaries &&
        (failedBoundaries.has(fiber) ||
          (null !== alternate && failedBoundaries.has(alternate))) &&
        (type = !0);
      type && (fiber._debugNeedsRemount = !0);
      if (type || needsRender)
        (alternate = enqueueConcurrentRenderForLane(fiber, 2)),
          null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);
      null === child ||
        type ||
        scheduleFibersWithFamiliesRecursively(
          child,
          updatedFamilies,
          staleFamilies
        );
      null !== sibling &&
        scheduleFibersWithFamiliesRecursively(
          sibling,
          updatedFamilies,
          staleFamilies
        );
    }
    function FiberNode(tag, pendingProps, key, mode) {
      this.tag = tag;
      this.key = key;
      this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null;
      this.index = 0;
      this.refCleanup = this.ref = null;
      this.pendingProps = pendingProps;
      this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null;
      this.mode = mode;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
      this.actualDuration = -0;
      this.actualStartTime = -1.1;
      this.treeBaseDuration = this.selfBaseDuration = -0;
      this._debugTask =
        this._debugStack =
        this._debugOwner =
        this._debugInfo =
          null;
      this._debugNeedsRemount = !1;
      this._debugHookTypes = null;
      hasBadMapPolyfill ||
        "function" !== typeof Object.preventExtensions ||
        Object.preventExtensions(this);
    }
    function shouldConstruct(Component) {
      Component = Component.prototype;
      return !(!Component || !Component.isReactComponent);
    }
    function createWorkInProgress(current, pendingProps) {
      var workInProgress = current.alternate;
      null === workInProgress
        ? ((workInProgress = createFiber(
            current.tag,
            pendingProps,
            current.key,
            current.mode
          )),
          (workInProgress.elementType = current.elementType),
          (workInProgress.type = current.type),
          (workInProgress.stateNode = current.stateNode),
          (workInProgress._debugOwner = current._debugOwner),
          (workInProgress._debugStack = current._debugStack),
          (workInProgress._debugTask = current._debugTask),
          (workInProgress._debugHookTypes = current._debugHookTypes),
          (workInProgress.alternate = current),
          (current.alternate = workInProgress))
        : ((workInProgress.pendingProps = pendingProps),
          (workInProgress.type = current.type),
          (workInProgress.flags = 0),
          (workInProgress.subtreeFlags = 0),
          (workInProgress.deletions = null),
          (workInProgress.actualDuration = -0),
          (workInProgress.actualStartTime = -1.1));
      workInProgress.flags = current.flags & 65011712;
      workInProgress.childLanes = current.childLanes;
      workInProgress.lanes = current.lanes;
      workInProgress.child = current.child;
      workInProgress.memoizedProps = current.memoizedProps;
      workInProgress.memoizedState = current.memoizedState;
      workInProgress.updateQueue = current.updateQueue;
      pendingProps = current.dependencies;
      workInProgress.dependencies =
        null === pendingProps
          ? null
          : {
              lanes: pendingProps.lanes,
              firstContext: pendingProps.firstContext,
              _debugThenableState: pendingProps._debugThenableState
            };
      workInProgress.sibling = current.sibling;
      workInProgress.index = current.index;
      workInProgress.ref = current.ref;
      workInProgress.refCleanup = current.refCleanup;
      workInProgress.selfBaseDuration = current.selfBaseDuration;
      workInProgress.treeBaseDuration = current.treeBaseDuration;
      workInProgress._debugInfo = current._debugInfo;
      workInProgress._debugNeedsRemount = current._debugNeedsRemount;
      switch (workInProgress.tag) {
        case 0:
        case 15:
          workInProgress.type = resolveFunctionForHotReloading(current.type);
          break;
        case 1:
          workInProgress.type = resolveFunctionForHotReloading(current.type);
          break;
        case 11:
          workInProgress.type = resolveForwardRefForHotReloading(current.type);
      }
      return workInProgress;
    }
    function resetWorkInProgress(workInProgress, renderLanes) {
      workInProgress.flags &= 65011714;
      var current = workInProgress.alternate;
      null === current
        ? ((workInProgress.childLanes = 0),
          (workInProgress.lanes = renderLanes),
          (workInProgress.child = null),
          (workInProgress.subtreeFlags = 0),
          (workInProgress.memoizedProps = null),
          (workInProgress.memoizedState = null),
          (workInProgress.updateQueue = null),
          (workInProgress.dependencies = null),
          (workInProgress.stateNode = null),
          (workInProgress.selfBaseDuration = 0),
          (workInProgress.treeBaseDuration = 0))
        : ((workInProgress.childLanes = current.childLanes),
          (workInProgress.lanes = current.lanes),
          (workInProgress.child = current.child),
          (workInProgress.subtreeFlags = 0),
          (workInProgress.deletions = null),
          (workInProgress.memoizedProps = current.memoizedProps),
          (workInProgress.memoizedState = current.memoizedState),
          (workInProgress.updateQueue = current.updateQueue),
          (workInProgress.type = current.type),
          (renderLanes = current.dependencies),
          (workInProgress.dependencies =
            null === renderLanes
              ? null
              : {
                  lanes: renderLanes.lanes,
                  firstContext: renderLanes.firstContext,
                  _debugThenableState: renderLanes._debugThenableState
                }),
          (workInProgress.selfBaseDuration = current.selfBaseDuration),
          (workInProgress.treeBaseDuration = current.treeBaseDuration));
      return workInProgress;
    }
    function createFiberFromTypeAndProps(
      type,
      key,
      pendingProps,
      owner,
      mode,
      lanes
    ) {
      var fiberTag = 0,
        resolvedType = type;
      if ("function" === typeof type)
        shouldConstruct(type) && (fiberTag = 1),
          (resolvedType = resolveFunctionForHotReloading(resolvedType));
      else if ("string" === typeof type)
        (fiberTag = getHostContext()),
          (fiberTag = isHostHoistableType(type, pendingProps, fiberTag)
            ? 26
            : "html" === type || "head" === type || "body" === type
              ? 27
              : 5);
      else
        a: switch (type) {
          case REACT_ACTIVITY_TYPE:
            return (
              (key = createFiber(31, pendingProps, key, mode)),
              (key.elementType = REACT_ACTIVITY_TYPE),
              (key.lanes = lanes),
              key
            );
          case REACT_FRAGMENT_TYPE:
            return createFiberFromFragment(
              pendingProps.children,
              mode,
              lanes,
              key
            );
          case REACT_STRICT_MODE_TYPE:
            fiberTag = 8;
            mode |= StrictLegacyMode;
            mode |= StrictEffectsMode;
            break;
          case REACT_PROFILER_TYPE:
            return (
              (type = pendingProps),
              (owner = mode),
              "string" !== typeof type.id &&
                console.error(
                  'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
                  typeof type.id
                ),
              (key = createFiber(12, type, key, owner | ProfileMode)),
              (key.elementType = REACT_PROFILER_TYPE),
              (key.lanes = lanes),
              (key.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }),
              key
            );
          case REACT_SUSPENSE_TYPE:
            return (
              (key = createFiber(13, pendingProps, key, mode)),
              (key.elementType = REACT_SUSPENSE_TYPE),
              (key.lanes = lanes),
              key
            );
          case REACT_SUSPENSE_LIST_TYPE:
            return (
              (key = createFiber(19, pendingProps, key, mode)),
              (key.elementType = REACT_SUSPENSE_LIST_TYPE),
              (key.lanes = lanes),
              key
            );
          default:
            if ("object" === typeof type && null !== type)
              switch (type.$$typeof) {
                case REACT_PROVIDER_TYPE:
                case REACT_CONTEXT_TYPE:
                  fiberTag = 10;
                  break a;
                case REACT_CONSUMER_TYPE:
                  fiberTag = 9;
                  break a;
                case REACT_FORWARD_REF_TYPE:
                  fiberTag = 11;
                  resolvedType = resolveForwardRefForHotReloading(resolvedType);
                  break a;
                case REACT_MEMO_TYPE:
                  fiberTag = 14;
                  break a;
                case REACT_LAZY_TYPE:
                  fiberTag = 16;
                  resolvedType = null;
                  break a;
              }
            resolvedType = "";
            if (
              void 0 === type ||
              ("object" === typeof type &&
                null !== type &&
                0 === Object.keys(type).length)
            )
              resolvedType +=
                " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            null === type
              ? (pendingProps = "null")
              : isArrayImpl(type)
                ? (pendingProps = "array")
                : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE
                  ? ((pendingProps =
                      "<" +
                      (getComponentNameFromType(type.type) || "Unknown") +
                      " />"),
                    (resolvedType =
                      " Did you accidentally export a JSX literal instead of a component?"))
                  : (pendingProps = typeof type);
            (fiberTag = owner ? getComponentNameFromOwner(owner) : null) &&
              (resolvedType +=
                "\n\nCheck the render method of `" + fiberTag + "`.");
            fiberTag = 29;
            pendingProps = Error(
              "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " +
                (pendingProps + "." + resolvedType)
            );
            resolvedType = null;
        }
      key = createFiber(fiberTag, pendingProps, key, mode);
      key.elementType = type;
      key.type = resolvedType;
      key.lanes = lanes;
      key._debugOwner = owner;
      return key;
    }
    function createFiberFromElement(element, mode, lanes) {
      mode = createFiberFromTypeAndProps(
        element.type,
        element.key,
        element.props,
        element._owner,
        mode,
        lanes
      );
      mode._debugOwner = element._owner;
      mode._debugStack = element._debugStack;
      mode._debugTask = element._debugTask;
      return mode;
    }
    function createFiberFromFragment(elements, mode, lanes, key) {
      elements = createFiber(7, elements, key, mode);
      elements.lanes = lanes;
      return elements;
    }
    function createFiberFromText(content, mode, lanes) {
      content = createFiber(6, content, null, mode);
      content.lanes = lanes;
      return content;
    }
    function createFiberFromPortal(portal, mode, lanes) {
      mode = createFiber(
        4,
        null !== portal.children ? portal.children : [],
        portal.key,
        mode
      );
      mode.lanes = lanes;
      mode.stateNode = {
        containerInfo: portal.containerInfo,
        pendingChildren: null,
        implementation: portal.implementation
      };
      return mode;
    }
    function pushTreeFork(workInProgress, totalChildren) {
      warnIfNotHydrating();
      forkStack[forkStackIndex++] = treeForkCount;
      forkStack[forkStackIndex++] = treeForkProvider;
      treeForkProvider = workInProgress;
      treeForkCount = totalChildren;
    }
    function pushTreeId(workInProgress, totalChildren, index) {
      warnIfNotHydrating();
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextProvider = workInProgress;
      var baseIdWithLeadingBit = treeContextId;
      workInProgress = treeContextOverflow;
      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
      baseIdWithLeadingBit &= ~(1 << baseLength);
      index += 1;
      var length = 32 - clz32(totalChildren) + baseLength;
      if (30 < length) {
        var numberOfOverflowBits = baseLength - (baseLength % 5);
        length = (
          baseIdWithLeadingBit &
          ((1 << numberOfOverflowBits) - 1)
        ).toString(32);
        baseIdWithLeadingBit >>= numberOfOverflowBits;
        baseLength -= numberOfOverflowBits;
        treeContextId =
          (1 << (32 - clz32(totalChildren) + baseLength)) |
          (index << baseLength) |
          baseIdWithLeadingBit;
        treeContextOverflow = length + workInProgress;
      } else
        (treeContextId =
          (1 << length) | (index << baseLength) | baseIdWithLeadingBit),
          (treeContextOverflow = workInProgress);
    }
    function pushMaterializedTreeId(workInProgress) {
      warnIfNotHydrating();
      null !== workInProgress.return &&
        (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
    }
    function popTreeContext(workInProgress) {
      for (; workInProgress === treeForkProvider; )
        (treeForkProvider = forkStack[--forkStackIndex]),
          (forkStack[forkStackIndex] = null),
          (treeForkCount = forkStack[--forkStackIndex]),
          (forkStack[forkStackIndex] = null);
      for (; workInProgress === treeContextProvider; )
        (treeContextProvider = idStack[--idStackIndex]),
          (idStack[idStackIndex] = null),
          (treeContextOverflow = idStack[--idStackIndex]),
          (idStack[idStackIndex] = null),
          (treeContextId = idStack[--idStackIndex]),
          (idStack[idStackIndex] = null);
    }
    function warnIfNotHydrating() {
      isHydrating ||
        console.error(
          "Expected to be hydrating. This is a bug in React. Please file an issue."
        );
    }
    function buildHydrationDiffNode(fiber, distanceFromLeaf) {
      if (null === fiber.return) {
        if (null === hydrationDiffRootDEV)
          hydrationDiffRootDEV = {
            fiber: fiber,
            children: [],
            serverProps: void 0,
            serverTail: [],
            distanceFromLeaf: distanceFromLeaf
          };
        else {
          if (hydrationDiffRootDEV.fiber !== fiber)
            throw Error(
              "Saw multiple hydration diff roots in a pass. This is a bug in React."
            );
          hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf &&
            (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
        }
        return hydrationDiffRootDEV;
      }
      var siblings = buildHydrationDiffNode(
        fiber.return,
        distanceFromLeaf + 1
      ).children;
      if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber)
        return (
          (siblings = siblings[siblings.length - 1]),
          siblings.distanceFromLeaf > distanceFromLeaf &&
            (siblings.distanceFromLeaf = distanceFromLeaf),
          siblings
        );
      distanceFromLeaf = {
        fiber: fiber,
        children: [],
        serverProps: void 0,
        serverTail: [],
        distanceFromLeaf: distanceFromLeaf
      };
      siblings.push(distanceFromLeaf);
      return distanceFromLeaf;
    }
    function warnNonHydratedInstance(fiber, rejectedCandidate) {
      didSuspendOrErrorDEV ||
        ((fiber = buildHydrationDiffNode(fiber, 0)),
        (fiber.serverProps = null),
        null !== rejectedCandidate &&
          ((rejectedCandidate =
            describeHydratableInstanceForDevWarnings(rejectedCandidate)),
          fiber.serverTail.push(rejectedCandidate)));
    }
    function throwOnHydrationMismatch(fiber) {
      var diff = "",
        diffRoot = hydrationDiffRootDEV;
      null !== diffRoot &&
        ((hydrationDiffRootDEV = null), (diff = describeDiff(diffRoot)));
      queueHydrationError(
        createCapturedValueAtFiber(
          Error(
            "Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" +
              diff
          ),
          fiber
        )
      );
      throw HydrationMismatchException;
    }
    function prepareToHydrateHostInstance(fiber) {
      var didHydrate = fiber.stateNode;
      var type = fiber.type,
        props = fiber.memoizedProps;
      didHydrate[internalInstanceKey] = fiber;
      didHydrate[internalPropsKey] = props;
      validatePropertiesInDevelopment(type, props);
      switch (type) {
        case "dialog":
          listenToNonDelegatedEvent("cancel", didHydrate);
          listenToNonDelegatedEvent("close", didHydrate);
          break;
        case "iframe":
        case "object":
        case "embed":
          listenToNonDelegatedEvent("load", didHydrate);
          break;
        case "video":
        case "audio":
          for (type = 0; type < mediaEventTypes.length; type++)
            listenToNonDelegatedEvent(mediaEventTypes[type], didHydrate);
          break;
        case "source":
          listenToNonDelegatedEvent("error", didHydrate);
          break;
        case "img":
        case "image":
        case "link":
          listenToNonDelegatedEvent("error", didHydrate);
          listenToNonDelegatedEvent("load", didHydrate);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", didHydrate);
          break;
        case "input":
          checkControlledValueProps("input", props);
          listenToNonDelegatedEvent("invalid", didHydrate);
          validateInputProps(didHydrate, props);
          initInput(
            didHydrate,
            props.value,
            props.defaultValue,
            props.checked,
            props.defaultChecked,
            props.type,
            props.name,
            !0
          );
          track(didHydrate);
          break;
        case "option":
          validateOptionProps(didHydrate, props);
          break;
        case "select":
          checkControlledValueProps("select", props);
          listenToNonDelegatedEvent("invalid", didHydrate);
          validateSelectProps(didHydrate, props);
          break;
        case "textarea":
          checkControlledValueProps("textarea", props),
            listenToNonDelegatedEvent("invalid", didHydrate),
            validateTextareaProps(didHydrate, props),
            initTextarea(
              didHydrate,
              props.value,
              props.defaultValue,
              props.children
            ),
            track(didHydrate);
      }
      type = props.children;
      ("string" !== typeof type &&
        "number" !== typeof type &&
        "bigint" !== typeof type) ||
      didHydrate.textContent === "" + type ||
      !0 === props.suppressHydrationWarning ||
      checkForUnmatchedText(didHydrate.textContent, type)
        ? (null != props.popover &&
            (listenToNonDelegatedEvent("beforetoggle", didHydrate),
            listenToNonDelegatedEvent("toggle", didHydrate)),
          null != props.onScroll &&
            listenToNonDelegatedEvent("scroll", didHydrate),
          null != props.onScrollEnd &&
            listenToNonDelegatedEvent("scrollend", didHydrate),
          null != props.onClick && (didHydrate.onclick = noop$1),
          (didHydrate = !0))
        : (didHydrate = !1);
      didHydrate || throwOnHydrationMismatch(fiber);
    }
    function popToNextHostParent(fiber) {
      for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
        switch (hydrationParentFiber.tag) {
          case 5:
          case 13:
            rootOrSingletonContext = !1;
            return;
          case 27:
          case 3:
            rootOrSingletonContext = !0;
            return;
          default:
            hydrationParentFiber = hydrationParentFiber.return;
        }
    }
    function popHydrationState(fiber) {
      if (fiber !== hydrationParentFiber) return !1;
      if (!isHydrating)
        return popToNextHostParent(fiber), (isHydrating = !0), !1;
      var tag = fiber.tag,
        JSCompiler_temp;
      if ((JSCompiler_temp = 3 !== tag && 27 !== tag)) {
        if ((JSCompiler_temp = 5 === tag))
          (JSCompiler_temp = fiber.type),
            (JSCompiler_temp =
              !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) ||
              shouldSetTextContent(fiber.type, fiber.memoizedProps));
        JSCompiler_temp = !JSCompiler_temp;
      }
      if (JSCompiler_temp && nextHydratableInstance) {
        for (JSCompiler_temp = nextHydratableInstance; JSCompiler_temp; ) {
          var diffNode = buildHydrationDiffNode(fiber, 0),
            description =
              describeHydratableInstanceForDevWarnings(JSCompiler_temp);
          diffNode.serverTail.push(description);
          JSCompiler_temp =
            "Suspense" === description.type
              ? getNextHydratableInstanceAfterSuspenseInstance(JSCompiler_temp)
              : getNextHydratable(JSCompiler_temp.nextSibling);
        }
        throwOnHydrationMismatch(fiber);
      }
      popToNextHostParent(fiber);
      if (13 === tag) {
        fiber = fiber.memoizedState;
        fiber = null !== fiber ? fiber.dehydrated : null;
        if (!fiber)
          throw Error(
            "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
          );
        nextHydratableInstance =
          getNextHydratableInstanceAfterSuspenseInstance(fiber);
      } else
        27 === tag
          ? ((tag = nextHydratableInstance),
            isSingletonScope(fiber.type)
              ? ((fiber = previousHydratableOnEnteringScopedSingleton),
                (previousHydratableOnEnteringScopedSingleton = null),
                (nextHydratableInstance = fiber))
              : (nextHydratableInstance = tag))
          : (nextHydratableInstance = hydrationParentFiber
              ? getNextHydratable(fiber.stateNode.nextSibling)
              : null);
      return !0;
    }
    function resetHydrationState() {
      nextHydratableInstance = hydrationParentFiber = null;
      didSuspendOrErrorDEV = isHydrating = !1;
    }
    function upgradeHydrationErrorsToRecoverable() {
      var queuedErrors = hydrationErrors;
      null !== queuedErrors &&
        (null === workInProgressRootRecoverableErrors
          ? (workInProgressRootRecoverableErrors = queuedErrors)
          : workInProgressRootRecoverableErrors.push.apply(
              workInProgressRootRecoverableErrors,
              queuedErrors
            ),
        (hydrationErrors = null));
      return queuedErrors;
    }
    function queueHydrationError(error) {
      null === hydrationErrors
        ? (hydrationErrors = [error])
        : hydrationErrors.push(error);
    }
    function emitPendingHydrationWarnings() {
      var diffRoot = hydrationDiffRootDEV;
      if (null !== diffRoot) {
        hydrationDiffRootDEV = null;
        for (var diff = describeDiff(diffRoot); 0 < diffRoot.children.length; )
          diffRoot = diffRoot.children[0];
        runWithFiberInDEV(diffRoot.fiber, function () {
          console.error(
            "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s",
            "https://react.dev/link/hydration-mismatch",
            diff
          );
        });
      }
    }
    function resetContextDependencies() {
      lastContextDependency = currentlyRenderingFiber$1 = null;
      isDisallowedContextReadInDEV = !1;
    }
    function pushProvider(providerFiber, context, nextValue) {
      push(valueCursor, context._currentValue, providerFiber);
      context._currentValue = nextValue;
      push(rendererCursorDEV, context._currentRenderer, providerFiber);
      void 0 !== context._currentRenderer &&
        null !== context._currentRenderer &&
        context._currentRenderer !== rendererSigil &&
        console.error(
          "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
        );
      context._currentRenderer = rendererSigil;
    }
    function popProvider(context, providerFiber) {
      context._currentValue = valueCursor.current;
      var currentRenderer = rendererCursorDEV.current;
      pop(rendererCursorDEV, providerFiber);
      context._currentRenderer = currentRenderer;
      pop(valueCursor, providerFiber);
    }
    function scheduleContextWorkOnParentPath(
      parent,
      renderLanes,
      propagationRoot
    ) {
      for (; null !== parent; ) {
        var alternate = parent.alternate;
        (parent.childLanes & renderLanes) !== renderLanes
          ? ((parent.childLanes |= renderLanes),
            null !== alternate && (alternate.childLanes |= renderLanes))
          : null !== alternate &&
            (alternate.childLanes & renderLanes) !== renderLanes &&
            (alternate.childLanes |= renderLanes);
        if (parent === propagationRoot) break;
        parent = parent.return;
      }
      parent !== propagationRoot &&
        console.error(
          "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
        );
    }
    function propagateContextChanges(
      workInProgress,
      contexts,
      renderLanes,
      forcePropagateEntireTree
    ) {
      var fiber = workInProgress.child;
      null !== fiber && (fiber.return = workInProgress);
      for (; null !== fiber; ) {
        var list = fiber.dependencies;
        if (null !== list) {
          var nextFiber = fiber.child;
          list = list.firstContext;
          a: for (; null !== list; ) {
            var dependency = list;
            list = fiber;
            for (var i = 0; i < contexts.length; i++)
              if (dependency.context === contexts[i]) {
                list.lanes |= renderLanes;
                dependency = list.alternate;
                null !== dependency && (dependency.lanes |= renderLanes);
                scheduleContextWorkOnParentPath(
                  list.return,
                  renderLanes,
                  workInProgress
                );
                forcePropagateEntireTree || (nextFiber = null);
                break a;
              }
            list = dependency.next;
          }
        } else if (18 === fiber.tag) {
          nextFiber = fiber.return;
          if (null === nextFiber)
            throw Error(
              "We just came from a parent so we must have had a parent. This is a bug in React."
            );
          nextFiber.lanes |= renderLanes;
          list = nextFiber.alternate;
          null !== list && (list.lanes |= renderLanes);
          scheduleContextWorkOnParentPath(
            nextFiber,
            renderLanes,
            workInProgress
          );
          nextFiber = null;
        } else nextFiber = fiber.child;
        if (null !== nextFiber) nextFiber.return = fiber;
        else
          for (nextFiber = fiber; null !== nextFiber; ) {
            if (nextFiber === workInProgress) {
              nextFiber = null;
              break;
            }
            fiber = nextFiber.sibling;
            if (null !== fiber) {
              fiber.return = nextFiber.return;
              nextFiber = fiber;
              break;
            }
            nextFiber = nextFiber.return;
          }
        fiber = nextFiber;
      }
    }
    function propagateParentContextChanges(
      current,
      workInProgress,
      renderLanes,
      forcePropagateEntireTree
    ) {
      current = null;
      for (
        var parent = workInProgress, isInsidePropagationBailout = !1;
        null !== parent;

      ) {
        if (!isInsidePropagationBailout)
          if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;
          else if (0 !== (parent.flags & 262144)) break;
        if (10 === parent.tag) {
          var currentParent = parent.alternate;
          if (null === currentParent)
            throw Error("Should have a current fiber. This is a bug in React.");
          currentParent = currentParent.memoizedProps;
          if (null !== currentParent) {
            var context = parent.type;
            objectIs(parent.pendingProps.value, currentParent.value) ||
              (null !== current
                ? current.push(context)
                : (current = [context]));
          }
        } else if (parent === hostTransitionProviderCursor.current) {
          currentParent = parent.alternate;
          if (null === currentParent)
            throw Error("Should have a current fiber. This is a bug in React.");
          currentParent.memoizedState.memoizedState !==
            parent.memoizedState.memoizedState &&
            (null !== current
              ? current.push(HostTransitionContext)
              : (current = [HostTransitionContext]));
        }
        parent = parent.return;
      }
      null !== current &&
        propagateContextChanges(
          workInProgress,
          current,
          renderLanes,
          forcePropagateEntireTree
        );
      workInProgress.flags |= 262144;
    }
    function checkIfContextChanged(currentDependencies) {
      for (
        currentDependencies = currentDependencies.firstContext;
        null !== currentDependencies;

      ) {
        if (
          !objectIs(
            currentDependencies.context._currentValue,
            currentDependencies.memoizedValue
          )
        )
          return !0;
        currentDependencies = currentDependencies.next;
      }
      return !1;
    }
    function prepareToReadContext(workInProgress) {
      currentlyRenderingFiber$1 = workInProgress;
      lastContextDependency = null;
      workInProgress = workInProgress.dependencies;
      null !== workInProgress && (workInProgress.firstContext = null);
    }
    function readContext(context) {
      isDisallowedContextReadInDEV &&
        console.error(
          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
        );
      return readContextForConsumer(currentlyRenderingFiber$1, context);
    }
    function readContextDuringReconciliation(consumer, context) {
      null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
      return readContextForConsumer(consumer, context);
    }
    function readContextForConsumer(consumer, context) {
      var value = context._currentValue;
      context = { context: context, memoizedValue: value, next: null };
      if (null === lastContextDependency) {
        if (null === consumer)
          throw Error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
        lastContextDependency = context;
        consumer.dependencies = {
          lanes: 0,
          firstContext: context,
          _debugThenableState: null
        };
        consumer.flags |= 524288;
      } else lastContextDependency = lastContextDependency.next = context;
      return value;
    }
    function createCache() {
      return {
        controller: new AbortControllerLocal(),
        data: new Map(),
        refCount: 0
      };
    }
    function retainCache(cache) {
      cache.controller.signal.aborted &&
        console.warn(
          "A cache instance was retained after it was already freed. This likely indicates a bug in React."
        );
      cache.refCount++;
    }
    function releaseCache(cache) {
      cache.refCount--;
      0 > cache.refCount &&
        console.warn(
          "A cache instance was released after it was already freed. This likely indicates a bug in React."
        );
      0 === cache.refCount &&
        scheduleCallback$2(NormalPriority, function () {
          cache.controller.abort();
        });
    }
    function pushNestedEffectDurations() {
      var prevEffectDuration = profilerEffectDuration;
      profilerEffectDuration = 0;
      return prevEffectDuration;
    }
    function popNestedEffectDurations(prevEffectDuration) {
      var elapsedTime = profilerEffectDuration;
      profilerEffectDuration = prevEffectDuration;
      return elapsedTime;
    }
    function bubbleNestedEffectDurations(prevEffectDuration) {
      var elapsedTime = profilerEffectDuration;
      profilerEffectDuration += prevEffectDuration;
      return elapsedTime;
    }
    function startProfilerTimer(fiber) {
      profilerStartTime = now();
      0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
    }
    function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
      if (0 <= profilerStartTime) {
        var elapsedTime = now() - profilerStartTime;
        fiber.actualDuration += elapsedTime;
        fiber.selfBaseDuration = elapsedTime;
        profilerStartTime = -1;
      }
    }
    function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
      if (0 <= profilerStartTime) {
        var elapsedTime = now() - profilerStartTime;
        fiber.actualDuration += elapsedTime;
        profilerStartTime = -1;
      }
    }
    function recordEffectDuration() {
      if (0 <= profilerStartTime) {
        var elapsedTime = now() - profilerStartTime;
        profilerStartTime = -1;
        profilerEffectDuration += elapsedTime;
      }
    }
    function startEffectTimer() {
      profilerStartTime = now();
    }
    function transferActualDuration(fiber) {
      for (var child = fiber.child; child; )
        (fiber.actualDuration += child.actualDuration), (child = child.sibling);
    }
    function entangleAsyncAction(transition, thenable) {
      if (null === currentEntangledListeners) {
        var entangledListeners = (currentEntangledListeners = []);
        currentEntangledPendingCount = 0;
        currentEntangledLane = requestTransitionLane();
        currentEntangledActionThenable = {
          status: "pending",
          value: void 0,
          then: function (resolve) {
            entangledListeners.push(resolve);
          }
        };
      }
      currentEntangledPendingCount++;
      thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
      return thenable;
    }
    function pingEngtangledActionScope() {
      if (
        0 === --currentEntangledPendingCount &&
        null !== currentEntangledListeners
      ) {
        null !== currentEntangledActionThenable &&
          (currentEntangledActionThenable.status = "fulfilled");
        var listeners = currentEntangledListeners;
        currentEntangledListeners = null;
        currentEntangledLane = 0;
        currentEntangledActionThenable = null;
        for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
      }
    }
    function chainThenableValue(thenable, result) {
      var listeners = [],
        thenableWithOverride = {
          status: "pending",
          value: null,
          reason: null,
          then: function (resolve) {
            listeners.push(resolve);
          }
        };
      thenable.then(
        function () {
          thenableWithOverride.status = "fulfilled";
          thenableWithOverride.value = result;
          for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
        },
        function (error) {
          thenableWithOverride.status = "rejected";
          thenableWithOverride.reason = error;
          for (error = 0; error < listeners.length; error++)
            (0, listeners[error])(void 0);
        }
      );
      return thenableWithOverride;
    }
    function peekCacheFromPool() {
      var cacheResumedFromPreviousRender = resumedCache.current;
      return null !== cacheResumedFromPreviousRender
        ? cacheResumedFromPreviousRender
        : workInProgressRoot.pooledCache;
    }
    function pushTransition(offscreenWorkInProgress, prevCachePool) {
      null === prevCachePool
        ? push(resumedCache, resumedCache.current, offscreenWorkInProgress)
        : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
    }
    function getSuspendedCache() {
      var cacheFromPool = peekCacheFromPool();
      return null === cacheFromPool
        ? null
        : { parent: CacheContext._currentValue, pool: cacheFromPool };
    }
    function createThenableState() {
      return { didWarnAboutUncachedPromise: !1, thenables: [] };
    }
    function isThenableResolved(thenable) {
      thenable = thenable.status;
      return "fulfilled" === thenable || "rejected" === thenable;
    }
    function noop$3() {}
    function trackUsedThenable(thenableState, thenable, index) {
      null !== ReactSharedInternals.actQueue &&
        (ReactSharedInternals.didUsePromise = !0);
      var trackedThenables = thenableState.thenables;
      index = trackedThenables[index];
      void 0 === index
        ? trackedThenables.push(thenable)
        : index !== thenable &&
          (thenableState.didWarnAboutUncachedPromise ||
            ((thenableState.didWarnAboutUncachedPromise = !0),
            console.error(
              "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
            )),
          thenable.then(noop$3, noop$3),
          (thenable = index));
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw (
            ((thenableState = thenable.reason),
            checkIfUseWrappedInAsyncCatch(thenableState),
            thenableState)
          );
        default:
          if ("string" === typeof thenable.status)
            thenable.then(noop$3, noop$3);
          else {
            thenableState = workInProgressRoot;
            if (
              null !== thenableState &&
              100 < thenableState.shellSuspendCounter
            )
              throw Error(
                "An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
              );
            thenableState = thenable;
            thenableState.status = "pending";
            thenableState.then(
              function (fulfilledValue) {
                if ("pending" === thenable.status) {
                  var fulfilledThenable = thenable;
                  fulfilledThenable.status = "fulfilled";
                  fulfilledThenable.value = fulfilledValue;
                }
              },
              function (error) {
                if ("pending" === thenable.status) {
                  var rejectedThenable = thenable;
                  rejectedThenable.status = "rejected";
                  rejectedThenable.reason = error;
                }
              }
            );
          }
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw (
                ((thenableState = thenable.reason),
                checkIfUseWrappedInAsyncCatch(thenableState),
                thenableState)
              );
          }
          suspendedThenable = thenable;
          needsToResetSuspendedThenableDEV = !0;
          throw SuspenseException;
      }
    }
    function getSuspendedThenable() {
      if (null === suspendedThenable)
        throw Error(
          "Expected a suspended thenable. This is a bug in React. Please file an issue."
        );
      var thenable = suspendedThenable;
      suspendedThenable = null;
      needsToResetSuspendedThenableDEV = !1;
      return thenable;
    }
    function checkIfUseWrappedInAsyncCatch(rejectedReason) {
      if (
        rejectedReason === SuspenseException ||
        rejectedReason === SuspenseActionException
      )
        throw Error(
          "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
        );
    }
    function initializeUpdateQueue(fiber) {
      fiber.updateQueue = {
        baseState: fiber.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    function cloneUpdateQueue(current, workInProgress) {
      current = current.updateQueue;
      workInProgress.updateQueue === current &&
        (workInProgress.updateQueue = {
          baseState: current.baseState,
          firstBaseUpdate: current.firstBaseUpdate,
          lastBaseUpdate: current.lastBaseUpdate,
          shared: current.shared,
          callbacks: null
        });
    }
    function createUpdate(lane) {
      return {
        lane: lane,
        tag: UpdateState,
        payload: null,
        callback: null,
        next: null
      };
    }
    function enqueueUpdate(fiber, update, lane) {
      var updateQueue = fiber.updateQueue;
      if (null === updateQueue) return null;
      updateQueue = updateQueue.shared;
      if (
        currentlyProcessingQueue === updateQueue &&
        !didWarnUpdateInsideUpdate
      ) {
        var componentName = getComponentNameFromFiber(fiber);
        console.error(
          "An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s",
          componentName
        );
        didWarnUpdateInsideUpdate = !0;
      }
      if ((executionContext & RenderContext) !== NoContext)
        return (
          (componentName = updateQueue.pending),
          null === componentName
            ? (update.next = update)
            : ((update.next = componentName.next),
              (componentName.next = update)),
          (updateQueue.pending = update),
          (update = getRootForUpdatedFiber(fiber)),
          markUpdateLaneFromFiberToRoot(fiber, null, lane),
          update
        );
      enqueueUpdate$1(fiber, updateQueue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function entangleTransitions(root, fiber, lane) {
      fiber = fiber.updateQueue;
      if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194048))) {
        var queueLanes = fiber.lanes;
        queueLanes &= root.pendingLanes;
        lane |= queueLanes;
        fiber.lanes = lane;
        markRootEntangled(root, lane);
      }
    }
    function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
      var queue = workInProgress.updateQueue,
        current = workInProgress.alternate;
      if (
        null !== current &&
        ((current = current.updateQueue), queue === current)
      ) {
        var newFirst = null,
          newLast = null;
        queue = queue.firstBaseUpdate;
        if (null !== queue) {
          do {
            var clone = {
              lane: queue.lane,
              tag: queue.tag,
              payload: queue.payload,
              callback: null,
              next: null
            };
            null === newLast
              ? (newFirst = newLast = clone)
              : (newLast = newLast.next = clone);
            queue = queue.next;
          } while (null !== queue);
          null === newLast
            ? (newFirst = newLast = capturedUpdate)
            : (newLast = newLast.next = capturedUpdate);
        } else newFirst = newLast = capturedUpdate;
        queue = {
          baseState: current.baseState,
          firstBaseUpdate: newFirst,
          lastBaseUpdate: newLast,
          shared: current.shared,
          callbacks: current.callbacks
        };
        workInProgress.updateQueue = queue;
        return;
      }
      workInProgress = queue.lastBaseUpdate;
      null === workInProgress
        ? (queue.firstBaseUpdate = capturedUpdate)
        : (workInProgress.next = capturedUpdate);
      queue.lastBaseUpdate = capturedUpdate;
    }
    function suspendIfUpdateReadFromEntangledAsyncAction() {
      if (didReadFromEntangledAsyncAction) {
        var entangledActionThenable = currentEntangledActionThenable;
        if (null !== entangledActionThenable) throw entangledActionThenable;
      }
    }
    function processUpdateQueue(
      workInProgress,
      props,
      instance$jscomp$0,
      renderLanes
    ) {
      didReadFromEntangledAsyncAction = !1;
      var queue = workInProgress.updateQueue;
      hasForceUpdate = !1;
      currentlyProcessingQueue = queue.shared;
      var firstBaseUpdate = queue.firstBaseUpdate,
        lastBaseUpdate = queue.lastBaseUpdate,
        pendingQueue = queue.shared.pending;
      if (null !== pendingQueue) {
        queue.shared.pending = null;
        var lastPendingUpdate = pendingQueue,
          firstPendingUpdate = lastPendingUpdate.next;
        lastPendingUpdate.next = null;
        null === lastBaseUpdate
          ? (firstBaseUpdate = firstPendingUpdate)
          : (lastBaseUpdate.next = firstPendingUpdate);
        lastBaseUpdate = lastPendingUpdate;
        var current = workInProgress.alternate;
        null !== current &&
          ((current = current.updateQueue),
          (pendingQueue = current.lastBaseUpdate),
          pendingQueue !== lastBaseUpdate &&
            (null === pendingQueue
              ? (current.firstBaseUpdate = firstPendingUpdate)
              : (pendingQueue.next = firstPendingUpdate),
            (current.lastBaseUpdate = lastPendingUpdate)));
      }
      if (null !== firstBaseUpdate) {
        var newState = queue.baseState;
        lastBaseUpdate = 0;
        current = firstPendingUpdate = lastPendingUpdate = null;
        pendingQueue = firstBaseUpdate;
        do {
          var updateLane = pendingQueue.lane & -536870913,
            isHiddenUpdate = updateLane !== pendingQueue.lane;
          if (
            isHiddenUpdate
              ? (workInProgressRootRenderLanes & updateLane) === updateLane
              : (renderLanes & updateLane) === updateLane
          ) {
            0 !== updateLane &&
              updateLane === currentEntangledLane &&
              (didReadFromEntangledAsyncAction = !0);
            null !== current &&
              (current = current.next =
                {
                  lane: 0,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: null,
                  next: null
                });
            a: {
              updateLane = workInProgress;
              var partialState = pendingQueue;
              var nextProps = props,
                instance = instance$jscomp$0;
              switch (partialState.tag) {
                case ReplaceState:
                  partialState = partialState.payload;
                  if ("function" === typeof partialState) {
                    isDisallowedContextReadInDEV = !0;
                    var nextState = partialState.call(
                      instance,
                      newState,
                      nextProps
                    );
                    if (updateLane.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(!0);
                      try {
                        partialState.call(instance, newState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(!1);
                      }
                    }
                    isDisallowedContextReadInDEV = !1;
                    newState = nextState;
                    break a;
                  }
                  newState = partialState;
                  break a;
                case CaptureUpdate:
                  updateLane.flags = (updateLane.flags & -65537) | 128;
                case UpdateState:
                  nextState = partialState.payload;
                  if ("function" === typeof nextState) {
                    isDisallowedContextReadInDEV = !0;
                    partialState = nextState.call(
                      instance,
                      newState,
                      nextProps
                    );
                    if (updateLane.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(!0);
                      try {
                        nextState.call(instance, newState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(!1);
                      }
                    }
                    isDisallowedContextReadInDEV = !1;
                  } else partialState = nextState;
                  if (null === partialState || void 0 === partialState) break a;
                  newState = assign({}, newState, partialState);
                  break a;
                case ForceUpdate:
                  hasForceUpdate = !0;
              }
            }
            updateLane = pendingQueue.callback;
            null !== updateLane &&
              ((workInProgress.flags |= 64),
              isHiddenUpdate && (workInProgress.flags |= 8192),
              (isHiddenUpdate = queue.callbacks),
              null === isHiddenUpdate
                ? (queue.callbacks = [updateLane])
                : isHiddenUpdate.push(updateLane));
          } else
            (isHiddenUpdate = {
              lane: updateLane,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: pendingQueue.callback,
              next: null
            }),
              null === current
                ? ((firstPendingUpdate = current = isHiddenUpdate),
                  (lastPendingUpdate = newState))
                : (current = current.next = isHiddenUpdate),
              (lastBaseUpdate |= updateLane);
          pendingQueue = pendingQueue.next;
          if (null === pendingQueue)
            if (((pendingQueue = queue.shared.pending), null === pendingQueue))
              break;
            else
              (isHiddenUpdate = pendingQueue),
                (pendingQueue = isHiddenUpdate.next),
                (isHiddenUpdate.next = null),
                (queue.lastBaseUpdate = isHiddenUpdate),
                (queue.shared.pending = null);
        } while (1);
        null === current && (lastPendingUpdate = newState);
        queue.baseState = lastPendingUpdate;
        queue.firstBaseUpdate = firstPendingUpdate;
        queue.lastBaseUpdate = current;
        null === firstBaseUpdate && (queue.shared.lanes = 0);
        workInProgressRootSkippedLanes |= lastBaseUpdate;
        workInProgress.lanes = lastBaseUpdate;
        workInProgress.memoizedState = newState;
      }
      currentlyProcessingQueue = null;
    }
    function callCallback(callback, context) {
      if ("function" !== typeof callback)
        throw Error(
          "Invalid argument passed as callback. Expected a function. Instead received: " +
            callback
        );
      callback.call(context);
    }
    function commitHiddenCallbacks(updateQueue, context) {
      var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
      if (null !== hiddenCallbacks)
        for (
          updateQueue.shared.hiddenCallbacks = null, updateQueue = 0;
          updateQueue < hiddenCallbacks.length;
          updateQueue++
        )
          callCallback(hiddenCallbacks[updateQueue], context);
    }
    function commitCallbacks(updateQueue, context) {
      var callbacks = updateQueue.callbacks;
      if (null !== callbacks)
        for (
          updateQueue.callbacks = null, updateQueue = 0;
          updateQueue < callbacks.length;
          updateQueue++
        )
          callCallback(callbacks[updateQueue], context);
    }
    function pushHiddenContext(fiber, context) {
      var prevEntangledRenderLanes = entangledRenderLanes;
      push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
      push(currentTreeHiddenStackCursor, context, fiber);
      entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
    }
    function reuseHiddenContextOnStack(fiber) {
      push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
      push(
        currentTreeHiddenStackCursor,
        currentTreeHiddenStackCursor.current,
        fiber
      );
    }
    function popHiddenContext(fiber) {
      entangledRenderLanes = prevEntangledRenderLanesCursor.current;
      pop(currentTreeHiddenStackCursor, fiber);
      pop(prevEntangledRenderLanesCursor, fiber);
    }
    function mountHookTypesDev() {
      var hookName = currentHookNameInDev;
      null === hookTypesDev
        ? (hookTypesDev = [hookName])
        : hookTypesDev.push(hookName);
    }
    function updateHookTypesDev() {
      var hookName = currentHookNameInDev;
      if (
        null !== hookTypesDev &&
        (hookTypesUpdateIndexDev++,
        hookTypesDev[hookTypesUpdateIndexDev] !== hookName)
      ) {
        var componentName = getComponentNameFromFiber(currentlyRenderingFiber);
        if (
          !didWarnAboutMismatchedHooksForComponent.has(componentName) &&
          (didWarnAboutMismatchedHooksForComponent.add(componentName),
          null !== hookTypesDev)
        ) {
          for (var table = "", i = 0; i <= hookTypesUpdateIndexDev; i++) {
            var oldHookName = hookTypesDev[i],
              newHookName =
                i === hookTypesUpdateIndexDev ? hookName : oldHookName;
            for (
              oldHookName = i + 1 + ". " + oldHookName;
              30 > oldHookName.length;

            )
              oldHookName += " ";
            oldHookName += newHookName + "\n";
            table += oldHookName;
          }
          console.error(
            "React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
            componentName,
            table
          );
        }
      }
    }
    function checkDepsAreArrayDev(deps) {
      void 0 === deps ||
        null === deps ||
        isArrayImpl(deps) ||
        console.error(
          "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
          currentHookNameInDev,
          typeof deps
        );
    }
    function warnOnUseFormStateInDev() {
      var componentName = getComponentNameFromFiber(currentlyRenderingFiber);
      didWarnAboutUseFormState.has(componentName) ||
        (didWarnAboutUseFormState.add(componentName),
        console.error(
          "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
          componentName
        ));
    }
    function throwInvalidHookError() {
      throw Error(
        "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
      );
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
      if (ignorePreviousDependencies) return !1;
      if (null === prevDeps)
        return (
          console.error(
            "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
            currentHookNameInDev
          ),
          !1
        );
      nextDeps.length !== prevDeps.length &&
        console.error(
          "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
          currentHookNameInDev,
          "[" + prevDeps.join(", ") + "]",
          "[" + nextDeps.join(", ") + "]"
        );
      for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
        if (!objectIs(nextDeps[i], prevDeps[i])) return !1;
      return !0;
    }
    function renderWithHooks(
      current,
      workInProgress,
      Component,
      props,
      secondArg,
      nextRenderLanes
    ) {
      renderLanes = nextRenderLanes;
      currentlyRenderingFiber = workInProgress;
      hookTypesDev = null !== current ? current._debugHookTypes : null;
      hookTypesUpdateIndexDev = -1;
      ignorePreviousDependencies =
        null !== current && current.type !== workInProgress.type;
      if (
        "[object AsyncFunction]" ===
          Object.prototype.toString.call(Component) ||
        "[object AsyncGeneratorFunction]" ===
          Object.prototype.toString.call(Component)
      )
        (nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber)),
          didWarnAboutAsyncClientComponent.has(nextRenderLanes) ||
            (didWarnAboutAsyncClientComponent.add(nextRenderLanes),
            console.error(
              "%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.",
              null === nextRenderLanes
                ? "An unknown Component"
                : "<" + nextRenderLanes + ">"
            ));
      workInProgress.memoizedState = null;
      workInProgress.updateQueue = null;
      workInProgress.lanes = 0;
      ReactSharedInternals.H =
        null !== current && null !== current.memoizedState
          ? HooksDispatcherOnUpdateInDEV
          : null !== hookTypesDev
            ? HooksDispatcherOnMountWithHookTypesInDEV
            : HooksDispatcherOnMountInDEV;
      shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes =
        (workInProgress.mode & StrictLegacyMode) !== NoMode;
      var children = callComponentInDEV(Component, props, secondArg);
      shouldDoubleInvokeUserFnsInHooksDEV = !1;
      didScheduleRenderPhaseUpdateDuringThisPass &&
        (children = renderWithHooksAgain(
          workInProgress,
          Component,
          props,
          secondArg
        ));
      if (nextRenderLanes) {
        setIsStrictModeForDevtools(!0);
        try {
          children = renderWithHooksAgain(
            workInProgress,
            Component,
            props,
            secondArg
          );
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      finishRenderingHooks(current, workInProgress);
      return children;
    }
    function finishRenderingHooks(current, workInProgress) {
      workInProgress._debugHookTypes = hookTypesDev;
      null === workInProgress.dependencies
        ? null !== thenableState$1 &&
          (workInProgress.dependencies = {
            lanes: 0,
            firstContext: null,
            _debugThenableState: thenableState$1
          })
        : (workInProgress.dependencies._debugThenableState = thenableState$1);
      ReactSharedInternals.H = ContextOnlyDispatcher;
      var didRenderTooFewHooks =
        null !== currentHook && null !== currentHook.next;
      renderLanes = 0;
      hookTypesDev =
        currentHookNameInDev =
        workInProgressHook =
        currentHook =
        currentlyRenderingFiber =
          null;
      hookTypesUpdateIndexDev = -1;
      null !== current &&
        (current.flags & 65011712) !== (workInProgress.flags & 65011712) &&
        console.error(
          "Internal React error: Expected static flag was missing. Please notify the React team."
        );
      didScheduleRenderPhaseUpdate = !1;
      thenableIndexCounter$1 = 0;
      thenableState$1 = null;
      if (didRenderTooFewHooks)
        throw Error(
          "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
        );
      null === current ||
        didReceiveUpdate ||
        ((current = current.dependencies),
        null !== current &&
          checkIfContextChanged(current) &&
          (didReceiveUpdate = !0));
      needsToResetSuspendedThenableDEV
        ? ((needsToResetSuspendedThenableDEV = !1), (current = !0))
        : (current = !1);
      current &&
        ((workInProgress =
          getComponentNameFromFiber(workInProgress) || "Unknown"),
        didWarnAboutUseWrappedInTryCatch.has(workInProgress) ||
          didWarnAboutAsyncClientComponent.has(workInProgress) ||
          (didWarnAboutUseWrappedInTryCatch.add(workInProgress),
          console.error(
            "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
          )));
    }
    function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
      currentlyRenderingFiber = workInProgress;
      var numberOfReRenders = 0;
      do {
        didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
        thenableIndexCounter$1 = 0;
        didScheduleRenderPhaseUpdateDuringThisPass = !1;
        if (numberOfReRenders >= RE_RENDER_LIMIT)
          throw Error(
            "Too many re-renders. React limits the number of renders to prevent an infinite loop."
          );
        numberOfReRenders += 1;
        ignorePreviousDependencies = !1;
        workInProgressHook = currentHook = null;
        if (null != workInProgress.updateQueue) {
          var children = workInProgress.updateQueue;
          children.lastEffect = null;
          children.events = null;
          children.stores = null;
          null != children.memoCache && (children.memoCache.index = 0);
        }
        hookTypesUpdateIndexDev = -1;
        ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
        children = callComponentInDEV(Component, props, secondArg);
      } while (didScheduleRenderPhaseUpdateDuringThisPass);
      return children;
    }
    function TransitionAwareHostComponent() {
      var dispatcher = ReactSharedInternals.H,
        maybeThenable = dispatcher.useState()[0];
      maybeThenable =
        "function" === typeof maybeThenable.then
          ? useThenable(maybeThenable)
          : maybeThenable;
      dispatcher = dispatcher.useState()[0];
      (null !== currentHook ? currentHook.memoizedState : null) !==
        dispatcher && (currentlyRenderingFiber.flags |= 1024);
      return maybeThenable;
    }
    function checkDidRenderIdHook() {
      var didRenderIdHook = 0 !== localIdCounter;
      localIdCounter = 0;
      return didRenderIdHook;
    }
    function bailoutHooks(current, workInProgress, lanes) {
      workInProgress.updateQueue = current.updateQueue;
      workInProgress.flags =
        (workInProgress.mode & StrictEffectsMode) !== NoMode
          ? workInProgress.flags & -402655237
          : workInProgress.flags & -2053;
      current.lanes &= ~lanes;
    }
    function resetHooksOnUnwind(workInProgress) {
      if (didScheduleRenderPhaseUpdate) {
        for (
          workInProgress = workInProgress.memoizedState;
          null !== workInProgress;

        ) {
          var queue = workInProgress.queue;
          null !== queue && (queue.pending = null);
          workInProgress = workInProgress.next;
        }
        didScheduleRenderPhaseUpdate = !1;
      }
      renderLanes = 0;
      hookTypesDev =
        workInProgressHook =
        currentHook =
        currentlyRenderingFiber =
          null;
      hookTypesUpdateIndexDev = -1;
      currentHookNameInDev = null;
      didScheduleRenderPhaseUpdateDuringThisPass = !1;
      thenableIndexCounter$1 = localIdCounter = 0;
      thenableState$1 = null;
    }
    function mountWorkInProgressHook() {
      var hook = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      null === workInProgressHook
        ? (currentlyRenderingFiber.memoizedState = workInProgressHook = hook)
        : (workInProgressHook = workInProgressHook.next = hook);
      return workInProgressHook;
    }
    function updateWorkInProgressHook() {
      if (null === currentHook) {
        var nextCurrentHook = currentlyRenderingFiber.alternate;
        nextCurrentHook =
          null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
      } else nextCurrentHook = currentHook.next;
      var nextWorkInProgressHook =
        null === workInProgressHook
          ? currentlyRenderingFiber.memoizedState
          : workInProgressHook.next;
      if (null !== nextWorkInProgressHook)
        (workInProgressHook = nextWorkInProgressHook),
          (currentHook = nextCurrentHook);
      else {
        if (null === nextCurrentHook) {
          if (null === currentlyRenderingFiber.alternate)
            throw Error(
              "Update hook called on initial render. This is likely a bug in React. Please file an issue."
            );
          throw Error("Rendered more hooks than during the previous render.");
        }
        currentHook = nextCurrentHook;
        nextCurrentHook = {
          memoizedState: currentHook.memoizedState,
          baseState: currentHook.baseState,
          baseQueue: currentHook.baseQueue,
          queue: currentHook.queue,
          next: null
        };
        null === workInProgressHook
          ? (currentlyRenderingFiber.memoizedState = workInProgressHook =
              nextCurrentHook)
          : (workInProgressHook = workInProgressHook.next = nextCurrentHook);
      }
      return workInProgressHook;
    }
    function createFunctionComponentUpdateQueue() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }
    function useThenable(thenable) {
      var index = thenableIndexCounter$1;
      thenableIndexCounter$1 += 1;
      null === thenableState$1 && (thenableState$1 = createThenableState());
      thenable = trackUsedThenable(thenableState$1, thenable, index);
      index = currentlyRenderingFiber;
      null ===
        (null === workInProgressHook
          ? index.memoizedState
          : workInProgressHook.next) &&
        ((index = index.alternate),
        (ReactSharedInternals.H =
          null !== index && null !== index.memoizedState
            ? HooksDispatcherOnUpdateInDEV
            : HooksDispatcherOnMountInDEV));
      return thenable;
    }
    function use(usable) {
      if (null !== usable && "object" === typeof usable) {
        if ("function" === typeof usable.then) return useThenable(usable);
        if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
      }
      throw Error("An unsupported type was passed to use(): " + String(usable));
    }
    function useMemoCache(size) {
      var memoCache = null,
        updateQueue = currentlyRenderingFiber.updateQueue;
      null !== updateQueue && (memoCache = updateQueue.memoCache);
      if (null == memoCache) {
        var current = currentlyRenderingFiber.alternate;
        null !== current &&
          ((current = current.updateQueue),
          null !== current &&
            ((current = current.memoCache),
            null != current &&
              (memoCache = {
                data: current.data.map(function (array) {
                  return array.slice();
                }),
                index: 0
              })));
      }
      null == memoCache && (memoCache = { data: [], index: 0 });
      null === updateQueue &&
        ((updateQueue = createFunctionComponentUpdateQueue()),
        (currentlyRenderingFiber.updateQueue = updateQueue));
      updateQueue.memoCache = memoCache;
      updateQueue = memoCache.data[memoCache.index];
      if (void 0 === updateQueue || ignorePreviousDependencies)
        for (
          updateQueue = memoCache.data[memoCache.index] = Array(size),
            current = 0;
          current < size;
          current++
        )
          updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
      else
        updateQueue.length !== size &&
          console.error(
            "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
            updateQueue.length,
            size
          );
      memoCache.index++;
      return updateQueue;
    }
    function basicStateReducer(state, action) {
      return "function" === typeof action ? action(state) : action;
    }
    function mountReducer(reducer, initialArg, init) {
      var hook = mountWorkInProgressHook();
      if (void 0 !== init) {
        var initialState = init(initialArg);
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(!0);
          try {
            init(initialArg);
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
      } else initialState = initialArg;
      hook.memoizedState = hook.baseState = initialState;
      reducer = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: reducer,
        lastRenderedState: initialState
      };
      hook.queue = reducer;
      reducer = reducer.dispatch = dispatchReducerAction.bind(
        null,
        currentlyRenderingFiber,
        reducer
      );
      return [hook.memoizedState, reducer];
    }
    function updateReducer(reducer) {
      var hook = updateWorkInProgressHook();
      return updateReducerImpl(hook, currentHook, reducer);
    }
    function updateReducerImpl(hook, current, reducer) {
      var queue = hook.queue;
      if (null === queue)
        throw Error(
          "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
        );
      queue.lastRenderedReducer = reducer;
      var baseQueue = hook.baseQueue,
        pendingQueue = queue.pending;
      if (null !== pendingQueue) {
        if (null !== baseQueue) {
          var baseFirst = baseQueue.next;
          baseQueue.next = pendingQueue.next;
          pendingQueue.next = baseFirst;
        }
        current.baseQueue !== baseQueue &&
          console.error(
            "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
          );
        current.baseQueue = baseQueue = pendingQueue;
        queue.pending = null;
      }
      pendingQueue = hook.baseState;
      if (null === baseQueue) hook.memoizedState = pendingQueue;
      else {
        current = baseQueue.next;
        var newBaseQueueFirst = (baseFirst = null),
          newBaseQueueLast = null,
          update = current,
          didReadFromEntangledAsyncAction = !1;
        do {
          var updateLane = update.lane & -536870913;
          if (
            updateLane !== update.lane
              ? (workInProgressRootRenderLanes & updateLane) === updateLane
              : (renderLanes & updateLane) === updateLane
          ) {
            var revertLane = update.revertLane;
            if (0 === revertLane)
              null !== newBaseQueueLast &&
                (newBaseQueueLast = newBaseQueueLast.next =
                  {
                    lane: 0,
                    revertLane: 0,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  }),
                updateLane === currentEntangledLane &&
                  (didReadFromEntangledAsyncAction = !0);
            else if ((renderLanes & revertLane) === revertLane) {
              update = update.next;
              revertLane === currentEntangledLane &&
                (didReadFromEntangledAsyncAction = !0);
              continue;
            } else
              (updateLane = {
                lane: 0,
                revertLane: update.revertLane,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }),
                null === newBaseQueueLast
                  ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),
                    (baseFirst = pendingQueue))
                  : (newBaseQueueLast = newBaseQueueLast.next = updateLane),
                (currentlyRenderingFiber.lanes |= revertLane),
                (workInProgressRootSkippedLanes |= revertLane);
            updateLane = update.action;
            shouldDoubleInvokeUserFnsInHooksDEV &&
              reducer(pendingQueue, updateLane);
            pendingQueue = update.hasEagerState
              ? update.eagerState
              : reducer(pendingQueue, updateLane);
          } else
            (revertLane = {
              lane: updateLane,
              revertLane: update.revertLane,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }),
              null === newBaseQueueLast
                ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),
                  (baseFirst = pendingQueue))
                : (newBaseQueueLast = newBaseQueueLast.next = revertLane),
              (currentlyRenderingFiber.lanes |= updateLane),
              (workInProgressRootSkippedLanes |= updateLane);
          update = update.next;
        } while (null !== update && update !== current);
        null === newBaseQueueLast
          ? (baseFirst = pendingQueue)
          : (newBaseQueueLast.next = newBaseQueueFirst);
        if (
          !objectIs(pendingQueue, hook.memoizedState) &&
          ((didReceiveUpdate = !0),
          didReadFromEntangledAsyncAction &&
            ((reducer = currentEntangledActionThenable), null !== reducer))
        )
          throw reducer;
        hook.memoizedState = pendingQueue;
        hook.baseState = baseFirst;
        hook.baseQueue = newBaseQueueLast;
        queue.lastRenderedState = pendingQueue;
      }
      null === baseQueue && (queue.lanes = 0);
      return [hook.memoizedState, queue.dispatch];
    }
    function rerenderReducer(reducer) {
      var hook = updateWorkInProgressHook(),
        queue = hook.queue;
      if (null === queue)
        throw Error(
          "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
        );
      queue.lastRenderedReducer = reducer;
      var dispatch = queue.dispatch,
        lastRenderPhaseUpdate = queue.pending,
        newState = hook.memoizedState;
      if (null !== lastRenderPhaseUpdate) {
        queue.pending = null;
        var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);
        do
          (newState = reducer(newState, update.action)), (update = update.next);
        while (update !== lastRenderPhaseUpdate);
        objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);
        hook.memoizedState = newState;
        null === hook.baseQueue && (hook.baseState = newState);
        queue.lastRenderedState = newState;
      }
      return [newState, dispatch];
    }
    function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber,
        hook = mountWorkInProgressHook();
      if (isHydrating) {
        if (void 0 === getServerSnapshot)
          throw Error(
            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
          );
        var nextSnapshot = getServerSnapshot();
        didWarnUncachedGetSnapshot ||
          nextSnapshot === getServerSnapshot() ||
          (console.error(
            "The result of getServerSnapshot should be cached to avoid an infinite loop"
          ),
          (didWarnUncachedGetSnapshot = !0));
      } else {
        nextSnapshot = getSnapshot();
        didWarnUncachedGetSnapshot ||
          ((getServerSnapshot = getSnapshot()),
          objectIs(nextSnapshot, getServerSnapshot) ||
            (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ),
            (didWarnUncachedGetSnapshot = !0)));
        if (null === workInProgressRoot)
          throw Error(
            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
          );
        0 !== (workInProgressRootRenderLanes & 124) ||
          pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
      }
      hook.memoizedState = nextSnapshot;
      getServerSnapshot = { value: nextSnapshot, getSnapshot: getSnapshot };
      hook.queue = getServerSnapshot;
      mountEffect(
        subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe),
        [subscribe]
      );
      fiber.flags |= 2048;
      pushSimpleEffect(
        HasEffect | Passive,
        createEffectInstance(),
        updateStoreInstance.bind(
          null,
          fiber,
          getServerSnapshot,
          nextSnapshot,
          getSnapshot
        ),
        null
      );
      return nextSnapshot;
    }
    function updateSyncExternalStore(
      subscribe,
      getSnapshot,
      getServerSnapshot
    ) {
      var fiber = currentlyRenderingFiber,
        hook = updateWorkInProgressHook(),
        isHydrating$jscomp$0 = isHydrating;
      if (isHydrating$jscomp$0) {
        if (void 0 === getServerSnapshot)
          throw Error(
            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
          );
        getServerSnapshot = getServerSnapshot();
      } else if (
        ((getServerSnapshot = getSnapshot()), !didWarnUncachedGetSnapshot)
      ) {
        var cachedSnapshot = getSnapshot();
        objectIs(getServerSnapshot, cachedSnapshot) ||
          (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ),
          (didWarnUncachedGetSnapshot = !0));
      }
      if (
        (cachedSnapshot = !objectIs(
          (currentHook || hook).memoizedState,
          getServerSnapshot
        ))
      )
        (hook.memoizedState = getServerSnapshot), (didReceiveUpdate = !0);
      hook = hook.queue;
      var create = subscribeToStore.bind(null, fiber, hook, subscribe);
      updateEffectImpl(2048, Passive, create, [subscribe]);
      if (
        hook.getSnapshot !== getSnapshot ||
        cachedSnapshot ||
        (null !== workInProgressHook &&
          workInProgressHook.memoizedState.tag & HasEffect)
      ) {
        fiber.flags |= 2048;
        pushSimpleEffect(
          HasEffect | Passive,
          createEffectInstance(),
          updateStoreInstance.bind(
            null,
            fiber,
            hook,
            getServerSnapshot,
            getSnapshot
          ),
          null
        );
        if (null === workInProgressRoot)
          throw Error(
            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
          );
        isHydrating$jscomp$0 ||
          0 !== (renderLanes & 124) ||
          pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      return getServerSnapshot;
    }
    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
      fiber.flags |= 16384;
      fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };
      getSnapshot = currentlyRenderingFiber.updateQueue;
      null === getSnapshot
        ? ((getSnapshot = createFunctionComponentUpdateQueue()),
          (currentlyRenderingFiber.updateQueue = getSnapshot),
          (getSnapshot.stores = [fiber]))
        : ((renderedSnapshot = getSnapshot.stores),
          null === renderedSnapshot
            ? (getSnapshot.stores = [fiber])
            : renderedSnapshot.push(fiber));
    }
    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
      inst.value = nextSnapshot;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    }
    function subscribeToStore(fiber, inst, subscribe) {
      return subscribe(function () {
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      });
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error) {
        return !0;
      }
    }
    function forceStoreRerender(fiber) {
      var root = enqueueConcurrentRenderForLane(fiber, 2);
      null !== root && scheduleUpdateOnFiber(root, fiber, 2);
    }
    function mountStateImpl(initialState) {
      var hook = mountWorkInProgressHook();
      if ("function" === typeof initialState) {
        var initialStateInitializer = initialState;
        initialState = initialStateInitializer();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(!0);
          try {
            initialStateInitializer();
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
      }
      hook.memoizedState = hook.baseState = initialState;
      hook.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialState
      };
      return hook;
    }
    function mountState(initialState) {
      initialState = mountStateImpl(initialState);
      var queue = initialState.queue,
        dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
      queue.dispatch = dispatch;
      return [initialState.memoizedState, dispatch];
    }
    function mountOptimistic(passthrough) {
      var hook = mountWorkInProgressHook();
      hook.memoizedState = hook.baseState = passthrough;
      var queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      hook.queue = queue;
      hook = dispatchOptimisticSetState.bind(
        null,
        currentlyRenderingFiber,
        !0,
        queue
      );
      queue.dispatch = hook;
      return [passthrough, hook];
    }
    function updateOptimistic(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    }
    function updateOptimisticImpl(hook, current, passthrough, reducer) {
      hook.baseState = passthrough;
      return updateReducerImpl(
        hook,
        currentHook,
        "function" === typeof reducer ? reducer : basicStateReducer
      );
    }
    function rerenderOptimistic(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      if (null !== currentHook)
        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
      hook.baseState = passthrough;
      return [passthrough, hook.queue.dispatch];
    }
    function dispatchActionState(
      fiber,
      actionQueue,
      setPendingState,
      setState,
      payload
    ) {
      if (isRenderPhaseUpdate(fiber))
        throw Error("Cannot update form state while rendering.");
      fiber = actionQueue.action;
      if (null !== fiber) {
        var actionNode = {
          payload: payload,
          action: fiber,
          next: null,
          isTransition: !0,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function (listener) {
            actionNode.listeners.push(listener);
          }
        };
        null !== ReactSharedInternals.T
          ? setPendingState(!0)
          : (actionNode.isTransition = !1);
        setState(actionNode);
        setPendingState = actionQueue.pending;
        null === setPendingState
          ? ((actionNode.next = actionQueue.pending = actionNode),
            runActionStateAction(actionQueue, actionNode))
          : ((actionNode.next = setPendingState.next),
            (actionQueue.pending = setPendingState.next = actionNode));
      }
    }
    function runActionStateAction(actionQueue, node) {
      var action = node.action,
        payload = node.payload,
        prevState = actionQueue.state;
      if (node.isTransition) {
        var prevTransition = ReactSharedInternals.T,
          currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        ReactSharedInternals.T._updatedFibers = new Set();
        try {
          var returnValue = action(prevState, payload),
            onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish &&
            onStartTransitionFinish(currentTransition, returnValue);
          handleActionReturnValue(actionQueue, node, returnValue);
        } catch (error) {
          onActionError(actionQueue, node, error);
        } finally {
          (ReactSharedInternals.T = prevTransition),
            null === prevTransition &&
              currentTransition._updatedFibers &&
              ((actionQueue = currentTransition._updatedFibers.size),
              currentTransition._updatedFibers.clear(),
              10 < actionQueue &&
                console.warn(
                  "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
                ));
        }
      } else
        try {
          (currentTransition = action(prevState, payload)),
            handleActionReturnValue(actionQueue, node, currentTransition);
        } catch (error$4) {
          onActionError(actionQueue, node, error$4);
        }
    }
    function handleActionReturnValue(actionQueue, node, returnValue) {
      null !== returnValue &&
      "object" === typeof returnValue &&
      "function" === typeof returnValue.then
        ? (returnValue.then(
            function (nextState) {
              onActionSuccess(actionQueue, node, nextState);
            },
            function (error) {
              return onActionError(actionQueue, node, error);
            }
          ),
          node.isTransition ||
            console.error(
              "An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop."
            ))
        : onActionSuccess(actionQueue, node, returnValue);
    }
    function onActionSuccess(actionQueue, actionNode, nextState) {
      actionNode.status = "fulfilled";
      actionNode.value = nextState;
      notifyActionListeners(actionNode);
      actionQueue.state = nextState;
      actionNode = actionQueue.pending;
      null !== actionNode &&
        ((nextState = actionNode.next),
        nextState === actionNode
          ? (actionQueue.pending = null)
          : ((nextState = nextState.next),
            (actionNode.next = nextState),
            runActionStateAction(actionQueue, nextState)));
    }
    function onActionError(actionQueue, actionNode, error) {
      var last = actionQueue.pending;
      actionQueue.pending = null;
      if (null !== last) {
        last = last.next;
        do
          (actionNode.status = "rejected"),
            (actionNode.reason = error),
            notifyActionListeners(actionNode),
            (actionNode = actionNode.next);
        while (actionNode !== last);
      }
      actionQueue.action = null;
    }
    function notifyActionListeners(actionNode) {
      actionNode = actionNode.listeners;
      for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
    }
    function actionStateReducer(oldState, newState) {
      return newState;
    }
    function mountActionState(action, initialStateProp) {
      if (isHydrating) {
        var ssrFormState = workInProgressRoot.formState;
        if (null !== ssrFormState) {
          a: {
            var isMatching = currentlyRenderingFiber;
            if (isHydrating) {
              if (nextHydratableInstance) {
                b: {
                  var markerInstance = nextHydratableInstance;
                  for (
                    var inRootOrSingleton = rootOrSingletonContext;
                    8 !== markerInstance.nodeType;

                  ) {
                    if (!inRootOrSingleton) {
                      markerInstance = null;
                      break b;
                    }
                    markerInstance = getNextHydratable(
                      markerInstance.nextSibling
                    );
                    if (null === markerInstance) {
                      markerInstance = null;
                      break b;
                    }
                  }
                  inRootOrSingleton = markerInstance.data;
                  markerInstance =
                    inRootOrSingleton === FORM_STATE_IS_MATCHING ||
                    inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING
                      ? markerInstance
                      : null;
                }
                if (markerInstance) {
                  nextHydratableInstance = getNextHydratable(
                    markerInstance.nextSibling
                  );
                  isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;
                  break a;
                }
              }
              throwOnHydrationMismatch(isMatching);
            }
            isMatching = !1;
          }
          isMatching && (initialStateProp = ssrFormState[0]);
        }
      }
      ssrFormState = mountWorkInProgressHook();
      ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
      isMatching = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: actionStateReducer,
        lastRenderedState: initialStateProp
      };
      ssrFormState.queue = isMatching;
      ssrFormState = dispatchSetState.bind(
        null,
        currentlyRenderingFiber,
        isMatching
      );
      isMatching.dispatch = ssrFormState;
      isMatching = mountStateImpl(!1);
      inRootOrSingleton = dispatchOptimisticSetState.bind(
        null,
        currentlyRenderingFiber,
        !1,
        isMatching.queue
      );
      isMatching = mountWorkInProgressHook();
      markerInstance = {
        state: initialStateProp,
        dispatch: null,
        action: action,
        pending: null
      };
      isMatching.queue = markerInstance;
      ssrFormState = dispatchActionState.bind(
        null,
        currentlyRenderingFiber,
        markerInstance,
        inRootOrSingleton,
        ssrFormState
      );
      markerInstance.dispatch = ssrFormState;
      isMatching.memoizedState = action;
      return [initialStateProp, ssrFormState, !1];
    }
    function updateActionState(action) {
      var stateHook = updateWorkInProgressHook();
      return updateActionStateImpl(stateHook, currentHook, action);
    }
    function updateActionStateImpl(stateHook, currentStateHook, action) {
      currentStateHook = updateReducerImpl(
        stateHook,
        currentStateHook,
        actionStateReducer
      )[0];
      stateHook = updateReducer(basicStateReducer)[0];
      if (
        "object" === typeof currentStateHook &&
        null !== currentStateHook &&
        "function" === typeof currentStateHook.then
      )
        try {
          var state = useThenable(currentStateHook);
        } catch (x) {
          if (x === SuspenseException) throw SuspenseActionException;
          throw x;
        }
      else state = currentStateHook;
      currentStateHook = updateWorkInProgressHook();
      var actionQueue = currentStateHook.queue,
        dispatch = actionQueue.dispatch;
      action !== currentStateHook.memoizedState &&
        ((currentlyRenderingFiber.flags |= 2048),
        pushSimpleEffect(
          HasEffect | Passive,
          createEffectInstance(),
          actionStateActionEffect.bind(null, actionQueue, action),
          null
        ));
      return [state, dispatch, stateHook];
    }
    function actionStateActionEffect(actionQueue, action) {
      actionQueue.action = action;
    }
    function rerenderActionState(action) {
      var stateHook = updateWorkInProgressHook(),
        currentStateHook = currentHook;
      if (null !== currentStateHook)
        return updateActionStateImpl(stateHook, currentStateHook, action);
      updateWorkInProgressHook();
      stateHook = stateHook.memoizedState;
      currentStateHook = updateWorkInProgressHook();
      var dispatch = currentStateHook.queue.dispatch;
      currentStateHook.memoizedState = action;
      return [stateHook, dispatch, !1];
    }
    function pushSimpleEffect(tag, inst, create, createDeps) {
      tag = {
        tag: tag,
        create: create,
        deps: createDeps,
        inst: inst,
        next: null
      };
      inst = currentlyRenderingFiber.updateQueue;
      null === inst &&
        ((inst = createFunctionComponentUpdateQueue()),
        (currentlyRenderingFiber.updateQueue = inst));
      create = inst.lastEffect;
      null === create
        ? (inst.lastEffect = tag.next = tag)
        : ((createDeps = create.next),
          (create.next = tag),
          (tag.next = createDeps),
          (inst.lastEffect = tag));
      return tag;
    }
    function createEffectInstance() {
      return { destroy: void 0, resource: void 0 };
    }
    function mountRef(initialValue) {
      var hook = mountWorkInProgressHook();
      initialValue = { current: initialValue };
      return (hook.memoizedState = initialValue);
    }
    function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
      var hook = mountWorkInProgressHook();
      createDeps = void 0 === createDeps ? null : createDeps;
      currentlyRenderingFiber.flags |= fiberFlags;
      hook.memoizedState = pushSimpleEffect(
        HasEffect | hookFlags,
        createEffectInstance(),
        create,
        createDeps
      );
    }
    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var inst = hook.memoizedState.inst;
      null !== currentHook &&
      null !== deps &&
      areHookInputsEqual(deps, currentHook.memoizedState.deps)
        ? (hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps))
        : ((currentlyRenderingFiber.flags |= fiberFlags),
          (hook.memoizedState = pushSimpleEffect(
            HasEffect | hookFlags,
            inst,
            create,
            deps
          )));
    }
    function mountEffect(create, createDeps) {
      (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode &&
      (currentlyRenderingFiber.mode & NoStrictPassiveEffectsMode) === NoMode
        ? mountEffectImpl(276826112, Passive, create, createDeps)
        : mountEffectImpl(8390656, Passive, create, createDeps);
    }
    function mountLayoutEffect(create, deps) {
      var fiberFlags = 4194308;
      (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode &&
        (fiberFlags |= 134217728);
      return mountEffectImpl(fiberFlags, Layout, create, deps);
    }
    function imperativeHandleEffect(create, ref) {
      if ("function" === typeof ref) {
        create = create();
        var refCleanup = ref(create);
        return function () {
          "function" === typeof refCleanup ? refCleanup() : ref(null);
        };
      }
      if (null !== ref && void 0 !== ref)
        return (
          ref.hasOwnProperty("current") ||
            console.error(
              "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
              "an object with keys {" + Object.keys(ref).join(", ") + "}"
            ),
          (create = create()),
          (ref.current = create),
          function () {
            ref.current = null;
          }
        );
    }
    function mountImperativeHandle(ref, create, deps) {
      "function" !== typeof create &&
        console.error(
          "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
          null !== create ? typeof create : "null"
        );
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      var fiberFlags = 4194308;
      (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode &&
        (fiberFlags |= 134217728);
      mountEffectImpl(
        fiberFlags,
        Layout,
        imperativeHandleEffect.bind(null, create, ref),
        deps
      );
    }
    function updateImperativeHandle(ref, create, deps) {
      "function" !== typeof create &&
        console.error(
          "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
          null !== create ? typeof create : "null"
        );
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      updateEffectImpl(
        4,
        Layout,
        imperativeHandleEffect.bind(null, create, ref),
        deps
      );
    }
    function mountCallback(callback, deps) {
      mountWorkInProgressHook().memoizedState = [
        callback,
        void 0 === deps ? null : deps
      ];
      return callback;
    }
    function updateCallback(callback, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      hook.memoizedState = [callback, deps];
      return callback;
    }
    function mountMemo(nextCreate, deps) {
      var hook = mountWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var nextValue = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(!0);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      hook.memoizedState = [nextValue, deps];
      return nextValue;
    }
    function updateMemo(nextCreate, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      prevState = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(!0);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      hook.memoizedState = [prevState, deps];
      return prevState;
    }
    function mountDeferredValue(value, initialValue) {
      var hook = mountWorkInProgressHook();
      return mountDeferredValueImpl(hook, value, initialValue);
    }
    function updateDeferredValue(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return updateDeferredValueImpl(
        hook,
        currentHook.memoizedState,
        value,
        initialValue
      );
    }
    function rerenderDeferredValue(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return null === currentHook
        ? mountDeferredValueImpl(hook, value, initialValue)
        : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
    }
    function mountDeferredValueImpl(hook, value, initialValue) {
      if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
        return (hook.memoizedState = value);
      hook.memoizedState = initialValue;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return initialValue;
    }
    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
      if (objectIs(value, prevValue)) return value;
      if (null !== currentTreeHiddenStackCursor.current)
        return (
          (hook = mountDeferredValueImpl(hook, value, initialValue)),
          objectIs(hook, prevValue) || (didReceiveUpdate = !0),
          hook
        );
      if (0 === (renderLanes & 42))
        return (didReceiveUpdate = !0), (hook.memoizedState = value);
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return prevValue;
    }
    function startTransition(
      fiber,
      queue,
      pendingState,
      finishedState,
      callback
    ) {
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p =
        0 !== previousPriority && previousPriority < ContinuousEventPriority
          ? previousPriority
          : ContinuousEventPriority;
      var prevTransition = ReactSharedInternals.T,
        currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      dispatchOptimisticSetState(fiber, !1, queue, pendingState);
      currentTransition._updatedFibers = new Set();
      try {
        var returnValue = callback(),
          onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish &&
          onStartTransitionFinish(currentTransition, returnValue);
        if (
          null !== returnValue &&
          "object" === typeof returnValue &&
          "function" === typeof returnValue.then
        ) {
          var thenableForFinishedState = chainThenableValue(
            returnValue,
            finishedState
          );
          dispatchSetStateInternal(
            fiber,
            queue,
            thenableForFinishedState,
            requestUpdateLane(fiber)
          );
        } else
          dispatchSetStateInternal(
            fiber,
            queue,
            finishedState,
            requestUpdateLane(fiber)
          );
      } catch (error) {
        dispatchSetStateInternal(
          fiber,
          queue,
          { then: function () {}, status: "rejected", reason: error },
          requestUpdateLane(fiber)
        );
      } finally {
        (ReactDOMSharedInternals.p = previousPriority),
          (ReactSharedInternals.T = prevTransition),
          null === prevTransition &&
            currentTransition._updatedFibers &&
            ((fiber = currentTransition._updatedFibers.size),
            currentTransition._updatedFibers.clear(),
            10 < fiber &&
              console.warn(
                "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
              ));
      }
    }
    function startHostTransition(formFiber, pendingState, action, formData) {
      if (5 !== formFiber.tag)
        throw Error(
          "Expected the form instance to be a HostComponent. This is a bug in React."
        );
      var queue = ensureFormComponentIsStateful(formFiber).queue;
      startTransition(
        formFiber,
        queue,
        pendingState,
        NotPendingTransition,
        null === action
          ? noop$2
          : function () {
              requestFormReset$1(formFiber);
              return action(formData);
            }
      );
    }
    function ensureFormComponentIsStateful(formFiber) {
      var existingStateHook = formFiber.memoizedState;
      if (null !== existingStateHook) return existingStateHook;
      existingStateHook = {
        memoizedState: NotPendingTransition,
        baseState: NotPendingTransition,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: NotPendingTransition
        },
        next: null
      };
      var initialResetState = {};
      existingStateHook.next = {
        memoizedState: initialResetState,
        baseState: initialResetState,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialResetState
        },
        next: null
      };
      formFiber.memoizedState = existingStateHook;
      formFiber = formFiber.alternate;
      null !== formFiber && (formFiber.memoizedState = existingStateHook);
      return existingStateHook;
    }
    function requestFormReset$1(formFiber) {
      null === ReactSharedInternals.T &&
        console.error(
          "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
        );
      var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
      dispatchSetStateInternal(
        formFiber,
        resetStateQueue,
        {},
        requestUpdateLane(formFiber)
      );
    }
    function mountTransition() {
      var stateHook = mountStateImpl(!1);
      stateHook = startTransition.bind(
        null,
        currentlyRenderingFiber,
        stateHook.queue,
        !0,
        !1
      );
      mountWorkInProgressHook().memoizedState = stateHook;
      return [!1, stateHook];
    }
    function updateTransition() {
      var booleanOrThenable = updateReducer(basicStateReducer)[0],
        start = updateWorkInProgressHook().memoizedState;
      return [
        "boolean" === typeof booleanOrThenable
          ? booleanOrThenable
          : useThenable(booleanOrThenable),
        start
      ];
    }
    function rerenderTransition() {
      var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
        start = updateWorkInProgressHook().memoizedState;
      return [
        "boolean" === typeof booleanOrThenable
          ? booleanOrThenable
          : useThenable(booleanOrThenable),
        start
      ];
    }
    function useHostTransitionStatus() {
      return readContext(HostTransitionContext);
    }
    function mountId() {
      var hook = mountWorkInProgressHook(),
        identifierPrefix = workInProgressRoot.identifierPrefix;
      if (isHydrating) {
        var treeId = treeContextOverflow;
        var idWithLeadingBit = treeContextId;
        treeId =
          (
            idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))
          ).toString(32) + treeId;
        identifierPrefix = "\u00ab" + identifierPrefix + "R" + treeId;
        treeId = localIdCounter++;
        0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
        identifierPrefix += "\u00bb";
      } else
        (treeId = globalClientIdCounter++),
          (identifierPrefix =
            "\u00ab" + identifierPrefix + "r" + treeId.toString(32) + "\u00bb");
      return (hook.memoizedState = identifierPrefix);
    }
    function mountRefresh() {
      return (mountWorkInProgressHook().memoizedState = refreshCache.bind(
        null,
        currentlyRenderingFiber
      ));
    }
    function refreshCache(fiber, seedKey) {
      for (var provider = fiber.return; null !== provider; ) {
        switch (provider.tag) {
          case 24:
          case 3:
            var lane = requestUpdateLane(provider);
            fiber = createUpdate(lane);
            var root = enqueueUpdate(provider, fiber, lane);
            null !== root &&
              (scheduleUpdateOnFiber(root, provider, lane),
              entangleTransitions(root, provider, lane));
            provider = createCache();
            null !== seedKey &&
              void 0 !== seedKey &&
              null !== root &&
              console.error(
                "The seed argument is not enabled outside experimental channels."
              );
            fiber.payload = { cache: provider };
            return;
        }
        provider = provider.return;
      }
    }
    function dispatchReducerAction(fiber, queue, action) {
      var args = arguments;
      "function" === typeof args[3] &&
        console.error(
          "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
        );
      args = requestUpdateLane(fiber);
      var update = {
        lane: args,
        revertLane: 0,
        action: action,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      isRenderPhaseUpdate(fiber)
        ? enqueueRenderPhaseUpdate(queue, update)
        : ((update = enqueueConcurrentHookUpdate(fiber, queue, update, args)),
          null !== update &&
            (scheduleUpdateOnFiber(update, fiber, args),
            entangleTransitionUpdate(update, queue, args)));
      markStateUpdateScheduled(fiber, args);
    }
    function dispatchSetState(fiber, queue, action) {
      var args = arguments;
      "function" === typeof args[3] &&
        console.error(
          "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
        );
      args = requestUpdateLane(fiber);
      dispatchSetStateInternal(fiber, queue, action, args);
      markStateUpdateScheduled(fiber, args);
    }
    function dispatchSetStateInternal(fiber, queue, action, lane) {
      var update = {
        lane: lane,
        revertLane: 0,
        action: action,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
      else {
        var alternate = fiber.alternate;
        if (
          0 === fiber.lanes &&
          (null === alternate || 0 === alternate.lanes) &&
          ((alternate = queue.lastRenderedReducer), null !== alternate)
        ) {
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            var currentState = queue.lastRenderedState,
              eagerState = alternate(currentState, action);
            update.hasEagerState = !0;
            update.eagerState = eagerState;
            if (objectIs(eagerState, currentState))
              return (
                enqueueUpdate$1(fiber, queue, update, 0),
                null === workInProgressRoot &&
                  finishQueueingConcurrentUpdates(),
                !1
              );
          } catch (error) {
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        }
        action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
        if (null !== action)
          return (
            scheduleUpdateOnFiber(action, fiber, lane),
            entangleTransitionUpdate(action, queue, lane),
            !0
          );
      }
      return !1;
    }
    function dispatchOptimisticSetState(
      fiber,
      throwIfDuringRender,
      queue,
      action
    ) {
      null === ReactSharedInternals.T &&
        0 === currentEntangledLane &&
        console.error(
          "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
        );
      action = {
        lane: 2,
        revertLane: requestTransitionLane(),
        action: action,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) {
        if (throwIfDuringRender)
          throw Error("Cannot update optimistic state while rendering.");
        console.error("Cannot call startTransition while rendering.");
      } else
        (throwIfDuringRender = enqueueConcurrentHookUpdate(
          fiber,
          queue,
          action,
          2
        )),
          null !== throwIfDuringRender &&
            scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
      markStateUpdateScheduled(fiber, 2);
    }
    function isRenderPhaseUpdate(fiber) {
      var alternate = fiber.alternate;
      return (
        fiber === currentlyRenderingFiber ||
        (null !== alternate && alternate === currentlyRenderingFiber)
      );
    }
    function enqueueRenderPhaseUpdate(queue, update) {
      didScheduleRenderPhaseUpdateDuringThisPass =
        didScheduleRenderPhaseUpdate = !0;
      var pending = queue.pending;
      null === pending
        ? (update.next = update)
        : ((update.next = pending.next), (pending.next = update));
      queue.pending = update;
    }
    function entangleTransitionUpdate(root, queue, lane) {
      if (0 !== (lane & 4194048)) {
        var queueLanes = queue.lanes;
        queueLanes &= root.pendingLanes;
        lane |= queueLanes;
        queue.lanes = lane;
        markRootEntangled(root, lane);
      }
    }
    function pushDebugInfo(debugInfo) {
      var previousDebugInfo = currentDebugInfo;
      null != debugInfo &&
        (currentDebugInfo =
          null === previousDebugInfo
            ? debugInfo
            : previousDebugInfo.concat(debugInfo));
      return previousDebugInfo;
    }
    function validateFragmentProps(element, fiber, returnFiber) {
      for (var keys = Object.keys(element.props), i = 0; i < keys.length; i++) {
        var key = keys[i];
        if ("children" !== key && "key" !== key) {
          null === fiber &&
            ((fiber = createFiberFromElement(element, returnFiber.mode, 0)),
            (fiber._debugInfo = currentDebugInfo),
            (fiber.return = returnFiber));
          runWithFiberInDEV(
            fiber,
            function (erroredKey) {
              console.error(
                "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                erroredKey
              );
            },
            key
          );
          break;
        }
      }
    }
    function unwrapThenable(thenable) {
      var index = thenableIndexCounter;
      thenableIndexCounter += 1;
      null === thenableState && (thenableState = createThenableState());
      return trackUsedThenable(thenableState, thenable, index);
    }
    function coerceRef(workInProgress, element) {
      element = element.props.ref;
      workInProgress.ref = void 0 !== element ? element : null;
    }
    function throwOnInvalidObjectType(returnFiber, newChild) {
      if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
        throw Error(
          'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
        );
      returnFiber = Object.prototype.toString.call(newChild);
      throw Error(
        "Objects are not valid as a React child (found: " +
          ("[object Object]" === returnFiber
            ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
            : returnFiber) +
          "). If you meant to render a collection of children, use an array instead."
      );
    }
    function warnOnFunctionType(returnFiber, invalidChild) {
      var parentName = getComponentNameFromFiber(returnFiber) || "Component";
      ownerHasFunctionTypeWarning[parentName] ||
        ((ownerHasFunctionTypeWarning[parentName] = !0),
        (invalidChild =
          invalidChild.displayName || invalidChild.name || "Component"),
        3 === returnFiber.tag
          ? console.error(
              "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)",
              invalidChild,
              invalidChild,
              invalidChild
            )
          : console.error(
              "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>",
              invalidChild,
              invalidChild,
              parentName,
              invalidChild,
              parentName
            ));
    }
    function warnOnSymbolType(returnFiber, invalidChild) {
      var parentName = getComponentNameFromFiber(returnFiber) || "Component";
      ownerHasSymbolTypeWarning[parentName] ||
        ((ownerHasSymbolTypeWarning[parentName] = !0),
        (invalidChild = String(invalidChild)),
        3 === returnFiber.tag
          ? console.error(
              "Symbols are not valid as a React child.\n  root.render(%s)",
              invalidChild
            )
          : console.error(
              "Symbols are not valid as a React child.\n  <%s>%s</%s>",
              parentName,
              invalidChild,
              parentName
            ));
    }
    function createChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
        if (shouldTrackSideEffects) {
          var deletions = returnFiber.deletions;
          null === deletions
            ? ((returnFiber.deletions = [childToDelete]),
              (returnFiber.flags |= 16))
            : deletions.push(childToDelete);
        }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
        if (!shouldTrackSideEffects) return null;
        for (; null !== currentFirstChild; )
          deleteChild(returnFiber, currentFirstChild),
            (currentFirstChild = currentFirstChild.sibling);
        return null;
      }
      function mapRemainingChildren(currentFirstChild) {
        for (var existingChildren = new Map(); null !== currentFirstChild; )
          null !== currentFirstChild.key
            ? existingChildren.set(currentFirstChild.key, currentFirstChild)
            : existingChildren.set(currentFirstChild.index, currentFirstChild),
            (currentFirstChild = currentFirstChild.sibling);
        return existingChildren;
      }
      function useFiber(fiber, pendingProps) {
        fiber = createWorkInProgress(fiber, pendingProps);
        fiber.index = 0;
        fiber.sibling = null;
        return fiber;
      }
      function placeChild(newFiber, lastPlacedIndex, newIndex) {
        newFiber.index = newIndex;
        if (!shouldTrackSideEffects)
          return (newFiber.flags |= 1048576), lastPlacedIndex;
        newIndex = newFiber.alternate;
        if (null !== newIndex)
          return (
            (newIndex = newIndex.index),
            newIndex < lastPlacedIndex
              ? ((newFiber.flags |= 67108866), lastPlacedIndex)
              : newIndex
          );
        newFiber.flags |= 67108866;
        return lastPlacedIndex;
      }
      function placeSingleChild(newFiber) {
        shouldTrackSideEffects &&
          null === newFiber.alternate &&
          (newFiber.flags |= 67108866);
        return newFiber;
      }
      function updateTextNode(returnFiber, current, textContent, lanes) {
        if (null === current || 6 !== current.tag)
          return (
            (current = createFiberFromText(
              textContent,
              returnFiber.mode,
              lanes
            )),
            (current.return = returnFiber),
            (current._debugOwner = returnFiber),
            (current._debugTask = returnFiber._debugTask),
            (current._debugInfo = currentDebugInfo),
            current
          );
        current = useFiber(current, textContent);
        current.return = returnFiber;
        current._debugInfo = currentDebugInfo;
        return current;
      }
      function updateElement(returnFiber, current, element, lanes) {
        var elementType = element.type;
        if (elementType === REACT_FRAGMENT_TYPE)
          return (
            (current = updateFragment(
              returnFiber,
              current,
              element.props.children,
              lanes,
              element.key
            )),
            validateFragmentProps(element, current, returnFiber),
            current
          );
        if (
          null !== current &&
          (current.elementType === elementType ||
            isCompatibleFamilyForHotReloading(current, element) ||
            ("object" === typeof elementType &&
              null !== elementType &&
              elementType.$$typeof === REACT_LAZY_TYPE &&
              callLazyInitInDEV(elementType) === current.type))
        )
          return (
            (current = useFiber(current, element.props)),
            coerceRef(current, element),
            (current.return = returnFiber),
            (current._debugOwner = element._owner),
            (current._debugInfo = currentDebugInfo),
            current
          );
        current = createFiberFromElement(element, returnFiber.mode, lanes);
        coerceRef(current, element);
        current.return = returnFiber;
        current._debugInfo = currentDebugInfo;
        return current;
      }
      function updatePortal(returnFiber, current, portal, lanes) {
        if (
          null === current ||
          4 !== current.tag ||
          current.stateNode.containerInfo !== portal.containerInfo ||
          current.stateNode.implementation !== portal.implementation
        )
          return (
            (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),
            (current.return = returnFiber),
            (current._debugInfo = currentDebugInfo),
            current
          );
        current = useFiber(current, portal.children || []);
        current.return = returnFiber;
        current._debugInfo = currentDebugInfo;
        return current;
      }
      function updateFragment(returnFiber, current, fragment, lanes, key) {
        if (null === current || 7 !== current.tag)
          return (
            (current = createFiberFromFragment(
              fragment,
              returnFiber.mode,
              lanes,
              key
            )),
            (current.return = returnFiber),
            (current._debugOwner = returnFiber),
            (current._debugTask = returnFiber._debugTask),
            (current._debugInfo = currentDebugInfo),
            current
          );
        current = useFiber(current, fragment);
        current.return = returnFiber;
        current._debugInfo = currentDebugInfo;
        return current;
      }
      function createChild(returnFiber, newChild, lanes) {
        if (
          ("string" === typeof newChild && "" !== newChild) ||
          "number" === typeof newChild ||
          "bigint" === typeof newChild
        )
          return (
            (newChild = createFiberFromText(
              "" + newChild,
              returnFiber.mode,
              lanes
            )),
            (newChild.return = returnFiber),
            (newChild._debugOwner = returnFiber),
            (newChild._debugTask = returnFiber._debugTask),
            (newChild._debugInfo = currentDebugInfo),
            newChild
          );
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return (
                (lanes = createFiberFromElement(
                  newChild,
                  returnFiber.mode,
                  lanes
                )),
                coerceRef(lanes, newChild),
                (lanes.return = returnFiber),
                (returnFiber = pushDebugInfo(newChild._debugInfo)),
                (lanes._debugInfo = currentDebugInfo),
                (currentDebugInfo = returnFiber),
                lanes
              );
            case REACT_PORTAL_TYPE:
              return (
                (newChild = createFiberFromPortal(
                  newChild,
                  returnFiber.mode,
                  lanes
                )),
                (newChild.return = returnFiber),
                (newChild._debugInfo = currentDebugInfo),
                newChild
              );
            case REACT_LAZY_TYPE:
              var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
              newChild = callLazyInitInDEV(newChild);
              returnFiber = createChild(returnFiber, newChild, lanes);
              currentDebugInfo = _prevDebugInfo;
              return returnFiber;
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return (
              (lanes = createFiberFromFragment(
                newChild,
                returnFiber.mode,
                lanes,
                null
              )),
              (lanes.return = returnFiber),
              (lanes._debugOwner = returnFiber),
              (lanes._debugTask = returnFiber._debugTask),
              (returnFiber = pushDebugInfo(newChild._debugInfo)),
              (lanes._debugInfo = currentDebugInfo),
              (currentDebugInfo = returnFiber),
              lanes
            );
          if ("function" === typeof newChild.then)
            return (
              (_prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
              (returnFiber = createChild(
                returnFiber,
                unwrapThenable(newChild),
                lanes
              )),
              (currentDebugInfo = _prevDebugInfo),
              returnFiber
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return createChild(
              returnFiber,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        "function" === typeof newChild &&
          warnOnFunctionType(returnFiber, newChild);
        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
        var key = null !== oldFiber ? oldFiber.key : null;
        if (
          ("string" === typeof newChild && "" !== newChild) ||
          "number" === typeof newChild ||
          "bigint" === typeof newChild
        )
          return null !== key
            ? null
            : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return newChild.key === key
                ? ((key = pushDebugInfo(newChild._debugInfo)),
                  (returnFiber = updateElement(
                    returnFiber,
                    oldFiber,
                    newChild,
                    lanes
                  )),
                  (currentDebugInfo = key),
                  returnFiber)
                : null;
            case REACT_PORTAL_TYPE:
              return newChild.key === key
                ? updatePortal(returnFiber, oldFiber, newChild, lanes)
                : null;
            case REACT_LAZY_TYPE:
              return (
                (key = pushDebugInfo(newChild._debugInfo)),
                (newChild = callLazyInitInDEV(newChild)),
                (returnFiber = updateSlot(
                  returnFiber,
                  oldFiber,
                  newChild,
                  lanes
                )),
                (currentDebugInfo = key),
                returnFiber
              );
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
            if (null !== key) return null;
            key = pushDebugInfo(newChild._debugInfo);
            returnFiber = updateFragment(
              returnFiber,
              oldFiber,
              newChild,
              lanes,
              null
            );
            currentDebugInfo = key;
            return returnFiber;
          }
          if ("function" === typeof newChild.then)
            return (
              (key = pushDebugInfo(newChild._debugInfo)),
              (returnFiber = updateSlot(
                returnFiber,
                oldFiber,
                unwrapThenable(newChild),
                lanes
              )),
              (currentDebugInfo = key),
              returnFiber
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateSlot(
              returnFiber,
              oldFiber,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        "function" === typeof newChild &&
          warnOnFunctionType(returnFiber, newChild);
        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function updateFromMap(
        existingChildren,
        returnFiber,
        newIdx,
        newChild,
        lanes
      ) {
        if (
          ("string" === typeof newChild && "" !== newChild) ||
          "number" === typeof newChild ||
          "bigint" === typeof newChild
        )
          return (
            (existingChildren = existingChildren.get(newIdx) || null),
            updateTextNode(returnFiber, existingChildren, "" + newChild, lanes)
          );
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return (
                (newIdx =
                  existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null),
                (existingChildren = pushDebugInfo(newChild._debugInfo)),
                (returnFiber = updateElement(
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes
                )),
                (currentDebugInfo = existingChildren),
                returnFiber
              );
            case REACT_PORTAL_TYPE:
              return (
                (existingChildren =
                  existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null),
                updatePortal(returnFiber, existingChildren, newChild, lanes)
              );
            case REACT_LAZY_TYPE:
              var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
              newChild = callLazyInitInDEV(newChild);
              returnFiber = updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                newChild,
                lanes
              );
              currentDebugInfo = _prevDebugInfo7;
              return returnFiber;
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return (
              (newIdx = existingChildren.get(newIdx) || null),
              (existingChildren = pushDebugInfo(newChild._debugInfo)),
              (returnFiber = updateFragment(
                returnFiber,
                newIdx,
                newChild,
                lanes,
                null
              )),
              (currentDebugInfo = existingChildren),
              returnFiber
            );
          if ("function" === typeof newChild.then)
            return (
              (_prevDebugInfo7 = pushDebugInfo(newChild._debugInfo)),
              (returnFiber = updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                unwrapThenable(newChild),
                lanes
              )),
              (currentDebugInfo = _prevDebugInfo7),
              returnFiber
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        "function" === typeof newChild &&
          warnOnFunctionType(returnFiber, newChild);
        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys) {
        if ("object" !== typeof child || null === child) return knownKeys;
        switch (child.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            warnForMissingKey(returnFiber, workInProgress, child);
            var key = child.key;
            if ("string" !== typeof key) break;
            if (null === knownKeys) {
              knownKeys = new Set();
              knownKeys.add(key);
              break;
            }
            if (!knownKeys.has(key)) {
              knownKeys.add(key);
              break;
            }
            runWithFiberInDEV(workInProgress, function () {
              console.error(
                "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.",
                key
              );
            });
            break;
          case REACT_LAZY_TYPE:
            (child = callLazyInitInDEV(child)),
              warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys);
        }
        return knownKeys;
      }
      function reconcileChildrenArray(
        returnFiber,
        currentFirstChild,
        newChildren,
        lanes
      ) {
        for (
          var knownKeys = null,
            resultingFirstChild = null,
            previousNewFiber = null,
            oldFiber = currentFirstChild,
            newIdx = (currentFirstChild = 0),
            nextOldFiber = null;
          null !== oldFiber && newIdx < newChildren.length;
          newIdx++
        ) {
          oldFiber.index > newIdx
            ? ((nextOldFiber = oldFiber), (oldFiber = null))
            : (nextOldFiber = oldFiber.sibling);
          var newFiber = updateSlot(
            returnFiber,
            oldFiber,
            newChildren[newIdx],
            lanes
          );
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          knownKeys = warnOnInvalidKey(
            returnFiber,
            newFiber,
            newChildren[newIdx],
            knownKeys
          );
          shouldTrackSideEffects &&
            oldFiber &&
            null === newFiber.alternate &&
            deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber
            ? (resultingFirstChild = newFiber)
            : (previousNewFiber.sibling = newFiber);
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (newIdx === newChildren.length)
          return (
            deleteRemainingChildren(returnFiber, oldFiber),
            isHydrating && pushTreeFork(returnFiber, newIdx),
            resultingFirstChild
          );
        if (null === oldFiber) {
          for (; newIdx < newChildren.length; newIdx++)
            (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),
              null !== oldFiber &&
                ((knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  newChildren[newIdx],
                  knownKeys
                )),
                (currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                )),
                null === previousNewFiber
                  ? (resultingFirstChild = oldFiber)
                  : (previousNewFiber.sibling = oldFiber),
                (previousNewFiber = oldFiber));
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (
          oldFiber = mapRemainingChildren(oldFiber);
          newIdx < newChildren.length;
          newIdx++
        )
          (nextOldFiber = updateFromMap(
            oldFiber,
            returnFiber,
            newIdx,
            newChildren[newIdx],
            lanes
          )),
            null !== nextOldFiber &&
              ((knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                newChildren[newIdx],
                knownKeys
              )),
              shouldTrackSideEffects &&
                null !== nextOldFiber.alternate &&
                oldFiber.delete(
                  null === nextOldFiber.key ? newIdx : nextOldFiber.key
                ),
              (currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              )),
              null === previousNewFiber
                ? (resultingFirstChild = nextOldFiber)
                : (previousNewFiber.sibling = nextOldFiber),
              (previousNewFiber = nextOldFiber));
        shouldTrackSideEffects &&
          oldFiber.forEach(function (child) {
            return deleteChild(returnFiber, child);
          });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildrenIterator(
        returnFiber,
        currentFirstChild,
        newChildren,
        lanes
      ) {
        if (null == newChildren)
          throw Error("An iterable object provided no iterator.");
        for (
          var resultingFirstChild = null,
            previousNewFiber = null,
            oldFiber = currentFirstChild,
            newIdx = (currentFirstChild = 0),
            nextOldFiber = null,
            knownKeys = null,
            step = newChildren.next();
          null !== oldFiber && !step.done;
          newIdx++, step = newChildren.next()
        ) {
          oldFiber.index > newIdx
            ? ((nextOldFiber = oldFiber), (oldFiber = null))
            : (nextOldFiber = oldFiber.sibling);
          var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          knownKeys = warnOnInvalidKey(
            returnFiber,
            newFiber,
            step.value,
            knownKeys
          );
          shouldTrackSideEffects &&
            oldFiber &&
            null === newFiber.alternate &&
            deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber
            ? (resultingFirstChild = newFiber)
            : (previousNewFiber.sibling = newFiber);
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (step.done)
          return (
            deleteRemainingChildren(returnFiber, oldFiber),
            isHydrating && pushTreeFork(returnFiber, newIdx),
            resultingFirstChild
          );
        if (null === oldFiber) {
          for (; !step.done; newIdx++, step = newChildren.next())
            (oldFiber = createChild(returnFiber, step.value, lanes)),
              null !== oldFiber &&
                ((knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  step.value,
                  knownKeys
                )),
                (currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                )),
                null === previousNewFiber
                  ? (resultingFirstChild = oldFiber)
                  : (previousNewFiber.sibling = oldFiber),
                (previousNewFiber = oldFiber));
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (
          oldFiber = mapRemainingChildren(oldFiber);
          !step.done;
          newIdx++, step = newChildren.next()
        )
          (nextOldFiber = updateFromMap(
            oldFiber,
            returnFiber,
            newIdx,
            step.value,
            lanes
          )),
            null !== nextOldFiber &&
              ((knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                step.value,
                knownKeys
              )),
              shouldTrackSideEffects &&
                null !== nextOldFiber.alternate &&
                oldFiber.delete(
                  null === nextOldFiber.key ? newIdx : nextOldFiber.key
                ),
              (currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              )),
              null === previousNewFiber
                ? (resultingFirstChild = nextOldFiber)
                : (previousNewFiber.sibling = nextOldFiber),
              (previousNewFiber = nextOldFiber));
        shouldTrackSideEffects &&
          oldFiber.forEach(function (child) {
            return deleteChild(returnFiber, child);
          });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildFibersImpl(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes
      ) {
        "object" === typeof newChild &&
          null !== newChild &&
          newChild.type === REACT_FRAGMENT_TYPE &&
          null === newChild.key &&
          (validateFragmentProps(newChild, null, returnFiber),
          (newChild = newChild.props.children));
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
              a: {
                for (var key = newChild.key; null !== currentFirstChild; ) {
                  if (currentFirstChild.key === key) {
                    key = newChild.type;
                    if (key === REACT_FRAGMENT_TYPE) {
                      if (7 === currentFirstChild.tag) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(
                          currentFirstChild,
                          newChild.props.children
                        );
                        lanes.return = returnFiber;
                        lanes._debugOwner = newChild._owner;
                        lanes._debugInfo = currentDebugInfo;
                        validateFragmentProps(newChild, lanes, returnFiber);
                        returnFiber = lanes;
                        break a;
                      }
                    } else if (
                      currentFirstChild.elementType === key ||
                      isCompatibleFamilyForHotReloading(
                        currentFirstChild,
                        newChild
                      ) ||
                      ("object" === typeof key &&
                        null !== key &&
                        key.$$typeof === REACT_LAZY_TYPE &&
                        callLazyInitInDEV(key) === currentFirstChild.type)
                    ) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(currentFirstChild, newChild.props);
                      coerceRef(lanes, newChild);
                      lanes.return = returnFiber;
                      lanes._debugOwner = newChild._owner;
                      lanes._debugInfo = currentDebugInfo;
                      returnFiber = lanes;
                      break a;
                    }
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  } else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                newChild.type === REACT_FRAGMENT_TYPE
                  ? ((lanes = createFiberFromFragment(
                      newChild.props.children,
                      returnFiber.mode,
                      lanes,
                      newChild.key
                    )),
                    (lanes.return = returnFiber),
                    (lanes._debugOwner = returnFiber),
                    (lanes._debugTask = returnFiber._debugTask),
                    (lanes._debugInfo = currentDebugInfo),
                    validateFragmentProps(newChild, lanes, returnFiber),
                    (returnFiber = lanes))
                  : ((lanes = createFiberFromElement(
                      newChild,
                      returnFiber.mode,
                      lanes
                    )),
                    coerceRef(lanes, newChild),
                    (lanes.return = returnFiber),
                    (lanes._debugInfo = currentDebugInfo),
                    (returnFiber = lanes));
              }
              returnFiber = placeSingleChild(returnFiber);
              currentDebugInfo = prevDebugInfo;
              return returnFiber;
            case REACT_PORTAL_TYPE:
              a: {
                prevDebugInfo = newChild;
                for (
                  newChild = prevDebugInfo.key;
                  null !== currentFirstChild;

                ) {
                  if (currentFirstChild.key === newChild)
                    if (
                      4 === currentFirstChild.tag &&
                      currentFirstChild.stateNode.containerInfo ===
                        prevDebugInfo.containerInfo &&
                      currentFirstChild.stateNode.implementation ===
                        prevDebugInfo.implementation
                    ) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(
                        currentFirstChild,
                        prevDebugInfo.children || []
                      );
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    } else {
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    }
                  else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                lanes = createFiberFromPortal(
                  prevDebugInfo,
                  returnFiber.mode,
                  lanes
                );
                lanes.return = returnFiber;
                returnFiber = lanes;
              }
              return placeSingleChild(returnFiber);
            case REACT_LAZY_TYPE:
              return (
                (prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
                (newChild = callLazyInitInDEV(newChild)),
                (returnFiber = reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                )),
                (currentDebugInfo = prevDebugInfo),
                returnFiber
              );
          }
          if (isArrayImpl(newChild))
            return (
              (prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
              (returnFiber = reconcileChildrenArray(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              )),
              (currentDebugInfo = prevDebugInfo),
              returnFiber
            );
          if (getIteratorFn(newChild)) {
            prevDebugInfo = pushDebugInfo(newChild._debugInfo);
            key = getIteratorFn(newChild);
            if ("function" !== typeof key)
              throw Error(
                "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
              );
            var newChildren = key.call(newChild);
            if (newChildren === newChild) {
              if (
                0 !== returnFiber.tag ||
                "[object GeneratorFunction]" !==
                  Object.prototype.toString.call(returnFiber.type) ||
                "[object Generator]" !==
                  Object.prototype.toString.call(newChildren)
              )
                didWarnAboutGenerators ||
                  console.error(
                    "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
                  ),
                  (didWarnAboutGenerators = !0);
            } else
              newChild.entries !== key ||
                didWarnAboutMaps ||
                (console.error(
                  "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                ),
                (didWarnAboutMaps = !0));
            returnFiber = reconcileChildrenIterator(
              returnFiber,
              currentFirstChild,
              newChildren,
              lanes
            );
            currentDebugInfo = prevDebugInfo;
            return returnFiber;
          }
          if ("function" === typeof newChild.then)
            return (
              (prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
              (returnFiber = reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                unwrapThenable(newChild),
                lanes
              )),
              (currentDebugInfo = prevDebugInfo),
              returnFiber
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        if (
          ("string" === typeof newChild && "" !== newChild) ||
          "number" === typeof newChild ||
          "bigint" === typeof newChild
        )
          return (
            (prevDebugInfo = "" + newChild),
            null !== currentFirstChild && 6 === currentFirstChild.tag
              ? (deleteRemainingChildren(
                  returnFiber,
                  currentFirstChild.sibling
                ),
                (lanes = useFiber(currentFirstChild, prevDebugInfo)),
                (lanes.return = returnFiber),
                (returnFiber = lanes))
              : (deleteRemainingChildren(returnFiber, currentFirstChild),
                (lanes = createFiberFromText(
                  prevDebugInfo,
                  returnFiber.mode,
                  lanes
                )),
                (lanes.return = returnFiber),
                (lanes._debugOwner = returnFiber),
                (lanes._debugTask = returnFiber._debugTask),
                (lanes._debugInfo = currentDebugInfo),
                (returnFiber = lanes)),
            placeSingleChild(returnFiber)
          );
        "function" === typeof newChild &&
          warnOnFunctionType(returnFiber, newChild);
        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
        return deleteRemainingChildren(returnFiber, currentFirstChild);
      }
      return function (returnFiber, currentFirstChild, newChild, lanes) {
        var prevDebugInfo = currentDebugInfo;
        currentDebugInfo = null;
        try {
          thenableIndexCounter = 0;
          var firstChildFiber = reconcileChildFibersImpl(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes
          );
          thenableState = null;
          return firstChildFiber;
        } catch (x) {
          if (x === SuspenseException || x === SuspenseActionException) throw x;
          var fiber = createFiber(29, x, null, returnFiber.mode);
          fiber.lanes = lanes;
          fiber.return = returnFiber;
          var debugInfo = (fiber._debugInfo = currentDebugInfo);
          fiber._debugOwner = returnFiber._debugOwner;
          fiber._debugTask = returnFiber._debugTask;
          if (null != debugInfo)
            for (var i = debugInfo.length - 1; 0 <= i; i--)
              if ("string" === typeof debugInfo[i].stack) {
                fiber._debugOwner = debugInfo[i];
                fiber._debugTask = debugInfo[i].debugTask;
                break;
              }
          return fiber;
        } finally {
          currentDebugInfo = prevDebugInfo;
        }
      };
    }
    function pushPrimaryTreeSuspenseHandler(handler) {
      var current = handler.alternate;
      push(
        suspenseStackCursor,
        suspenseStackCursor.current & SubtreeSuspenseContextMask,
        handler
      );
      push(suspenseHandlerStackCursor, handler, handler);
      null === shellBoundary &&
        (null === current || null !== currentTreeHiddenStackCursor.current
          ? (shellBoundary = handler)
          : null !== current.memoizedState && (shellBoundary = handler));
    }
    function pushOffscreenSuspenseHandler(fiber) {
      if (22 === fiber.tag) {
        if (
          (push(suspenseStackCursor, suspenseStackCursor.current, fiber),
          push(suspenseHandlerStackCursor, fiber, fiber),
          null === shellBoundary)
        ) {
          var current = fiber.alternate;
          null !== current &&
            null !== current.memoizedState &&
            (shellBoundary = fiber);
        }
      } else reuseSuspenseHandlerOnStack(fiber);
    }
    function reuseSuspenseHandlerOnStack(fiber) {
      push(suspenseStackCursor, suspenseStackCursor.current, fiber);
      push(
        suspenseHandlerStackCursor,
        suspenseHandlerStackCursor.current,
        fiber
      );
    }
    function popSuspenseHandler(fiber) {
      pop(suspenseHandlerStackCursor, fiber);
      shellBoundary === fiber && (shellBoundary = null);
      pop(suspenseStackCursor, fiber);
    }
    function findFirstSuspended(row) {
      for (var node = row; null !== node; ) {
        if (13 === node.tag) {
          var state = node.memoizedState;
          if (
            null !== state &&
            ((state = state.dehydrated),
            null === state ||
              state.data === SUSPENSE_PENDING_START_DATA ||
              isSuspenseInstanceFallback(state))
          )
            return node;
        } else if (
          19 === node.tag &&
          void 0 !== node.memoizedProps.revealOrder
        ) {
          if (0 !== (node.flags & 128)) return node;
        } else if (null !== node.child) {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === row) break;
        for (; null === node.sibling; ) {
          if (null === node.return || node.return === row) return null;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
      return null;
    }
    function warnOnInvalidCallback(callback) {
      if (null !== callback && "function" !== typeof callback) {
        var key = String(callback);
        didWarnOnInvalidCallback.has(key) ||
          (didWarnOnInvalidCallback.add(key),
          console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback
          ));
      }
    }
    function applyDerivedStateFromProps(
      workInProgress,
      ctor,
      getDerivedStateFromProps,
      nextProps
    ) {
      var prevState = workInProgress.memoizedState,
        partialState = getDerivedStateFromProps(nextProps, prevState);
      if (workInProgress.mode & StrictLegacyMode) {
        setIsStrictModeForDevtools(!0);
        try {
          partialState = getDerivedStateFromProps(nextProps, prevState);
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      void 0 === partialState &&
        ((ctor = getComponentNameFromType(ctor) || "Component"),
        didWarnAboutUndefinedDerivedState.has(ctor) ||
          (didWarnAboutUndefinedDerivedState.add(ctor),
          console.error(
            "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
            ctor
          )));
      prevState =
        null === partialState || void 0 === partialState
          ? prevState
          : assign({}, prevState, partialState);
      workInProgress.memoizedState = prevState;
      0 === workInProgress.lanes &&
        (workInProgress.updateQueue.baseState = prevState);
    }
    function checkShouldComponentUpdate(
      workInProgress,
      ctor,
      oldProps,
      newProps,
      oldState,
      newState,
      nextContext
    ) {
      var instance = workInProgress.stateNode;
      if ("function" === typeof instance.shouldComponentUpdate) {
        oldProps = instance.shouldComponentUpdate(
          newProps,
          newState,
          nextContext
        );
        if (workInProgress.mode & StrictLegacyMode) {
          setIsStrictModeForDevtools(!0);
          try {
            oldProps = instance.shouldComponentUpdate(
              newProps,
              newState,
              nextContext
            );
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
        void 0 === oldProps &&
          console.error(
            "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
            getComponentNameFromType(ctor) || "Component"
          );
        return oldProps;
      }
      return ctor.prototype && ctor.prototype.isPureReactComponent
        ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
        : !0;
    }
    function callComponentWillReceiveProps(
      workInProgress,
      instance,
      newProps,
      nextContext
    ) {
      var oldState = instance.state;
      "function" === typeof instance.componentWillReceiveProps &&
        instance.componentWillReceiveProps(newProps, nextContext);
      "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
        instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
      instance.state !== oldState &&
        ((workInProgress =
          getComponentNameFromFiber(workInProgress) || "Component"),
        didWarnAboutStateAssignmentForComponent.has(workInProgress) ||
          (didWarnAboutStateAssignmentForComponent.add(workInProgress),
          console.error(
            "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
            workInProgress
          )),
        classComponentUpdater.enqueueReplaceState(
          instance,
          instance.state,
          null
        ));
    }
    function resolveClassComponentProps(Component, baseProps) {
      var newProps = baseProps;
      if ("ref" in baseProps) {
        newProps = {};
        for (var propName in baseProps)
          "ref" !== propName && (newProps[propName] = baseProps[propName]);
      }
      if ((Component = Component.defaultProps)) {
        newProps === baseProps && (newProps = assign({}, newProps));
        for (var _propName in Component)
          void 0 === newProps[_propName] &&
            (newProps[_propName] = Component[_propName]);
      }
      return newProps;
    }
    function defaultOnUncaughtError(error) {
      reportGlobalError(error);
      console.warn(
        "%s\n\n%s\n",
        componentName
          ? "An error occurred in the <" + componentName + "> component."
          : "An error occurred in one of your React components.",
        "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries."
      );
    }
    function defaultOnCaughtError(error) {
      var componentNameMessage = componentName
          ? "The above error occurred in the <" + componentName + "> component."
          : "The above error occurred in one of your React components.",
        recreateMessage =
          "React will try to recreate this component tree from scratch using the error boundary you provided, " +
          ((errorBoundaryName || "Anonymous") + ".");
      if (
        "object" === typeof error &&
        null !== error &&
        "string" === typeof error.environmentName
      ) {
        var JSCompiler_inline_result = error.environmentName;
        error = [
          "%o\n\n%s\n\n%s\n",
          error,
          componentNameMessage,
          recreateMessage
        ].slice(0);
        "string" === typeof error[0]
          ? error.splice(
              0,
              1,
              badgeFormat + error[0],
              badgeStyle,
              pad + JSCompiler_inline_result + pad,
              resetStyle
            )
          : error.splice(
              0,
              0,
              badgeFormat,
              badgeStyle,
              pad + JSCompiler_inline_result + pad,
              resetStyle
            );
        error.unshift(console);
        JSCompiler_inline_result = bind.apply(console.error, error);
        JSCompiler_inline_result();
      } else
        console.error(
          "%o\n\n%s\n\n%s\n",
          error,
          componentNameMessage,
          recreateMessage
        );
    }
    function defaultOnRecoverableError(error) {
      reportGlobalError(error);
    }
    function logUncaughtError(root, errorInfo) {
      try {
        componentName = errorInfo.source
          ? getComponentNameFromFiber(errorInfo.source)
          : null;
        errorBoundaryName = null;
        var error = errorInfo.value;
        if (null !== ReactSharedInternals.actQueue)
          ReactSharedInternals.thrownErrors.push(error);
        else {
          var onUncaughtError = root.onUncaughtError;
          onUncaughtError(error, { componentStack: errorInfo.stack });
        }
      } catch (e$5) {
        setTimeout(function () {
          throw e$5;
        });
      }
    }
    function logCaughtError(root, boundary, errorInfo) {
      try {
        componentName = errorInfo.source
          ? getComponentNameFromFiber(errorInfo.source)
          : null;
        errorBoundaryName = getComponentNameFromFiber(boundary);
        var onCaughtError = root.onCaughtError;
        onCaughtError(errorInfo.value, {
          componentStack: errorInfo.stack,
          errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
        });
      } catch (e$6) {
        setTimeout(function () {
          throw e$6;
        });
      }
    }
    function createRootErrorUpdate(root, errorInfo, lane) {
      lane = createUpdate(lane);
      lane.tag = CaptureUpdate;
      lane.payload = { element: null };
      lane.callback = function () {
        runWithFiberInDEV(errorInfo.source, logUncaughtError, root, errorInfo);
      };
      return lane;
    }
    function createClassErrorUpdate(lane) {
      lane = createUpdate(lane);
      lane.tag = CaptureUpdate;
      return lane;
    }
    function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
      var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
      if ("function" === typeof getDerivedStateFromError) {
        var error = errorInfo.value;
        update.payload = function () {
          return getDerivedStateFromError(error);
        };
        update.callback = function () {
          markFailedErrorBoundaryForHotReloading(fiber);
          runWithFiberInDEV(
            errorInfo.source,
            logCaughtError,
            root,
            fiber,
            errorInfo
          );
        };
      }
      var inst = fiber.stateNode;
      null !== inst &&
        "function" === typeof inst.componentDidCatch &&
        (update.callback = function () {
          markFailedErrorBoundaryForHotReloading(fiber);
          runWithFiberInDEV(
            errorInfo.source,
            logCaughtError,
            root,
            fiber,
            errorInfo
          );
          "function" !== typeof getDerivedStateFromError &&
            (null === legacyErrorBoundariesThatAlreadyFailed
              ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
              : legacyErrorBoundariesThatAlreadyFailed.add(this));
          callComponentDidCatchInDEV(this, errorInfo);
          "function" === typeof getDerivedStateFromError ||
            (0 === (fiber.lanes & 2) &&
              console.error(
                "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
                getComponentNameFromFiber(fiber) || "Unknown"
              ));
        });
    }
    function throwException(
      root,
      returnFiber,
      sourceFiber,
      value,
      rootRenderLanes
    ) {
      sourceFiber.flags |= 32768;
      isDevToolsPresent && restorePendingUpdaters(root, rootRenderLanes);
      if (
        null !== value &&
        "object" === typeof value &&
        "function" === typeof value.then
      ) {
        returnFiber = sourceFiber.alternate;
        null !== returnFiber &&
          propagateParentContextChanges(
            returnFiber,
            sourceFiber,
            rootRenderLanes,
            !0
          );
        isHydrating && (didSuspendOrErrorDEV = !0);
        sourceFiber = suspenseHandlerStackCursor.current;
        if (null !== sourceFiber) {
          switch (sourceFiber.tag) {
            case 13:
              return (
                null === shellBoundary
                  ? renderDidSuspendDelayIfPossible()
                  : null === sourceFiber.alternate &&
                    workInProgressRootExitStatus === RootInProgress &&
                    (workInProgressRootExitStatus = RootSuspended),
                (sourceFiber.flags &= -257),
                (sourceFiber.flags |= 65536),
                (sourceFiber.lanes = rootRenderLanes),
                value === noopSuspenseyCommitThenable
                  ? (sourceFiber.flags |= 16384)
                  : ((returnFiber = sourceFiber.updateQueue),
                    null === returnFiber
                      ? (sourceFiber.updateQueue = new Set([value]))
                      : returnFiber.add(value),
                    attachPingListener(root, value, rootRenderLanes)),
                !1
              );
            case 22:
              return (
                (sourceFiber.flags |= 65536),
                value === noopSuspenseyCommitThenable
                  ? (sourceFiber.flags |= 16384)
                  : ((returnFiber = sourceFiber.updateQueue),
                    null === returnFiber
                      ? ((returnFiber = {
                          transitions: null,
                          markerInstances: null,
                          retryQueue: new Set([value])
                        }),
                        (sourceFiber.updateQueue = returnFiber))
                      : ((sourceFiber = returnFiber.retryQueue),
                        null === sourceFiber
                          ? (returnFiber.retryQueue = new Set([value]))
                          : sourceFiber.add(value)),
                    attachPingListener(root, value, rootRenderLanes)),
                !1
              );
          }
          throw Error(
            "Unexpected Suspense handler tag (" +
              sourceFiber.tag +
              "). This is a bug in React."
          );
        }
        attachPingListener(root, value, rootRenderLanes);
        renderDidSuspendDelayIfPossible();
        return !1;
      }
      if (isHydrating)
        return (
          (didSuspendOrErrorDEV = !0),
          (returnFiber = suspenseHandlerStackCursor.current),
          null !== returnFiber
            ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),
              (returnFiber.flags |= 65536),
              (returnFiber.lanes = rootRenderLanes),
              value !== HydrationMismatchException &&
                queueHydrationError(
                  createCapturedValueAtFiber(
                    Error(
                      "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
                      { cause: value }
                    ),
                    sourceFiber
                  )
                ))
            : (value !== HydrationMismatchException &&
                queueHydrationError(
                  createCapturedValueAtFiber(
                    Error(
                      "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
                      { cause: value }
                    ),
                    sourceFiber
                  )
                ),
              (root = root.current.alternate),
              (root.flags |= 65536),
              (rootRenderLanes &= -rootRenderLanes),
              (root.lanes |= rootRenderLanes),
              (value = createCapturedValueAtFiber(value, sourceFiber)),
              (rootRenderLanes = createRootErrorUpdate(
                root.stateNode,
                value,
                rootRenderLanes
              )),
              enqueueCapturedUpdate(root, rootRenderLanes),
              workInProgressRootExitStatus !== RootSuspendedWithDelay &&
                (workInProgressRootExitStatus = RootErrored)),
          !1
        );
      var error = createCapturedValueAtFiber(
        Error(
          "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
          { cause: value }
        ),
        sourceFiber
      );
      null === workInProgressRootConcurrentErrors
        ? (workInProgressRootConcurrentErrors = [error])
        : workInProgressRootConcurrentErrors.push(error);
      workInProgressRootExitStatus !== RootSuspendedWithDelay &&
        (workInProgressRootExitStatus = RootErrored);
      if (null === returnFiber) return !0;
      value = createCapturedValueAtFiber(value, sourceFiber);
      sourceFiber = returnFiber;
      do {
        switch (sourceFiber.tag) {
          case 3:
            return (
              (sourceFiber.flags |= 65536),
              (root = rootRenderLanes & -rootRenderLanes),
              (sourceFiber.lanes |= root),
              (root = createRootErrorUpdate(
                sourceFiber.stateNode,
                value,
                root
              )),
              enqueueCapturedUpdate(sourceFiber, root),
              !1
            );
          case 1:
            if (
              ((returnFiber = sourceFiber.type),
              (error = sourceFiber.stateNode),
              0 === (sourceFiber.flags & 128) &&
                ("function" === typeof returnFiber.getDerivedStateFromError ||
                  (null !== error &&
                    "function" === typeof error.componentDidCatch &&
                    (null === legacyErrorBoundariesThatAlreadyFailed ||
                      !legacyErrorBoundariesThatAlreadyFailed.has(error)))))
            )
              return (
                (sourceFiber.flags |= 65536),
                (rootRenderLanes &= -rootRenderLanes),
                (sourceFiber.lanes |= rootRenderLanes),
                (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),
                initializeClassErrorUpdate(
                  rootRenderLanes,
                  root,
                  sourceFiber,
                  value
                ),
                enqueueCapturedUpdate(sourceFiber, rootRenderLanes),
                !1
              );
        }
        sourceFiber = sourceFiber.return;
      } while (null !== sourceFiber);
      return !1;
    }
    function reconcileChildren(
      current,
      workInProgress,
      nextChildren,
      renderLanes
    ) {
      workInProgress.child =
        null === current
          ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)
          : reconcileChildFibers(
              workInProgress,
              current.child,
              nextChildren,
              renderLanes
            );
    }
    function updateForwardRef(
      current,
      workInProgress,
      Component,
      nextProps,
      renderLanes
    ) {
      Component = Component.render;
      var ref = workInProgress.ref;
      if ("ref" in nextProps) {
        var propsWithoutRef = {};
        for (var key in nextProps)
          "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
      } else propsWithoutRef = nextProps;
      prepareToReadContext(workInProgress);
      markComponentRenderStarted(workInProgress);
      nextProps = renderWithHooks(
        current,
        workInProgress,
        Component,
        propsWithoutRef,
        ref,
        renderLanes
      );
      key = checkDidRenderIdHook();
      markComponentRenderStopped();
      if (null !== current && !didReceiveUpdate)
        return (
          bailoutHooks(current, workInProgress, renderLanes),
          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
        );
      isHydrating && key && pushMaterializedTreeId(workInProgress);
      workInProgress.flags |= 1;
      reconcileChildren(current, workInProgress, nextProps, renderLanes);
      return workInProgress.child;
    }
    function updateMemoComponent(
      current,
      workInProgress,
      Component,
      nextProps,
      renderLanes
    ) {
      if (null === current) {
        var type = Component.type;
        if (
          "function" === typeof type &&
          !shouldConstruct(type) &&
          void 0 === type.defaultProps &&
          null === Component.compare
        )
          return (
            (Component = resolveFunctionForHotReloading(type)),
            (workInProgress.tag = 15),
            (workInProgress.type = Component),
            validateFunctionComponentInDev(workInProgress, type),
            updateSimpleMemoComponent(
              current,
              workInProgress,
              Component,
              nextProps,
              renderLanes
            )
          );
        current = createFiberFromTypeAndProps(
          Component.type,
          null,
          nextProps,
          workInProgress,
          workInProgress.mode,
          renderLanes
        );
        current.ref = workInProgress.ref;
        current.return = workInProgress;
        return (workInProgress.child = current);
      }
      type = current.child;
      if (!checkScheduledUpdateOrContext(current, renderLanes)) {
        var prevProps = type.memoizedProps;
        Component = Component.compare;
        Component = null !== Component ? Component : shallowEqual;
        if (
          Component(prevProps, nextProps) &&
          current.ref === workInProgress.ref
        )
          return bailoutOnAlreadyFinishedWork(
            current,
            workInProgress,
            renderLanes
          );
      }
      workInProgress.flags |= 1;
      current = createWorkInProgress(type, nextProps);
      current.ref = workInProgress.ref;
      current.return = workInProgress;
      return (workInProgress.child = current);
    }
    function updateSimpleMemoComponent(
      current,
      workInProgress,
      Component,
      nextProps,
      renderLanes
    ) {
      if (null !== current) {
        var prevProps = current.memoizedProps;
        if (
          shallowEqual(prevProps, nextProps) &&
          current.ref === workInProgress.ref &&
          workInProgress.type === current.type
        )
          if (
            ((didReceiveUpdate = !1),
            (workInProgress.pendingProps = nextProps = prevProps),
            checkScheduledUpdateOrContext(current, renderLanes))
          )
            0 !== (current.flags & 131072) && (didReceiveUpdate = !0);
          else
            return (
              (workInProgress.lanes = current.lanes),
              bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
            );
      }
      return updateFunctionComponent(
        current,
        workInProgress,
        Component,
        nextProps,
        renderLanes
      );
    }
    function updateOffscreenComponent(current, workInProgress, renderLanes) {
      var nextProps = workInProgress.pendingProps,
        nextChildren = nextProps.children,
        prevState = null !== current ? current.memoizedState : null;
      if ("hidden" === nextProps.mode) {
        if (0 !== (workInProgress.flags & 128)) {
          nextProps =
            null !== prevState
              ? prevState.baseLanes | renderLanes
              : renderLanes;
          if (null !== current) {
            nextChildren = workInProgress.child = current.child;
            for (prevState = 0; null !== nextChildren; )
              (prevState =
                prevState | nextChildren.lanes | nextChildren.childLanes),
                (nextChildren = nextChildren.sibling);
            workInProgress.childLanes = prevState & ~nextProps;
          } else (workInProgress.childLanes = 0), (workInProgress.child = null);
          return deferHiddenOffscreenComponent(
            current,
            workInProgress,
            nextProps,
            renderLanes
          );
        }
        if (0 !== (renderLanes & 536870912))
          (workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),
            null !== current &&
              pushTransition(
                workInProgress,
                null !== prevState ? prevState.cachePool : null
              ),
            null !== prevState
              ? pushHiddenContext(workInProgress, prevState)
              : reuseHiddenContextOnStack(workInProgress),
            pushOffscreenSuspenseHandler(workInProgress);
        else
          return (
            (workInProgress.lanes = workInProgress.childLanes = 536870912),
            deferHiddenOffscreenComponent(
              current,
              workInProgress,
              null !== prevState
                ? prevState.baseLanes | renderLanes
                : renderLanes,
              renderLanes
            )
          );
      } else
        null !== prevState
          ? (pushTransition(workInProgress, prevState.cachePool),
            pushHiddenContext(workInProgress, prevState),
            reuseSuspenseHandlerOnStack(workInProgress),
            (workInProgress.memoizedState = null))
          : (null !== current && pushTransition(workInProgress, null),
            reuseHiddenContextOnStack(workInProgress),
            reuseSuspenseHandlerOnStack(workInProgress));
      reconcileChildren(current, workInProgress, nextChildren, renderLanes);
      return workInProgress.child;
    }
    function deferHiddenOffscreenComponent(
      current,
      workInProgress,
      nextBaseLanes,
      renderLanes
    ) {
      var JSCompiler_inline_result = peekCacheFromPool();
      JSCompiler_inline_result =
        null === JSCompiler_inline_result
          ? null
          : {
              parent: CacheContext._currentValue,
              pool: JSCompiler_inline_result
            };
      workInProgress.memoizedState = {
        baseLanes: nextBaseLanes,
        cachePool: JSCompiler_inline_result
      };
      null !== current && pushTransition(workInProgress, null);
      reuseHiddenContextOnStack(workInProgress);
      pushOffscreenSuspenseHandler(workInProgress);
      null !== current &&
        propagateParentContextChanges(current, workInProgress, renderLanes, !0);
      return null;
    }
    function markRef(current, workInProgress) {
      var ref = workInProgress.ref;
      if (null === ref)
        null !== current &&
          null !== current.ref &&
          (workInProgress.flags |= 4194816);
      else {
        if ("function" !== typeof ref && "object" !== typeof ref)
          throw Error(
            "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
          );
        if (null === current || current.ref !== ref)
          workInProgress.flags |= 4194816;
      }
    }
    function updateFunctionComponent(
      current,
      workInProgress,
      Component,
      nextProps,
      renderLanes
    ) {
      if (
        Component.prototype &&
        "function" === typeof Component.prototype.render
      ) {
        var componentName = getComponentNameFromType(Component) || "Unknown";
        didWarnAboutBadClass[componentName] ||
          (console.error(
            "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
            componentName,
            componentName
          ),
          (didWarnAboutBadClass[componentName] = !0));
      }
      workInProgress.mode & StrictLegacyMode &&
        ReactStrictModeWarnings.recordLegacyContextWarning(
          workInProgress,
          null
        );
      null === current &&
        (validateFunctionComponentInDev(workInProgress, workInProgress.type),
        Component.contextTypes &&
          ((componentName = getComponentNameFromType(Component) || "Unknown"),
          didWarnAboutContextTypes[componentName] ||
            ((didWarnAboutContextTypes[componentName] = !0),
            console.error(
              "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
              componentName
            ))));
      prepareToReadContext(workInProgress);
      markComponentRenderStarted(workInProgress);
      Component = renderWithHooks(
        current,
        workInProgress,
        Component,
        nextProps,
        void 0,
        renderLanes
      );
      nextProps = checkDidRenderIdHook();
      markComponentRenderStopped();
      if (null !== current && !didReceiveUpdate)
        return (
          bailoutHooks(current, workInProgress, renderLanes),
          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
        );
      isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
      workInProgress.flags |= 1;
      reconcileChildren(current, workInProgress, Component, renderLanes);
      return workInProgress.child;
    }
    function replayFunctionComponent(
      current,
      workInProgress,
      nextProps,
      Component,
      secondArg,
      renderLanes
    ) {
      prepareToReadContext(workInProgress);
      markComponentRenderStarted(workInProgress);
      hookTypesUpdateIndexDev = -1;
      ignorePreviousDependencies =
        null !== current && current.type !== workInProgress.type;
      workInProgress.updateQueue = null;
      nextProps = renderWithHooksAgain(
        workInProgress,
        Component,
        nextProps,
        secondArg
      );
      finishRenderingHooks(current, workInProgress);
      Component = checkDidRenderIdHook();
      markComponentRenderStopped();
      if (null !== current && !didReceiveUpdate)
        return (
          bailoutHooks(current, workInProgress, renderLanes),
          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
        );
      isHydrating && Component && pushMaterializedTreeId(workInProgress);
      workInProgress.flags |= 1;
      reconcileChildren(current, workInProgress, nextProps, renderLanes);
      return workInProgress.child;
    }
    function updateClassComponent(
      current,
      workInProgress,
      Component,
      nextProps,
      renderLanes
    ) {
      switch (shouldErrorImpl(workInProgress)) {
        case !1:
          var _instance = workInProgress.stateNode,
            state = new workInProgress.type(
              workInProgress.memoizedProps,
              _instance.context
            ).state;
          _instance.updater.enqueueSetState(_instance, state, null);
          break;
        case !0:
          workInProgress.flags |= 128;
          workInProgress.flags |= 65536;
          _instance = Error("Simulated error coming from DevTools");
          var lane = renderLanes & -renderLanes;
          workInProgress.lanes |= lane;
          state = workInProgressRoot;
          if (null === state)
            throw Error(
              "Expected a work-in-progress root. This is a bug in React. Please file an issue."
            );
          lane = createClassErrorUpdate(lane);
          initializeClassErrorUpdate(
            lane,
            state,
            workInProgress,
            createCapturedValueAtFiber(_instance, workInProgress)
          );
          enqueueCapturedUpdate(workInProgress, lane);
      }
      prepareToReadContext(workInProgress);
      if (null === workInProgress.stateNode) {
        state = emptyContextObject;
        _instance = Component.contextType;
        "contextType" in Component &&
          null !== _instance &&
          (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) &&
          !didWarnAboutInvalidateContextType.has(Component) &&
          (didWarnAboutInvalidateContextType.add(Component),
          (lane =
            void 0 === _instance
              ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file."
              : "object" !== typeof _instance
                ? " However, it is set to a " + typeof _instance + "."
                : _instance.$$typeof === REACT_CONSUMER_TYPE
                  ? " Did you accidentally pass the Context.Consumer instead?"
                  : " However, it is set to an object with keys {" +
                    Object.keys(_instance).join(", ") +
                    "}."),
          console.error(
            "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
            getComponentNameFromType(Component) || "Component",
            lane
          ));
        "object" === typeof _instance &&
          null !== _instance &&
          (state = readContext(_instance));
        _instance = new Component(nextProps, state);
        if (workInProgress.mode & StrictLegacyMode) {
          setIsStrictModeForDevtools(!0);
          try {
            _instance = new Component(nextProps, state);
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
        state = workInProgress.memoizedState =
          null !== _instance.state && void 0 !== _instance.state
            ? _instance.state
            : null;
        _instance.updater = classComponentUpdater;
        workInProgress.stateNode = _instance;
        _instance._reactInternals = workInProgress;
        _instance._reactInternalInstance = fakeInternalInstance;
        "function" === typeof Component.getDerivedStateFromProps &&
          null === state &&
          ((state = getComponentNameFromType(Component) || "Component"),
          didWarnAboutUninitializedState.has(state) ||
            (didWarnAboutUninitializedState.add(state),
            console.error(
              "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
              state,
              null === _instance.state ? "null" : "undefined",
              state
            )));
        if (
          "function" === typeof Component.getDerivedStateFromProps ||
          "function" === typeof _instance.getSnapshotBeforeUpdate
        ) {
          var foundWillUpdateName = (lane = state = null);
          "function" === typeof _instance.componentWillMount &&
          !0 !== _instance.componentWillMount.__suppressDeprecationWarning
            ? (state = "componentWillMount")
            : "function" === typeof _instance.UNSAFE_componentWillMount &&
              (state = "UNSAFE_componentWillMount");
          "function" === typeof _instance.componentWillReceiveProps &&
          !0 !==
            _instance.componentWillReceiveProps.__suppressDeprecationWarning
            ? (lane = "componentWillReceiveProps")
            : "function" ===
                typeof _instance.UNSAFE_componentWillReceiveProps &&
              (lane = "UNSAFE_componentWillReceiveProps");
          "function" === typeof _instance.componentWillUpdate &&
          !0 !== _instance.componentWillUpdate.__suppressDeprecationWarning
            ? (foundWillUpdateName = "componentWillUpdate")
            : "function" === typeof _instance.UNSAFE_componentWillUpdate &&
              (foundWillUpdateName = "UNSAFE_componentWillUpdate");
          if (null !== state || null !== lane || null !== foundWillUpdateName) {
            _instance = getComponentNameFromType(Component) || "Component";
            var newApiName =
              "function" === typeof Component.getDerivedStateFromProps
                ? "getDerivedStateFromProps()"
                : "getSnapshotBeforeUpdate()";
            didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) ||
              (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance),
              console.error(
                "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                _instance,
                newApiName,
                null !== state ? "\n  " + state : "",
                null !== lane ? "\n  " + lane : "",
                null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
              ));
          }
        }
        _instance = workInProgress.stateNode;
        state = getComponentNameFromType(Component) || "Component";
        _instance.render ||
          (Component.prototype &&
          "function" === typeof Component.prototype.render
            ? console.error(
                "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
                state
              )
            : console.error(
                "No `render` method found on the %s instance: you may have forgotten to define `render`.",
                state
              ));
        !_instance.getInitialState ||
          _instance.getInitialState.isReactClassApproved ||
          _instance.state ||
          console.error(
            "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
            state
          );
        _instance.getDefaultProps &&
          !_instance.getDefaultProps.isReactClassApproved &&
          console.error(
            "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
            state
          );
        _instance.contextType &&
          console.error(
            "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
            state
          );
        Component.childContextTypes &&
          !didWarnAboutChildContextTypes.has(Component) &&
          (didWarnAboutChildContextTypes.add(Component),
          console.error(
            "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
            state
          ));
        Component.contextTypes &&
          !didWarnAboutContextTypes$1.has(Component) &&
          (didWarnAboutContextTypes$1.add(Component),
          console.error(
            "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
            state
          ));
        "function" === typeof _instance.componentShouldUpdate &&
          console.error(
            "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
            state
          );
        Component.prototype &&
          Component.prototype.isPureReactComponent &&
          "undefined" !== typeof _instance.shouldComponentUpdate &&
          console.error(
            "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
            getComponentNameFromType(Component) || "A pure component"
          );
        "function" === typeof _instance.componentDidUnmount &&
          console.error(
            "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
            state
          );
        "function" === typeof _instance.componentDidReceiveProps &&
          console.error(
            "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
            state
          );
        "function" === typeof _instance.componentWillRecieveProps &&
          console.error(
            "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
            state
          );
        "function" === typeof _instance.UNSAFE_componentWillRecieveProps &&
          console.error(
            "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
            state
          );
        lane = _instance.props !== nextProps;
        void 0 !== _instance.props &&
          lane &&
          console.error(
            "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
            state
          );
        _instance.defaultProps &&
          console.error(
            "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
            state,
            state
          );
        "function" !== typeof _instance.getSnapshotBeforeUpdate ||
          "function" === typeof _instance.componentDidUpdate ||
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) ||
          (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component),
          console.error(
            "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
            getComponentNameFromType(Component)
          ));
        "function" === typeof _instance.getDerivedStateFromProps &&
          console.error(
            "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
            state
          );
        "function" === typeof _instance.getDerivedStateFromError &&
          console.error(
            "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
            state
          );
        "function" === typeof Component.getSnapshotBeforeUpdate &&
          console.error(
            "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
            state
          );
        (lane = _instance.state) &&
          ("object" !== typeof lane || isArrayImpl(lane)) &&
          console.error("%s.state: must be set to an object or null", state);
        "function" === typeof _instance.getChildContext &&
          "object" !== typeof Component.childContextTypes &&
          console.error(
            "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
            state
          );
        _instance = workInProgress.stateNode;
        _instance.props = nextProps;
        _instance.state = workInProgress.memoizedState;
        _instance.refs = {};
        initializeUpdateQueue(workInProgress);
        state = Component.contextType;
        _instance.context =
          "object" === typeof state && null !== state
            ? readContext(state)
            : emptyContextObject;
        _instance.state === nextProps &&
          ((state = getComponentNameFromType(Component) || "Component"),
          didWarnAboutDirectlyAssigningPropsToState.has(state) ||
            (didWarnAboutDirectlyAssigningPropsToState.add(state),
            console.error(
              "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
              state
            )));
        workInProgress.mode & StrictLegacyMode &&
          ReactStrictModeWarnings.recordLegacyContextWarning(
            workInProgress,
            _instance
          );
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
          workInProgress,
          _instance
        );
        _instance.state = workInProgress.memoizedState;
        state = Component.getDerivedStateFromProps;
        "function" === typeof state &&
          (applyDerivedStateFromProps(
            workInProgress,
            Component,
            state,
            nextProps
          ),
          (_instance.state = workInProgress.memoizedState));
        "function" === typeof Component.getDerivedStateFromProps ||
          "function" === typeof _instance.getSnapshotBeforeUpdate ||
          ("function" !== typeof _instance.UNSAFE_componentWillMount &&
            "function" !== typeof _instance.componentWillMount) ||
          ((state = _instance.state),
          "function" === typeof _instance.componentWillMount &&
            _instance.componentWillMount(),
          "function" === typeof _instance.UNSAFE_componentWillMount &&
            _instance.UNSAFE_componentWillMount(),
          state !== _instance.state &&
            (console.error(
              "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
              getComponentNameFromFiber(workInProgress) || "Component"
            ),
            classComponentUpdater.enqueueReplaceState(
              _instance,
              _instance.state,
              null
            )),
          processUpdateQueue(workInProgress, nextProps, _instance, renderLanes),
          suspendIfUpdateReadFromEntangledAsyncAction(),
          (_instance.state = workInProgress.memoizedState));
        "function" === typeof _instance.componentDidMount &&
          (workInProgress.flags |= 4194308);
        (workInProgress.mode & StrictEffectsMode) !== NoMode &&
          (workInProgress.flags |= 134217728);
        _instance = !0;
      } else if (null === current) {
        _instance = workInProgress.stateNode;
        var unresolvedOldProps = workInProgress.memoizedProps;
        lane = resolveClassComponentProps(Component, unresolvedOldProps);
        _instance.props = lane;
        var oldContext = _instance.context;
        foundWillUpdateName = Component.contextType;
        state = emptyContextObject;
        "object" === typeof foundWillUpdateName &&
          null !== foundWillUpdateName &&
          (state = readContext(foundWillUpdateName));
        newApiName = Component.getDerivedStateFromProps;
        foundWillUpdateName =
          "function" === typeof newApiName ||
          "function" === typeof _instance.getSnapshotBeforeUpdate;
        unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
        foundWillUpdateName ||
          ("function" !== typeof _instance.UNSAFE_componentWillReceiveProps &&
            "function" !== typeof _instance.componentWillReceiveProps) ||
          ((unresolvedOldProps || oldContext !== state) &&
            callComponentWillReceiveProps(
              workInProgress,
              _instance,
              nextProps,
              state
            ));
        hasForceUpdate = !1;
        var oldState = workInProgress.memoizedState;
        _instance.state = oldState;
        processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);
        suspendIfUpdateReadFromEntangledAsyncAction();
        oldContext = workInProgress.memoizedState;
        unresolvedOldProps || oldState !== oldContext || hasForceUpdate
          ? ("function" === typeof newApiName &&
              (applyDerivedStateFromProps(
                workInProgress,
                Component,
                newApiName,
                nextProps
              ),
              (oldContext = workInProgress.memoizedState)),
            (lane =
              hasForceUpdate ||
              checkShouldComponentUpdate(
                workInProgress,
                Component,
                lane,
                nextProps,
                oldState,
                oldContext,
                state
              ))
              ? (foundWillUpdateName ||
                  ("function" !== typeof _instance.UNSAFE_componentWillMount &&
                    "function" !== typeof _instance.componentWillMount) ||
                  ("function" === typeof _instance.componentWillMount &&
                    _instance.componentWillMount(),
                  "function" === typeof _instance.UNSAFE_componentWillMount &&
                    _instance.UNSAFE_componentWillMount()),
                "function" === typeof _instance.componentDidMount &&
                  (workInProgress.flags |= 4194308),
                (workInProgress.mode & StrictEffectsMode) !== NoMode &&
                  (workInProgress.flags |= 134217728))
              : ("function" === typeof _instance.componentDidMount &&
                  (workInProgress.flags |= 4194308),
                (workInProgress.mode & StrictEffectsMode) !== NoMode &&
                  (workInProgress.flags |= 134217728),
                (workInProgress.memoizedProps = nextProps),
                (workInProgress.memoizedState = oldContext)),
            (_instance.props = nextProps),
            (_instance.state = oldContext),
            (_instance.context = state),
            (_instance = lane))
          : ("function" === typeof _instance.componentDidMount &&
              (workInProgress.flags |= 4194308),
            (workInProgress.mode & StrictEffectsMode) !== NoMode &&
              (workInProgress.flags |= 134217728),
            (_instance = !1));
      } else {
        _instance = workInProgress.stateNode;
        cloneUpdateQueue(current, workInProgress);
        state = workInProgress.memoizedProps;
        foundWillUpdateName = resolveClassComponentProps(Component, state);
        _instance.props = foundWillUpdateName;
        newApiName = workInProgress.pendingProps;
        oldState = _instance.context;
        oldContext = Component.contextType;
        lane = emptyContextObject;
        "object" === typeof oldContext &&
          null !== oldContext &&
          (lane = readContext(oldContext));
        unresolvedOldProps = Component.getDerivedStateFromProps;
        (oldContext =
          "function" === typeof unresolvedOldProps ||
          "function" === typeof _instance.getSnapshotBeforeUpdate) ||
          ("function" !== typeof _instance.UNSAFE_componentWillReceiveProps &&
            "function" !== typeof _instance.componentWillReceiveProps) ||
          ((state !== newApiName || oldState !== lane) &&
            callComponentWillReceiveProps(
              workInProgress,
              _instance,
              nextProps,
              lane
            ));
        hasForceUpdate = !1;
        oldState = workInProgress.memoizedState;
        _instance.state = oldState;
        processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);
        suspendIfUpdateReadFromEntangledAsyncAction();
        var newState = workInProgress.memoizedState;
        state !== newApiName ||
        oldState !== newState ||
        hasForceUpdate ||
        (null !== current &&
          null !== current.dependencies &&
          checkIfContextChanged(current.dependencies))
          ? ("function" === typeof unresolvedOldProps &&
              (applyDerivedStateFromProps(
                workInProgress,
                Component,
                unresolvedOldProps,
                nextProps
              ),
              (newState = workInProgress.memoizedState)),
            (foundWillUpdateName =
              hasForceUpdate ||
              checkShouldComponentUpdate(
                workInProgress,
                Component,
                foundWillUpdateName,
                nextProps,
                oldState,
                newState,
                lane
              ) ||
              (null !== current &&
                null !== current.dependencies &&
                checkIfContextChanged(current.dependencies)))
              ? (oldContext ||
                  ("function" !== typeof _instance.UNSAFE_componentWillUpdate &&
                    "function" !== typeof _instance.componentWillUpdate) ||
                  ("function" === typeof _instance.componentWillUpdate &&
                    _instance.componentWillUpdate(nextProps, newState, lane),
                  "function" === typeof _instance.UNSAFE_componentWillUpdate &&
                    _instance.UNSAFE_componentWillUpdate(
                      nextProps,
                      newState,
                      lane
                    )),
                "function" === typeof _instance.componentDidUpdate &&
                  (workInProgress.flags |= 4),
                "function" === typeof _instance.getSnapshotBeforeUpdate &&
                  (workInProgress.flags |= 1024))
              : ("function" !== typeof _instance.componentDidUpdate ||
                  (state === current.memoizedProps &&
                    oldState === current.memoizedState) ||
                  (workInProgress.flags |= 4),
                "function" !== typeof _instance.getSnapshotBeforeUpdate ||
                  (state === current.memoizedProps &&
                    oldState === current.memoizedState) ||
                  (workInProgress.flags |= 1024),
                (workInProgress.memoizedProps = nextProps),
                (workInProgress.memoizedState = newState)),
            (_instance.props = nextProps),
            (_instance.state = newState),
            (_instance.context = lane),
            (_instance = foundWillUpdateName))
          : ("function" !== typeof _instance.componentDidUpdate ||
              (state === current.memoizedProps &&
                oldState === current.memoizedState) ||
              (workInProgress.flags |= 4),
            "function" !== typeof _instance.getSnapshotBeforeUpdate ||
              (state === current.memoizedProps &&
                oldState === current.memoizedState) ||
              (workInProgress.flags |= 1024),
            (_instance = !1));
      }
      lane = _instance;
      markRef(current, workInProgress);
      state = 0 !== (workInProgress.flags & 128);
      if (lane || state) {
        lane = workInProgress.stateNode;
        setCurrentFiber(workInProgress);
        if (state && "function" !== typeof Component.getDerivedStateFromError)
          (Component = null), (profilerStartTime = -1);
        else {
          markComponentRenderStarted(workInProgress);
          Component = callRenderInDEV(lane);
          if (workInProgress.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(!0);
            try {
              callRenderInDEV(lane);
            } finally {
              setIsStrictModeForDevtools(!1);
            }
          }
          markComponentRenderStopped();
        }
        workInProgress.flags |= 1;
        null !== current && state
          ? ((workInProgress.child = reconcileChildFibers(
              workInProgress,
              current.child,
              null,
              renderLanes
            )),
            (workInProgress.child = reconcileChildFibers(
              workInProgress,
              null,
              Component,
              renderLanes
            )))
          : reconcileChildren(current, workInProgress, Component, renderLanes);
        workInProgress.memoizedState = lane.state;
        current = workInProgress.child;
      } else
        current = bailoutOnAlreadyFinishedWork(
          current,
          workInProgress,
          renderLanes
        );
      renderLanes = workInProgress.stateNode;
      _instance &&
        renderLanes.props !== nextProps &&
        (didWarnAboutReassigningProps ||
          console.error(
            "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
            getComponentNameFromFiber(workInProgress) || "a component"
          ),
        (didWarnAboutReassigningProps = !0));
      return current;
    }
    function mountHostRootWithoutHydrating(
      current,
      workInProgress,
      nextChildren,
      renderLanes
    ) {
      resetHydrationState();
      workInProgress.flags |= 256;
      reconcileChildren(current, workInProgress, nextChildren, renderLanes);
      return workInProgress.child;
    }
    function validateFunctionComponentInDev(workInProgress, Component) {
      Component &&
        Component.childContextTypes &&
        console.error(
          "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
          Component.displayName || Component.name || "Component"
        );
      "function" === typeof Component.getDerivedStateFromProps &&
        ((workInProgress = getComponentNameFromType(Component) || "Unknown"),
        didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] ||
          (console.error(
            "%s: Function components do not support getDerivedStateFromProps.",
            workInProgress
          ),
          (didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] =
            !0)));
      "object" === typeof Component.contextType &&
        null !== Component.contextType &&
        ((Component = getComponentNameFromType(Component) || "Unknown"),
        didWarnAboutContextTypeOnFunctionComponent[Component] ||
          (console.error(
            "%s: Function components do not support contextType.",
            Component
          ),
          (didWarnAboutContextTypeOnFunctionComponent[Component] = !0)));
    }
    function mountSuspenseOffscreenState(renderLanes) {
      return { baseLanes: renderLanes, cachePool: getSuspendedCache() };
    }
    function getRemainingWorkInPrimaryTree(
      current,
      primaryTreeDidDefer,
      renderLanes
    ) {
      current = null !== current ? current.childLanes & ~renderLanes : 0;
      primaryTreeDidDefer && (current |= workInProgressDeferredLane);
      return current;
    }
    function updateSuspenseComponent(current, workInProgress, renderLanes) {
      var JSCompiler_object_inline_digest_2451;
      var JSCompiler_object_inline_stack_2452 = workInProgress.pendingProps;
      shouldSuspendImpl(workInProgress) && (workInProgress.flags |= 128);
      var JSCompiler_object_inline_componentStack_2453 = !1;
      var didSuspend = 0 !== (workInProgress.flags & 128);
      (JSCompiler_object_inline_digest_2451 = didSuspend) ||
        (JSCompiler_object_inline_digest_2451 =
          null !== current && null === current.memoizedState
            ? !1
            : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
      JSCompiler_object_inline_digest_2451 &&
        ((JSCompiler_object_inline_componentStack_2453 = !0),
        (workInProgress.flags &= -129));
      JSCompiler_object_inline_digest_2451 = 0 !== (workInProgress.flags & 32);
      workInProgress.flags &= -33;
      if (null === current) {
        if (isHydrating) {
          JSCompiler_object_inline_componentStack_2453
            ? pushPrimaryTreeSuspenseHandler(workInProgress)
            : reuseSuspenseHandlerOnStack(workInProgress);
          if (isHydrating) {
            var JSCompiler_object_inline_message_2450 = nextHydratableInstance;
            var JSCompiler_temp;
            if (!(JSCompiler_temp = !JSCompiler_object_inline_message_2450)) {
              c: {
                var instance = JSCompiler_object_inline_message_2450;
                for (
                  JSCompiler_temp = rootOrSingletonContext;
                  8 !== instance.nodeType;

                ) {
                  if (!JSCompiler_temp) {
                    JSCompiler_temp = null;
                    break c;
                  }
                  instance = getNextHydratable(instance.nextSibling);
                  if (null === instance) {
                    JSCompiler_temp = null;
                    break c;
                  }
                }
                JSCompiler_temp = instance;
              }
              null !== JSCompiler_temp
                ? (warnIfNotHydrating(),
                  (workInProgress.memoizedState = {
                    dehydrated: JSCompiler_temp,
                    treeContext:
                      null !== treeContextProvider
                        ? { id: treeContextId, overflow: treeContextOverflow }
                        : null,
                    retryLane: 536870912,
                    hydrationErrors: null
                  }),
                  (instance = createFiber(18, null, null, NoMode)),
                  (instance.stateNode = JSCompiler_temp),
                  (instance.return = workInProgress),
                  (workInProgress.child = instance),
                  (hydrationParentFiber = workInProgress),
                  (nextHydratableInstance = null),
                  (JSCompiler_temp = !0))
                : (JSCompiler_temp = !1);
              JSCompiler_temp = !JSCompiler_temp;
            }
            JSCompiler_temp &&
              (warnNonHydratedInstance(
                workInProgress,
                JSCompiler_object_inline_message_2450
              ),
              throwOnHydrationMismatch(workInProgress));
          }
          JSCompiler_object_inline_message_2450 = workInProgress.memoizedState;
          if (
            null !== JSCompiler_object_inline_message_2450 &&
            ((JSCompiler_object_inline_message_2450 =
              JSCompiler_object_inline_message_2450.dehydrated),
            null !== JSCompiler_object_inline_message_2450)
          )
            return (
              isSuspenseInstanceFallback(JSCompiler_object_inline_message_2450)
                ? (workInProgress.lanes = 32)
                : (workInProgress.lanes = 536870912),
              null
            );
          popSuspenseHandler(workInProgress);
        }
        JSCompiler_object_inline_message_2450 =
          JSCompiler_object_inline_stack_2452.children;
        JSCompiler_object_inline_stack_2452 =
          JSCompiler_object_inline_stack_2452.fallback;
        if (JSCompiler_object_inline_componentStack_2453)
          return (
            reuseSuspenseHandlerOnStack(workInProgress),
            (JSCompiler_object_inline_componentStack_2453 =
              workInProgress.mode),
            (JSCompiler_object_inline_message_2450 =
              mountWorkInProgressOffscreenFiber(
                {
                  mode: "hidden",
                  children: JSCompiler_object_inline_message_2450
                },
                JSCompiler_object_inline_componentStack_2453
              )),
            (JSCompiler_object_inline_stack_2452 = createFiberFromFragment(
              JSCompiler_object_inline_stack_2452,
              JSCompiler_object_inline_componentStack_2453,
              renderLanes,
              null
            )),
            (JSCompiler_object_inline_message_2450.return = workInProgress),
            (JSCompiler_object_inline_stack_2452.return = workInProgress),
            (JSCompiler_object_inline_message_2450.sibling =
              JSCompiler_object_inline_stack_2452),
            (workInProgress.child = JSCompiler_object_inline_message_2450),
            (JSCompiler_object_inline_componentStack_2453 =
              workInProgress.child),
            (JSCompiler_object_inline_componentStack_2453.memoizedState =
              mountSuspenseOffscreenState(renderLanes)),
            (JSCompiler_object_inline_componentStack_2453.childLanes =
              getRemainingWorkInPrimaryTree(
                current,
                JSCompiler_object_inline_digest_2451,
                renderLanes
              )),
            (workInProgress.memoizedState = SUSPENDED_MARKER),
            JSCompiler_object_inline_stack_2452
          );
        pushPrimaryTreeSuspenseHandler(workInProgress);
        return mountSuspensePrimaryChildren(
          workInProgress,
          JSCompiler_object_inline_message_2450
        );
      }
      var prevState = current.memoizedState;
      if (
        null !== prevState &&
        ((JSCompiler_object_inline_message_2450 = prevState.dehydrated),
        null !== JSCompiler_object_inline_message_2450)
      ) {
        if (didSuspend)
          workInProgress.flags & 256
            ? (pushPrimaryTreeSuspenseHandler(workInProgress),
              (workInProgress.flags &= -257),
              (workInProgress = retrySuspenseComponentWithoutHydrating(
                current,
                workInProgress,
                renderLanes
              )))
            : null !== workInProgress.memoizedState
              ? (reuseSuspenseHandlerOnStack(workInProgress),
                (workInProgress.child = current.child),
                (workInProgress.flags |= 128),
                (workInProgress = null))
              : (reuseSuspenseHandlerOnStack(workInProgress),
                (JSCompiler_object_inline_componentStack_2453 =
                  JSCompiler_object_inline_stack_2452.fallback),
                (JSCompiler_object_inline_message_2450 = workInProgress.mode),
                (JSCompiler_object_inline_stack_2452 =
                  mountWorkInProgressOffscreenFiber(
                    {
                      mode: "visible",
                      children: JSCompiler_object_inline_stack_2452.children
                    },
                    JSCompiler_object_inline_message_2450
                  )),
                (JSCompiler_object_inline_componentStack_2453 =
                  createFiberFromFragment(
                    JSCompiler_object_inline_componentStack_2453,
                    JSCompiler_object_inline_message_2450,
                    renderLanes,
                    null
                  )),
                (JSCompiler_object_inline_componentStack_2453.flags |= 2),
                (JSCompiler_object_inline_stack_2452.return = workInProgress),
                (JSCompiler_object_inline_componentStack_2453.return =
                  workInProgress),
                (JSCompiler_object_inline_stack_2452.sibling =
                  JSCompiler_object_inline_componentStack_2453),
                (workInProgress.child = JSCompiler_object_inline_stack_2452),
                reconcileChildFibers(
                  workInProgress,
                  current.child,
                  null,
                  renderLanes
                ),
                (JSCompiler_object_inline_stack_2452 = workInProgress.child),
                (JSCompiler_object_inline_stack_2452.memoizedState =
                  mountSuspenseOffscreenState(renderLanes)),
                (JSCompiler_object_inline_stack_2452.childLanes =
                  getRemainingWorkInPrimaryTree(
                    current,
                    JSCompiler_object_inline_digest_2451,
                    renderLanes
                  )),
                (workInProgress.memoizedState = SUSPENDED_MARKER),
                (workInProgress =
                  JSCompiler_object_inline_componentStack_2453));
        else if (
          (pushPrimaryTreeSuspenseHandler(workInProgress),
          isHydrating &&
            console.error(
              "We should not be hydrating here. This is a bug in React. Please file a bug."
            ),
          isSuspenseInstanceFallback(JSCompiler_object_inline_message_2450))
        ) {
          JSCompiler_object_inline_digest_2451 =
            JSCompiler_object_inline_message_2450.nextSibling &&
            JSCompiler_object_inline_message_2450.nextSibling.dataset;
          if (JSCompiler_object_inline_digest_2451) {
            JSCompiler_temp = JSCompiler_object_inline_digest_2451.dgst;
            var message = JSCompiler_object_inline_digest_2451.msg;
            instance = JSCompiler_object_inline_digest_2451.stck;
            var componentStack = JSCompiler_object_inline_digest_2451.cstck;
          }
          JSCompiler_object_inline_message_2450 = message;
          JSCompiler_object_inline_digest_2451 = JSCompiler_temp;
          JSCompiler_object_inline_stack_2452 = instance;
          JSCompiler_temp = JSCompiler_object_inline_componentStack_2453 =
            componentStack;
          JSCompiler_object_inline_componentStack_2453 =
            JSCompiler_object_inline_message_2450
              ? Error(JSCompiler_object_inline_message_2450)
              : Error(
                  "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
                );
          JSCompiler_object_inline_componentStack_2453.stack =
            JSCompiler_object_inline_stack_2452 || "";
          JSCompiler_object_inline_componentStack_2453.digest =
            JSCompiler_object_inline_digest_2451;
          JSCompiler_object_inline_digest_2451 =
            void 0 === JSCompiler_temp ? null : JSCompiler_temp;
          JSCompiler_object_inline_stack_2452 = {
            value: JSCompiler_object_inline_componentStack_2453,
            source: null,
            stack: JSCompiler_object_inline_digest_2451
          };
          "string" === typeof JSCompiler_object_inline_digest_2451 &&
            CapturedStacks.set(
              JSCompiler_object_inline_componentStack_2453,
              JSCompiler_object_inline_stack_2452
            );
          queueHydrationError(JSCompiler_object_inline_stack_2452);
          workInProgress = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress,
            renderLanes
          );
        } else if (
          (didReceiveUpdate ||
            propagateParentContextChanges(
              current,
              workInProgress,
              renderLanes,
              !1
            ),
          (JSCompiler_object_inline_digest_2451 =
            0 !== (renderLanes & current.childLanes)),
          didReceiveUpdate || JSCompiler_object_inline_digest_2451)
        ) {
          JSCompiler_object_inline_digest_2451 = workInProgressRoot;
          if (
            null !== JSCompiler_object_inline_digest_2451 &&
            ((JSCompiler_object_inline_stack_2452 = renderLanes & -renderLanes),
            (JSCompiler_object_inline_stack_2452 =
              0 !== (JSCompiler_object_inline_stack_2452 & 42)
                ? 1
                : getBumpedLaneForHydrationByLane(
                    JSCompiler_object_inline_stack_2452
                  )),
            (JSCompiler_object_inline_stack_2452 =
              0 !==
              (JSCompiler_object_inline_stack_2452 &
                (JSCompiler_object_inline_digest_2451.suspendedLanes |
                  renderLanes))
                ? 0
                : JSCompiler_object_inline_stack_2452),
            0 !== JSCompiler_object_inline_stack_2452 &&
              JSCompiler_object_inline_stack_2452 !== prevState.retryLane)
          )
            throw (
              ((prevState.retryLane = JSCompiler_object_inline_stack_2452),
              enqueueConcurrentRenderForLane(
                current,
                JSCompiler_object_inline_stack_2452
              ),
              scheduleUpdateOnFiber(
                JSCompiler_object_inline_digest_2451,
                current,
                JSCompiler_object_inline_stack_2452
              ),
              SelectiveHydrationException)
            );
          JSCompiler_object_inline_message_2450.data ===
            SUSPENSE_PENDING_START_DATA || renderDidSuspendDelayIfPossible();
          workInProgress = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress,
            renderLanes
          );
        } else
          JSCompiler_object_inline_message_2450.data ===
          SUSPENSE_PENDING_START_DATA
            ? ((workInProgress.flags |= 192),
              (workInProgress.child = current.child),
              (workInProgress = null))
            : ((current = prevState.treeContext),
              (nextHydratableInstance = getNextHydratable(
                JSCompiler_object_inline_message_2450.nextSibling
              )),
              (hydrationParentFiber = workInProgress),
              (isHydrating = !0),
              (hydrationErrors = null),
              (didSuspendOrErrorDEV = !1),
              (hydrationDiffRootDEV = null),
              (rootOrSingletonContext = !1),
              null !== current &&
                (warnIfNotHydrating(),
                (idStack[idStackIndex++] = treeContextId),
                (idStack[idStackIndex++] = treeContextOverflow),
                (idStack[idStackIndex++] = treeContextProvider),
                (treeContextId = current.id),
                (treeContextOverflow = current.overflow),
                (treeContextProvider = workInProgress)),
              (workInProgress = mountSuspensePrimaryChildren(
                workInProgress,
                JSCompiler_object_inline_stack_2452.children
              )),
              (workInProgress.flags |= 4096));
        return workInProgress;
      }
      if (JSCompiler_object_inline_componentStack_2453)
        return (
          reuseSuspenseHandlerOnStack(workInProgress),
          (JSCompiler_object_inline_componentStack_2453 =
            JSCompiler_object_inline_stack_2452.fallback),
          (JSCompiler_object_inline_message_2450 = workInProgress.mode),
          (JSCompiler_temp = current.child),
          (instance = JSCompiler_temp.sibling),
          (JSCompiler_object_inline_stack_2452 = createWorkInProgress(
            JSCompiler_temp,
            {
              mode: "hidden",
              children: JSCompiler_object_inline_stack_2452.children
            }
          )),
          (JSCompiler_object_inline_stack_2452.subtreeFlags =
            JSCompiler_temp.subtreeFlags & 65011712),
          null !== instance
            ? (JSCompiler_object_inline_componentStack_2453 =
                createWorkInProgress(
                  instance,
                  JSCompiler_object_inline_componentStack_2453
                ))
            : ((JSCompiler_object_inline_componentStack_2453 =
                createFiberFromFragment(
                  JSCompiler_object_inline_componentStack_2453,
                  JSCompiler_object_inline_message_2450,
                  renderLanes,
                  null
                )),
              (JSCompiler_object_inline_componentStack_2453.flags |= 2)),
          (JSCompiler_object_inline_componentStack_2453.return =
            workInProgress),
          (JSCompiler_object_inline_stack_2452.return = workInProgress),
          (JSCompiler_object_inline_stack_2452.sibling =
            JSCompiler_object_inline_componentStack_2453),
          (workInProgress.child = JSCompiler_object_inline_stack_2452),
          (JSCompiler_object_inline_stack_2452 =
            JSCompiler_object_inline_componentStack_2453),
          (JSCompiler_object_inline_componentStack_2453 = workInProgress.child),
          (JSCompiler_object_inline_message_2450 = current.child.memoizedState),
          null === JSCompiler_object_inline_message_2450
            ? (JSCompiler_object_inline_message_2450 =
                mountSuspenseOffscreenState(renderLanes))
            : ((JSCompiler_temp =
                JSCompiler_object_inline_message_2450.cachePool),
              null !== JSCompiler_temp
                ? ((instance = CacheContext._currentValue),
                  (JSCompiler_temp =
                    JSCompiler_temp.parent !== instance
                      ? { parent: instance, pool: instance }
                      : JSCompiler_temp))
                : (JSCompiler_temp = getSuspendedCache()),
              (JSCompiler_object_inline_message_2450 = {
                baseLanes:
                  JSCompiler_object_inline_message_2450.baseLanes | renderLanes,
                cachePool: JSCompiler_temp
              })),
          (JSCompiler_object_inline_componentStack_2453.memoizedState =
            JSCompiler_object_inline_message_2450),
          (JSCompiler_object_inline_componentStack_2453.childLanes =
            getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_object_inline_digest_2451,
              renderLanes
            )),
          (workInProgress.memoizedState = SUSPENDED_MARKER),
          JSCompiler_object_inline_stack_2452
        );
      pushPrimaryTreeSuspenseHandler(workInProgress);
      renderLanes = current.child;
      current = renderLanes.sibling;
      renderLanes = createWorkInProgress(renderLanes, {
        mode: "visible",
        children: JSCompiler_object_inline_stack_2452.children
      });
      renderLanes.return = workInProgress;
      renderLanes.sibling = null;
      null !== current &&
        ((JSCompiler_object_inline_digest_2451 = workInProgress.deletions),
        null === JSCompiler_object_inline_digest_2451
          ? ((workInProgress.deletions = [current]),
            (workInProgress.flags |= 16))
          : JSCompiler_object_inline_digest_2451.push(current));
      workInProgress.child = renderLanes;
      workInProgress.memoizedState = null;
      return renderLanes;
    }
    function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
      primaryChildren = mountWorkInProgressOffscreenFiber(
        { mode: "visible", children: primaryChildren },
        workInProgress.mode
      );
      primaryChildren.return = workInProgress;
      return (workInProgress.child = primaryChildren);
    }
    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
      offscreenProps = createFiber(22, offscreenProps, null, mode);
      offscreenProps.lanes = 0;
      offscreenProps.stateNode = {
        _visibility: OffscreenVisible,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      };
      return offscreenProps;
    }
    function retrySuspenseComponentWithoutHydrating(
      current,
      workInProgress,
      renderLanes
    ) {
      reconcileChildFibers(workInProgress, current.child, null, renderLanes);
      current = mountSuspensePrimaryChildren(
        workInProgress,
        workInProgress.pendingProps.children
      );
      current.flags |= 2;
      workInProgress.memoizedState = null;
      return current;
    }
    function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
      fiber.lanes |= renderLanes;
      var alternate = fiber.alternate;
      null !== alternate && (alternate.lanes |= renderLanes);
      scheduleContextWorkOnParentPath(
        fiber.return,
        renderLanes,
        propagationRoot
      );
    }
    function validateSuspenseListNestedChild(childSlot, index) {
      var isAnArray = isArrayImpl(childSlot);
      childSlot = !isAnArray && "function" === typeof getIteratorFn(childSlot);
      return isAnArray || childSlot
        ? ((isAnArray = isAnArray ? "array" : "iterable"),
          console.error(
            "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
            isAnArray,
            index,
            isAnArray
          ),
          !1)
        : !0;
    }
    function initSuspenseListRenderState(
      workInProgress,
      isBackwards,
      tail,
      lastContentRow,
      tailMode
    ) {
      var renderState = workInProgress.memoizedState;
      null === renderState
        ? (workInProgress.memoizedState = {
            isBackwards: isBackwards,
            rendering: null,
            renderingStartTime: 0,
            last: lastContentRow,
            tail: tail,
            tailMode: tailMode
          })
        : ((renderState.isBackwards = isBackwards),
          (renderState.rendering = null),
          (renderState.renderingStartTime = 0),
          (renderState.last = lastContentRow),
          (renderState.tail = tail),
          (renderState.tailMode = tailMode));
    }
    function updateSuspenseListComponent(current, workInProgress, renderLanes) {
      var nextProps = workInProgress.pendingProps,
        revealOrder = nextProps.revealOrder,
        tailMode = nextProps.tail;
      nextProps = nextProps.children;
      if (
        void 0 !== revealOrder &&
        "forwards" !== revealOrder &&
        "backwards" !== revealOrder &&
        "together" !== revealOrder &&
        !didWarnAboutRevealOrder[revealOrder]
      )
        if (
          ((didWarnAboutRevealOrder[revealOrder] = !0),
          "string" === typeof revealOrder)
        )
          switch (revealOrder.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards":
              console.error(
                '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                revealOrder,
                revealOrder.toLowerCase()
              );
              break;
            case "forward":
            case "backward":
              console.error(
                '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                revealOrder,
                revealOrder.toLowerCase()
              );
              break;
            default:
              console.error(
                '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
                revealOrder
              );
          }
        else
          console.error(
            '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
            revealOrder
          );
      void 0 === tailMode ||
        didWarnAboutTailOptions[tailMode] ||
        ("collapsed" !== tailMode && "hidden" !== tailMode
          ? ((didWarnAboutTailOptions[tailMode] = !0),
            console.error(
              '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
              tailMode
            ))
          : "forwards" !== revealOrder &&
            "backwards" !== revealOrder &&
            ((didWarnAboutTailOptions[tailMode] = !0),
            console.error(
              '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
              tailMode
            )));
      a: if (
        ("forwards" === revealOrder || "backwards" === revealOrder) &&
        void 0 !== nextProps &&
        null !== nextProps &&
        !1 !== nextProps
      )
        if (isArrayImpl(nextProps))
          for (var i = 0; i < nextProps.length; i++) {
            if (!validateSuspenseListNestedChild(nextProps[i], i)) break a;
          }
        else if (((i = getIteratorFn(nextProps)), "function" === typeof i)) {
          if ((i = i.call(nextProps)))
            for (var step = i.next(), _i = 0; !step.done; step = i.next()) {
              if (!validateSuspenseListNestedChild(step.value, _i)) break a;
              _i++;
            }
        } else
          console.error(
            'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
            revealOrder
          );
      reconcileChildren(current, workInProgress, nextProps, renderLanes);
      nextProps = suspenseStackCursor.current;
      if (0 !== (nextProps & ForceSuspenseFallback))
        (nextProps =
          (nextProps & SubtreeSuspenseContextMask) | ForceSuspenseFallback),
          (workInProgress.flags |= 128);
      else {
        if (null !== current && 0 !== (current.flags & 128))
          a: for (current = workInProgress.child; null !== current; ) {
            if (13 === current.tag)
              null !== current.memoizedState &&
                scheduleSuspenseWorkOnFiber(
                  current,
                  renderLanes,
                  workInProgress
                );
            else if (19 === current.tag)
              scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
            else if (null !== current.child) {
              current.child.return = current;
              current = current.child;
              continue;
            }
            if (current === workInProgress) break a;
            for (; null === current.sibling; ) {
              if (null === current.return || current.return === workInProgress)
                break a;
              current = current.return;
            }
            current.sibling.return = current.return;
            current = current.sibling;
          }
        nextProps &= SubtreeSuspenseContextMask;
      }
      push(suspenseStackCursor, nextProps, workInProgress);
      switch (revealOrder) {
        case "forwards":
          renderLanes = workInProgress.child;
          for (revealOrder = null; null !== renderLanes; )
            (current = renderLanes.alternate),
              null !== current &&
                null === findFirstSuspended(current) &&
                (revealOrder = renderLanes),
              (renderLanes = renderLanes.sibling);
          renderLanes = revealOrder;
          null === renderLanes
            ? ((revealOrder = workInProgress.child),
              (workInProgress.child = null))
            : ((revealOrder = renderLanes.sibling),
              (renderLanes.sibling = null));
          initSuspenseListRenderState(
            workInProgress,
            !1,
            revealOrder,
            renderLanes,
            tailMode
          );
          break;
        case "backwards":
          renderLanes = null;
          revealOrder = workInProgress.child;
          for (workInProgress.child = null; null !== revealOrder; ) {
            current = revealOrder.alternate;
            if (null !== current && null === findFirstSuspended(current)) {
              workInProgress.child = revealOrder;
              break;
            }
            current = revealOrder.sibling;
            revealOrder.sibling = renderLanes;
            renderLanes = revealOrder;
            revealOrder = current;
          }
          initSuspenseListRenderState(
            workInProgress,
            !0,
            renderLanes,
            null,
            tailMode
          );
          break;
        case "together":
          initSuspenseListRenderState(workInProgress, !1, null, null, void 0);
          break;
        default:
          workInProgress.memoizedState = null;
      }
      return workInProgress.child;
    }
    function bailoutOnAlreadyFinishedWork(
      current,
      workInProgress,
      renderLanes
    ) {
      null !== current && (workInProgress.dependencies = current.dependencies);
      profilerStartTime = -1;
      workInProgressRootSkippedLanes |= workInProgress.lanes;
      if (0 === (renderLanes & workInProgress.childLanes))
        if (null !== current) {
          if (
            (propagateParentContextChanges(
              current,
              workInProgress,
              renderLanes,
              !1
            ),
            0 === (renderLanes & workInProgress.childLanes))
          )
            return null;
        } else return null;
      if (null !== current && workInProgress.child !== current.child)
        throw Error("Resuming work not yet implemented.");
      if (null !== workInProgress.child) {
        current = workInProgress.child;
        renderLanes = createWorkInProgress(current, current.pendingProps);
        workInProgress.child = renderLanes;
        for (renderLanes.return = workInProgress; null !== current.sibling; )
          (current = current.sibling),
            (renderLanes = renderLanes.sibling =
              createWorkInProgress(current, current.pendingProps)),
            (renderLanes.return = workInProgress);
        renderLanes.sibling = null;
      }
      return workInProgress.child;
    }
    function checkScheduledUpdateOrContext(current, renderLanes) {
      if (0 !== (current.lanes & renderLanes)) return !0;
      current = current.dependencies;
      return null !== current && checkIfContextChanged(current) ? !0 : !1;
    }
    function attemptEarlyBailoutIfNoScheduledUpdate(
      current,
      workInProgress,
      renderLanes
    ) {
      switch (workInProgress.tag) {
        case 3:
          pushHostContainer(
            workInProgress,
            workInProgress.stateNode.containerInfo
          );
          pushProvider(
            workInProgress,
            CacheContext,
            current.memoizedState.cache
          );
          resetHydrationState();
          break;
        case 27:
        case 5:
          pushHostContext(workInProgress);
          break;
        case 4:
          pushHostContainer(
            workInProgress,
            workInProgress.stateNode.containerInfo
          );
          break;
        case 10:
          pushProvider(
            workInProgress,
            workInProgress.type,
            workInProgress.memoizedProps.value
          );
          break;
        case 12:
          0 !== (renderLanes & workInProgress.childLanes) &&
            (workInProgress.flags |= 4);
          workInProgress.flags |= 2048;
          var stateNode = workInProgress.stateNode;
          stateNode.effectDuration = -0;
          stateNode.passiveEffectDuration = -0;
          break;
        case 13:
          stateNode = workInProgress.memoizedState;
          if (null !== stateNode) {
            if (null !== stateNode.dehydrated)
              return (
                pushPrimaryTreeSuspenseHandler(workInProgress),
                (workInProgress.flags |= 128),
                null
              );
            if (0 !== (renderLanes & workInProgress.child.childLanes))
              return updateSuspenseComponent(
                current,
                workInProgress,
                renderLanes
              );
            pushPrimaryTreeSuspenseHandler(workInProgress);
            current = bailoutOnAlreadyFinishedWork(
              current,
              workInProgress,
              renderLanes
            );
            return null !== current ? current.sibling : null;
          }
          pushPrimaryTreeSuspenseHandler(workInProgress);
          break;
        case 19:
          var didSuspendBefore = 0 !== (current.flags & 128);
          stateNode = 0 !== (renderLanes & workInProgress.childLanes);
          stateNode ||
            (propagateParentContextChanges(
              current,
              workInProgress,
              renderLanes,
              !1
            ),
            (stateNode = 0 !== (renderLanes & workInProgress.childLanes)));
          if (didSuspendBefore) {
            if (stateNode)
              return updateSuspenseListComponent(
                current,
                workInProgress,
                renderLanes
              );
            workInProgress.flags |= 128;
          }
          didSuspendBefore = workInProgress.memoizedState;
          null !== didSuspendBefore &&
            ((didSuspendBefore.rendering = null),
            (didSuspendBefore.tail = null),
            (didSuspendBefore.lastEffect = null));
          push(
            suspenseStackCursor,
            suspenseStackCursor.current,
            workInProgress
          );
          if (stateNode) break;
          else return null;
        case 22:
        case 23:
          return (
            (workInProgress.lanes = 0),
            updateOffscreenComponent(current, workInProgress, renderLanes)
          );
        case 24:
          pushProvider(
            workInProgress,
            CacheContext,
            current.memoizedState.cache
          );
      }
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
    function beginWork(current, workInProgress, renderLanes) {
      if (workInProgress._debugNeedsRemount && null !== current) {
        renderLanes = createFiberFromTypeAndProps(
          workInProgress.type,
          workInProgress.key,
          workInProgress.pendingProps,
          workInProgress._debugOwner || null,
          workInProgress.mode,
          workInProgress.lanes
        );
        renderLanes._debugStack = workInProgress._debugStack;
        renderLanes._debugTask = workInProgress._debugTask;
        var returnFiber = workInProgress.return;
        if (null === returnFiber) throw Error("Cannot swap the root fiber.");
        current.alternate = null;
        workInProgress.alternate = null;
        renderLanes.index = workInProgress.index;
        renderLanes.sibling = workInProgress.sibling;
        renderLanes.return = workInProgress.return;
        renderLanes.ref = workInProgress.ref;
        renderLanes._debugInfo = workInProgress._debugInfo;
        if (workInProgress === returnFiber.child)
          returnFiber.child = renderLanes;
        else {
          var prevSibling = returnFiber.child;
          if (null === prevSibling)
            throw Error("Expected parent to have a child.");
          for (; prevSibling.sibling !== workInProgress; )
            if (((prevSibling = prevSibling.sibling), null === prevSibling))
              throw Error("Expected to find the previous sibling.");
          prevSibling.sibling = renderLanes;
        }
        workInProgress = returnFiber.deletions;
        null === workInProgress
          ? ((returnFiber.deletions = [current]), (returnFiber.flags |= 16))
          : workInProgress.push(current);
        renderLanes.flags |= 2;
        return renderLanes;
      }
      if (null !== current)
        if (
          current.memoizedProps !== workInProgress.pendingProps ||
          workInProgress.type !== current.type
        )
          didReceiveUpdate = !0;
        else {
          if (
            !checkScheduledUpdateOrContext(current, renderLanes) &&
            0 === (workInProgress.flags & 128)
          )
            return (
              (didReceiveUpdate = !1),
              attemptEarlyBailoutIfNoScheduledUpdate(
                current,
                workInProgress,
                renderLanes
              )
            );
          didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
        }
      else {
        didReceiveUpdate = !1;
        if ((returnFiber = isHydrating))
          warnIfNotHydrating(),
            (returnFiber = 0 !== (workInProgress.flags & 1048576));
        returnFiber &&
          ((returnFiber = workInProgress.index),
          warnIfNotHydrating(),
          pushTreeId(workInProgress, treeForkCount, returnFiber));
      }
      workInProgress.lanes = 0;
      switch (workInProgress.tag) {
        case 16:
          a: if (
            ((returnFiber = workInProgress.pendingProps),
            (current = callLazyInitInDEV(workInProgress.elementType)),
            (workInProgress.type = current),
            "function" === typeof current)
          )
            shouldConstruct(current)
              ? ((returnFiber = resolveClassComponentProps(
                  current,
                  returnFiber
                )),
                (workInProgress.tag = 1),
                (workInProgress.type = current =
                  resolveFunctionForHotReloading(current)),
                (workInProgress = updateClassComponent(
                  null,
                  workInProgress,
                  current,
                  returnFiber,
                  renderLanes
                )))
              : ((workInProgress.tag = 0),
                validateFunctionComponentInDev(workInProgress, current),
                (workInProgress.type = current =
                  resolveFunctionForHotReloading(current)),
                (workInProgress = updateFunctionComponent(
                  null,
                  workInProgress,
                  current,
                  returnFiber,
                  renderLanes
                )));
          else {
            if (void 0 !== current && null !== current)
              if (
                ((prevSibling = current.$$typeof),
                prevSibling === REACT_FORWARD_REF_TYPE)
              ) {
                workInProgress.tag = 11;
                workInProgress.type = current =
                  resolveForwardRefForHotReloading(current);
                workInProgress = updateForwardRef(
                  null,
                  workInProgress,
                  current,
                  returnFiber,
                  renderLanes
                );
                break a;
              } else if (prevSibling === REACT_MEMO_TYPE) {
                workInProgress.tag = 14;
                workInProgress = updateMemoComponent(
                  null,
                  workInProgress,
                  current,
                  returnFiber,
                  renderLanes
                );
                break a;
              }
            workInProgress = "";
            null !== current &&
              "object" === typeof current &&
              current.$$typeof === REACT_LAZY_TYPE &&
              (workInProgress =
                " Did you wrap a component in React.lazy() more than once?");
            current = getComponentNameFromType(current) || current;
            throw Error(
              "Element type is invalid. Received a promise that resolves to: " +
                current +
                ". Lazy element type must resolve to a class or function." +
                workInProgress
            );
          }
          return workInProgress;
        case 0:
          return updateFunctionComponent(
            current,
            workInProgress,
            workInProgress.type,
            workInProgress.pendingProps,
            renderLanes
          );
        case 1:
          return (
            (returnFiber = workInProgress.type),
            (prevSibling = resolveClassComponentProps(
              returnFiber,
              workInProgress.pendingProps
            )),
            updateClassComponent(
              current,
              workInProgress,
              returnFiber,
              prevSibling,
              renderLanes
            )
          );
        case 3:
          a: {
            pushHostContainer(
              workInProgress,
              workInProgress.stateNode.containerInfo
            );
            if (null === current)
              throw Error(
                "Should have a current fiber. This is a bug in React."
              );
            returnFiber = workInProgress.pendingProps;
            var prevState = workInProgress.memoizedState;
            prevSibling = prevState.element;
            cloneUpdateQueue(current, workInProgress);
            processUpdateQueue(workInProgress, returnFiber, null, renderLanes);
            var nextState = workInProgress.memoizedState;
            returnFiber = nextState.cache;
            pushProvider(workInProgress, CacheContext, returnFiber);
            returnFiber !== prevState.cache &&
              propagateContextChanges(
                workInProgress,
                [CacheContext],
                renderLanes,
                !0
              );
            suspendIfUpdateReadFromEntangledAsyncAction();
            returnFiber = nextState.element;
            if (prevState.isDehydrated)
              if (
                ((prevState = {
                  element: returnFiber,
                  isDehydrated: !1,
                  cache: nextState.cache
                }),
                (workInProgress.updateQueue.baseState = prevState),
                (workInProgress.memoizedState = prevState),
                workInProgress.flags & 256)
              ) {
                workInProgress = mountHostRootWithoutHydrating(
                  current,
                  workInProgress,
                  returnFiber,
                  renderLanes
                );
                break a;
              } else if (returnFiber !== prevSibling) {
                prevSibling = createCapturedValueAtFiber(
                  Error(
                    "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
                  ),
                  workInProgress
                );
                queueHydrationError(prevSibling);
                workInProgress = mountHostRootWithoutHydrating(
                  current,
                  workInProgress,
                  returnFiber,
                  renderLanes
                );
                break a;
              } else {
                current = workInProgress.stateNode.containerInfo;
                switch (current.nodeType) {
                  case 9:
                    current = current.body;
                    break;
                  default:
                    current =
                      "HTML" === current.nodeName
                        ? current.ownerDocument.body
                        : current;
                }
                nextHydratableInstance = getNextHydratable(current.firstChild);
                hydrationParentFiber = workInProgress;
                isHydrating = !0;
                hydrationErrors = null;
                didSuspendOrErrorDEV = !1;
                hydrationDiffRootDEV = null;
                rootOrSingletonContext = !0;
                current = mountChildFibers(
                  workInProgress,
                  null,
                  returnFiber,
                  renderLanes
                );
                for (workInProgress.child = current; current; )
                  (current.flags = (current.flags & -3) | 4096),
                    (current = current.sibling);
              }
            else {
              resetHydrationState();
              if (returnFiber === prevSibling) {
                workInProgress = bailoutOnAlreadyFinishedWork(
                  current,
                  workInProgress,
                  renderLanes
                );
                break a;
              }
              reconcileChildren(
                current,
                workInProgress,
                returnFiber,
                renderLanes
              );
            }
            workInProgress = workInProgress.child;
          }
          return workInProgress;
        case 26:
          return (
            markRef(current, workInProgress),
            null === current
              ? (current = getResource(
                  workInProgress.type,
                  null,
                  workInProgress.pendingProps,
                  null
                ))
                ? (workInProgress.memoizedState = current)
                : isHydrating ||
                  ((current = workInProgress.type),
                  (renderLanes = workInProgress.pendingProps),
                  (returnFiber = requiredContext(
                    rootInstanceStackCursor.current
                  )),
                  (returnFiber =
                    getOwnerDocumentFromRootContainer(
                      returnFiber
                    ).createElement(current)),
                  (returnFiber[internalInstanceKey] = workInProgress),
                  (returnFiber[internalPropsKey] = renderLanes),
                  setInitialProperties(returnFiber, current, renderLanes),
                  markNodeAsHoistable(returnFiber),
                  (workInProgress.stateNode = returnFiber))
              : (workInProgress.memoizedState = getResource(
                  workInProgress.type,
                  current.memoizedProps,
                  workInProgress.pendingProps,
                  current.memoizedState
                )),
            null
          );
        case 27:
          return (
            pushHostContext(workInProgress),
            null === current &&
              isHydrating &&
              ((returnFiber = requiredContext(rootInstanceStackCursor.current)),
              (prevSibling = getHostContext()),
              (returnFiber = workInProgress.stateNode =
                resolveSingletonInstance(
                  workInProgress.type,
                  workInProgress.pendingProps,
                  returnFiber,
                  prevSibling,
                  !1
                )),
              didSuspendOrErrorDEV ||
                ((prevSibling = diffHydratedProperties(
                  returnFiber,
                  workInProgress.type,
                  workInProgress.pendingProps,
                  prevSibling
                )),
                null !== prevSibling &&
                  (buildHydrationDiffNode(workInProgress, 0).serverProps =
                    prevSibling)),
              (hydrationParentFiber = workInProgress),
              (rootOrSingletonContext = !0),
              (prevSibling = nextHydratableInstance),
              isSingletonScope(workInProgress.type)
                ? ((previousHydratableOnEnteringScopedSingleton = prevSibling),
                  (nextHydratableInstance = getNextHydratable(
                    returnFiber.firstChild
                  )))
                : (nextHydratableInstance = prevSibling)),
            reconcileChildren(
              current,
              workInProgress,
              workInProgress.pendingProps.children,
              renderLanes
            ),
            markRef(current, workInProgress),
            null === current && (workInProgress.flags |= 4194304),
            workInProgress.child
          );
        case 5:
          return (
            null === current &&
              isHydrating &&
              ((prevState = getHostContext()),
              (returnFiber = validateDOMNesting(
                workInProgress.type,
                prevState.ancestorInfo
              )),
              (prevSibling = nextHydratableInstance),
              (nextState = !prevSibling) ||
                ((nextState = canHydrateInstance(
                  prevSibling,
                  workInProgress.type,
                  workInProgress.pendingProps,
                  rootOrSingletonContext
                )),
                null !== nextState
                  ? ((workInProgress.stateNode = nextState),
                    didSuspendOrErrorDEV ||
                      ((prevState = diffHydratedProperties(
                        nextState,
                        workInProgress.type,
                        workInProgress.pendingProps,
                        prevState
                      )),
                      null !== prevState &&
                        (buildHydrationDiffNode(workInProgress, 0).serverProps =
                          prevState)),
                    (hydrationParentFiber = workInProgress),
                    (nextHydratableInstance = getNextHydratable(
                      nextState.firstChild
                    )),
                    (rootOrSingletonContext = !1),
                    (prevState = !0))
                  : (prevState = !1),
                (nextState = !prevState)),
              nextState &&
                (returnFiber &&
                  warnNonHydratedInstance(workInProgress, prevSibling),
                throwOnHydrationMismatch(workInProgress))),
            pushHostContext(workInProgress),
            (prevSibling = workInProgress.type),
            (prevState = workInProgress.pendingProps),
            (nextState = null !== current ? current.memoizedProps : null),
            (returnFiber = prevState.children),
            shouldSetTextContent(prevSibling, prevState)
              ? (returnFiber = null)
              : null !== nextState &&
                shouldSetTextContent(prevSibling, nextState) &&
                (workInProgress.flags |= 32),
            null !== workInProgress.memoizedState &&
              ((prevSibling = renderWithHooks(
                current,
                workInProgress,
                TransitionAwareHostComponent,
                null,
                null,
                renderLanes
              )),
              (HostTransitionContext._currentValue = prevSibling)),
            markRef(current, workInProgress),
            reconcileChildren(
              current,
              workInProgress,
              returnFiber,
              renderLanes
            ),
            workInProgress.child
          );
        case 6:
          return (
            null === current &&
              isHydrating &&
              ((current = workInProgress.pendingProps),
              (renderLanes = getHostContext()),
              (returnFiber = renderLanes.ancestorInfo.current),
              (current =
                null != returnFiber
                  ? validateTextNesting(
                      current,
                      returnFiber.tag,
                      renderLanes.ancestorInfo.implicitRootScope
                    )
                  : !0),
              (renderLanes = nextHydratableInstance),
              (returnFiber = !renderLanes) ||
                ((returnFiber = canHydrateTextInstance(
                  renderLanes,
                  workInProgress.pendingProps,
                  rootOrSingletonContext
                )),
                null !== returnFiber
                  ? ((workInProgress.stateNode = returnFiber),
                    (hydrationParentFiber = workInProgress),
                    (nextHydratableInstance = null),
                    (returnFiber = !0))
                  : (returnFiber = !1),
                (returnFiber = !returnFiber)),
              returnFiber &&
                (current &&
                  warnNonHydratedInstance(workInProgress, renderLanes),
                throwOnHydrationMismatch(workInProgress))),
            null
          );
        case 13:
          return updateSuspenseComponent(current, workInProgress, renderLanes);
        case 4:
          return (
            pushHostContainer(
              workInProgress,
              workInProgress.stateNode.containerInfo
            ),
            (returnFiber = workInProgress.pendingProps),
            null === current
              ? (workInProgress.child = reconcileChildFibers(
                  workInProgress,
                  null,
                  returnFiber,
                  renderLanes
                ))
              : reconcileChildren(
                  current,
                  workInProgress,
                  returnFiber,
                  renderLanes
                ),
            workInProgress.child
          );
        case 11:
          return updateForwardRef(
            current,
            workInProgress,
            workInProgress.type,
            workInProgress.pendingProps,
            renderLanes
          );
        case 7:
          return (
            reconcileChildren(
              current,
              workInProgress,
              workInProgress.pendingProps,
              renderLanes
            ),
            workInProgress.child
          );
        case 8:
          return (
            reconcileChildren(
              current,
              workInProgress,
              workInProgress.pendingProps.children,
              renderLanes
            ),
            workInProgress.child
          );
        case 12:
          return (
            (workInProgress.flags |= 4),
            (workInProgress.flags |= 2048),
            (returnFiber = workInProgress.stateNode),
            (returnFiber.effectDuration = -0),
            (returnFiber.passiveEffectDuration = -0),
            reconcileChildren(
              current,
              workInProgress,
              workInProgress.pendingProps.children,
              renderLanes
            ),
            workInProgress.child
          );
        case 10:
          return (
            (returnFiber = workInProgress.type),
            (prevSibling = workInProgress.pendingProps),
            (prevState = prevSibling.value),
            "value" in prevSibling ||
              hasWarnedAboutUsingNoValuePropOnContextProvider ||
              ((hasWarnedAboutUsingNoValuePropOnContextProvider = !0),
              console.error(
                "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
              )),
            pushProvider(workInProgress, returnFiber, prevState),
            reconcileChildren(
              current,
              workInProgress,
              prevSibling.children,
              renderLanes
            ),
            workInProgress.child
          );
        case 9:
          return (
            (prevSibling = workInProgress.type._context),
            (returnFiber = workInProgress.pendingProps.children),
            "function" !== typeof returnFiber &&
              console.error(
                "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
              ),
            prepareToReadContext(workInProgress),
            (prevSibling = readContext(prevSibling)),
            markComponentRenderStarted(workInProgress),
            (returnFiber = callComponentInDEV(
              returnFiber,
              prevSibling,
              void 0
            )),
            markComponentRenderStopped(),
            (workInProgress.flags |= 1),
            reconcileChildren(
              current,
              workInProgress,
              returnFiber,
              renderLanes
            ),
            workInProgress.child
          );
        case 14:
          return updateMemoComponent(
            current,
            workInProgress,
            workInProgress.type,
            workInProgress.pendingProps,
            renderLanes
          );
        case 15:
          return updateSimpleMemoComponent(
            current,
            workInProgress,
            workInProgress.type,
            workInProgress.pendingProps,
            renderLanes
          );
        case 19:
          return updateSuspenseListComponent(
            current,
            workInProgress,
            renderLanes
          );
        case 31:
          return (
            (returnFiber = workInProgress.pendingProps),
            (renderLanes = workInProgress.mode),
            (returnFiber = {
              mode: returnFiber.mode,
              children: returnFiber.children
            }),
            null === current
              ? ((current = mountWorkInProgressOffscreenFiber(
                  returnFiber,
                  renderLanes
                )),
                (current.ref = workInProgress.ref),
                (workInProgress.child = current),
                (current.return = workInProgress),
                (workInProgress = current))
              : ((current = createWorkInProgress(current.child, returnFiber)),
                (current.ref = workInProgress.ref),
                (workInProgress.child = current),
                (current.return = workInProgress),
                (workInProgress = current)),
            workInProgress
          );
        case 22:
          return updateOffscreenComponent(current, workInProgress, renderLanes);
        case 24:
          return (
            prepareToReadContext(workInProgress),
            (returnFiber = readContext(CacheContext)),
            null === current
              ? ((prevSibling = peekCacheFromPool()),
                null === prevSibling &&
                  ((prevSibling = workInProgressRoot),
                  (prevState = createCache()),
                  (prevSibling.pooledCache = prevState),
                  retainCache(prevState),
                  null !== prevState &&
                    (prevSibling.pooledCacheLanes |= renderLanes),
                  (prevSibling = prevState)),
                (workInProgress.memoizedState = {
                  parent: returnFiber,
                  cache: prevSibling
                }),
                initializeUpdateQueue(workInProgress),
                pushProvider(workInProgress, CacheContext, prevSibling))
              : (0 !== (current.lanes & renderLanes) &&
                  (cloneUpdateQueue(current, workInProgress),
                  processUpdateQueue(workInProgress, null, null, renderLanes),
                  suspendIfUpdateReadFromEntangledAsyncAction()),
                (prevSibling = current.memoizedState),
                (prevState = workInProgress.memoizedState),
                prevSibling.parent !== returnFiber
                  ? ((prevSibling = {
                      parent: returnFiber,
                      cache: returnFiber
                    }),
                    (workInProgress.memoizedState = prevSibling),
                    0 === workInProgress.lanes &&
                      (workInProgress.memoizedState =
                        workInProgress.updateQueue.baseState =
                          prevSibling),
                    pushProvider(workInProgress, CacheContext, returnFiber))
                  : ((returnFiber = prevState.cache),
                    pushProvider(workInProgress, CacheContext, returnFiber),
                    returnFiber !== prevSibling.cache &&
                      propagateContextChanges(
                        workInProgress,
                        [CacheContext],
                        renderLanes,
                        !0
                      ))),
            reconcileChildren(
              current,
              workInProgress,
              workInProgress.pendingProps.children,
              renderLanes
            ),
            workInProgress.child
          );
        case 29:
          throw workInProgress.pendingProps;
      }
      throw Error(
        "Unknown unit of work tag (" +
          workInProgress.tag +
          "). This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function markUpdate(workInProgress) {
      workInProgress.flags |= 4;
    }
    function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
      if (
        "stylesheet" !== resource.type ||
        (resource.state.loading & Inserted) !== NotLoaded
      )
        workInProgress.flags &= -16777217;
      else if (
        ((workInProgress.flags |= 16777216), !preloadResource(resource))
      ) {
        resource = suspenseHandlerStackCursor.current;
        if (
          null !== resource &&
          ((workInProgressRootRenderLanes & 4194048) ===
          workInProgressRootRenderLanes
            ? null !== shellBoundary
            : ((workInProgressRootRenderLanes & 62914560) !==
                workInProgressRootRenderLanes &&
                0 === (workInProgressRootRenderLanes & 536870912)) ||
              resource !== shellBoundary)
        )
          throw (
            ((suspendedThenable = noopSuspenseyCommitThenable),
            SuspenseyCommitException)
          );
        workInProgress.flags |= 8192;
      }
    }
    function scheduleRetryEffect(workInProgress, retryQueue) {
      null !== retryQueue && (workInProgress.flags |= 4);
      workInProgress.flags & 16384 &&
        ((retryQueue =
          22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
        (workInProgress.lanes |= retryQueue),
        (workInProgressSuspendedRetryLanes |= retryQueue));
    }
    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
      if (!isHydrating)
        switch (renderState.tailMode) {
          case "hidden":
            hasRenderedATailFallback = renderState.tail;
            for (var lastTailNode = null; null !== hasRenderedATailFallback; )
              null !== hasRenderedATailFallback.alternate &&
                (lastTailNode = hasRenderedATailFallback),
                (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
            null === lastTailNode
              ? (renderState.tail = null)
              : (lastTailNode.sibling = null);
            break;
          case "collapsed":
            lastTailNode = renderState.tail;
            for (var _lastTailNode = null; null !== lastTailNode; )
              null !== lastTailNode.alternate && (_lastTailNode = lastTailNode),
                (lastTailNode = lastTailNode.sibling);
            null === _lastTailNode
              ? hasRenderedATailFallback || null === renderState.tail
                ? (renderState.tail = null)
                : (renderState.tail.sibling = null)
              : (_lastTailNode.sibling = null);
        }
    }
    function bubbleProperties(completedWork) {
      var didBailout =
          null !== completedWork.alternate &&
          completedWork.alternate.child === completedWork.child,
        newChildLanes = 0,
        subtreeFlags = 0;
      if (didBailout)
        if ((completedWork.mode & ProfileMode) !== NoMode) {
          for (
            var _treeBaseDuration = completedWork.selfBaseDuration,
              _child2 = completedWork.child;
            null !== _child2;

          )
            (newChildLanes |= _child2.lanes | _child2.childLanes),
              (subtreeFlags |= _child2.subtreeFlags & 65011712),
              (subtreeFlags |= _child2.flags & 65011712),
              (_treeBaseDuration += _child2.treeBaseDuration),
              (_child2 = _child2.sibling);
          completedWork.treeBaseDuration = _treeBaseDuration;
        } else
          for (
            _treeBaseDuration = completedWork.child;
            null !== _treeBaseDuration;

          )
            (newChildLanes |=
              _treeBaseDuration.lanes | _treeBaseDuration.childLanes),
              (subtreeFlags |= _treeBaseDuration.subtreeFlags & 65011712),
              (subtreeFlags |= _treeBaseDuration.flags & 65011712),
              (_treeBaseDuration.return = completedWork),
              (_treeBaseDuration = _treeBaseDuration.sibling);
      else if ((completedWork.mode & ProfileMode) !== NoMode) {
        _treeBaseDuration = completedWork.actualDuration;
        _child2 = completedWork.selfBaseDuration;
        for (var child = completedWork.child; null !== child; )
          (newChildLanes |= child.lanes | child.childLanes),
            (subtreeFlags |= child.subtreeFlags),
            (subtreeFlags |= child.flags),
            (_treeBaseDuration += child.actualDuration),
            (_child2 += child.treeBaseDuration),
            (child = child.sibling);
        completedWork.actualDuration = _treeBaseDuration;
        completedWork.treeBaseDuration = _child2;
      } else
        for (
          _treeBaseDuration = completedWork.child;
          null !== _treeBaseDuration;

        )
          (newChildLanes |=
            _treeBaseDuration.lanes | _treeBaseDuration.childLanes),
            (subtreeFlags |= _treeBaseDuration.subtreeFlags),
            (subtreeFlags |= _treeBaseDuration.flags),
            (_treeBaseDuration.return = completedWork),
            (_treeBaseDuration = _treeBaseDuration.sibling);
      completedWork.subtreeFlags |= subtreeFlags;
      completedWork.childLanes = newChildLanes;
      return didBailout;
    }
    function completeWork(current, workInProgress, renderLanes) {
      var newProps = workInProgress.pendingProps;
      popTreeContext(workInProgress);
      switch (workInProgress.tag) {
        case 31:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return bubbleProperties(workInProgress), null;
        case 1:
          return bubbleProperties(workInProgress), null;
        case 3:
          renderLanes = workInProgress.stateNode;
          newProps = null;
          null !== current && (newProps = current.memoizedState.cache);
          workInProgress.memoizedState.cache !== newProps &&
            (workInProgress.flags |= 2048);
          popProvider(CacheContext, workInProgress);
          popHostContainer(workInProgress);
          renderLanes.pendingContext &&
            ((renderLanes.context = renderLanes.pendingContext),
            (renderLanes.pendingContext = null));
          if (null === current || null === current.child)
            popHydrationState(workInProgress)
              ? (emitPendingHydrationWarnings(), markUpdate(workInProgress))
              : null === current ||
                (current.memoizedState.isDehydrated &&
                  0 === (workInProgress.flags & 256)) ||
                ((workInProgress.flags |= 1024),
                upgradeHydrationErrorsToRecoverable());
          bubbleProperties(workInProgress);
          return null;
        case 26:
          return (
            (renderLanes = workInProgress.memoizedState),
            null === current
              ? (markUpdate(workInProgress),
                null !== renderLanes
                  ? (bubbleProperties(workInProgress),
                    preloadResourceAndSuspendIfNeeded(
                      workInProgress,
                      renderLanes
                    ))
                  : (bubbleProperties(workInProgress),
                    (workInProgress.flags &= -16777217)))
              : renderLanes
                ? renderLanes !== current.memoizedState
                  ? (markUpdate(workInProgress),
                    bubbleProperties(workInProgress),
                    preloadResourceAndSuspendIfNeeded(
                      workInProgress,
                      renderLanes
                    ))
                  : (bubbleProperties(workInProgress),
                    (workInProgress.flags &= -16777217))
                : (current.memoizedProps !== newProps &&
                    markUpdate(workInProgress),
                  bubbleProperties(workInProgress),
                  (workInProgress.flags &= -16777217)),
            null
          );
        case 27:
          popHostContext(workInProgress);
          renderLanes = requiredContext(rootInstanceStackCursor.current);
          var _type = workInProgress.type;
          if (null !== current && null != workInProgress.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress);
          else {
            if (!newProps) {
              if (null === workInProgress.stateNode)
                throw Error(
                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                );
              bubbleProperties(workInProgress);
              return null;
            }
            current = getHostContext();
            popHydrationState(workInProgress)
              ? prepareToHydrateHostInstance(workInProgress, current)
              : ((current = resolveSingletonInstance(
                  _type,
                  newProps,
                  renderLanes,
                  current,
                  !0
                )),
                (workInProgress.stateNode = current),
                markUpdate(workInProgress));
          }
          bubbleProperties(workInProgress);
          return null;
        case 5:
          popHostContext(workInProgress);
          renderLanes = workInProgress.type;
          if (null !== current && null != workInProgress.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress);
          else {
            if (!newProps) {
              if (null === workInProgress.stateNode)
                throw Error(
                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                );
              bubbleProperties(workInProgress);
              return null;
            }
            _type = getHostContext();
            if (popHydrationState(workInProgress))
              prepareToHydrateHostInstance(workInProgress, _type);
            else {
              current = requiredContext(rootInstanceStackCursor.current);
              validateDOMNesting(renderLanes, _type.ancestorInfo);
              _type = _type.context;
              current = getOwnerDocumentFromRootContainer(current);
              switch (_type) {
                case HostContextNamespaceSvg:
                  current = current.createElementNS(SVG_NAMESPACE, renderLanes);
                  break;
                case HostContextNamespaceMath:
                  current = current.createElementNS(
                    MATH_NAMESPACE,
                    renderLanes
                  );
                  break;
                default:
                  switch (renderLanes) {
                    case "svg":
                      current = current.createElementNS(
                        SVG_NAMESPACE,
                        renderLanes
                      );
                      break;
                    case "math":
                      current = current.createElementNS(
                        MATH_NAMESPACE,
                        renderLanes
                      );
                      break;
                    case "script":
                      current = current.createElement("div");
                      current.innerHTML = "<script>\x3c/script>";
                      current = current.removeChild(current.firstChild);
                      break;
                    case "select":
                      current =
                        "string" === typeof newProps.is
                          ? current.createElement("select", { is: newProps.is })
                          : current.createElement("select");
                      newProps.multiple
                        ? (current.multiple = !0)
                        : newProps.size && (current.size = newProps.size);
                      break;
                    default:
                      (current =
                        "string" === typeof newProps.is
                          ? current.createElement(renderLanes, {
                              is: newProps.is
                            })
                          : current.createElement(renderLanes)),
                        -1 === renderLanes.indexOf("-") &&
                          (renderLanes !== renderLanes.toLowerCase() &&
                            console.error(
                              "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
                              renderLanes
                            ),
                          "[object HTMLUnknownElement]" !==
                            Object.prototype.toString.call(current) ||
                            hasOwnProperty.call(
                              warnedUnknownTags,
                              renderLanes
                            ) ||
                            ((warnedUnknownTags[renderLanes] = !0),
                            console.error(
                              "The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",
                              renderLanes
                            )));
                  }
              }
              current[internalInstanceKey] = workInProgress;
              current[internalPropsKey] = newProps;
              a: for (_type = workInProgress.child; null !== _type; ) {
                if (5 === _type.tag || 6 === _type.tag)
                  current.appendChild(_type.stateNode);
                else if (
                  4 !== _type.tag &&
                  27 !== _type.tag &&
                  null !== _type.child
                ) {
                  _type.child.return = _type;
                  _type = _type.child;
                  continue;
                }
                if (_type === workInProgress) break a;
                for (; null === _type.sibling; ) {
                  if (null === _type.return || _type.return === workInProgress)
                    break a;
                  _type = _type.return;
                }
                _type.sibling.return = _type.return;
                _type = _type.sibling;
              }
              workInProgress.stateNode = current;
              a: switch (
                (setInitialProperties(current, renderLanes, newProps),
                renderLanes)
              ) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  current = !!newProps.autoFocus;
                  break a;
                case "img":
                  current = !0;
                  break a;
                default:
                  current = !1;
              }
              current && markUpdate(workInProgress);
            }
          }
          bubbleProperties(workInProgress);
          workInProgress.flags &= -16777217;
          return null;
        case 6:
          if (current && null != workInProgress.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress);
          else {
            if (
              "string" !== typeof newProps &&
              null === workInProgress.stateNode
            )
              throw Error(
                "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
              );
            current = requiredContext(rootInstanceStackCursor.current);
            renderLanes = getHostContext();
            if (popHydrationState(workInProgress)) {
              current = workInProgress.stateNode;
              renderLanes = workInProgress.memoizedProps;
              _type = !didSuspendOrErrorDEV;
              newProps = null;
              var returnFiber = hydrationParentFiber;
              if (null !== returnFiber)
                switch (returnFiber.tag) {
                  case 3:
                    _type &&
                      ((_type = diffHydratedTextForDevWarnings(
                        current,
                        renderLanes,
                        newProps
                      )),
                      null !== _type &&
                        (buildHydrationDiffNode(workInProgress, 0).serverProps =
                          _type));
                    break;
                  case 27:
                  case 5:
                    (newProps = returnFiber.memoizedProps),
                      _type &&
                        ((_type = diffHydratedTextForDevWarnings(
                          current,
                          renderLanes,
                          newProps
                        )),
                        null !== _type &&
                          (buildHydrationDiffNode(
                            workInProgress,
                            0
                          ).serverProps = _type));
                }
              current[internalInstanceKey] = workInProgress;
              current =
                current.nodeValue === renderLanes ||
                (null !== newProps &&
                  !0 === newProps.suppressHydrationWarning) ||
                checkForUnmatchedText(current.nodeValue, renderLanes)
                  ? !0
                  : !1;
              current || throwOnHydrationMismatch(workInProgress);
            } else
              (_type = renderLanes.ancestorInfo.current),
                null != _type &&
                  validateTextNesting(
                    newProps,
                    _type.tag,
                    renderLanes.ancestorInfo.implicitRootScope
                  ),
                (current =
                  getOwnerDocumentFromRootContainer(current).createTextNode(
                    newProps
                  )),
                (current[internalInstanceKey] = workInProgress),
                (workInProgress.stateNode = current);
          }
          bubbleProperties(workInProgress);
          return null;
        case 13:
          newProps = workInProgress.memoizedState;
          if (
            null === current ||
            (null !== current.memoizedState &&
              null !== current.memoizedState.dehydrated)
          ) {
            _type = popHydrationState(workInProgress);
            if (null !== newProps && null !== newProps.dehydrated) {
              if (null === current) {
                if (!_type)
                  throw Error(
                    "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                  );
                _type = workInProgress.memoizedState;
                _type = null !== _type ? _type.dehydrated : null;
                if (!_type)
                  throw Error(
                    "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                  );
                _type[internalInstanceKey] = workInProgress;
                bubbleProperties(workInProgress);
                (workInProgress.mode & ProfileMode) !== NoMode &&
                  null !== newProps &&
                  ((_type = workInProgress.child),
                  null !== _type &&
                    (workInProgress.treeBaseDuration -=
                      _type.treeBaseDuration));
              } else
                emitPendingHydrationWarnings(),
                  resetHydrationState(),
                  0 === (workInProgress.flags & 128) &&
                    (workInProgress.memoizedState = null),
                  (workInProgress.flags |= 4),
                  bubbleProperties(workInProgress),
                  (workInProgress.mode & ProfileMode) !== NoMode &&
                    null !== newProps &&
                    ((_type = workInProgress.child),
                    null !== _type &&
                      (workInProgress.treeBaseDuration -=
                        _type.treeBaseDuration));
              _type = !1;
            } else
              (_type = upgradeHydrationErrorsToRecoverable()),
                null !== current &&
                  null !== current.memoizedState &&
                  (current.memoizedState.hydrationErrors = _type),
                (_type = !0);
            if (!_type) {
              if (workInProgress.flags & 256)
                return popSuspenseHandler(workInProgress), workInProgress;
              popSuspenseHandler(workInProgress);
              return null;
            }
          }
          popSuspenseHandler(workInProgress);
          if (0 !== (workInProgress.flags & 128))
            return (
              (workInProgress.lanes = renderLanes),
              (workInProgress.mode & ProfileMode) !== NoMode &&
                transferActualDuration(workInProgress),
              workInProgress
            );
          renderLanes = null !== newProps;
          current = null !== current && null !== current.memoizedState;
          renderLanes &&
            ((newProps = workInProgress.child),
            (_type = null),
            null !== newProps.alternate &&
              null !== newProps.alternate.memoizedState &&
              null !== newProps.alternate.memoizedState.cachePool &&
              (_type = newProps.alternate.memoizedState.cachePool.pool),
            (returnFiber = null),
            null !== newProps.memoizedState &&
              null !== newProps.memoizedState.cachePool &&
              (returnFiber = newProps.memoizedState.cachePool.pool),
            returnFiber !== _type && (newProps.flags |= 2048));
          renderLanes !== current &&
            renderLanes &&
            (workInProgress.child.flags |= 8192);
          scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
          bubbleProperties(workInProgress);
          (workInProgress.mode & ProfileMode) !== NoMode &&
            renderLanes &&
            ((current = workInProgress.child),
            null !== current &&
              (workInProgress.treeBaseDuration -= current.treeBaseDuration));
          return null;
        case 4:
          return (
            popHostContainer(workInProgress),
            null === current &&
              listenToAllSupportedEvents(
                workInProgress.stateNode.containerInfo
              ),
            bubbleProperties(workInProgress),
            null
          );
        case 10:
          return (
            popProvider(workInProgress.type, workInProgress),
            bubbleProperties(workInProgress),
            null
          );
        case 19:
          pop(suspenseStackCursor, workInProgress);
          _type = workInProgress.memoizedState;
          if (null === _type) return bubbleProperties(workInProgress), null;
          newProps = 0 !== (workInProgress.flags & 128);
          returnFiber = _type.rendering;
          if (null === returnFiber)
            if (newProps) cutOffTailIfNeeded(_type, !1);
            else {
              if (
                workInProgressRootExitStatus !== RootInProgress ||
                (null !== current && 0 !== (current.flags & 128))
              )
                for (current = workInProgress.child; null !== current; ) {
                  returnFiber = findFirstSuspended(current);
                  if (null !== returnFiber) {
                    workInProgress.flags |= 128;
                    cutOffTailIfNeeded(_type, !1);
                    current = returnFiber.updateQueue;
                    workInProgress.updateQueue = current;
                    scheduleRetryEffect(workInProgress, current);
                    workInProgress.subtreeFlags = 0;
                    current = renderLanes;
                    for (
                      renderLanes = workInProgress.child;
                      null !== renderLanes;

                    )
                      resetWorkInProgress(renderLanes, current),
                        (renderLanes = renderLanes.sibling);
                    push(
                      suspenseStackCursor,
                      (suspenseStackCursor.current &
                        SubtreeSuspenseContextMask) |
                        ForceSuspenseFallback,
                      workInProgress
                    );
                    return workInProgress.child;
                  }
                  current = current.sibling;
                }
              null !== _type.tail &&
                now$1() > workInProgressRootRenderTargetTime &&
                ((workInProgress.flags |= 128),
                (newProps = !0),
                cutOffTailIfNeeded(_type, !1),
                (workInProgress.lanes = 4194304));
            }
          else {
            if (!newProps)
              if (
                ((current = findFirstSuspended(returnFiber)), null !== current)
              ) {
                if (
                  ((workInProgress.flags |= 128),
                  (newProps = !0),
                  (current = current.updateQueue),
                  (workInProgress.updateQueue = current),
                  scheduleRetryEffect(workInProgress, current),
                  cutOffTailIfNeeded(_type, !0),
                  null === _type.tail &&
                    "hidden" === _type.tailMode &&
                    !returnFiber.alternate &&
                    !isHydrating)
                )
                  return bubbleProperties(workInProgress), null;
              } else
                2 * now$1() - _type.renderingStartTime >
                  workInProgressRootRenderTargetTime &&
                  536870912 !== renderLanes &&
                  ((workInProgress.flags |= 128),
                  (newProps = !0),
                  cutOffTailIfNeeded(_type, !1),
                  (workInProgress.lanes = 4194304));
            _type.isBackwards
              ? ((returnFiber.sibling = workInProgress.child),
                (workInProgress.child = returnFiber))
              : ((current = _type.last),
                null !== current
                  ? (current.sibling = returnFiber)
                  : (workInProgress.child = returnFiber),
                (_type.last = returnFiber));
          }
          if (null !== _type.tail)
            return (
              (current = _type.tail),
              (_type.rendering = current),
              (_type.tail = current.sibling),
              (_type.renderingStartTime = now$1()),
              (current.sibling = null),
              (renderLanes = suspenseStackCursor.current),
              (renderLanes = newProps
                ? (renderLanes & SubtreeSuspenseContextMask) |
                  ForceSuspenseFallback
                : renderLanes & SubtreeSuspenseContextMask),
              push(suspenseStackCursor, renderLanes, workInProgress),
              current
            );
          bubbleProperties(workInProgress);
          return null;
        case 22:
        case 23:
          return (
            popSuspenseHandler(workInProgress),
            popHiddenContext(workInProgress),
            (newProps = null !== workInProgress.memoizedState),
            null !== current
              ? (null !== current.memoizedState) !== newProps &&
                (workInProgress.flags |= 8192)
              : newProps && (workInProgress.flags |= 8192),
            newProps
              ? 0 !== (renderLanes & 536870912) &&
                0 === (workInProgress.flags & 128) &&
                (bubbleProperties(workInProgress),
                workInProgress.subtreeFlags & 6 &&
                  (workInProgress.flags |= 8192))
              : bubbleProperties(workInProgress),
            (renderLanes = workInProgress.updateQueue),
            null !== renderLanes &&
              scheduleRetryEffect(workInProgress, renderLanes.retryQueue),
            (renderLanes = null),
            null !== current &&
              null !== current.memoizedState &&
              null !== current.memoizedState.cachePool &&
              (renderLanes = current.memoizedState.cachePool.pool),
            (newProps = null),
            null !== workInProgress.memoizedState &&
              null !== workInProgress.memoizedState.cachePool &&
              (newProps = workInProgress.memoizedState.cachePool.pool),
            newProps !== renderLanes && (workInProgress.flags |= 2048),
            null !== current && pop(resumedCache, workInProgress),
            null
          );
        case 24:
          return (
            (renderLanes = null),
            null !== current && (renderLanes = current.memoizedState.cache),
            workInProgress.memoizedState.cache !== renderLanes &&
              (workInProgress.flags |= 2048),
            popProvider(CacheContext, workInProgress),
            bubbleProperties(workInProgress),
            null
          );
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error(
        "Unknown unit of work tag (" +
          workInProgress.tag +
          "). This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function unwindWork(current, workInProgress) {
      popTreeContext(workInProgress);
      switch (workInProgress.tag) {
        case 1:
          return (
            (current = workInProgress.flags),
            current & 65536
              ? ((workInProgress.flags = (current & -65537) | 128),
                (workInProgress.mode & ProfileMode) !== NoMode &&
                  transferActualDuration(workInProgress),
                workInProgress)
              : null
          );
        case 3:
          return (
            popProvider(CacheContext, workInProgress),
            popHostContainer(workInProgress),
            (current = workInProgress.flags),
            0 !== (current & 65536) && 0 === (current & 128)
              ? ((workInProgress.flags = (current & -65537) | 128),
                workInProgress)
              : null
          );
        case 26:
        case 27:
        case 5:
          return popHostContext(workInProgress), null;
        case 13:
          popSuspenseHandler(workInProgress);
          current = workInProgress.memoizedState;
          if (null !== current && null !== current.dehydrated) {
            if (null === workInProgress.alternate)
              throw Error(
                "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
              );
            resetHydrationState();
          }
          current = workInProgress.flags;
          return current & 65536
            ? ((workInProgress.flags = (current & -65537) | 128),
              (workInProgress.mode & ProfileMode) !== NoMode &&
                transferActualDuration(workInProgress),
              workInProgress)
            : null;
        case 19:
          return pop(suspenseStackCursor, workInProgress), null;
        case 4:
          return popHostContainer(workInProgress), null;
        case 10:
          return popProvider(workInProgress.type, workInProgress), null;
        case 22:
        case 23:
          return (
            popSuspenseHandler(workInProgress),
            popHiddenContext(workInProgress),
            null !== current && pop(resumedCache, workInProgress),
            (current = workInProgress.flags),
            current & 65536
              ? ((workInProgress.flags = (current & -65537) | 128),
                (workInProgress.mode & ProfileMode) !== NoMode &&
                  transferActualDuration(workInProgress),
                workInProgress)
              : null
          );
        case 24:
          return popProvider(CacheContext, workInProgress), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function unwindInterruptedWork(current, interruptedWork) {
      popTreeContext(interruptedWork);
      switch (interruptedWork.tag) {
        case 3:
          popProvider(CacheContext, interruptedWork);
          popHostContainer(interruptedWork);
          break;
        case 26:
        case 27:
        case 5:
          popHostContext(interruptedWork);
          break;
        case 4:
          popHostContainer(interruptedWork);
          break;
        case 13:
          popSuspenseHandler(interruptedWork);
          break;
        case 19:
          pop(suspenseStackCursor, interruptedWork);
          break;
        case 10:
          popProvider(interruptedWork.type, interruptedWork);
          break;
        case 22:
        case 23:
          popSuspenseHandler(interruptedWork);
          popHiddenContext(interruptedWork);
          null !== current && pop(resumedCache, interruptedWork);
          break;
        case 24:
          popProvider(CacheContext, interruptedWork);
      }
    }
    function shouldProfile(current) {
      return (current.mode & ProfileMode) !== NoMode;
    }
    function commitHookLayoutEffects(finishedWork, hookFlags) {
      shouldProfile(finishedWork)
        ? (startEffectTimer(),
          commitHookEffectListMount(hookFlags, finishedWork),
          recordEffectDuration())
        : commitHookEffectListMount(hookFlags, finishedWork);
    }
    function commitHookLayoutUnmountEffects(
      finishedWork,
      nearestMountedAncestor,
      hookFlags
    ) {
      shouldProfile(finishedWork)
        ? (startEffectTimer(),
          commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ),
          recordEffectDuration())
        : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
    }
    function commitHookEffectListMount(flags, finishedWork) {
      try {
        var updateQueue = finishedWork.updateQueue,
          lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if (
              (updateQueue.tag & flags) === flags &&
              ((flags & Passive) !== NoFlags
                ? null !== injectedProfilingHooks &&
                  "function" ===
                    typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted &&
                  injectedProfilingHooks.markComponentPassiveEffectMountStarted(
                    finishedWork
                  )
                : (flags & Layout) !== NoFlags &&
                  null !== injectedProfilingHooks &&
                  "function" ===
                    typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted &&
                  injectedProfilingHooks.markComponentLayoutEffectMountStarted(
                    finishedWork
                  ),
              (lastEffect = void 0),
              (flags & Insertion) !== NoFlags &&
                (isRunningInsertionEffect = !0),
              (lastEffect = runWithFiberInDEV(
                finishedWork,
                callCreateInDEV,
                updateQueue
              )),
              (flags & Insertion) !== NoFlags &&
                (isRunningInsertionEffect = !1),
              (flags & Passive) !== NoFlags
                ? null !== injectedProfilingHooks &&
                  "function" ===
                    typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped &&
                  injectedProfilingHooks.markComponentPassiveEffectMountStopped()
                : (flags & Layout) !== NoFlags &&
                  null !== injectedProfilingHooks &&
                  "function" ===
                    typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped &&
                  injectedProfilingHooks.markComponentLayoutEffectMountStopped(),
              void 0 !== lastEffect && "function" !== typeof lastEffect)
            ) {
              var hookName = void 0;
              hookName =
                0 !== (updateQueue.tag & Layout)
                  ? "useLayoutEffect"
                  : 0 !== (updateQueue.tag & Insertion)
                    ? "useInsertionEffect"
                    : "useEffect";
              var addendum = void 0;
              addendum =
                null === lastEffect
                  ? " You returned null. If your effect does not require clean up, return undefined (or nothing)."
                  : "function" === typeof lastEffect.then
                    ? "\n\nIt looks like you wrote " +
                      hookName +
                      "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" +
                      hookName +
                      "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching"
                    : " You returned: " + lastEffect;
              runWithFiberInDEV(
                finishedWork,
                function (n, a) {
                  console.error(
                    "%s must not return anything besides a function, which is used for clean-up.%s",
                    n,
                    a
                  );
                },
                hookName,
                addendum
              );
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookEffectListUnmount(
      flags,
      finishedWork,
      nearestMountedAncestor
    ) {
      try {
        var updateQueue = finishedWork.updateQueue,
          lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              var inst = updateQueue.inst,
                destroy = inst.destroy;
              void 0 !== destroy &&
                ((inst.destroy = void 0),
                (flags & Passive) !== NoFlags
                  ? null !== injectedProfilingHooks &&
                    "function" ===
                      typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted &&
                    injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(
                      finishedWork
                    )
                  : (flags & Layout) !== NoFlags &&
                    null !== injectedProfilingHooks &&
                    "function" ===
                      typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted &&
                    injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(
                      finishedWork
                    ),
                (flags & Insertion) !== NoFlags &&
                  (isRunningInsertionEffect = !0),
                (lastEffect = finishedWork),
                runWithFiberInDEV(
                  lastEffect,
                  callDestroyInDEV,
                  lastEffect,
                  nearestMountedAncestor,
                  destroy
                ),
                (flags & Insertion) !== NoFlags &&
                  (isRunningInsertionEffect = !1),
                (flags & Passive) !== NoFlags
                  ? null !== injectedProfilingHooks &&
                    "function" ===
                      typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped &&
                    injectedProfilingHooks.markComponentPassiveEffectUnmountStopped()
                  : (flags & Layout) !== NoFlags &&
                    null !== injectedProfilingHooks &&
                    "function" ===
                      typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped &&
                    injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookPassiveMountEffects(finishedWork, hookFlags) {
      shouldProfile(finishedWork)
        ? (startEffectTimer(),
          commitHookEffectListMount(hookFlags, finishedWork),
          recordEffectDuration())
        : commitHookEffectListMount(hookFlags, finishedWork);
    }
    function commitHookPassiveUnmountEffects(
      finishedWork,
      nearestMountedAncestor,
      hookFlags
    ) {
      shouldProfile(finishedWork)
        ? (startEffectTimer(),
          commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ),
          recordEffectDuration())
        : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
    }
    function commitClassCallbacks(finishedWork) {
      var updateQueue = finishedWork.updateQueue;
      if (null !== updateQueue) {
        var instance = finishedWork.stateNode;
        finishedWork.type.defaultProps ||
          "ref" in finishedWork.memoizedProps ||
          didWarnAboutReassigningProps ||
          (instance.props !== finishedWork.memoizedProps &&
            console.error(
              "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ),
          instance.state !== finishedWork.memoizedState &&
            console.error(
              "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ));
        try {
          runWithFiberInDEV(
            finishedWork,
            commitCallbacks,
            updateQueue,
            instance
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
      return instance.getSnapshotBeforeUpdate(prevProps, prevState);
    }
    function commitClassSnapshot(finishedWork, current) {
      var prevProps = current.memoizedProps,
        prevState = current.memoizedState;
      current = finishedWork.stateNode;
      finishedWork.type.defaultProps ||
        "ref" in finishedWork.memoizedProps ||
        didWarnAboutReassigningProps ||
        (current.props !== finishedWork.memoizedProps &&
          console.error(
            "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ),
        current.state !== finishedWork.memoizedState &&
          console.error(
            "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ));
      try {
        var resolvedPrevProps = resolveClassComponentProps(
          finishedWork.type,
          prevProps,
          finishedWork.elementType === finishedWork.type
        );
        var snapshot = runWithFiberInDEV(
          finishedWork,
          callGetSnapshotBeforeUpdates,
          current,
          resolvedPrevProps,
          prevState
        );
        prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
        void 0 !== snapshot ||
          prevProps.has(finishedWork.type) ||
          (prevProps.add(finishedWork.type),
          runWithFiberInDEV(finishedWork, function () {
            console.error(
              "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
              getComponentNameFromFiber(finishedWork)
            );
          }));
        current.__reactInternalSnapshotBeforeUpdate = snapshot;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function safelyCallComponentWillUnmount(
      current,
      nearestMountedAncestor,
      instance
    ) {
      instance.props = resolveClassComponentProps(
        current.type,
        current.memoizedProps
      );
      instance.state = current.memoizedState;
      shouldProfile(current)
        ? (startEffectTimer(),
          runWithFiberInDEV(
            current,
            callComponentWillUnmountInDEV,
            current,
            nearestMountedAncestor,
            instance
          ),
          recordEffectDuration())
        : runWithFiberInDEV(
            current,
            callComponentWillUnmountInDEV,
            current,
            nearestMountedAncestor,
            instance
          );
    }
    function commitAttachRef(finishedWork) {
      var ref = finishedWork.ref;
      if (null !== ref) {
        switch (finishedWork.tag) {
          case 26:
          case 27:
          case 5:
            var instanceToUse = finishedWork.stateNode;
            break;
          case 30:
            instanceToUse = finishedWork.stateNode;
            break;
          default:
            instanceToUse = finishedWork.stateNode;
        }
        if ("function" === typeof ref)
          if (shouldProfile(finishedWork))
            try {
              startEffectTimer(),
                (finishedWork.refCleanup = ref(instanceToUse));
            } finally {
              recordEffectDuration();
            }
          else finishedWork.refCleanup = ref(instanceToUse);
        else
          "string" === typeof ref
            ? console.error("String refs are no longer supported.")
            : ref.hasOwnProperty("current") ||
              console.error(
                "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
                getComponentNameFromFiber(finishedWork)
              ),
            (ref.current = instanceToUse);
      }
    }
    function safelyAttachRef(current, nearestMountedAncestor) {
      try {
        runWithFiberInDEV(current, commitAttachRef, current);
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      }
    }
    function safelyDetachRef(current, nearestMountedAncestor) {
      var ref = current.ref,
        refCleanup = current.refCleanup;
      if (null !== ref)
        if ("function" === typeof refCleanup)
          try {
            if (shouldProfile(current))
              try {
                startEffectTimer(), runWithFiberInDEV(current, refCleanup);
              } finally {
                recordEffectDuration(current);
              }
            else runWithFiberInDEV(current, refCleanup);
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          } finally {
            (current.refCleanup = null),
              (current = current.alternate),
              null != current && (current.refCleanup = null);
          }
        else if ("function" === typeof ref)
          try {
            if (shouldProfile(current))
              try {
                startEffectTimer(), runWithFiberInDEV(current, ref, null);
              } finally {
                recordEffectDuration(current);
              }
            else runWithFiberInDEV(current, ref, null);
          } catch (error$7) {
            captureCommitPhaseError(current, nearestMountedAncestor, error$7);
          }
        else ref.current = null;
    }
    function commitProfiler(
      finishedWork,
      current,
      commitStartTime,
      effectDuration
    ) {
      var _finishedWork$memoize = finishedWork.memoizedProps,
        id = _finishedWork$memoize.id,
        onCommit = _finishedWork$memoize.onCommit;
      _finishedWork$memoize = _finishedWork$memoize.onRender;
      current = null === current ? "mount" : "update";
      currentUpdateIsNested && (current = "nested-update");
      "function" === typeof _finishedWork$memoize &&
        _finishedWork$memoize(
          id,
          current,
          finishedWork.actualDuration,
          finishedWork.treeBaseDuration,
          finishedWork.actualStartTime,
          commitStartTime
        );
      "function" === typeof onCommit &&
        onCommit(
          finishedWork.memoizedProps.id,
          current,
          effectDuration,
          commitStartTime
        );
    }
    function commitProfilerPostCommitImpl(
      finishedWork,
      current,
      commitStartTime,
      passiveEffectDuration
    ) {
      var _finishedWork$memoize2 = finishedWork.memoizedProps;
      finishedWork = _finishedWork$memoize2.id;
      _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
      current = null === current ? "mount" : "update";
      currentUpdateIsNested && (current = "nested-update");
      "function" === typeof _finishedWork$memoize2 &&
        _finishedWork$memoize2(
          finishedWork,
          current,
          passiveEffectDuration,
          commitStartTime
        );
    }
    function commitHostMount(finishedWork) {
      var type = finishedWork.type,
        props = finishedWork.memoizedProps,
        instance = finishedWork.stateNode;
      try {
        runWithFiberInDEV(
          finishedWork,
          commitMount,
          instance,
          type,
          props,
          finishedWork
        );
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHostUpdate(finishedWork, newProps, oldProps) {
      try {
        runWithFiberInDEV(
          finishedWork,
          commitUpdate,
          finishedWork.stateNode,
          finishedWork.type,
          oldProps,
          newProps,
          finishedWork
        );
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function isHostParent(fiber) {
      return (
        5 === fiber.tag ||
        3 === fiber.tag ||
        26 === fiber.tag ||
        (27 === fiber.tag && isSingletonScope(fiber.type)) ||
        4 === fiber.tag
      );
    }
    function getHostSibling(fiber) {
      a: for (;;) {
        for (; null === fiber.sibling; ) {
          if (null === fiber.return || isHostParent(fiber.return)) return null;
          fiber = fiber.return;
        }
        fiber.sibling.return = fiber.return;
        for (
          fiber = fiber.sibling;
          5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;

        ) {
          if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
          if (fiber.flags & 2) continue a;
          if (null === fiber.child || 4 === fiber.tag) continue a;
          else (fiber.child.return = fiber), (fiber = fiber.child);
        }
        if (!(fiber.flags & 2)) return fiber.stateNode;
      }
    }
    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
      var tag = node.tag;
      if (5 === tag || 6 === tag)
        (node = node.stateNode),
          before
            ? (9 === parent.nodeType
                ? parent.body
                : "HTML" === parent.nodeName
                  ? parent.ownerDocument.body
                  : parent
              ).insertBefore(node, before)
            : ((before =
                9 === parent.nodeType
                  ? parent.body
                  : "HTML" === parent.nodeName
                    ? parent.ownerDocument.body
                    : parent),
              before.appendChild(node),
              (parent = parent._reactRootContainer),
              (null !== parent && void 0 !== parent) ||
                null !== before.onclick ||
                (before.onclick = noop$1));
      else if (
        4 !== tag &&
        (27 === tag &&
          isSingletonScope(node.type) &&
          ((parent = node.stateNode), (before = null)),
        (node = node.child),
        null !== node)
      )
        for (
          insertOrAppendPlacementNodeIntoContainer(node, before, parent),
            node = node.sibling;
          null !== node;

        )
          insertOrAppendPlacementNodeIntoContainer(node, before, parent),
            (node = node.sibling);
    }
    function insertOrAppendPlacementNode(node, before, parent) {
      var tag = node.tag;
      if (5 === tag || 6 === tag)
        (node = node.stateNode),
          before ? parent.insertBefore(node, before) : parent.appendChild(node);
      else if (
        4 !== tag &&
        (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode),
        (node = node.child),
        null !== node)
      )
        for (
          insertOrAppendPlacementNode(node, before, parent),
            node = node.sibling;
          null !== node;

        )
          insertOrAppendPlacementNode(node, before, parent),
            (node = node.sibling);
    }
    function commitPlacement(finishedWork) {
      for (
        var hostParentFiber, parentFiber = finishedWork.return;
        null !== parentFiber;

      ) {
        if (isHostParent(parentFiber)) {
          hostParentFiber = parentFiber;
          break;
        }
        parentFiber = parentFiber.return;
      }
      if (null == hostParentFiber)
        throw Error(
          "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
        );
      switch (hostParentFiber.tag) {
        case 27:
          hostParentFiber = hostParentFiber.stateNode;
          parentFiber = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(
            finishedWork,
            parentFiber,
            hostParentFiber
          );
          break;
        case 5:
          parentFiber = hostParentFiber.stateNode;
          hostParentFiber.flags & 32 &&
            (resetTextContent(parentFiber), (hostParentFiber.flags &= -33));
          hostParentFiber = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(
            finishedWork,
            hostParentFiber,
            parentFiber
          );
          break;
        case 3:
        case 4:
          hostParentFiber = hostParentFiber.stateNode.containerInfo;
          parentFiber = getHostSibling(finishedWork);
          insertOrAppendPlacementNodeIntoContainer(
            finishedWork,
            parentFiber,
            hostParentFiber
          );
          break;
        default:
          throw Error(
            "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
          );
      }
    }
    function commitHostSingletonAcquisition(finishedWork) {
      var singleton = finishedWork.stateNode,
        props = finishedWork.memoizedProps;
      try {
        runWithFiberInDEV(
          finishedWork,
          acquireSingletonInstance,
          finishedWork.type,
          props,
          singleton,
          finishedWork
        );
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitBeforeMutationEffects(root, firstChild) {
      root = root.containerInfo;
      eventsEnabled = _enabled;
      root = getActiveElementDeep(root);
      if (hasSelectionCapabilities(root)) {
        if ("selectionStart" in root)
          var JSCompiler_temp = {
            start: root.selectionStart,
            end: root.selectionEnd
          };
        else
          a: {
            JSCompiler_temp =
              ((JSCompiler_temp = root.ownerDocument) &&
                JSCompiler_temp.defaultView) ||
              window;
            var selection =
              JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
            if (selection && 0 !== selection.rangeCount) {
              JSCompiler_temp = selection.anchorNode;
              var anchorOffset = selection.anchorOffset,
                focusNode = selection.focusNode;
              selection = selection.focusOffset;
              try {
                JSCompiler_temp.nodeType, focusNode.nodeType;
              } catch (e$2) {
                JSCompiler_temp = null;
                break a;
              }
              var length = 0,
                start = -1,
                end = -1,
                indexWithinAnchor = 0,
                indexWithinFocus = 0,
                node = root,
                parentNode = null;
              b: for (;;) {
                for (var next; ; ) {
                  node !== JSCompiler_temp ||
                    (0 !== anchorOffset && 3 !== node.nodeType) ||
                    (start = length + anchorOffset);
                  node !== focusNode ||
                    (0 !== selection && 3 !== node.nodeType) ||
                    (end = length + selection);
                  3 === node.nodeType && (length += node.nodeValue.length);
                  if (null === (next = node.firstChild)) break;
                  parentNode = node;
                  node = next;
                }
                for (;;) {
                  if (node === root) break b;
                  parentNode === JSCompiler_temp &&
                    ++indexWithinAnchor === anchorOffset &&
                    (start = length);
                  parentNode === focusNode &&
                    ++indexWithinFocus === selection &&
                    (end = length);
                  if (null !== (next = node.nextSibling)) break;
                  node = parentNode;
                  parentNode = node.parentNode;
                }
                node = next;
              }
              JSCompiler_temp =
                -1 === start || -1 === end ? null : { start: start, end: end };
            } else JSCompiler_temp = null;
          }
        JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
      } else JSCompiler_temp = null;
      selectionInformation = {
        focusedElem: root,
        selectionRange: JSCompiler_temp
      };
      _enabled = !1;
      for (nextEffect = firstChild; null !== nextEffect; )
        if (
          ((firstChild = nextEffect),
          (root = firstChild.child),
          0 !== (firstChild.subtreeFlags & 1024) && null !== root)
        )
          (root.return = firstChild), (nextEffect = root);
        else
          for (; null !== nextEffect; ) {
            root = firstChild = nextEffect;
            JSCompiler_temp = root.alternate;
            anchorOffset = root.flags;
            switch (root.tag) {
              case 0:
                break;
              case 11:
              case 15:
                break;
              case 1:
                0 !== (anchorOffset & 1024) &&
                  null !== JSCompiler_temp &&
                  commitClassSnapshot(root, JSCompiler_temp);
                break;
              case 3:
                if (0 !== (anchorOffset & 1024))
                  if (
                    ((root = root.stateNode.containerInfo),
                    (JSCompiler_temp = root.nodeType),
                    9 === JSCompiler_temp)
                  )
                    clearContainerSparingly(root);
                  else if (1 === JSCompiler_temp)
                    switch (root.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY":
                        clearContainerSparingly(root);
                        break;
                      default:
                        root.textContent = "";
                    }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if (0 !== (anchorOffset & 1024))
                  throw Error(
                    "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                  );
            }
            root = firstChild.sibling;
            if (null !== root) {
              root.return = firstChild.return;
              nextEffect = root;
              break;
            }
            nextEffect = firstChild.return;
          }
    }
    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 &&
            commitHookLayoutEffects(finishedWork, Layout | HasEffect);
          break;
        case 1:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 4)
            if (((finishedRoot = finishedWork.stateNode), null === current))
              finishedWork.type.defaultProps ||
                "ref" in finishedWork.memoizedProps ||
                didWarnAboutReassigningProps ||
                (finishedRoot.props !== finishedWork.memoizedProps &&
                  console.error(
                    "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ),
                finishedRoot.state !== finishedWork.memoizedState &&
                  console.error(
                    "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  )),
                shouldProfile(finishedWork)
                  ? (startEffectTimer(),
                    runWithFiberInDEV(
                      finishedWork,
                      callComponentDidMountInDEV,
                      finishedWork,
                      finishedRoot
                    ),
                    recordEffectDuration())
                  : runWithFiberInDEV(
                      finishedWork,
                      callComponentDidMountInDEV,
                      finishedWork,
                      finishedRoot
                    );
            else {
              var prevProps = resolveClassComponentProps(
                finishedWork.type,
                current.memoizedProps
              );
              current = current.memoizedState;
              finishedWork.type.defaultProps ||
                "ref" in finishedWork.memoizedProps ||
                didWarnAboutReassigningProps ||
                (finishedRoot.props !== finishedWork.memoizedProps &&
                  console.error(
                    "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ),
                finishedRoot.state !== finishedWork.memoizedState &&
                  console.error(
                    "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ));
              shouldProfile(finishedWork)
                ? (startEffectTimer(),
                  runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  ),
                  recordEffectDuration())
                : runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
            }
          flags & 64 && commitClassCallbacks(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 3:
          current = pushNestedEffectDurations();
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (
            flags & 64 &&
            ((flags = finishedWork.updateQueue), null !== flags)
          ) {
            prevProps = null;
            if (null !== finishedWork.child)
              switch (finishedWork.child.tag) {
                case 27:
                case 5:
                  prevProps = finishedWork.child.stateNode;
                  break;
                case 1:
                  prevProps = finishedWork.child.stateNode;
              }
            try {
              runWithFiberInDEV(
                finishedWork,
                commitCallbacks,
                flags,
                prevProps
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          finishedRoot.effectDuration += popNestedEffectDurations(current);
          break;
        case 27:
          null === current &&
            flags & 4 &&
            commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          null === current && flags & 4 && commitHostMount(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          if (flags & 4) {
            flags = pushNestedEffectDurations();
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            finishedRoot = finishedWork.stateNode;
            finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(
                finishedWork,
                commitProfiler,
                finishedWork,
                current,
                commitStartTime,
                finishedRoot.effectDuration
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          break;
        case 13:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 &&
            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          flags & 64 &&
            ((finishedRoot = finishedWork.memoizedState),
            null !== finishedRoot &&
              ((finishedRoot = finishedRoot.dehydrated),
              null !== finishedRoot &&
                ((finishedWork = retryDehydratedSuspenseBoundary.bind(
                  null,
                  finishedWork
                )),
                registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
          break;
        case 22:
          flags =
            null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
          if (!flags) {
            current =
              (null !== current && null !== current.memoizedState) ||
              offscreenSubtreeWasHidden;
            prevProps = offscreenSubtreeIsHidden;
            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = flags;
            (offscreenSubtreeWasHidden = current) &&
            !prevOffscreenSubtreeWasHidden
              ? recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  0 !== (finishedWork.subtreeFlags & 8772)
                )
              : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            offscreenSubtreeIsHidden = prevProps;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          }
          break;
        case 30:
          break;
        default:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      }
    }
    function detachFiberAfterEffects(fiber) {
      var alternate = fiber.alternate;
      null !== alternate &&
        ((fiber.alternate = null), detachFiberAfterEffects(alternate));
      fiber.child = null;
      fiber.deletions = null;
      fiber.sibling = null;
      5 === fiber.tag &&
        ((alternate = fiber.stateNode),
        null !== alternate && detachDeletedInstance(alternate));
      fiber.stateNode = null;
      fiber._debugOwner = null;
      fiber.return = null;
      fiber.dependencies = null;
      fiber.memoizedProps = null;
      fiber.memoizedState = null;
      fiber.pendingProps = null;
      fiber.stateNode = null;
      fiber.updateQueue = null;
    }
    function recursivelyTraverseDeletionEffects(
      finishedRoot,
      nearestMountedAncestor,
      parent
    ) {
      for (parent = parent.child; null !== parent; )
        commitDeletionEffectsOnFiber(
          finishedRoot,
          nearestMountedAncestor,
          parent
        ),
          (parent = parent.sibling);
    }
    function commitDeletionEffectsOnFiber(
      finishedRoot,
      nearestMountedAncestor,
      deletedFiber
    ) {
      if (
        injectedHook &&
        "function" === typeof injectedHook.onCommitFiberUnmount
      )
        try {
          injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
        } catch (err) {
          hasLoggedError ||
            ((hasLoggedError = !0),
            console.error(
              "React instrumentation encountered an error: %s",
              err
            ));
        }
      switch (deletedFiber.tag) {
        case 26:
          offscreenSubtreeWasHidden ||
            safelyDetachRef(deletedFiber, nearestMountedAncestor);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          deletedFiber.memoizedState
            ? deletedFiber.memoizedState.count--
            : deletedFiber.stateNode &&
              ((deletedFiber = deletedFiber.stateNode),
              deletedFiber.parentNode.removeChild(deletedFiber));
          break;
        case 27:
          offscreenSubtreeWasHidden ||
            safelyDetachRef(deletedFiber, nearestMountedAncestor);
          var prevHostParent = hostParent,
            prevHostParentIsContainer = hostParentIsContainer;
          isSingletonScope(deletedFiber.type) &&
            ((hostParent = deletedFiber.stateNode),
            (hostParentIsContainer = !1));
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          runWithFiberInDEV(
            deletedFiber,
            releaseSingletonInstance,
            deletedFiber.stateNode
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 5:
          offscreenSubtreeWasHidden ||
            safelyDetachRef(deletedFiber, nearestMountedAncestor);
        case 6:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = null;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          if (null !== hostParent)
            if (hostParentIsContainer)
              try {
                runWithFiberInDEV(
                  deletedFiber,
                  removeChildFromContainer,
                  hostParent,
                  deletedFiber.stateNode
                );
              } catch (error) {
                captureCommitPhaseError(
                  deletedFiber,
                  nearestMountedAncestor,
                  error
                );
              }
            else
              try {
                runWithFiberInDEV(
                  deletedFiber,
                  removeChild,
                  hostParent,
                  deletedFiber.stateNode
                );
              } catch (error) {
                captureCommitPhaseError(
                  deletedFiber,
                  nearestMountedAncestor,
                  error
                );
              }
          break;
        case 18:
          null !== hostParent &&
            (hostParentIsContainer
              ? ((finishedRoot = hostParent),
                clearSuspenseBoundary(
                  9 === finishedRoot.nodeType
                    ? finishedRoot.body
                    : "HTML" === finishedRoot.nodeName
                      ? finishedRoot.ownerDocument.body
                      : finishedRoot,
                  deletedFiber.stateNode
                ),
                retryIfBlockedOn(finishedRoot))
              : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
          break;
        case 4:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = deletedFiber.stateNode.containerInfo;
          hostParentIsContainer = !0;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          offscreenSubtreeWasHidden ||
            commitHookEffectListUnmount(
              Insertion,
              deletedFiber,
              nearestMountedAncestor
            );
          offscreenSubtreeWasHidden ||
            commitHookLayoutUnmountEffects(
              deletedFiber,
              nearestMountedAncestor,
              Layout
            );
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 1:
          offscreenSubtreeWasHidden ||
            (safelyDetachRef(deletedFiber, nearestMountedAncestor),
            (prevHostParent = deletedFiber.stateNode),
            "function" === typeof prevHostParent.componentWillUnmount &&
              safelyCallComponentWillUnmount(
                deletedFiber,
                nearestMountedAncestor,
                prevHostParent
              ));
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 21:
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 22:
          offscreenSubtreeWasHidden =
            (prevHostParent = offscreenSubtreeWasHidden) ||
            null !== deletedFiber.memoizedState;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          offscreenSubtreeWasHidden = prevHostParent;
          break;
        default:
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
      }
    }
    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
      if (
        null === finishedWork.memoizedState &&
        ((finishedRoot = finishedWork.alternate),
        null !== finishedRoot &&
          ((finishedRoot = finishedRoot.memoizedState),
          null !== finishedRoot &&
            ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))
      )
        try {
          runWithFiberInDEV(
            finishedWork,
            commitHydratedSuspenseInstance,
            finishedRoot
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
    }
    function getRetryCache(finishedWork) {
      switch (finishedWork.tag) {
        case 13:
        case 19:
          var retryCache = finishedWork.stateNode;
          null === retryCache &&
            (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
          return retryCache;
        case 22:
          return (
            (finishedWork = finishedWork.stateNode),
            (retryCache = finishedWork._retryCache),
            null === retryCache &&
              (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
            retryCache
          );
        default:
          throw Error(
            "Unexpected Suspense handler tag (" +
              finishedWork.tag +
              "). This is a bug in React."
          );
      }
    }
    function attachSuspenseRetryListeners(finishedWork, wakeables) {
      var retryCache = getRetryCache(finishedWork);
      wakeables.forEach(function (wakeable) {
        var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
        if (!retryCache.has(wakeable)) {
          retryCache.add(wakeable);
          if (isDevToolsPresent)
            if (null !== inProgressLanes && null !== inProgressRoot)
              restorePendingUpdaters(inProgressRoot, inProgressLanes);
            else
              throw Error(
                "Expected finished root and lanes to be set. This is a bug in React."
              );
          wakeable.then(retry, retry);
        }
      });
    }
    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
      var deletions = parentFiber.deletions;
      if (null !== deletions)
        for (var i = 0; i < deletions.length; i++) {
          var root = root$jscomp$0,
            returnFiber = parentFiber,
            deletedFiber = deletions[i],
            parent = returnFiber;
          a: for (; null !== parent; ) {
            switch (parent.tag) {
              case 27:
                if (isSingletonScope(parent.type)) {
                  hostParent = parent.stateNode;
                  hostParentIsContainer = !1;
                  break a;
                }
                break;
              case 5:
                hostParent = parent.stateNode;
                hostParentIsContainer = !1;
                break a;
              case 3:
              case 4:
                hostParent = parent.stateNode.containerInfo;
                hostParentIsContainer = !0;
                break a;
            }
            parent = parent.return;
          }
          if (null === hostParent)
            throw Error(
              "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
            );
          commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
          hostParent = null;
          hostParentIsContainer = !1;
          root = deletedFiber;
          returnFiber = root.alternate;
          null !== returnFiber && (returnFiber.return = null);
          root.return = null;
        }
      if (parentFiber.subtreeFlags & 13878)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
            (parentFiber = parentFiber.sibling);
    }
    function commitMutationEffectsOnFiber(finishedWork, root) {
      var current = finishedWork.alternate,
        flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 &&
            (commitHookEffectListUnmount(
              Insertion | HasEffect,
              finishedWork,
              finishedWork.return
            ),
            commitHookEffectListMount(Insertion | HasEffect, finishedWork),
            commitHookLayoutUnmountEffects(
              finishedWork,
              finishedWork.return,
              Layout | HasEffect
            ));
          break;
        case 1:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 &&
            (offscreenSubtreeWasHidden ||
              null === current ||
              safelyDetachRef(current, current.return));
          flags & 64 &&
            offscreenSubtreeIsHidden &&
            ((finishedWork = finishedWork.updateQueue),
            null !== finishedWork &&
              ((flags = finishedWork.callbacks),
              null !== flags &&
                ((current = finishedWork.shared.hiddenCallbacks),
                (finishedWork.shared.hiddenCallbacks =
                  null === current ? flags : current.concat(flags)))));
          break;
        case 26:
          var hoistableRoot = currentHoistableRoot;
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 &&
            (offscreenSubtreeWasHidden ||
              null === current ||
              safelyDetachRef(current, current.return));
          if (flags & 4)
            if (
              ((root = null !== current ? current.memoizedState : null),
              (flags = finishedWork.memoizedState),
              null === current)
            )
              if (null === flags)
                if (null === finishedWork.stateNode) {
                  a: {
                    flags = finishedWork.type;
                    current = finishedWork.memoizedProps;
                    root = hoistableRoot.ownerDocument || hoistableRoot;
                    b: switch (flags) {
                      case "title":
                        hoistableRoot = root.getElementsByTagName("title")[0];
                        if (
                          !hoistableRoot ||
                          hoistableRoot[internalHoistableMarker] ||
                          hoistableRoot[internalInstanceKey] ||
                          hoistableRoot.namespaceURI === SVG_NAMESPACE ||
                          hoistableRoot.hasAttribute("itemprop")
                        )
                          (hoistableRoot = root.createElement(flags)),
                            root.head.insertBefore(
                              hoistableRoot,
                              root.querySelector("head > title")
                            );
                        setInitialProperties(hoistableRoot, flags, current);
                        hoistableRoot[internalInstanceKey] = finishedWork;
                        markNodeAsHoistable(hoistableRoot);
                        flags = hoistableRoot;
                        break a;
                      case "link":
                        var maybeNodes = getHydratableHoistableCache(
                          "link",
                          "href",
                          root
                        ).get(flags + (current.href || ""));
                        if (maybeNodes)
                          for (var i = 0; i < maybeNodes.length; i++)
                            if (
                              ((hoistableRoot = maybeNodes[i]),
                              hoistableRoot.getAttribute("href") ===
                                (null == current.href || "" === current.href
                                  ? null
                                  : current.href) &&
                                hoistableRoot.getAttribute("rel") ===
                                  (null == current.rel ? null : current.rel) &&
                                hoistableRoot.getAttribute("title") ===
                                  (null == current.title
                                    ? null
                                    : current.title) &&
                                hoistableRoot.getAttribute("crossorigin") ===
                                  (null == current.crossOrigin
                                    ? null
                                    : current.crossOrigin))
                            ) {
                              maybeNodes.splice(i, 1);
                              break b;
                            }
                        hoistableRoot = root.createElement(flags);
                        setInitialProperties(hoistableRoot, flags, current);
                        root.head.appendChild(hoistableRoot);
                        break;
                      case "meta":
                        if (
                          (maybeNodes = getHydratableHoistableCache(
                            "meta",
                            "content",
                            root
                          ).get(flags + (current.content || "")))
                        )
                          for (i = 0; i < maybeNodes.length; i++)
                            if (
                              ((hoistableRoot = maybeNodes[i]),
                              checkAttributeStringCoercion(
                                current.content,
                                "content"
                              ),
                              hoistableRoot.getAttribute("content") ===
                                (null == current.content
                                  ? null
                                  : "" + current.content) &&
                                hoistableRoot.getAttribute("name") ===
                                  (null == current.name
                                    ? null
                                    : current.name) &&
                                hoistableRoot.getAttribute("property") ===
                                  (null == current.property
                                    ? null
                                    : current.property) &&
                                hoistableRoot.getAttribute("http-equiv") ===
                                  (null == current.httpEquiv
                                    ? null
                                    : current.httpEquiv) &&
                                hoistableRoot.getAttribute("charset") ===
                                  (null == current.charSet
                                    ? null
                                    : current.charSet))
                            ) {
                              maybeNodes.splice(i, 1);
                              break b;
                            }
                        hoistableRoot = root.createElement(flags);
                        setInitialProperties(hoistableRoot, flags, current);
                        root.head.appendChild(hoistableRoot);
                        break;
                      default:
                        throw Error(
                          'getNodesForType encountered a type it did not expect: "' +
                            flags +
                            '". This is a bug in React.'
                        );
                    }
                    hoistableRoot[internalInstanceKey] = finishedWork;
                    markNodeAsHoistable(hoistableRoot);
                    flags = hoistableRoot;
                  }
                  finishedWork.stateNode = flags;
                } else
                  mountHoistable(
                    hoistableRoot,
                    finishedWork.type,
                    finishedWork.stateNode
                  );
              else
                finishedWork.stateNode = acquireResource(
                  hoistableRoot,
                  flags,
                  finishedWork.memoizedProps
                );
            else
              root !== flags
                ? (null === root
                    ? null !== current.stateNode &&
                      ((current = current.stateNode),
                      current.parentNode.removeChild(current))
                    : root.count--,
                  null === flags
                    ? mountHoistable(
                        hoistableRoot,
                        finishedWork.type,
                        finishedWork.stateNode
                      )
                    : acquireResource(
                        hoistableRoot,
                        flags,
                        finishedWork.memoizedProps
                      ))
                : null === flags &&
                  null !== finishedWork.stateNode &&
                  commitHostUpdate(
                    finishedWork,
                    finishedWork.memoizedProps,
                    current.memoizedProps
                  );
          break;
        case 27:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 &&
            (offscreenSubtreeWasHidden ||
              null === current ||
              safelyDetachRef(current, current.return));
          null !== current &&
            flags & 4 &&
            commitHostUpdate(
              finishedWork,
              finishedWork.memoizedProps,
              current.memoizedProps
            );
          break;
        case 5:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 &&
            (offscreenSubtreeWasHidden ||
              null === current ||
              safelyDetachRef(current, current.return));
          if (finishedWork.flags & 32) {
            root = finishedWork.stateNode;
            try {
              runWithFiberInDEV(finishedWork, resetTextContent, root);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          flags & 4 &&
            null != finishedWork.stateNode &&
            ((root = finishedWork.memoizedProps),
            commitHostUpdate(
              finishedWork,
              root,
              null !== current ? current.memoizedProps : root
            ));
          flags & 1024 &&
            ((needsFormReset = !0),
            "form" !== finishedWork.type &&
              console.error(
                "Unexpected host component type. Expected a form. This is a bug in React."
              ));
          break;
        case 6:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          if (flags & 4) {
            if (null === finishedWork.stateNode)
              throw Error(
                "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
              );
            flags = finishedWork.memoizedProps;
            current = null !== current ? current.memoizedProps : flags;
            root = finishedWork.stateNode;
            try {
              runWithFiberInDEV(
                finishedWork,
                commitTextUpdate,
                root,
                current,
                flags
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 3:
          hoistableRoot = pushNestedEffectDurations();
          tagCaches = null;
          maybeNodes = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(root.containerInfo);
          recursivelyTraverseMutationEffects(root, finishedWork);
          currentHoistableRoot = maybeNodes;
          commitReconciliationEffects(finishedWork);
          if (
            flags & 4 &&
            null !== current &&
            current.memoizedState.isDehydrated
          )
            try {
              runWithFiberInDEV(
                finishedWork,
                commitHydratedContainer,
                root.containerInfo
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          needsFormReset &&
            ((needsFormReset = !1), recursivelyResetForms(finishedWork));
          root.effectDuration += popNestedEffectDurations(hoistableRoot);
          break;
        case 4:
          flags = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(
            finishedWork.stateNode.containerInfo
          );
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          currentHoistableRoot = flags;
          break;
        case 12:
          flags = pushNestedEffectDurations();
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.stateNode.effectDuration +=
            bubbleNestedEffectDurations(flags);
          break;
        case 13:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.child.flags & 8192 &&
            (null !== finishedWork.memoizedState) !==
              (null !== current && null !== current.memoizedState) &&
            (globalMostRecentFallbackTime = now$1());
          flags & 4 &&
            ((flags = finishedWork.updateQueue),
            null !== flags &&
              ((finishedWork.updateQueue = null),
              attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 22:
          hoistableRoot = null !== finishedWork.memoizedState;
          var wasHidden = null !== current && null !== current.memoizedState,
            prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
            prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden =
            prevOffscreenSubtreeIsHidden || hoistableRoot;
          offscreenSubtreeWasHidden =
            prevOffscreenSubtreeWasHidden || wasHidden;
          recursivelyTraverseMutationEffects(root, finishedWork);
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
          commitReconciliationEffects(finishedWork);
          if (flags & 8192)
            a: for (
              root = finishedWork.stateNode,
                root._visibility = hoistableRoot
                  ? root._visibility & ~OffscreenVisible
                  : root._visibility | OffscreenVisible,
                hoistableRoot &&
                  (null === current ||
                    wasHidden ||
                    offscreenSubtreeIsHidden ||
                    offscreenSubtreeWasHidden ||
                    recursivelyTraverseDisappearLayoutEffects(finishedWork)),
                current = null,
                root = finishedWork;
              ;

            ) {
              if (5 === root.tag || 26 === root.tag) {
                if (null === current) {
                  wasHidden = current = root;
                  try {
                    (maybeNodes = wasHidden.stateNode),
                      hoistableRoot
                        ? runWithFiberInDEV(wasHidden, hideInstance, maybeNodes)
                        : runWithFiberInDEV(
                            wasHidden,
                            unhideInstance,
                            wasHidden.stateNode,
                            wasHidden.memoizedProps
                          );
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if (6 === root.tag) {
                if (null === current) {
                  wasHidden = root;
                  try {
                    (i = wasHidden.stateNode),
                      hoistableRoot
                        ? runWithFiberInDEV(wasHidden, hideTextInstance, i)
                        : runWithFiberInDEV(
                            wasHidden,
                            unhideTextInstance,
                            i,
                            wasHidden.memoizedProps
                          );
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if (
                ((22 !== root.tag && 23 !== root.tag) ||
                  null === root.memoizedState ||
                  root === finishedWork) &&
                null !== root.child
              ) {
                root.child.return = root;
                root = root.child;
                continue;
              }
              if (root === finishedWork) break a;
              for (; null === root.sibling; ) {
                if (null === root.return || root.return === finishedWork)
                  break a;
                current === root && (current = null);
                root = root.return;
              }
              current === root && (current = null);
              root.sibling.return = root.return;
              root = root.sibling;
            }
          flags & 4 &&
            ((flags = finishedWork.updateQueue),
            null !== flags &&
              ((current = flags.retryQueue),
              null !== current &&
                ((flags.retryQueue = null),
                attachSuspenseRetryListeners(finishedWork, current))));
          break;
        case 19:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 &&
            ((flags = finishedWork.updateQueue),
            null !== flags &&
              ((finishedWork.updateQueue = null),
              attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          recursivelyTraverseMutationEffects(root, finishedWork),
            commitReconciliationEffects(finishedWork);
      }
    }
    function commitReconciliationEffects(finishedWork) {
      var flags = finishedWork.flags;
      if (flags & 2) {
        try {
          runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        finishedWork.flags &= -3;
      }
      flags & 4096 && (finishedWork.flags &= -4097);
    }
    function recursivelyResetForms(parentFiber) {
      if (parentFiber.subtreeFlags & 1024)
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var fiber = parentFiber;
          recursivelyResetForms(fiber);
          5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
          parentFiber = parentFiber.sibling;
        }
    }
    function recursivelyTraverseLayoutEffects(root, parentFiber) {
      if (parentFiber.subtreeFlags & 8772)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
            (parentFiber = parentFiber.sibling);
    }
    function disappearLayoutEffects(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          commitHookLayoutUnmountEffects(
            finishedWork,
            finishedWork.return,
            Layout
          );
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 1:
          safelyDetachRef(finishedWork, finishedWork.return);
          var instance = finishedWork.stateNode;
          "function" === typeof instance.componentWillUnmount &&
            safelyCallComponentWillUnmount(
              finishedWork,
              finishedWork.return,
              instance
            );
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 27:
          runWithFiberInDEV(
            finishedWork,
            releaseSingletonInstance,
            finishedWork.stateNode
          );
        case 26:
        case 5:
          safelyDetachRef(finishedWork, finishedWork.return);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 22:
          null === finishedWork.memoizedState &&
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 30:
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        default:
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
      }
    }
    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        disappearLayoutEffects(parentFiber),
          (parentFiber = parentFiber.sibling);
    }
    function reappearLayoutEffects(
      finishedRoot,
      current,
      finishedWork,
      includeWorkInProgressEffects
    ) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          commitHookLayoutEffects(finishedWork, Layout);
          break;
        case 1:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          current = finishedWork.stateNode;
          "function" === typeof current.componentDidMount &&
            runWithFiberInDEV(
              finishedWork,
              callComponentDidMountInDEV,
              finishedWork,
              current
            );
          current = finishedWork.updateQueue;
          if (null !== current) {
            finishedRoot = finishedWork.stateNode;
            try {
              runWithFiberInDEV(
                finishedWork,
                commitHiddenCallbacks,
                current,
                finishedRoot
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          includeWorkInProgressEffects &&
            flags & 64 &&
            commitClassCallbacks(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 27:
          commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          includeWorkInProgressEffects &&
            null === current &&
            flags & 4 &&
            commitHostMount(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          if (includeWorkInProgressEffects && flags & 4) {
            flags = pushNestedEffectDurations();
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects = finishedWork.stateNode;
            includeWorkInProgressEffects.effectDuration +=
              bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(
                finishedWork,
                commitProfiler,
                finishedWork,
                current,
                commitStartTime,
                includeWorkInProgressEffects.effectDuration
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
          break;
        case 13:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          includeWorkInProgressEffects &&
            flags & 4 &&
            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 22:
          null === finishedWork.memoizedState &&
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 30:
          break;
        default:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
      }
    }
    function recursivelyTraverseReappearLayoutEffects(
      finishedRoot,
      parentFiber,
      includeWorkInProgressEffects
    ) {
      includeWorkInProgressEffects =
        includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        reappearLayoutEffects(
          finishedRoot,
          parentFiber.alternate,
          parentFiber,
          includeWorkInProgressEffects
        ),
          (parentFiber = parentFiber.sibling);
    }
    function commitOffscreenPassiveMountEffects(current, finishedWork) {
      var previousCache = null;
      null !== current &&
        null !== current.memoizedState &&
        null !== current.memoizedState.cachePool &&
        (previousCache = current.memoizedState.cachePool.pool);
      current = null;
      null !== finishedWork.memoizedState &&
        null !== finishedWork.memoizedState.cachePool &&
        (current = finishedWork.memoizedState.cachePool.pool);
      current !== previousCache &&
        (null != current && retainCache(current),
        null != previousCache && releaseCache(previousCache));
    }
    function commitCachePassiveMountEffect(current, finishedWork) {
      current = null;
      null !== finishedWork.alternate &&
        (current = finishedWork.alternate.memoizedState.cache);
      finishedWork = finishedWork.memoizedState.cache;
      finishedWork !== current &&
        (retainCache(finishedWork), null != current && releaseCache(current));
    }
    function recursivelyTraversePassiveMountEffects(
      root,
      parentFiber,
      committedLanes,
      committedTransitions
    ) {
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitPassiveMountOnFiber(
            root,
            parentFiber,
            committedLanes,
            committedTransitions
          ),
            (parentFiber = parentFiber.sibling);
    }
    function commitPassiveMountOnFiber(
      finishedRoot,
      finishedWork,
      committedLanes,
      committedTransitions
    ) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 &&
            commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
          break;
        case 1:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          break;
        case 3:
          var prevEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 &&
            ((committedLanes = null),
            null !== finishedWork.alternate &&
              (committedLanes = finishedWork.alternate.memoizedState.cache),
            (finishedWork = finishedWork.memoizedState.cache),
            finishedWork !== committedLanes &&
              (retainCache(finishedWork),
              null != committedLanes && releaseCache(committedLanes)));
          finishedRoot.passiveEffectDuration +=
            popNestedEffectDurations(prevEffectDuration);
          break;
        case 12:
          if (flags & 2048) {
            flags = pushNestedEffectDurations();
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            finishedRoot = finishedWork.stateNode;
            finishedRoot.passiveEffectDuration +=
              bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(
                finishedWork,
                commitProfilerPostCommitImpl,
                finishedWork,
                finishedWork.alternate,
                commitStartTime,
                finishedRoot.passiveEffectDuration
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
          break;
        case 13:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          break;
        case 23:
          break;
        case 22:
          prevEffectDuration = finishedWork.stateNode;
          var _current = finishedWork.alternate;
          null !== finishedWork.memoizedState
            ? prevEffectDuration._visibility & OffscreenPassiveEffectsConnected
              ? recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions
                )
              : recursivelyTraverseAtomicPassiveEffects(
                  finishedRoot,
                  finishedWork
                )
            : prevEffectDuration._visibility & OffscreenPassiveEffectsConnected
              ? recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions
                )
              : ((prevEffectDuration._visibility |=
                  OffscreenPassiveEffectsConnected),
                recursivelyTraverseReconnectPassiveEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  0 !== (finishedWork.subtreeFlags & 10256)
                ));
          flags & 2048 &&
            commitOffscreenPassiveMountEffects(_current, finishedWork);
          break;
        case 24:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 &&
            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
      }
    }
    function recursivelyTraverseReconnectPassiveEffects(
      finishedRoot,
      parentFiber,
      committedLanes,
      committedTransitions,
      includeWorkInProgressEffects
    ) {
      includeWorkInProgressEffects =
        includeWorkInProgressEffects &&
        0 !== (parentFiber.subtreeFlags & 10256);
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        reconnectPassiveEffects(
          finishedRoot,
          parentFiber,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects
        ),
          (parentFiber = parentFiber.sibling);
    }
    function reconnectPassiveEffects(
      finishedRoot,
      finishedWork,
      committedLanes,
      committedTransitions,
      includeWorkInProgressEffects
    ) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects
          );
          commitHookPassiveMountEffects(finishedWork, Passive);
          break;
        case 23:
          break;
        case 22:
          var _instance2 = finishedWork.stateNode;
          null !== finishedWork.memoizedState
            ? _instance2._visibility & OffscreenPassiveEffectsConnected
              ? recursivelyTraverseReconnectPassiveEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  includeWorkInProgressEffects
                )
              : recursivelyTraverseAtomicPassiveEffects(
                  finishedRoot,
                  finishedWork
                )
            : ((_instance2._visibility |= OffscreenPassiveEffectsConnected),
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ));
          includeWorkInProgressEffects &&
            flags & 2048 &&
            commitOffscreenPassiveMountEffects(
              finishedWork.alternate,
              finishedWork
            );
          break;
        case 24:
          recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects
          );
          includeWorkInProgressEffects &&
            flags & 2048 &&
            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects
          );
      }
    }
    function recursivelyTraverseAtomicPassiveEffects(
      finishedRoot$jscomp$0,
      parentFiber
    ) {
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedRoot = finishedRoot$jscomp$0,
            finishedWork = parentFiber,
            flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 22:
              recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              );
              flags & 2048 &&
                commitOffscreenPassiveMountEffects(
                  finishedWork.alternate,
                  finishedWork
                );
              break;
            case 24:
              recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              );
              flags & 2048 &&
                commitCachePassiveMountEffect(
                  finishedWork.alternate,
                  finishedWork
                );
              break;
            default:
              recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              );
          }
          parentFiber = parentFiber.sibling;
        }
    }
    function recursivelyAccumulateSuspenseyCommit(parentFiber) {
      if (parentFiber.subtreeFlags & suspenseyCommitFlag)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          accumulateSuspenseyCommitOnFiber(parentFiber),
            (parentFiber = parentFiber.sibling);
    }
    function accumulateSuspenseyCommitOnFiber(fiber) {
      switch (fiber.tag) {
        case 26:
          recursivelyAccumulateSuspenseyCommit(fiber);
          fiber.flags & suspenseyCommitFlag &&
            null !== fiber.memoizedState &&
            suspendResource(
              currentHoistableRoot,
              fiber.memoizedState,
              fiber.memoizedProps
            );
          break;
        case 5:
          recursivelyAccumulateSuspenseyCommit(fiber);
          break;
        case 3:
        case 4:
          var previousHoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(
            fiber.stateNode.containerInfo
          );
          recursivelyAccumulateSuspenseyCommit(fiber);
          currentHoistableRoot = previousHoistableRoot;
          break;
        case 22:
          null === fiber.memoizedState &&
            ((previousHoistableRoot = fiber.alternate),
            null !== previousHoistableRoot &&
            null !== previousHoistableRoot.memoizedState
              ? ((previousHoistableRoot = suspenseyCommitFlag),
                (suspenseyCommitFlag = 16777216),
                recursivelyAccumulateSuspenseyCommit(fiber),
                (suspenseyCommitFlag = previousHoistableRoot))
              : recursivelyAccumulateSuspenseyCommit(fiber));
          break;
        default:
          recursivelyAccumulateSuspenseyCommit(fiber);
      }
    }
    function detachAlternateSiblings(parentFiber) {
      var previousFiber = parentFiber.alternate;
      if (
        null !== previousFiber &&
        ((parentFiber = previousFiber.child), null !== parentFiber)
      ) {
        previousFiber.child = null;
        do
          (previousFiber = parentFiber.sibling),
            (parentFiber.sibling = null),
            (parentFiber = previousFiber);
        while (null !== parentFiber);
      }
    }
    function recursivelyTraversePassiveUnmountEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i];
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
              childToDelete,
              parentFiber
            );
          }
        detachAlternateSiblings(parentFiber);
      }
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitPassiveUnmountOnFiber(parentFiber),
            (parentFiber = parentFiber.sibling);
    }
    function commitPassiveUnmountOnFiber(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.flags & 2048 &&
            commitHookPassiveUnmountEffects(
              finishedWork,
              finishedWork.return,
              Passive | HasEffect
            );
          break;
        case 3:
          var prevEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.stateNode.passiveEffectDuration +=
            popNestedEffectDurations(prevEffectDuration);
          break;
        case 12:
          prevEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.stateNode.passiveEffectDuration +=
            bubbleNestedEffectDurations(prevEffectDuration);
          break;
        case 22:
          prevEffectDuration = finishedWork.stateNode;
          null !== finishedWork.memoizedState &&
          prevEffectDuration._visibility & OffscreenPassiveEffectsConnected &&
          (null === finishedWork.return || 13 !== finishedWork.return.tag)
            ? ((prevEffectDuration._visibility &=
                ~OffscreenPassiveEffectsConnected),
              recursivelyTraverseDisconnectPassiveEffects(finishedWork))
            : recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        default:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
      }
    }
    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i];
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
              childToDelete,
              parentFiber
            );
          }
        detachAlternateSiblings(parentFiber);
      }
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        disconnectPassiveEffect(parentFiber),
          (parentFiber = parentFiber.sibling);
    }
    function disconnectPassiveEffect(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          commitHookPassiveUnmountEffects(
            finishedWork,
            finishedWork.return,
            Passive
          );
          recursivelyTraverseDisconnectPassiveEffects(finishedWork);
          break;
        case 22:
          var instance = finishedWork.stateNode;
          instance._visibility & OffscreenPassiveEffectsConnected &&
            ((instance._visibility &= ~OffscreenPassiveEffectsConnected),
            recursivelyTraverseDisconnectPassiveEffects(finishedWork));
          break;
        default:
          recursivelyTraverseDisconnectPassiveEffects(finishedWork);
      }
    }
    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
      deletedSubtreeRoot,
      nearestMountedAncestor
    ) {
      for (; null !== nextEffect; ) {
        var fiber = nextEffect,
          current = fiber;
        switch (current.tag) {
          case 0:
          case 11:
          case 15:
            commitHookPassiveUnmountEffects(
              current,
              nearestMountedAncestor,
              Passive
            );
            break;
          case 23:
          case 22:
            null !== current.memoizedState &&
              null !== current.memoizedState.cachePool &&
              ((current = current.memoizedState.cachePool.pool),
              null != current && retainCache(current));
            break;
          case 24:
            releaseCache(current.memoizedState.cache);
        }
        current = fiber.child;
        if (null !== current) (current.return = fiber), (nextEffect = current);
        else
          a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
            current = nextEffect;
            var sibling = current.sibling,
              returnFiber = current.return;
            detachFiberAfterEffects(current);
            if (current === fiber) {
              nextEffect = null;
              break a;
            }
            if (null !== sibling) {
              sibling.return = returnFiber;
              nextEffect = sibling;
              break a;
            }
            nextEffect = returnFiber;
          }
      }
    }
    function onCommitRoot() {
      commitHooks.forEach(function (commitHook) {
        return commitHook();
      });
    }
    function isConcurrentActEnvironment() {
      var isReactActEnvironmentGlobal =
        "undefined" !== typeof IS_REACT_ACT_ENVIRONMENT
          ? IS_REACT_ACT_ENVIRONMENT
          : void 0;
      isReactActEnvironmentGlobal ||
        null === ReactSharedInternals.actQueue ||
        console.error(
          "The current testing environment is not configured to support act(...)"
        );
      return isReactActEnvironmentGlobal;
    }
    function requestUpdateLane(fiber) {
      if (
        (executionContext & RenderContext) !== NoContext &&
        0 !== workInProgressRootRenderLanes
      )
        return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
      var transition = ReactSharedInternals.T;
      return null !== transition
        ? (transition._updatedFibers || (transition._updatedFibers = new Set()),
          transition._updatedFibers.add(fiber),
          (fiber = currentEntangledLane),
          0 !== fiber ? fiber : requestTransitionLane())
        : resolveUpdatePriority();
    }
    function requestDeferredLane() {
      0 === workInProgressDeferredLane &&
        (workInProgressDeferredLane =
          0 === (workInProgressRootRenderLanes & 536870912) || isHydrating
            ? claimNextTransitionLane()
            : 536870912);
      var suspenseHandler = suspenseHandlerStackCursor.current;
      null !== suspenseHandler && (suspenseHandler.flags |= 32);
      return workInProgressDeferredLane;
    }
    function scheduleUpdateOnFiber(root, fiber, lane) {
      isRunningInsertionEffect &&
        console.error("useInsertionEffect must not schedule updates.");
      isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = !0);
      if (
        (root === workInProgressRoot &&
          (workInProgressSuspendedReason === SuspendedOnData ||
            workInProgressSuspendedReason === SuspendedOnAction)) ||
        null !== root.cancelPendingCommit
      )
        prepareFreshStack(root, 0),
          markRootSuspended(
            root,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            !1
          );
      markRootUpdated$1(root, lane);
      if (
        0 !== (executionContext & RenderContext) &&
        root === workInProgressRoot
      ) {
        if (isRendering)
          switch (fiber.tag) {
            case 0:
            case 11:
            case 15:
              root =
                (workInProgress && getComponentNameFromFiber(workInProgress)) ||
                "Unknown";
              didWarnAboutUpdateInRenderForAnotherComponent.has(root) ||
                (didWarnAboutUpdateInRenderForAnotherComponent.add(root),
                (fiber = getComponentNameFromFiber(fiber) || "Unknown"),
                console.error(
                  "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
                  fiber,
                  root,
                  root
                ));
              break;
            case 1:
              didWarnAboutUpdateInRender ||
                (console.error(
                  "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
                ),
                (didWarnAboutUpdateInRender = !0));
          }
      } else
        isDevToolsPresent && addFiberToLanesMap(root, fiber, lane),
          warnIfUpdatesNotWrappedWithActDEV(fiber),
          root === workInProgressRoot &&
            ((executionContext & RenderContext) === NoContext &&
              (workInProgressRootInterleavedUpdatedLanes |= lane),
            workInProgressRootExitStatus === RootSuspendedWithDelay &&
              markRootSuspended(
                root,
                workInProgressRootRenderLanes,
                workInProgressDeferredLane,
                !1
              )),
          ensureRootIsScheduled(root);
    }
    function performWorkOnRoot(root, lanes, forceSync) {
      if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
        throw Error("Should not already be working.");
      var shouldTimeSlice =
          (!forceSync &&
            0 === (lanes & 124) &&
            0 === (lanes & root.expiredLanes)) ||
          checkIfRootIsPrerendering(root, lanes),
        exitStatus = shouldTimeSlice
          ? renderRootConcurrent(root, lanes)
          : renderRootSync(root, lanes, !0),
        renderWasConcurrent = shouldTimeSlice;
      do {
        if (exitStatus === RootInProgress) {
          workInProgressRootIsPrerendering &&
            !shouldTimeSlice &&
            markRootSuspended(root, lanes, 0, !1);
          break;
        } else {
          forceSync = root.current.alternate;
          if (
            renderWasConcurrent &&
            !isRenderConsistentWithExternalStores(forceSync)
          ) {
            exitStatus = renderRootSync(root, lanes, !1);
            renderWasConcurrent = !1;
            continue;
          }
          if (exitStatus === RootErrored) {
            renderWasConcurrent = lanes;
            if (root.errorRecoveryDisabledLanes & renderWasConcurrent)
              var errorRetryLanes = 0;
            else
              (errorRetryLanes = root.pendingLanes & -536870913),
                (errorRetryLanes =
                  0 !== errorRetryLanes
                    ? errorRetryLanes
                    : errorRetryLanes & 536870912
                      ? 536870912
                      : 0);
            if (0 !== errorRetryLanes) {
              lanes = errorRetryLanes;
              a: {
                exitStatus = root;
                var errorRetryLanes$jscomp$0 = errorRetryLanes;
                errorRetryLanes = workInProgressRootConcurrentErrors;
                var wasRootDehydrated =
                  exitStatus.current.memoizedState.isDehydrated;
                wasRootDehydrated &&
                  (prepareFreshStack(
                    exitStatus,
                    errorRetryLanes$jscomp$0
                  ).flags |= 256);
                errorRetryLanes$jscomp$0 = renderRootSync(
                  exitStatus,
                  errorRetryLanes$jscomp$0,
                  !1
                );
                if (errorRetryLanes$jscomp$0 !== RootErrored) {
                  if (
                    workInProgressRootDidAttachPingListener &&
                    !wasRootDehydrated
                  ) {
                    exitStatus.errorRecoveryDisabledLanes |=
                      renderWasConcurrent;
                    workInProgressRootInterleavedUpdatedLanes |=
                      renderWasConcurrent;
                    exitStatus = RootSuspendedWithDelay;
                    break a;
                  }
                  exitStatus = workInProgressRootRecoverableErrors;
                  workInProgressRootRecoverableErrors = errorRetryLanes;
                  null !== exitStatus &&
                    (null === workInProgressRootRecoverableErrors
                      ? (workInProgressRootRecoverableErrors = exitStatus)
                      : workInProgressRootRecoverableErrors.push.apply(
                          workInProgressRootRecoverableErrors,
                          exitStatus
                        ));
                }
                exitStatus = errorRetryLanes$jscomp$0;
              }
              renderWasConcurrent = !1;
              if (exitStatus !== RootErrored) continue;
            }
          }
          if (exitStatus === RootFatalErrored) {
            prepareFreshStack(root, 0);
            markRootSuspended(root, lanes, 0, !0);
            break;
          }
          a: {
            shouldTimeSlice = root;
            switch (exitStatus) {
              case RootInProgress:
              case RootFatalErrored:
                throw Error("Root did not complete. This is a bug in React.");
              case RootSuspendedWithDelay:
                if ((lanes & 4194048) !== lanes) break;
              case RootSuspendedAtTheShell:
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                break a;
              case RootErrored:
                workInProgressRootRecoverableErrors = null;
                break;
              case RootSuspended:
              case RootCompleted:
                break;
              default:
                throw Error("Unknown root exit status.");
            }
            if (null !== ReactSharedInternals.actQueue)
              commitRoot(
                shouldTimeSlice,
                forceSync,
                lanes,
                workInProgressRootRecoverableErrors,
                workInProgressTransitions,
                workInProgressRootDidIncludeRecursiveRenderUpdate,
                workInProgressDeferredLane,
                workInProgressRootInterleavedUpdatedLanes,
                workInProgressSuspendedRetryLanes
              );
            else {
              if (
                (lanes & 62914560) === lanes &&
                ((renderWasConcurrent =
                  globalMostRecentFallbackTime +
                  FALLBACK_THROTTLE_MS -
                  now$1()),
                10 < renderWasConcurrent)
              ) {
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                if (0 !== getNextLanes(shouldTimeSlice, 0, !0)) break a;
                shouldTimeSlice.timeoutHandle = scheduleTimeout(
                  commitRootWhenReady.bind(
                    null,
                    shouldTimeSlice,
                    forceSync,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    exitStatus,
                    THROTTLED_COMMIT,
                    renderStartTime,
                    0
                  ),
                  renderWasConcurrent
                );
                break a;
              }
              commitRootWhenReady(
                shouldTimeSlice,
                forceSync,
                workInProgressRootRecoverableErrors,
                workInProgressTransitions,
                workInProgressRootDidIncludeRecursiveRenderUpdate,
                lanes,
                workInProgressDeferredLane,
                workInProgressRootInterleavedUpdatedLanes,
                workInProgressSuspendedRetryLanes,
                workInProgressRootDidSkipSuspendedSiblings,
                exitStatus,
                IMMEDIATE_COMMIT,
                renderStartTime,
                0
              );
            }
          }
        }
        break;
      } while (1);
      ensureRootIsScheduled(root);
    }
    function commitRootWhenReady(
      root,
      finishedWork,
      recoverableErrors,
      transitions,
      didIncludeRenderPhaseUpdate,
      lanes,
      spawnedLane,
      updatedLanes,
      suspendedRetryLanes,
      didSkipSuspendedSiblings,
      exitStatus,
      suspendedCommitReason,
      completedRenderStartTime,
      completedRenderEndTime
    ) {
      root.timeoutHandle = noTimeout;
      suspendedCommitReason = finishedWork.subtreeFlags;
      if (
        suspendedCommitReason & 8192 ||
        16785408 === (suspendedCommitReason & 16785408)
      )
        if (
          ((suspendedState = { stylesheets: null, count: 0, unsuspend: noop }),
          accumulateSuspenseyCommitOnFiber(finishedWork),
          (suspendedCommitReason = waitForCommitToBeReady()),
          null !== suspendedCommitReason)
        ) {
          root.cancelPendingCommit = suspendedCommitReason(
            commitRoot.bind(
              null,
              root,
              finishedWork,
              lanes,
              recoverableErrors,
              transitions,
              didIncludeRenderPhaseUpdate,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes,
              exitStatus,
              SUSPENDED_COMMIT,
              completedRenderStartTime,
              completedRenderEndTime
            )
          );
          markRootSuspended(
            root,
            lanes,
            spawnedLane,
            !didSkipSuspendedSiblings
          );
          return;
        }
      commitRoot(
        root,
        finishedWork,
        lanes,
        recoverableErrors,
        transitions,
        didIncludeRenderPhaseUpdate,
        spawnedLane,
        updatedLanes,
        suspendedRetryLanes
      );
    }
    function isRenderConsistentWithExternalStores(finishedWork) {
      for (var node = finishedWork; ; ) {
        var tag = node.tag;
        if (
          (0 === tag || 11 === tag || 15 === tag) &&
          node.flags & 16384 &&
          ((tag = node.updateQueue),
          null !== tag && ((tag = tag.stores), null !== tag))
        )
          for (var i = 0; i < tag.length; i++) {
            var check = tag[i],
              getSnapshot = check.getSnapshot;
            check = check.value;
            try {
              if (!objectIs(getSnapshot(), check)) return !1;
            } catch (error) {
              return !1;
            }
          }
        tag = node.child;
        if (node.subtreeFlags & 16384 && null !== tag)
          (tag.return = node), (node = tag);
        else {
          if (node === finishedWork) break;
          for (; null === node.sibling; ) {
            if (null === node.return || node.return === finishedWork) return !0;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
      }
      return !0;
    }
    function markRootSuspended(
      root,
      suspendedLanes,
      spawnedLane,
      didAttemptEntireTree
    ) {
      suspendedLanes &= ~workInProgressRootPingedLanes;
      suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
      root.suspendedLanes |= suspendedLanes;
      root.pingedLanes &= ~suspendedLanes;
      didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
      didAttemptEntireTree = root.expirationTimes;
      for (var lanes = suspendedLanes; 0 < lanes; ) {
        var index = 31 - clz32(lanes),
          lane = 1 << index;
        didAttemptEntireTree[index] = -1;
        lanes &= ~lane;
      }
      0 !== spawnedLane &&
        markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
    }
    function flushSyncWork$1() {
      return (executionContext & (RenderContext | CommitContext)) === NoContext
        ? (flushSyncWorkAcrossRoots_impl(0, !1), !1)
        : !0;
    }
    function resetWorkInProgressStack() {
      if (null !== workInProgress) {
        if (workInProgressSuspendedReason === NotSuspended)
          var interruptedWork = workInProgress.return;
        else
          (interruptedWork = workInProgress),
            resetContextDependencies(),
            resetHooksOnUnwind(interruptedWork),
            (thenableState = null),
            (thenableIndexCounter = 0),
            (interruptedWork = workInProgress);
        for (; null !== interruptedWork; )
          unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
            (interruptedWork = interruptedWork.return);
        workInProgress = null;
      }
    }
    function prepareFreshStack(root, lanes) {
      var timeoutHandle = root.timeoutHandle;
      timeoutHandle !== noTimeout &&
        ((root.timeoutHandle = noTimeout), cancelTimeout(timeoutHandle));
      timeoutHandle = root.cancelPendingCommit;
      null !== timeoutHandle &&
        ((root.cancelPendingCommit = null), timeoutHandle());
      resetWorkInProgressStack();
      workInProgressRoot = root;
      workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
      workInProgressRootRenderLanes = lanes;
      workInProgressSuspendedReason = NotSuspended;
      workInProgressThrownValue = null;
      workInProgressRootDidSkipSuspendedSiblings = !1;
      workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
      workInProgressRootDidAttachPingListener = !1;
      workInProgressRootExitStatus = RootInProgress;
      workInProgressSuspendedRetryLanes =
        workInProgressDeferredLane =
        workInProgressRootPingedLanes =
        workInProgressRootInterleavedUpdatedLanes =
        workInProgressRootSkippedLanes =
          0;
      workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
        null;
      workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
      0 !== (lanes & 8) && (lanes |= lanes & 32);
      var allEntangledLanes = root.entangledLanes;
      if (0 !== allEntangledLanes)
        for (
          root = root.entanglements, allEntangledLanes &= lanes;
          0 < allEntangledLanes;

        ) {
          var index = 31 - clz32(allEntangledLanes),
            lane = 1 << index;
          lanes |= root[index];
          allEntangledLanes &= ~lane;
        }
      entangledRenderLanes = lanes;
      finishQueueingConcurrentUpdates();
      lanes = getCurrentTime();
      1e3 < lanes - lastResetTime &&
        ((ReactSharedInternals.recentlyCreatedOwnerStacks = 0),
        (lastResetTime = lanes));
      ReactStrictModeWarnings.discardPendingWarnings();
      return timeoutHandle;
    }
    function handleThrow(root, thrownValue) {
      currentlyRenderingFiber = null;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      ReactSharedInternals.getCurrentStack = null;
      isRendering = !1;
      current = null;
      thrownValue === SuspenseException ||
      thrownValue === SuspenseActionException
        ? ((thrownValue = getSuspendedThenable()),
          (workInProgressSuspendedReason = SuspendedOnImmediate))
        : thrownValue === SuspenseyCommitException
          ? ((thrownValue = getSuspendedThenable()),
            (workInProgressSuspendedReason = SuspendedOnInstance))
          : (workInProgressSuspendedReason =
              thrownValue === SelectiveHydrationException
                ? SuspendedOnHydration
                : null !== thrownValue &&
                    "object" === typeof thrownValue &&
                    "function" === typeof thrownValue.then
                  ? SuspendedOnDeprecatedThrowPromise
                  : SuspendedOnError);
      workInProgressThrownValue = thrownValue;
      var erroredWork = workInProgress;
      if (null === erroredWork)
        (workInProgressRootExitStatus = RootFatalErrored),
          logUncaughtError(
            root,
            createCapturedValueAtFiber(thrownValue, root.current)
          );
      else
        switch (
          (erroredWork.mode & ProfileMode &&
            stopProfilerTimerIfRunningAndRecordDuration(erroredWork),
          markComponentRenderStopped(),
          workInProgressSuspendedReason)
        ) {
          case SuspendedOnError:
            null !== injectedProfilingHooks &&
              "function" ===
                typeof injectedProfilingHooks.markComponentErrored &&
              injectedProfilingHooks.markComponentErrored(
                erroredWork,
                thrownValue,
                workInProgressRootRenderLanes
              );
            break;
          case SuspendedOnData:
          case SuspendedOnAction:
          case SuspendedOnImmediate:
          case SuspendedOnDeprecatedThrowPromise:
          case SuspendedAndReadyToContinue:
            null !== injectedProfilingHooks &&
              "function" ===
                typeof injectedProfilingHooks.markComponentSuspended &&
              injectedProfilingHooks.markComponentSuspended(
                erroredWork,
                thrownValue,
                workInProgressRootRenderLanes
              );
        }
    }
    function pushDispatcher() {
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
    }
    function pushAsyncDispatcher() {
      var prevAsyncDispatcher = ReactSharedInternals.A;
      ReactSharedInternals.A = DefaultAsyncDispatcher;
      return prevAsyncDispatcher;
    }
    function renderDidSuspendDelayIfPossible() {
      workInProgressRootExitStatus = RootSuspendedWithDelay;
      workInProgressRootDidSkipSuspendedSiblings ||
        ((workInProgressRootRenderLanes & 4194048) !==
          workInProgressRootRenderLanes &&
          null !== suspenseHandlerStackCursor.current) ||
        (workInProgressRootIsPrerendering = !0);
      (0 === (workInProgressRootSkippedLanes & 134217727) &&
        0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
        null === workInProgressRoot ||
        markRootSuspended(
          workInProgressRoot,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          !1
        );
    }
    function renderRootSync(root, lanes, shouldYieldForPrerendering) {
      var prevExecutionContext = executionContext;
      executionContext |= RenderContext;
      var prevDispatcher = pushDispatcher(),
        prevAsyncDispatcher = pushAsyncDispatcher();
      if (
        workInProgressRoot !== root ||
        workInProgressRootRenderLanes !== lanes
      ) {
        if (isDevToolsPresent) {
          var memoizedUpdaters = root.memoizedUpdaters;
          0 < memoizedUpdaters.size &&
            (restorePendingUpdaters(root, workInProgressRootRenderLanes),
            memoizedUpdaters.clear());
          movePendingFibersToMemoized(root, lanes);
        }
        workInProgressTransitions = null;
        prepareFreshStack(root, lanes);
      }
      markRenderStarted(lanes);
      lanes = !1;
      memoizedUpdaters = workInProgressRootExitStatus;
      a: do
        try {
          if (
            workInProgressSuspendedReason !== NotSuspended &&
            null !== workInProgress
          ) {
            var unitOfWork = workInProgress,
              thrownValue = workInProgressThrownValue;
            switch (workInProgressSuspendedReason) {
              case SuspendedOnHydration:
                resetWorkInProgressStack();
                memoizedUpdaters = RootSuspendedAtTheShell;
                break a;
              case SuspendedOnImmediate:
              case SuspendedOnData:
              case SuspendedOnAction:
              case SuspendedOnDeprecatedThrowPromise:
                null === suspenseHandlerStackCursor.current && (lanes = !0);
                var reason = workInProgressSuspendedReason;
                workInProgressSuspendedReason = NotSuspended;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
                if (
                  shouldYieldForPrerendering &&
                  workInProgressRootIsPrerendering
                ) {
                  memoizedUpdaters = RootInProgress;
                  break a;
                }
                break;
              default:
                (reason = workInProgressSuspendedReason),
                  (workInProgressSuspendedReason = NotSuspended),
                  (workInProgressThrownValue = null),
                  throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
            }
          }
          workLoopSync();
          memoizedUpdaters = workInProgressRootExitStatus;
          break;
        } catch (thrownValue$8) {
          handleThrow(root, thrownValue$8);
        }
      while (1);
      lanes && root.shellSuspendCounter++;
      resetContextDependencies();
      executionContext = prevExecutionContext;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      markRenderStopped();
      null === workInProgress &&
        ((workInProgressRoot = null),
        (workInProgressRootRenderLanes = 0),
        finishQueueingConcurrentUpdates());
      return memoizedUpdaters;
    }
    function workLoopSync() {
      for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
    }
    function renderRootConcurrent(root, lanes) {
      var prevExecutionContext = executionContext;
      executionContext |= RenderContext;
      var prevDispatcher = pushDispatcher(),
        prevAsyncDispatcher = pushAsyncDispatcher();
      if (
        workInProgressRoot !== root ||
        workInProgressRootRenderLanes !== lanes
      ) {
        if (isDevToolsPresent) {
          var memoizedUpdaters = root.memoizedUpdaters;
          0 < memoizedUpdaters.size &&
            (restorePendingUpdaters(root, workInProgressRootRenderLanes),
            memoizedUpdaters.clear());
          movePendingFibersToMemoized(root, lanes);
        }
        workInProgressTransitions = null;
        workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
        prepareFreshStack(root, lanes);
      } else
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
          root,
          lanes
        );
      markRenderStarted(lanes);
      a: do
        try {
          if (
            workInProgressSuspendedReason !== NotSuspended &&
            null !== workInProgress
          )
            b: switch (
              ((lanes = workInProgress),
              (memoizedUpdaters = workInProgressThrownValue),
              workInProgressSuspendedReason)
            ) {
              case SuspendedOnError:
                workInProgressSuspendedReason = NotSuspended;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(
                  root,
                  lanes,
                  memoizedUpdaters,
                  SuspendedOnError
                );
                break;
              case SuspendedOnData:
              case SuspendedOnAction:
                if (isThenableResolved(memoizedUpdaters)) {
                  workInProgressSuspendedReason = NotSuspended;
                  workInProgressThrownValue = null;
                  replaySuspendedUnitOfWork(lanes);
                  break;
                }
                lanes = function () {
                  (workInProgressSuspendedReason !== SuspendedOnData &&
                    workInProgressSuspendedReason !== SuspendedOnAction) ||
                    workInProgressRoot !== root ||
                    (workInProgressSuspendedReason =
                      SuspendedAndReadyToContinue);
                  ensureRootIsScheduled(root);
                };
                memoizedUpdaters.then(lanes, lanes);
                break a;
              case SuspendedOnImmediate:
                workInProgressSuspendedReason = SuspendedAndReadyToContinue;
                break a;
              case SuspendedOnInstance:
                workInProgressSuspendedReason =
                  SuspendedOnInstanceAndReadyToContinue;
                break a;
              case SuspendedAndReadyToContinue:
                isThenableResolved(memoizedUpdaters)
                  ? ((workInProgressSuspendedReason = NotSuspended),
                    (workInProgressThrownValue = null),
                    replaySuspendedUnitOfWork(lanes))
                  : ((workInProgressSuspendedReason = NotSuspended),
                    (workInProgressThrownValue = null),
                    throwAndUnwindWorkLoop(
                      root,
                      lanes,
                      memoizedUpdaters,
                      SuspendedAndReadyToContinue
                    ));
                break;
              case SuspendedOnInstanceAndReadyToContinue:
                var resource = null;
                switch (workInProgress.tag) {
                  case 26:
                    resource = workInProgress.memoizedState;
                  case 5:
                  case 27:
                    var hostFiber = workInProgress;
                    if (resource ? preloadResource(resource) : 1) {
                      workInProgressSuspendedReason = NotSuspended;
                      workInProgressThrownValue = null;
                      var sibling = hostFiber.sibling;
                      if (null !== sibling) workInProgress = sibling;
                      else {
                        var returnFiber = hostFiber.return;
                        null !== returnFiber
                          ? ((workInProgress = returnFiber),
                            completeUnitOfWork(returnFiber))
                          : (workInProgress = null);
                      }
                      break b;
                    }
                    break;
                  default:
                    console.error(
                      "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                    );
                }
                workInProgressSuspendedReason = NotSuspended;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(
                  root,
                  lanes,
                  memoizedUpdaters,
                  SuspendedOnInstanceAndReadyToContinue
                );
                break;
              case SuspendedOnDeprecatedThrowPromise:
                workInProgressSuspendedReason = NotSuspended;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(
                  root,
                  lanes,
                  memoizedUpdaters,
                  SuspendedOnDeprecatedThrowPromise
                );
                break;
              case SuspendedOnHydration:
                resetWorkInProgressStack();
                workInProgressRootExitStatus = RootSuspendedAtTheShell;
                break a;
              default:
                throw Error(
                  "Unexpected SuspendedReason. This is a bug in React."
                );
            }
          null !== ReactSharedInternals.actQueue
            ? workLoopSync()
            : workLoopConcurrentByScheduler();
          break;
        } catch (thrownValue$9) {
          handleThrow(root, thrownValue$9);
        }
      while (1);
      resetContextDependencies();
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      executionContext = prevExecutionContext;
      if (null !== workInProgress)
        return (
          null !== injectedProfilingHooks &&
            "function" === typeof injectedProfilingHooks.markRenderYielded &&
            injectedProfilingHooks.markRenderYielded(),
          RootInProgress
        );
      markRenderStopped();
      workInProgressRoot = null;
      workInProgressRootRenderLanes = 0;
      finishQueueingConcurrentUpdates();
      return workInProgressRootExitStatus;
    }
    function workLoopConcurrentByScheduler() {
      for (; null !== workInProgress && !shouldYield(); )
        performUnitOfWork(workInProgress);
    }
    function performUnitOfWork(unitOfWork) {
      var current = unitOfWork.alternate;
      (unitOfWork.mode & ProfileMode) !== NoMode
        ? (startProfilerTimer(unitOfWork),
          (current = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current,
            unitOfWork,
            entangledRenderLanes
          )),
          stopProfilerTimerIfRunningAndRecordDuration(unitOfWork))
        : (current = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current,
            unitOfWork,
            entangledRenderLanes
          ));
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === current
        ? completeUnitOfWork(unitOfWork)
        : (workInProgress = current);
    }
    function replaySuspendedUnitOfWork(unitOfWork) {
      var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
    }
    function replayBeginWork(unitOfWork) {
      var current = unitOfWork.alternate,
        isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;
      isProfilingMode && startProfilerTimer(unitOfWork);
      switch (unitOfWork.tag) {
        case 15:
        case 0:
          current = replayFunctionComponent(
            current,
            unitOfWork,
            unitOfWork.pendingProps,
            unitOfWork.type,
            void 0,
            workInProgressRootRenderLanes
          );
          break;
        case 11:
          current = replayFunctionComponent(
            current,
            unitOfWork,
            unitOfWork.pendingProps,
            unitOfWork.type.render,
            unitOfWork.ref,
            workInProgressRootRenderLanes
          );
          break;
        case 5:
          resetHooksOnUnwind(unitOfWork);
        default:
          unwindInterruptedWork(current, unitOfWork),
            (unitOfWork = workInProgress =
              resetWorkInProgress(unitOfWork, entangledRenderLanes)),
            (current = beginWork(current, unitOfWork, entangledRenderLanes));
      }
      isProfilingMode &&
        stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
      return current;
    }
    function throwAndUnwindWorkLoop(
      root,
      unitOfWork,
      thrownValue,
      suspendedReason
    ) {
      resetContextDependencies();
      resetHooksOnUnwind(unitOfWork);
      thenableState = null;
      thenableIndexCounter = 0;
      var returnFiber = unitOfWork.return;
      try {
        if (
          throwException(
            root,
            returnFiber,
            unitOfWork,
            thrownValue,
            workInProgressRootRenderLanes
          )
        ) {
          workInProgressRootExitStatus = RootFatalErrored;
          logUncaughtError(
            root,
            createCapturedValueAtFiber(thrownValue, root.current)
          );
          workInProgress = null;
          return;
        }
      } catch (error) {
        if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
        workInProgressRootExitStatus = RootFatalErrored;
        logUncaughtError(
          root,
          createCapturedValueAtFiber(thrownValue, root.current)
        );
        workInProgress = null;
        return;
      }
      if (unitOfWork.flags & 32768) {
        if (isHydrating || suspendedReason === SuspendedOnError) root = !0;
        else if (
          workInProgressRootIsPrerendering ||
          0 !== (workInProgressRootRenderLanes & 536870912)
        )
          root = !1;
        else if (
          ((workInProgressRootDidSkipSuspendedSiblings = root = !0),
          suspendedReason === SuspendedOnData ||
            suspendedReason === SuspendedOnAction ||
            suspendedReason === SuspendedOnImmediate ||
            suspendedReason === SuspendedOnDeprecatedThrowPromise)
        )
          (suspendedReason = suspenseHandlerStackCursor.current),
            null !== suspendedReason &&
              13 === suspendedReason.tag &&
              (suspendedReason.flags |= 16384);
        unwindUnitOfWork(unitOfWork, root);
      } else completeUnitOfWork(unitOfWork);
    }
    function completeUnitOfWork(unitOfWork) {
      var completedWork = unitOfWork;
      do {
        if (0 !== (completedWork.flags & 32768)) {
          unwindUnitOfWork(
            completedWork,
            workInProgressRootDidSkipSuspendedSiblings
          );
          return;
        }
        var current = completedWork.alternate;
        unitOfWork = completedWork.return;
        startProfilerTimer(completedWork);
        current = runWithFiberInDEV(
          completedWork,
          completeWork,
          current,
          completedWork,
          entangledRenderLanes
        );
        (completedWork.mode & ProfileMode) !== NoMode &&
          stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
        if (null !== current) {
          workInProgress = current;
          return;
        }
        completedWork = completedWork.sibling;
        if (null !== completedWork) {
          workInProgress = completedWork;
          return;
        }
        workInProgress = completedWork = unitOfWork;
      } while (null !== completedWork);
      workInProgressRootExitStatus === RootInProgress &&
        (workInProgressRootExitStatus = RootCompleted);
    }
    function unwindUnitOfWork(unitOfWork, skipSiblings) {
      do {
        var next = unwindWork(unitOfWork.alternate, unitOfWork);
        if (null !== next) {
          next.flags &= 32767;
          workInProgress = next;
          return;
        }
        if ((unitOfWork.mode & ProfileMode) !== NoMode) {
          stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
          next = unitOfWork.actualDuration;
          for (var child = unitOfWork.child; null !== child; )
            (next += child.actualDuration), (child = child.sibling);
          unitOfWork.actualDuration = next;
        }
        next = unitOfWork.return;
        null !== next &&
          ((next.flags |= 32768),
          (next.subtreeFlags = 0),
          (next.deletions = null));
        if (
          !skipSiblings &&
          ((unitOfWork = unitOfWork.sibling), null !== unitOfWork)
        ) {
          workInProgress = unitOfWork;
          return;
        }
        workInProgress = unitOfWork = next;
      } while (null !== unitOfWork);
      workInProgressRootExitStatus = RootSuspendedAtTheShell;
      workInProgress = null;
    }
    function commitRoot(
      root,
      finishedWork,
      lanes,
      recoverableErrors,
      transitions,
      didIncludeRenderPhaseUpdate,
      spawnedLane,
      updatedLanes,
      suspendedRetryLanes
    ) {
      root.cancelPendingCommit = null;
      do flushPendingEffects();
      while (pendingEffectsStatus !== NO_PENDING_EFFECTS);
      ReactStrictModeWarnings.flushLegacyContextWarning();
      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
      if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
        throw Error("Should not already be working.");
      null !== injectedProfilingHooks &&
        "function" === typeof injectedProfilingHooks.markCommitStarted &&
        injectedProfilingHooks.markCommitStarted(lanes);
      if (null === finishedWork) markCommitStopped();
      else {
        0 === lanes &&
          console.error(
            "finishedLanes should not be empty during a commit. This is a bug in React."
          );
        if (finishedWork === root.current)
          throw Error(
            "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
          );
        didIncludeRenderPhaseUpdate =
          finishedWork.lanes | finishedWork.childLanes;
        didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
        markRootFinished(
          root,
          lanes,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes
        );
        root === workInProgressRoot &&
          ((workInProgress = workInProgressRoot = null),
          (workInProgressRootRenderLanes = 0));
        pendingFinishedWork = finishedWork;
        pendingEffectsRoot = root;
        pendingEffectsLanes = lanes;
        pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
        pendingPassiveTransitions = transitions;
        pendingRecoverableErrors = recoverableErrors;
        0 !== (finishedWork.subtreeFlags & 10256) ||
        0 !== (finishedWork.flags & 10256)
          ? ((root.callbackNode = null),
            (root.callbackPriority = 0),
            scheduleCallback$1(NormalPriority$1, function () {
              flushPassiveEffects(!0);
              return null;
            }))
          : ((root.callbackNode = null), (root.callbackPriority = 0));
        commitStartTime = now();
        recoverableErrors = 0 !== (finishedWork.flags & 13878);
        if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
          recoverableErrors = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          transitions = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = DiscreteEventPriority;
          spawnedLane = executionContext;
          executionContext |= CommitContext;
          try {
            commitBeforeMutationEffects(root, finishedWork, lanes);
          } finally {
            (executionContext = spawnedLane),
              (ReactDOMSharedInternals.p = transitions),
              (ReactSharedInternals.T = recoverableErrors);
          }
        }
        pendingEffectsStatus = PENDING_MUTATION_PHASE;
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
      }
    }
    function flushMutationEffects() {
      if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        var root = pendingEffectsRoot,
          finishedWork = pendingFinishedWork,
          lanes = pendingEffectsLanes,
          rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
        if (
          0 !== (finishedWork.subtreeFlags & 13878) ||
          rootMutationHasEffect
        ) {
          rootMutationHasEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = DiscreteEventPriority;
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          try {
            inProgressLanes = lanes;
            inProgressRoot = root;
            commitMutationEffectsOnFiber(finishedWork, root);
            inProgressRoot = inProgressLanes = null;
            lanes = selectionInformation;
            var curFocusedElem = getActiveElementDeep(root.containerInfo),
              priorFocusedElem = lanes.focusedElem,
              priorSelectionRange = lanes.selectionRange;
            if (
              curFocusedElem !== priorFocusedElem &&
              priorFocusedElem &&
              priorFocusedElem.ownerDocument &&
              containsNode(
                priorFocusedElem.ownerDocument.documentElement,
                priorFocusedElem
              )
            ) {
              if (
                null !== priorSelectionRange &&
                hasSelectionCapabilities(priorFocusedElem)
              ) {
                var start = priorSelectionRange.start,
                  end = priorSelectionRange.end;
                void 0 === end && (end = start);
                if ("selectionStart" in priorFocusedElem)
                  (priorFocusedElem.selectionStart = start),
                    (priorFocusedElem.selectionEnd = Math.min(
                      end,
                      priorFocusedElem.value.length
                    ));
                else {
                  var doc = priorFocusedElem.ownerDocument || document,
                    win = (doc && doc.defaultView) || window;
                  if (win.getSelection) {
                    var selection = win.getSelection(),
                      length = priorFocusedElem.textContent.length,
                      start$jscomp$0 = Math.min(
                        priorSelectionRange.start,
                        length
                      ),
                      end$jscomp$0 =
                        void 0 === priorSelectionRange.end
                          ? start$jscomp$0
                          : Math.min(priorSelectionRange.end, length);
                    !selection.extend &&
                      start$jscomp$0 > end$jscomp$0 &&
                      ((curFocusedElem = end$jscomp$0),
                      (end$jscomp$0 = start$jscomp$0),
                      (start$jscomp$0 = curFocusedElem));
                    var startMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        start$jscomp$0
                      ),
                      endMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        end$jscomp$0
                      );
                    if (
                      startMarker &&
                      endMarker &&
                      (1 !== selection.rangeCount ||
                        selection.anchorNode !== startMarker.node ||
                        selection.anchorOffset !== startMarker.offset ||
                        selection.focusNode !== endMarker.node ||
                        selection.focusOffset !== endMarker.offset)
                    ) {
                      var range = doc.createRange();
                      range.setStart(startMarker.node, startMarker.offset);
                      selection.removeAllRanges();
                      start$jscomp$0 > end$jscomp$0
                        ? (selection.addRange(range),
                          selection.extend(endMarker.node, endMarker.offset))
                        : (range.setEnd(endMarker.node, endMarker.offset),
                          selection.addRange(range));
                    }
                  }
                }
              }
              doc = [];
              for (
                selection = priorFocusedElem;
                (selection = selection.parentNode);

              )
                1 === selection.nodeType &&
                  doc.push({
                    element: selection,
                    left: selection.scrollLeft,
                    top: selection.scrollTop
                  });
              "function" === typeof priorFocusedElem.focus &&
                priorFocusedElem.focus();
              for (
                priorFocusedElem = 0;
                priorFocusedElem < doc.length;
                priorFocusedElem++
              ) {
                var info = doc[priorFocusedElem];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
            _enabled = !!eventsEnabled;
            selectionInformation = eventsEnabled = null;
          } finally {
            (executionContext = prevExecutionContext),
              (ReactDOMSharedInternals.p = previousPriority),
              (ReactSharedInternals.T = rootMutationHasEffect);
          }
        }
        root.current = finishedWork;
        pendingEffectsStatus = PENDING_LAYOUT_PHASE;
      }
    }
    function flushLayoutEffects() {
      if (pendingEffectsStatus === PENDING_LAYOUT_PHASE) {
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        var root = pendingEffectsRoot,
          finishedWork = pendingFinishedWork,
          lanes = pendingEffectsLanes,
          rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
        if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
          rootHasLayoutEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = DiscreteEventPriority;
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          try {
            null !== injectedProfilingHooks &&
              "function" ===
                typeof injectedProfilingHooks.markLayoutEffectsStarted &&
              injectedProfilingHooks.markLayoutEffectsStarted(lanes),
              (inProgressLanes = lanes),
              (inProgressRoot = root),
              commitLayoutEffectOnFiber(
                root,
                finishedWork.alternate,
                finishedWork
              ),
              (inProgressRoot = inProgressLanes = null),
              null !== injectedProfilingHooks &&
                "function" ===
                  typeof injectedProfilingHooks.markLayoutEffectsStopped &&
                injectedProfilingHooks.markLayoutEffectsStopped();
          } finally {
            (executionContext = prevExecutionContext),
              (ReactDOMSharedInternals.p = previousPriority),
              (ReactSharedInternals.T = rootHasLayoutEffect);
          }
        }
        pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;
      }
    }
    function flushSpawnedWork() {
      if (
        pendingEffectsStatus === PENDING_SPAWNED_WORK ||
        pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE
      ) {
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        requestPaint();
        var root = pendingEffectsRoot,
          finishedWork = pendingFinishedWork,
          lanes = pendingEffectsLanes,
          recoverableErrors = pendingRecoverableErrors,
          rootDidHavePassiveEffects =
            0 !== (finishedWork.subtreeFlags & 10256) ||
            0 !== (finishedWork.flags & 10256);
        rootDidHavePassiveEffects
          ? (pendingEffectsStatus = PENDING_PASSIVE_PHASE)
          : ((pendingEffectsStatus = NO_PENDING_EFFECTS),
            (pendingFinishedWork = pendingEffectsRoot = null),
            releaseRootPooledCache(root, root.pendingLanes),
            (nestedPassiveUpdateCount = 0),
            (rootWithPassiveNestedUpdates = null));
        var remainingLanes = root.pendingLanes;
        0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
        rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(root);
        rootDidHavePassiveEffects = lanesToEventPriority(lanes);
        finishedWork = finishedWork.stateNode;
        if (
          injectedHook &&
          "function" === typeof injectedHook.onCommitFiberRoot
        )
          try {
            var didError = 128 === (finishedWork.current.flags & 128);
            switch (rootDidHavePassiveEffects) {
              case DiscreteEventPriority:
                var schedulerPriority = ImmediatePriority;
                break;
              case ContinuousEventPriority:
                schedulerPriority = UserBlockingPriority;
                break;
              case DefaultEventPriority:
                schedulerPriority = NormalPriority$1;
                break;
              case IdleEventPriority:
                schedulerPriority = IdlePriority;
                break;
              default:
                schedulerPriority = NormalPriority$1;
            }
            injectedHook.onCommitFiberRoot(
              rendererID,
              finishedWork,
              schedulerPriority,
              didError
            );
          } catch (err) {
            hasLoggedError ||
              ((hasLoggedError = !0),
              console.error(
                "React instrumentation encountered an error: %s",
                err
              ));
          }
        isDevToolsPresent && root.memoizedUpdaters.clear();
        onCommitRoot();
        if (null !== recoverableErrors) {
          didError = ReactSharedInternals.T;
          schedulerPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = DiscreteEventPriority;
          ReactSharedInternals.T = null;
          try {
            var onRecoverableError = root.onRecoverableError;
            for (
              finishedWork = 0;
              finishedWork < recoverableErrors.length;
              finishedWork++
            ) {
              var recoverableError = recoverableErrors[finishedWork],
                errorInfo = makeErrorInfo(recoverableError.stack);
              runWithFiberInDEV(
                recoverableError.source,
                onRecoverableError,
                recoverableError.value,
                errorInfo
              );
            }
          } finally {
            (ReactSharedInternals.T = didError),
              (ReactDOMSharedInternals.p = schedulerPriority);
          }
        }
        0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
        ensureRootIsScheduled(root);
        remainingLanes = root.pendingLanes;
        0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42)
          ? ((nestedUpdateScheduled = !0),
            root === rootWithNestedUpdates
              ? nestedUpdateCount++
              : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root)))
          : (nestedUpdateCount = 0);
        flushSyncWorkAcrossRoots_impl(0, !1);
        markCommitStopped();
      }
    }
    function makeErrorInfo(componentStack) {
      componentStack = { componentStack: componentStack };
      Object.defineProperty(componentStack, "digest", {
        get: function () {
          console.error(
            'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
          );
        }
      });
      return componentStack;
    }
    function releaseRootPooledCache(root, remainingLanes) {
      0 === (root.pooledCacheLanes &= remainingLanes) &&
        ((remainingLanes = root.pooledCache),
        null != remainingLanes &&
          ((root.pooledCache = null), releaseCache(remainingLanes)));
    }
    function flushPendingEffects(wasDelayedCommit) {
      flushMutationEffects();
      flushLayoutEffects();
      flushSpawnedWork();
      return flushPassiveEffects(wasDelayedCommit);
    }
    function flushPassiveEffects() {
      if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return !1;
      var root = pendingEffectsRoot,
        remainingLanes = pendingEffectsRemainingLanes;
      pendingEffectsRemainingLanes = 0;
      var renderPriority = lanesToEventPriority(pendingEffectsLanes),
        priority =
          0 === DefaultEventPriority || DefaultEventPriority > renderPriority
            ? DefaultEventPriority
            : renderPriority;
      renderPriority = ReactSharedInternals.T;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = priority;
        ReactSharedInternals.T = null;
        priority = pendingPassiveTransitions;
        pendingPassiveTransitions = null;
        var root$jscomp$0 = pendingEffectsRoot,
          lanes = pendingEffectsLanes;
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        pendingFinishedWork = pendingEffectsRoot = null;
        pendingEffectsLanes = 0;
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
          throw Error("Cannot flush passive effects while already rendering.");
        isFlushingPassiveEffects = !0;
        didScheduleUpdateDuringPassiveEffects = !1;
        null !== injectedProfilingHooks &&
          "function" ===
            typeof injectedProfilingHooks.markPassiveEffectsStarted &&
          injectedProfilingHooks.markPassiveEffectsStarted(lanes);
        var prevExecutionContext = executionContext;
        executionContext |= CommitContext;
        commitPassiveUnmountOnFiber(root$jscomp$0.current);
        commitPassiveMountOnFiber(
          root$jscomp$0,
          root$jscomp$0.current,
          lanes,
          priority
        );
        null !== injectedProfilingHooks &&
          "function" ===
            typeof injectedProfilingHooks.markPassiveEffectsStopped &&
          injectedProfilingHooks.markPassiveEffectsStopped();
        commitDoubleInvokeEffectsInDEV(root$jscomp$0);
        executionContext = prevExecutionContext;
        flushSyncWorkAcrossRoots_impl(0, !1);
        didScheduleUpdateDuringPassiveEffects
          ? root$jscomp$0 === rootWithPassiveNestedUpdates
            ? nestedPassiveUpdateCount++
            : ((nestedPassiveUpdateCount = 0),
              (rootWithPassiveNestedUpdates = root$jscomp$0))
          : (nestedPassiveUpdateCount = 0);
        didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = !1;
        if (
          injectedHook &&
          "function" === typeof injectedHook.onPostCommitFiberRoot
        )
          try {
            injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
          } catch (err) {
            hasLoggedError ||
              ((hasLoggedError = !0),
              console.error(
                "React instrumentation encountered an error: %s",
                err
              ));
          }
        var stateNode = root$jscomp$0.current.stateNode;
        stateNode.effectDuration = 0;
        stateNode.passiveEffectDuration = 0;
        return !0;
      } finally {
        (ReactDOMSharedInternals.p = previousPriority),
          (ReactSharedInternals.T = renderPriority),
          releaseRootPooledCache(root, remainingLanes);
      }
    }
    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
      sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
      sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
      rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
      null !== rootFiber &&
        (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
    }
    function captureCommitPhaseError(
      sourceFiber,
      nearestMountedAncestor,
      error
    ) {
      isRunningInsertionEffect = !1;
      if (3 === sourceFiber.tag)
        captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
      else {
        for (; null !== nearestMountedAncestor; ) {
          if (3 === nearestMountedAncestor.tag) {
            captureCommitPhaseErrorOnRoot(
              nearestMountedAncestor,
              sourceFiber,
              error
            );
            return;
          }
          if (1 === nearestMountedAncestor.tag) {
            var instance = nearestMountedAncestor.stateNode;
            if (
              "function" ===
                typeof nearestMountedAncestor.type.getDerivedStateFromError ||
              ("function" === typeof instance.componentDidCatch &&
                (null === legacyErrorBoundariesThatAlreadyFailed ||
                  !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
            ) {
              sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
              error = createClassErrorUpdate(2);
              instance = enqueueUpdate(nearestMountedAncestor, error, 2);
              null !== instance &&
                (initializeClassErrorUpdate(
                  error,
                  instance,
                  nearestMountedAncestor,
                  sourceFiber
                ),
                markRootUpdated$1(instance, 2),
                ensureRootIsScheduled(instance));
              return;
            }
          }
          nearestMountedAncestor = nearestMountedAncestor.return;
        }
        console.error(
          "Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s",
          error
        );
      }
    }
    function attachPingListener(root, wakeable, lanes) {
      var pingCache = root.pingCache;
      if (null === pingCache) {
        pingCache = root.pingCache = new PossiblyWeakMap();
        var threadIDs = new Set();
        pingCache.set(wakeable, threadIDs);
      } else
        (threadIDs = pingCache.get(wakeable)),
          void 0 === threadIDs &&
            ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
      threadIDs.has(lanes) ||
        ((workInProgressRootDidAttachPingListener = !0),
        threadIDs.add(lanes),
        (pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
        isDevToolsPresent && restorePendingUpdaters(root, lanes),
        wakeable.then(pingCache, pingCache));
    }
    function pingSuspendedRoot(root, wakeable, pingedLanes) {
      var pingCache = root.pingCache;
      null !== pingCache && pingCache.delete(wakeable);
      root.pingedLanes |= root.suspendedLanes & pingedLanes;
      root.warmLanes &= ~pingedLanes;
      isConcurrentActEnvironment() &&
        null === ReactSharedInternals.actQueue &&
        console.error(
          "A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"
        );
      workInProgressRoot === root &&
        (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
        (workInProgressRootExitStatus === RootSuspendedWithDelay ||
        (workInProgressRootExitStatus === RootSuspended &&
          (workInProgressRootRenderLanes & 62914560) ===
            workInProgressRootRenderLanes &&
          now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)
          ? (executionContext & RenderContext) === NoContext &&
            prepareFreshStack(root, 0)
          : (workInProgressRootPingedLanes |= pingedLanes),
        workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes &&
          (workInProgressSuspendedRetryLanes = 0));
      ensureRootIsScheduled(root);
    }
    function retryTimedOutBoundary(boundaryFiber, retryLane) {
      0 === retryLane && (retryLane = claimNextRetryLane());
      boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
      null !== boundaryFiber &&
        (markRootUpdated$1(boundaryFiber, retryLane),
        ensureRootIsScheduled(boundaryFiber));
    }
    function retryDehydratedSuspenseBoundary(boundaryFiber) {
      var suspenseState = boundaryFiber.memoizedState,
        retryLane = 0;
      null !== suspenseState && (retryLane = suspenseState.retryLane);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function resolveRetryWakeable(boundaryFiber, wakeable) {
      var retryLane = 0;
      switch (boundaryFiber.tag) {
        case 13:
          var retryCache = boundaryFiber.stateNode;
          var suspenseState = boundaryFiber.memoizedState;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          break;
        case 19:
          retryCache = boundaryFiber.stateNode;
          break;
        case 22:
          retryCache = boundaryFiber.stateNode._retryCache;
          break;
        default:
          throw Error(
            "Pinged unknown suspense boundary type. This is probably a bug in React."
          );
      }
      null !== retryCache && retryCache.delete(wakeable);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function recursivelyTraverseAndDoubleInvokeEffectsInDEV(
      root$jscomp$0,
      parentFiber,
      isInStrictMode
    ) {
      if (0 !== (parentFiber.subtreeFlags & 67117056))
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var root = root$jscomp$0,
            fiber = parentFiber,
            isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
          isStrictModeFiber = isInStrictMode || isStrictModeFiber;
          22 !== fiber.tag
            ? fiber.flags & 67108864
              ? isStrictModeFiber &&
                runWithFiberInDEV(
                  fiber,
                  doubleInvokeEffectsOnFiber,
                  root,
                  fiber,
                  (fiber.mode & NoStrictPassiveEffectsMode) === NoMode
                )
              : recursivelyTraverseAndDoubleInvokeEffectsInDEV(
                  root,
                  fiber,
                  isStrictModeFiber
                )
            : null === fiber.memoizedState &&
              (isStrictModeFiber && fiber.flags & 8192
                ? runWithFiberInDEV(
                    fiber,
                    doubleInvokeEffectsOnFiber,
                    root,
                    fiber
                  )
                : fiber.subtreeFlags & 67108864 &&
                  runWithFiberInDEV(
                    fiber,
                    recursivelyTraverseAndDoubleInvokeEffectsInDEV,
                    root,
                    fiber,
                    isStrictModeFiber
                  ));
          parentFiber = parentFiber.sibling;
        }
    }
    function doubleInvokeEffectsOnFiber(root, fiber) {
      var shouldDoubleInvokePassiveEffects =
        2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : !0;
      setIsStrictModeForDevtools(!0);
      try {
        disappearLayoutEffects(fiber),
          shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber),
          reappearLayoutEffects(root, fiber.alternate, fiber, !1),
          shouldDoubleInvokePassiveEffects &&
            reconnectPassiveEffects(root, fiber, 0, null, !1, 0);
      } finally {
        setIsStrictModeForDevtools(!1);
      }
    }
    function commitDoubleInvokeEffectsInDEV(root) {
      var doubleInvokeEffects = !0;
      root.current.mode & (StrictLegacyMode | StrictEffectsMode) ||
        (doubleInvokeEffects = !1);
      recursivelyTraverseAndDoubleInvokeEffectsInDEV(
        root,
        root.current,
        doubleInvokeEffects
      );
    }
    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
      if ((executionContext & RenderContext) === NoContext) {
        var tag = fiber.tag;
        if (
          3 === tag ||
          1 === tag ||
          0 === tag ||
          11 === tag ||
          14 === tag ||
          15 === tag
        ) {
          tag = getComponentNameFromFiber(fiber) || "ReactComponent";
          if (null !== didWarnStateUpdateForNotYetMountedComponent) {
            if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;
            didWarnStateUpdateForNotYetMountedComponent.add(tag);
          } else didWarnStateUpdateForNotYetMountedComponent = new Set([tag]);
          runWithFiberInDEV(fiber, function () {
            console.error(
              "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead."
            );
          });
        }
      }
    }
    function restorePendingUpdaters(root, lanes) {
      isDevToolsPresent &&
        root.memoizedUpdaters.forEach(function (schedulingFiber) {
          addFiberToLanesMap(root, schedulingFiber, lanes);
        });
    }
    function scheduleCallback$1(priorityLevel, callback) {
      var actQueue = ReactSharedInternals.actQueue;
      return null !== actQueue
        ? (actQueue.push(callback), fakeActCallbackNode$1)
        : scheduleCallback$3(priorityLevel, callback);
    }
    function warnIfUpdatesNotWrappedWithActDEV(fiber) {
      isConcurrentActEnvironment() &&
        null === ReactSharedInternals.actQueue &&
        runWithFiberInDEV(fiber, function () {
          console.error(
            "An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act",
            getComponentNameFromFiber(fiber)
          );
        });
    }
    function ensureRootIsScheduled(root) {
      root !== lastScheduledRoot &&
        null === root.next &&
        (null === lastScheduledRoot
          ? (firstScheduledRoot = lastScheduledRoot = root)
          : (lastScheduledRoot = lastScheduledRoot.next = root));
      mightHavePendingSyncWork = !0;
      null !== ReactSharedInternals.actQueue
        ? didScheduleMicrotask_act ||
          ((didScheduleMicrotask_act = !0), scheduleImmediateRootScheduleTask())
        : didScheduleMicrotask ||
          ((didScheduleMicrotask = !0), scheduleImmediateRootScheduleTask());
    }
    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
      if (!isFlushingWork && mightHavePendingSyncWork) {
        isFlushingWork = !0;
        do {
          var didPerformSomeWork = !1;
          for (var root = firstScheduledRoot; null !== root; ) {
            if (!onlyLegacy)
              if (0 !== syncTransitionLanes) {
                var pendingLanes = root.pendingLanes;
                if (0 === pendingLanes) var nextLanes = 0;
                else {
                  var suspendedLanes = root.suspendedLanes,
                    pingedLanes = root.pingedLanes;
                  nextLanes =
                    (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;
                  nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                  nextLanes =
                    nextLanes & 201326741
                      ? (nextLanes & 201326741) | 1
                      : nextLanes
                        ? nextLanes | 2
                        : 0;
                }
                0 !== nextLanes &&
                  ((didPerformSomeWork = !0),
                  performSyncWorkOnRoot(root, nextLanes));
              } else
                (nextLanes = workInProgressRootRenderLanes),
                  (nextLanes = getNextLanes(
                    root,
                    root === workInProgressRoot ? nextLanes : 0,
                    null !== root.cancelPendingCommit ||
                      root.timeoutHandle !== noTimeout
                  )),
                  0 === (nextLanes & 3) ||
                    checkIfRootIsPrerendering(root, nextLanes) ||
                    ((didPerformSomeWork = !0),
                    performSyncWorkOnRoot(root, nextLanes));
            root = root.next;
          }
        } while (didPerformSomeWork);
        isFlushingWork = !1;
      }
    }
    function processRootScheduleInImmediateTask() {
      processRootScheduleInMicrotask();
    }
    function processRootScheduleInMicrotask() {
      mightHavePendingSyncWork =
        didScheduleMicrotask_act =
        didScheduleMicrotask =
          !1;
      var syncTransitionLanes = 0;
      0 !== currentEventTransitionLane &&
        (shouldAttemptEagerTransition() &&
          (syncTransitionLanes = currentEventTransitionLane),
        (currentEventTransitionLane = 0));
      for (
        var currentTime = now$1(), prev = null, root = firstScheduledRoot;
        null !== root;

      ) {
        var next = root.next,
          nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
        if (0 === nextLanes)
          (root.next = null),
            null === prev ? (firstScheduledRoot = next) : (prev.next = next),
            null === next && (lastScheduledRoot = prev);
        else if (
          ((prev = root), 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
        )
          mightHavePendingSyncWork = !0;
        root = next;
      }
      flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);
    }
    function scheduleTaskForRootDuringMicrotask(root, currentTime) {
      for (
        var suspendedLanes = root.suspendedLanes,
          pingedLanes = root.pingedLanes,
          expirationTimes = root.expirationTimes,
          lanes = root.pendingLanes & -62914561;
        0 < lanes;

      ) {
        var index = 31 - clz32(lanes),
          lane = 1 << index,
          expirationTime = expirationTimes[index];
        if (-1 === expirationTime) {
          if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
            expirationTimes[index] = computeExpirationTime(lane, currentTime);
        } else expirationTime <= currentTime && (root.expiredLanes |= lane);
        lanes &= ~lane;
      }
      currentTime = workInProgressRoot;
      suspendedLanes = workInProgressRootRenderLanes;
      suspendedLanes = getNextLanes(
        root,
        root === currentTime ? suspendedLanes : 0,
        null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout
      );
      pingedLanes = root.callbackNode;
      if (
        0 === suspendedLanes ||
        (root === currentTime &&
          (workInProgressSuspendedReason === SuspendedOnData ||
            workInProgressSuspendedReason === SuspendedOnAction)) ||
        null !== root.cancelPendingCommit
      )
        return (
          null !== pingedLanes && cancelCallback(pingedLanes),
          (root.callbackNode = null),
          (root.callbackPriority = 0)
        );
      if (
        0 === (suspendedLanes & 3) ||
        checkIfRootIsPrerendering(root, suspendedLanes)
      ) {
        currentTime = suspendedLanes & -suspendedLanes;
        if (
          currentTime !== root.callbackPriority ||
          (null !== ReactSharedInternals.actQueue &&
            pingedLanes !== fakeActCallbackNode)
        )
          cancelCallback(pingedLanes);
        else return currentTime;
        switch (lanesToEventPriority(suspendedLanes)) {
          case DiscreteEventPriority:
          case ContinuousEventPriority:
            suspendedLanes = UserBlockingPriority;
            break;
          case DefaultEventPriority:
            suspendedLanes = NormalPriority$1;
            break;
          case IdleEventPriority:
            suspendedLanes = IdlePriority;
            break;
          default:
            suspendedLanes = NormalPriority$1;
        }
        pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
        null !== ReactSharedInternals.actQueue
          ? (ReactSharedInternals.actQueue.push(pingedLanes),
            (suspendedLanes = fakeActCallbackNode))
          : (suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes));
        root.callbackPriority = currentTime;
        root.callbackNode = suspendedLanes;
        return currentTime;
      }
      null !== pingedLanes && cancelCallback(pingedLanes);
      root.callbackPriority = 2;
      root.callbackNode = null;
      return 2;
    }
    function performWorkOnRootViaSchedulerTask(root, didTimeout) {
      nestedUpdateScheduled = currentUpdateIsNested = !1;
      if (
        pendingEffectsStatus !== NO_PENDING_EFFECTS &&
        pendingEffectsStatus !== PENDING_PASSIVE_PHASE
      )
        return (root.callbackNode = null), (root.callbackPriority = 0), null;
      var originalCallbackNode = root.callbackNode;
      if (flushPendingEffects(!0) && root.callbackNode !== originalCallbackNode)
        return null;
      var workInProgressRootRenderLanes$jscomp$0 =
        workInProgressRootRenderLanes;
      workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
        root,
        root === workInProgressRoot
          ? workInProgressRootRenderLanes$jscomp$0
          : 0,
        null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout
      );
      if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
      performWorkOnRoot(
        root,
        workInProgressRootRenderLanes$jscomp$0,
        didTimeout
      );
      scheduleTaskForRootDuringMicrotask(root, now$1());
      return null != root.callbackNode &&
        root.callbackNode === originalCallbackNode
        ? performWorkOnRootViaSchedulerTask.bind(null, root)
        : null;
    }
    function performSyncWorkOnRoot(root, lanes) {
      if (flushPendingEffects()) return null;
      currentUpdateIsNested = nestedUpdateScheduled;
      nestedUpdateScheduled = !1;
      performWorkOnRoot(root, lanes, !0);
    }
    function cancelCallback(callbackNode) {
      callbackNode !== fakeActCallbackNode &&
        null !== callbackNode &&
        cancelCallback$1(callbackNode);
    }
    function scheduleImmediateRootScheduleTask() {
      null !== ReactSharedInternals.actQueue &&
        ReactSharedInternals.actQueue.push(function () {
          processRootScheduleInMicrotask();
          return null;
        });
      scheduleMicrotask(function () {
        (executionContext & (RenderContext | CommitContext)) !== NoContext
          ? scheduleCallback$3(
              ImmediatePriority,
              processRootScheduleInImmediateTask
            )
          : processRootScheduleInMicrotask();
      });
    }
    function requestTransitionLane() {
      0 === currentEventTransitionLane &&
        (currentEventTransitionLane = claimNextTransitionLane());
      return currentEventTransitionLane;
    }
    function coerceFormActionProp(actionProp) {
      if (
        null == actionProp ||
        "symbol" === typeof actionProp ||
        "boolean" === typeof actionProp
      )
        return null;
      if ("function" === typeof actionProp) return actionProp;
      checkAttributeStringCoercion(actionProp, "action");
      return sanitizeURL("" + actionProp);
    }
    function createFormDataWithSubmitter(form, submitter) {
      var temp = submitter.ownerDocument.createElement("input");
      temp.name = submitter.name;
      temp.value = submitter.value;
      form.id && temp.setAttribute("form", form.id);
      submitter.parentNode.insertBefore(temp, submitter);
      form = new FormData(form);
      temp.parentNode.removeChild(temp);
      return form;
    }
    function extractEvents$1(
      dispatchQueue,
      domEventName,
      maybeTargetInst,
      nativeEvent,
      nativeEventTarget
    ) {
      if (
        "submit" === domEventName &&
        maybeTargetInst &&
        maybeTargetInst.stateNode === nativeEventTarget
      ) {
        var action = coerceFormActionProp(
            (nativeEventTarget[internalPropsKey] || null).action
          ),
          submitter = nativeEvent.submitter;
        submitter &&
          ((domEventName = (domEventName = submitter[internalPropsKey] || null)
            ? coerceFormActionProp(domEventName.formAction)
            : submitter.getAttribute("formAction")),
          null !== domEventName &&
            ((action = domEventName), (submitter = null)));
        var event = new SyntheticEvent(
          "action",
          "action",
          null,
          nativeEvent,
          nativeEventTarget
        );
        dispatchQueue.push({
          event: event,
          listeners: [
            {
              instance: null,
              listener: function () {
                if (nativeEvent.defaultPrevented) {
                  if (0 !== currentEventTransitionLane) {
                    var formData = submitter
                        ? createFormDataWithSubmitter(
                            nativeEventTarget,
                            submitter
                          )
                        : new FormData(nativeEventTarget),
                      pendingState = {
                        pending: !0,
                        data: formData,
                        method: nativeEventTarget.method,
                        action: action
                      };
                    Object.freeze(pendingState);
                    startHostTransition(
                      maybeTargetInst,
                      pendingState,
                      null,
                      formData
                    );
                  }
                } else
                  "function" === typeof action &&
                    (event.preventDefault(),
                    (formData = submitter
                      ? createFormDataWithSubmitter(
                          nativeEventTarget,
                          submitter
                        )
                      : new FormData(nativeEventTarget)),
                    (pendingState = {
                      pending: !0,
                      data: formData,
                      method: nativeEventTarget.method,
                      action: action
                    }),
                    Object.freeze(pendingState),
                    startHostTransition(
                      maybeTargetInst,
                      pendingState,
                      action,
                      formData
                    ));
              },
              currentTarget: nativeEventTarget
            }
          ]
        });
      }
    }
    function executeDispatch(event, listener, currentTarget) {
      event.currentTarget = currentTarget;
      try {
        listener(event);
      } catch (error) {
        reportGlobalError(error);
      }
      event.currentTarget = null;
    }
    function processDispatchQueue(dispatchQueue, eventSystemFlags) {
      eventSystemFlags = 0 !== (eventSystemFlags & 4);
      for (var i = 0; i < dispatchQueue.length; i++) {
        var _dispatchQueue$i = dispatchQueue[i];
        a: {
          var previousInstance = void 0,
            event = _dispatchQueue$i.event;
          _dispatchQueue$i = _dispatchQueue$i.listeners;
          if (eventSystemFlags)
            for (
              var i$jscomp$0 = _dispatchQueue$i.length - 1;
              0 <= i$jscomp$0;
              i$jscomp$0--
            ) {
              var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
                instance = _dispatchListeners$i.instance,
                currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              null !== instance
                ? runWithFiberInDEV(
                    instance,
                    executeDispatch,
                    event,
                    _dispatchListeners$i,
                    currentTarget
                  )
                : executeDispatch(event, _dispatchListeners$i, currentTarget);
              previousInstance = instance;
            }
          else
            for (
              i$jscomp$0 = 0;
              i$jscomp$0 < _dispatchQueue$i.length;
              i$jscomp$0++
            ) {
              _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
              instance = _dispatchListeners$i.instance;
              currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              null !== instance
                ? runWithFiberInDEV(
                    instance,
                    executeDispatch,
                    event,
                    _dispatchListeners$i,
                    currentTarget
                  )
                : executeDispatch(event, _dispatchListeners$i, currentTarget);
              previousInstance = instance;
            }
        }
      }
    }
    function listenToNonDelegatedEvent(domEventName, targetElement) {
      nonDelegatedEvents.has(domEventName) ||
        console.error(
          'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
          domEventName
        );
      var listenerSet = targetElement[internalEventHandlersKey];
      void 0 === listenerSet &&
        (listenerSet = targetElement[internalEventHandlersKey] = new Set());
      var listenerSetKey = domEventName + "__bubble";
      listenerSet.has(listenerSetKey) ||
        (addTrappedEventListener(targetElement, domEventName, 2, !1),
        listenerSet.add(listenerSetKey));
    }
    function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
      nonDelegatedEvents.has(domEventName) &&
        !isCapturePhaseListener &&
        console.error(
          'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
          domEventName
        );
      var eventSystemFlags = 0;
      isCapturePhaseListener && (eventSystemFlags |= 4);
      addTrappedEventListener(
        target,
        domEventName,
        eventSystemFlags,
        isCapturePhaseListener
      );
    }
    function listenToAllSupportedEvents(rootContainerElement) {
      if (!rootContainerElement[listeningMarker]) {
        rootContainerElement[listeningMarker] = !0;
        allNativeEvents.forEach(function (domEventName) {
          "selectionchange" !== domEventName &&
            (nonDelegatedEvents.has(domEventName) ||
              listenToNativeEvent(domEventName, !1, rootContainerElement),
            listenToNativeEvent(domEventName, !0, rootContainerElement));
        });
        var ownerDocument =
          9 === rootContainerElement.nodeType
            ? rootContainerElement
            : rootContainerElement.ownerDocument;
        null === ownerDocument ||
          ownerDocument[listeningMarker] ||
          ((ownerDocument[listeningMarker] = !0),
          listenToNativeEvent("selectionchange", !1, ownerDocument));
      }
    }
    function addTrappedEventListener(
      targetContainer,
      domEventName,
      eventSystemFlags,
      isCapturePhaseListener
    ) {
      switch (getEventPriority(domEventName)) {
        case DiscreteEventPriority:
          var listenerWrapper = dispatchDiscreteEvent;
          break;
        case ContinuousEventPriority:
          listenerWrapper = dispatchContinuousEvent;
          break;
        default:
          listenerWrapper = dispatchEvent;
      }
      eventSystemFlags = listenerWrapper.bind(
        null,
        domEventName,
        eventSystemFlags,
        targetContainer
      );
      listenerWrapper = void 0;
      !passiveBrowserEventsSupported ||
        ("touchstart" !== domEventName &&
          "touchmove" !== domEventName &&
          "wheel" !== domEventName) ||
        (listenerWrapper = !0);
      isCapturePhaseListener
        ? void 0 !== listenerWrapper
          ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
              capture: !0,
              passive: listenerWrapper
            })
          : targetContainer.addEventListener(domEventName, eventSystemFlags, !0)
        : void 0 !== listenerWrapper
          ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
              passive: listenerWrapper
            })
          : targetContainer.addEventListener(
              domEventName,
              eventSystemFlags,
              !1
            );
    }
    function dispatchEventForPluginEventSystem(
      domEventName,
      eventSystemFlags,
      nativeEvent,
      targetInst$jscomp$0,
      targetContainer
    ) {
      var ancestorInst = targetInst$jscomp$0;
      if (
        0 === (eventSystemFlags & 1) &&
        0 === (eventSystemFlags & 2) &&
        null !== targetInst$jscomp$0
      )
        a: for (;;) {
          if (null === targetInst$jscomp$0) return;
          var nodeTag = targetInst$jscomp$0.tag;
          if (3 === nodeTag || 4 === nodeTag) {
            var container = targetInst$jscomp$0.stateNode.containerInfo;
            if (container === targetContainer) break;
            if (4 === nodeTag)
              for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                var grandTag = nodeTag.tag;
                if (
                  (3 === grandTag || 4 === grandTag) &&
                  nodeTag.stateNode.containerInfo === targetContainer
                )
                  return;
                nodeTag = nodeTag.return;
              }
            for (; null !== container; ) {
              nodeTag = getClosestInstanceFromNode(container);
              if (null === nodeTag) return;
              grandTag = nodeTag.tag;
              if (
                5 === grandTag ||
                6 === grandTag ||
                26 === grandTag ||
                27 === grandTag
              ) {
                targetInst$jscomp$0 = ancestorInst = nodeTag;
                continue a;
              }
              container = container.parentNode;
            }
          }
          targetInst$jscomp$0 = targetInst$jscomp$0.return;
        }
      batchedUpdates$1(function () {
        var targetInst = ancestorInst,
          nativeEventTarget = getEventTarget(nativeEvent),
          dispatchQueue = [];
        a: {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (void 0 !== reactName) {
            var SyntheticEventCtor = SyntheticEvent,
              reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (0 === getEventCharCode(nativeEvent)) break a;
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (2 === nativeEvent.button) break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
              case "scrollend":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
              case "toggle":
              case "beforetoggle":
                SyntheticEventCtor = SyntheticToggleEvent;
            }
            var inCapturePhase = 0 !== (eventSystemFlags & 4),
              accumulateTargetOnly =
                !inCapturePhase &&
                ("scroll" === domEventName || "scrollend" === domEventName),
              reactEventName = inCapturePhase
                ? null !== reactName
                  ? reactName + "Capture"
                  : null
                : reactName;
            inCapturePhase = [];
            for (
              var instance = targetInst, lastHostComponent;
              null !== instance;

            ) {
              var _instance2 = instance;
              lastHostComponent = _instance2.stateNode;
              _instance2 = _instance2.tag;
              (5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2) ||
                null === lastHostComponent ||
                null === reactEventName ||
                ((_instance2 = getListener(instance, reactEventName)),
                null != _instance2 &&
                  inCapturePhase.push(
                    createDispatchListener(
                      instance,
                      _instance2,
                      lastHostComponent
                    )
                  ));
              if (accumulateTargetOnly) break;
              instance = instance.return;
            }
            0 < inCapturePhase.length &&
              ((reactName = new SyntheticEventCtor(
                reactName,
                reactEventType,
                null,
                nativeEvent,
                nativeEventTarget
              )),
              dispatchQueue.push({
                event: reactName,
                listeners: inCapturePhase
              }));
          }
        }
        if (0 === (eventSystemFlags & 7)) {
          a: {
            reactName =
              "mouseover" === domEventName || "pointerover" === domEventName;
            SyntheticEventCtor =
              "mouseout" === domEventName || "pointerout" === domEventName;
            if (
              reactName &&
              nativeEvent !== currentReplayingEvent &&
              (reactEventType =
                nativeEvent.relatedTarget || nativeEvent.fromElement) &&
              (getClosestInstanceFromNode(reactEventType) ||
                reactEventType[internalContainerInstanceKey])
            )
              break a;
            if (SyntheticEventCtor || reactName) {
              reactName =
                nativeEventTarget.window === nativeEventTarget
                  ? nativeEventTarget
                  : (reactName = nativeEventTarget.ownerDocument)
                    ? reactName.defaultView || reactName.parentWindow
                    : window;
              if (SyntheticEventCtor) {
                if (
                  ((reactEventType =
                    nativeEvent.relatedTarget || nativeEvent.toElement),
                  (SyntheticEventCtor = targetInst),
                  (reactEventType = reactEventType
                    ? getClosestInstanceFromNode(reactEventType)
                    : null),
                  null !== reactEventType &&
                    ((accumulateTargetOnly =
                      getNearestMountedFiber(reactEventType)),
                    (inCapturePhase = reactEventType.tag),
                    reactEventType !== accumulateTargetOnly ||
                      (5 !== inCapturePhase &&
                        27 !== inCapturePhase &&
                        6 !== inCapturePhase)))
                )
                  reactEventType = null;
              } else (SyntheticEventCtor = null), (reactEventType = targetInst);
              if (SyntheticEventCtor !== reactEventType) {
                inCapturePhase = SyntheticMouseEvent;
                _instance2 = "onMouseLeave";
                reactEventName = "onMouseEnter";
                instance = "mouse";
                if (
                  "pointerout" === domEventName ||
                  "pointerover" === domEventName
                )
                  (inCapturePhase = SyntheticPointerEvent),
                    (_instance2 = "onPointerLeave"),
                    (reactEventName = "onPointerEnter"),
                    (instance = "pointer");
                accumulateTargetOnly =
                  null == SyntheticEventCtor
                    ? reactName
                    : getNodeFromInstance(SyntheticEventCtor);
                lastHostComponent =
                  null == reactEventType
                    ? reactName
                    : getNodeFromInstance(reactEventType);
                reactName = new inCapturePhase(
                  _instance2,
                  instance + "leave",
                  SyntheticEventCtor,
                  nativeEvent,
                  nativeEventTarget
                );
                reactName.target = accumulateTargetOnly;
                reactName.relatedTarget = lastHostComponent;
                _instance2 = null;
                getClosestInstanceFromNode(nativeEventTarget) === targetInst &&
                  ((inCapturePhase = new inCapturePhase(
                    reactEventName,
                    instance + "enter",
                    reactEventType,
                    nativeEvent,
                    nativeEventTarget
                  )),
                  (inCapturePhase.target = lastHostComponent),
                  (inCapturePhase.relatedTarget = accumulateTargetOnly),
                  (_instance2 = inCapturePhase));
                accumulateTargetOnly = _instance2;
                if (SyntheticEventCtor && reactEventType)
                  b: {
                    inCapturePhase = SyntheticEventCtor;
                    reactEventName = reactEventType;
                    instance = 0;
                    for (
                      lastHostComponent = inCapturePhase;
                      lastHostComponent;
                      lastHostComponent = getParent(lastHostComponent)
                    )
                      instance++;
                    lastHostComponent = 0;
                    for (
                      _instance2 = reactEventName;
                      _instance2;
                      _instance2 = getParent(_instance2)
                    )
                      lastHostComponent++;
                    for (; 0 < instance - lastHostComponent; )
                      (inCapturePhase = getParent(inCapturePhase)), instance--;
                    for (; 0 < lastHostComponent - instance; )
                      (reactEventName = getParent(reactEventName)),
                        lastHostComponent--;
                    for (; instance--; ) {
                      if (
                        inCapturePhase === reactEventName ||
                        (null !== reactEventName &&
                          inCapturePhase === reactEventName.alternate)
                      )
                        break b;
                      inCapturePhase = getParent(inCapturePhase);
                      reactEventName = getParent(reactEventName);
                    }
                    inCapturePhase = null;
                  }
                else inCapturePhase = null;
                null !== SyntheticEventCtor &&
                  accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    reactName,
                    SyntheticEventCtor,
                    inCapturePhase,
                    !1
                  );
                null !== reactEventType &&
                  null !== accumulateTargetOnly &&
                  accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    accumulateTargetOnly,
                    reactEventType,
                    inCapturePhase,
                    !0
                  );
              }
            }
          }
          a: {
            reactName = targetInst ? getNodeFromInstance(targetInst) : window;
            SyntheticEventCtor =
              reactName.nodeName && reactName.nodeName.toLowerCase();
            if (
              "select" === SyntheticEventCtor ||
              ("input" === SyntheticEventCtor && "file" === reactName.type)
            )
              var getTargetInstFunc = getTargetInstForChangeEvent;
            else if (isTextInputElement(reactName))
              if (isInputEventSupported)
                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
              else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                var handleEventFunc = handleEventsForInputEventPolyfill;
              }
            else
              (SyntheticEventCtor = reactName.nodeName),
                !SyntheticEventCtor ||
                "input" !== SyntheticEventCtor.toLowerCase() ||
                ("checkbox" !== reactName.type && "radio" !== reactName.type)
                  ? targetInst &&
                    isCustomElement(targetInst.elementType) &&
                    (getTargetInstFunc = getTargetInstForChangeEvent)
                  : (getTargetInstFunc = getTargetInstForClickEvent);
            if (
              getTargetInstFunc &&
              (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))
            ) {
              createAndAccumulateChangeEvent(
                dispatchQueue,
                getTargetInstFunc,
                nativeEvent,
                nativeEventTarget
              );
              break a;
            }
            handleEventFunc &&
              handleEventFunc(domEventName, reactName, targetInst);
            "focusout" === domEventName &&
              targetInst &&
              "number" === reactName.type &&
              null != targetInst.memoizedProps.value &&
              setDefaultValue(reactName, "number", reactName.value);
          }
          handleEventFunc = targetInst
            ? getNodeFromInstance(targetInst)
            : window;
          switch (domEventName) {
            case "focusin":
              if (
                isTextInputElement(handleEventFunc) ||
                "true" === handleEventFunc.contentEditable
              )
                (activeElement = handleEventFunc),
                  (activeElementInst = targetInst),
                  (lastSelection = null);
              break;
            case "focusout":
              lastSelection = activeElementInst = activeElement = null;
              break;
            case "mousedown":
              mouseDown = !0;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              mouseDown = !1;
              constructSelectEvent(
                dispatchQueue,
                nativeEvent,
                nativeEventTarget
              );
              break;
            case "selectionchange":
              if (skipSelectionChangeEvent) break;
            case "keydown":
            case "keyup":
              constructSelectEvent(
                dispatchQueue,
                nativeEvent,
                nativeEventTarget
              );
          }
          var fallbackData;
          if (canUseCompositionEvent)
            b: {
              switch (domEventName) {
                case "compositionstart":
                  var eventType = "onCompositionStart";
                  break b;
                case "compositionend":
                  eventType = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  eventType = "onCompositionUpdate";
                  break b;
              }
              eventType = void 0;
            }
          else
            isComposing
              ? isFallbackCompositionEnd(domEventName, nativeEvent) &&
                (eventType = "onCompositionEnd")
              : "keydown" === domEventName &&
                nativeEvent.keyCode === START_KEYCODE &&
                (eventType = "onCompositionStart");
          eventType &&
            (useFallbackCompositionData &&
              "ko" !== nativeEvent.locale &&
              (isComposing || "onCompositionStart" !== eventType
                ? "onCompositionEnd" === eventType &&
                  isComposing &&
                  (fallbackData = getData())
                : ((root = nativeEventTarget),
                  (startText = "value" in root ? root.value : root.textContent),
                  (isComposing = !0))),
            (handleEventFunc = accumulateTwoPhaseListeners(
              targetInst,
              eventType
            )),
            0 < handleEventFunc.length &&
              ((eventType = new SyntheticCompositionEvent(
                eventType,
                domEventName,
                null,
                nativeEvent,
                nativeEventTarget
              )),
              dispatchQueue.push({
                event: eventType,
                listeners: handleEventFunc
              }),
              fallbackData
                ? (eventType.data = fallbackData)
                : ((fallbackData = getDataFromCustomEvent(nativeEvent)),
                  null !== fallbackData && (eventType.data = fallbackData))));
          if (
            (fallbackData = canUseTextInputEvent
              ? getNativeBeforeInputChars(domEventName, nativeEvent)
              : getFallbackBeforeInputChars(domEventName, nativeEvent))
          )
            (eventType = accumulateTwoPhaseListeners(
              targetInst,
              "onBeforeInput"
            )),
              0 < eventType.length &&
                ((handleEventFunc = new SyntheticInputEvent(
                  "onBeforeInput",
                  "beforeinput",
                  null,
                  nativeEvent,
                  nativeEventTarget
                )),
                dispatchQueue.push({
                  event: handleEventFunc,
                  listeners: eventType
                }),
                (handleEventFunc.data = fallbackData));
          extractEvents$1(
            dispatchQueue,
            domEventName,
            targetInst,
            nativeEvent,
            nativeEventTarget
          );
        }
        processDispatchQueue(dispatchQueue, eventSystemFlags);
      });
    }
    function createDispatchListener(instance, listener, currentTarget) {
      return {
        instance: instance,
        listener: listener,
        currentTarget: currentTarget
      };
    }
    function accumulateTwoPhaseListeners(targetFiber, reactName) {
      for (
        var captureName = reactName + "Capture", listeners = [];
        null !== targetFiber;

      ) {
        var _instance3 = targetFiber,
          stateNode = _instance3.stateNode;
        _instance3 = _instance3.tag;
        (5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3) ||
          null === stateNode ||
          ((_instance3 = getListener(targetFiber, captureName)),
          null != _instance3 &&
            listeners.unshift(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ),
          (_instance3 = getListener(targetFiber, reactName)),
          null != _instance3 &&
            listeners.push(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ));
        if (3 === targetFiber.tag) return listeners;
        targetFiber = targetFiber.return;
      }
      return [];
    }
    function getParent(inst) {
      if (null === inst) return null;
      do inst = inst.return;
      while (inst && 5 !== inst.tag && 27 !== inst.tag);
      return inst ? inst : null;
    }
    function accumulateEnterLeaveListenersForEvent(
      dispatchQueue,
      event,
      target,
      common,
      inCapturePhase
    ) {
      for (
        var registrationName = event._reactName, listeners = [];
        null !== target && target !== common;

      ) {
        var _instance4 = target,
          alternate = _instance4.alternate,
          stateNode = _instance4.stateNode;
        _instance4 = _instance4.tag;
        if (null !== alternate && alternate === common) break;
        (5 !== _instance4 && 26 !== _instance4 && 27 !== _instance4) ||
          null === stateNode ||
          ((alternate = stateNode),
          inCapturePhase
            ? ((stateNode = getListener(target, registrationName)),
              null != stateNode &&
                listeners.unshift(
                  createDispatchListener(target, stateNode, alternate)
                ))
            : inCapturePhase ||
              ((stateNode = getListener(target, registrationName)),
              null != stateNode &&
                listeners.push(
                  createDispatchListener(target, stateNode, alternate)
                )));
        target = target.return;
      }
      0 !== listeners.length &&
        dispatchQueue.push({ event: event, listeners: listeners });
    }
    function validatePropertiesInDevelopment(type, props) {
      validateProperties$2(type, props);
      ("input" !== type && "textarea" !== type && "select" !== type) ||
        null == props ||
        null !== props.value ||
        didWarnValueNull ||
        ((didWarnValueNull = !0),
        "select" === type && props.multiple
          ? console.error(
              "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
              type
            )
          : console.error(
              "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
              type
            ));
      var eventRegistry = {
        registrationNameDependencies: registrationNameDependencies,
        possibleRegistrationNames: possibleRegistrationNames
      };
      isCustomElement(type) ||
        "string" === typeof props.is ||
        warnUnknownProperties(type, props, eventRegistry);
      props.contentEditable &&
        !props.suppressContentEditableWarning &&
        null != props.children &&
        console.error(
          "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
        );
    }
    function warnForPropDifference(
      propName,
      serverValue,
      clientValue,
      serverDifferences
    ) {
      serverValue !== clientValue &&
        ((clientValue = normalizeMarkupForTextOrAttribute(clientValue)),
        normalizeMarkupForTextOrAttribute(serverValue) !== clientValue &&
          (serverDifferences[propName] = serverValue));
    }
    function warnForExtraAttributes(
      domElement,
      attributeNames,
      serverDifferences
    ) {
      attributeNames.forEach(function (attributeName) {
        serverDifferences[getPropNameFromAttributeName(attributeName)] =
          "style" === attributeName
            ? getStylesObjectFromElement(domElement)
            : domElement.getAttribute(attributeName);
      });
    }
    function warnForInvalidEventListener(registrationName, listener) {
      !1 === listener
        ? console.error(
            "Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",
            registrationName,
            registrationName,
            registrationName
          )
        : console.error(
            "Expected `%s` listener to be a function, instead got a value of `%s` type.",
            registrationName,
            typeof listener
          );
    }
    function normalizeHTML(parent, html) {
      parent =
        parent.namespaceURI === MATH_NAMESPACE ||
        parent.namespaceURI === SVG_NAMESPACE
          ? parent.ownerDocument.createElementNS(
              parent.namespaceURI,
              parent.tagName
            )
          : parent.ownerDocument.createElement(parent.tagName);
      parent.innerHTML = html;
      return parent.innerHTML;
    }
    function normalizeMarkupForTextOrAttribute(markup) {
      willCoercionThrow(markup) &&
        (console.error(
          "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
          typeName(markup)
        ),
        testStringCoercion(markup));
      return ("string" === typeof markup ? markup : "" + markup)
        .replace(NORMALIZE_NEWLINES_REGEX, "\n")
        .replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
    }
    function checkForUnmatchedText(serverText, clientText) {
      clientText = normalizeMarkupForTextOrAttribute(clientText);
      return normalizeMarkupForTextOrAttribute(serverText) === clientText
        ? !0
        : !1;
    }
    function noop$1() {}
    function setProp(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "children":
          if ("string" === typeof value)
            validateTextNesting(value, tag, !1),
              "body" === tag ||
                ("textarea" === tag && "" === value) ||
                setTextContent(domElement, value);
          else if ("number" === typeof value || "bigint" === typeof value)
            validateTextNesting("" + value, tag, !1),
              "body" !== tag && setTextContent(domElement, "" + value);
          break;
        case "className":
          setValueForKnownAttribute(domElement, "class", value);
          break;
        case "tabIndex":
          setValueForKnownAttribute(domElement, "tabindex", value);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          setValueForKnownAttribute(domElement, key, value);
          break;
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "data":
          if ("object" !== tag) {
            setValueForKnownAttribute(domElement, "data", value);
            break;
          }
        case "src":
        case "href":
          if ("" === value && ("a" !== tag || "href" !== key)) {
            "src" === key
              ? console.error(
                  'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                )
              : console.error(
                  'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                );
            domElement.removeAttribute(key);
            break;
          }
          if (
            null == value ||
            "function" === typeof value ||
            "symbol" === typeof value ||
            "boolean" === typeof value
          ) {
            domElement.removeAttribute(key);
            break;
          }
          checkAttributeStringCoercion(value, key);
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "action":
        case "formAction":
          null != value &&
            ("form" === tag
              ? "formAction" === key
                ? console.error(
                    "You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."
                  )
                : "function" === typeof value &&
                  ((null == props.encType && null == props.method) ||
                    didWarnFormActionMethod ||
                    ((didWarnFormActionMethod = !0),
                    console.error(
                      "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
                    )),
                  null == props.target ||
                    didWarnFormActionTarget ||
                    ((didWarnFormActionTarget = !0),
                    console.error(
                      "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
                    )))
              : "input" === tag || "button" === tag
                ? "action" === key
                  ? console.error(
                      "You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."
                    )
                  : "input" !== tag ||
                      "submit" === props.type ||
                      "image" === props.type ||
                      didWarnFormActionType
                    ? "button" !== tag ||
                      null == props.type ||
                      "submit" === props.type ||
                      didWarnFormActionType
                      ? "function" === typeof value &&
                        (null == props.name ||
                          didWarnFormActionName ||
                          ((didWarnFormActionName = !0),
                          console.error(
                            'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
                          )),
                        (null == props.formEncType &&
                          null == props.formMethod) ||
                          didWarnFormActionMethod ||
                          ((didWarnFormActionMethod = !0),
                          console.error(
                            "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
                          )),
                        null == props.formTarget ||
                          didWarnFormActionTarget ||
                          ((didWarnFormActionTarget = !0),
                          console.error(
                            "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
                          )))
                      : ((didWarnFormActionType = !0),
                        console.error(
                          'A button can only specify a formAction along with type="submit" or no type.'
                        ))
                    : ((didWarnFormActionType = !0),
                      console.error(
                        'An input can only specify a formAction along with type="submit" or type="image".'
                      ))
                : "action" === key
                  ? console.error(
                      "You can only pass the action prop to <form>."
                    )
                  : console.error(
                      "You can only pass the formAction prop to <input> or <button>."
                    ));
          if ("function" === typeof value) {
            domElement.setAttribute(
              key,
              "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
            );
            break;
          } else
            "function" === typeof prevValue &&
              ("formAction" === key
                ? ("input" !== tag &&
                    setProp(domElement, tag, "name", props.name, props, null),
                  setProp(
                    domElement,
                    tag,
                    "formEncType",
                    props.formEncType,
                    props,
                    null
                  ),
                  setProp(
                    domElement,
                    tag,
                    "formMethod",
                    props.formMethod,
                    props,
                    null
                  ),
                  setProp(
                    domElement,
                    tag,
                    "formTarget",
                    props.formTarget,
                    props,
                    null
                  ))
                : (setProp(
                    domElement,
                    tag,
                    "encType",
                    props.encType,
                    props,
                    null
                  ),
                  setProp(domElement, tag, "method", props.method, props, null),
                  setProp(
                    domElement,
                    tag,
                    "target",
                    props.target,
                    props,
                    null
                  )));
          if (
            null == value ||
            "symbol" === typeof value ||
            "boolean" === typeof value
          ) {
            domElement.removeAttribute(key);
            break;
          }
          checkAttributeStringCoercion(value, key);
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "onClick":
          null != value &&
            ("function" !== typeof value &&
              warnForInvalidEventListener(key, value),
            (domElement.onclick = noop$1));
          break;
        case "onScroll":
          null != value &&
            ("function" !== typeof value &&
              warnForInvalidEventListener(key, value),
            listenToNonDelegatedEvent("scroll", domElement));
          break;
        case "onScrollEnd":
          null != value &&
            ("function" !== typeof value &&
              warnForInvalidEventListener(key, value),
            listenToNonDelegatedEvent("scrollend", domElement));
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value))
              throw Error(
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
              );
            key = value.__html;
            if (null != key) {
              if (null != props.children)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              domElement.innerHTML = key;
            }
          }
          break;
        case "multiple":
          domElement.multiple =
            value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "muted":
          domElement.muted =
            value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (
            null == value ||
            "function" === typeof value ||
            "boolean" === typeof value ||
            "symbol" === typeof value
          ) {
            domElement.removeAttribute("xlink:href");
            break;
          }
          checkAttributeStringCoercion(value, key);
          key = sanitizeURL("" + value);
          domElement.setAttributeNS(xlinkNamespace, "xlink:href", key);
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          null != value &&
          "function" !== typeof value &&
          "symbol" !== typeof value
            ? (checkAttributeStringCoercion(value, key),
              domElement.setAttribute(key, "" + value))
            : domElement.removeAttribute(key);
          break;
        case "inert":
          "" !== value ||
            didWarnForNewBooleanPropsWithEmptyValue[key] ||
            ((didWarnForNewBooleanPropsWithEmptyValue[key] = !0),
            console.error(
              "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
              key
            ));
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          value && "function" !== typeof value && "symbol" !== typeof value
            ? domElement.setAttribute(key, "")
            : domElement.removeAttribute(key);
          break;
        case "capture":
        case "download":
          !0 === value
            ? domElement.setAttribute(key, "")
            : !1 !== value &&
                null != value &&
                "function" !== typeof value &&
                "symbol" !== typeof value
              ? (checkAttributeStringCoercion(value, key),
                domElement.setAttribute(key, value))
              : domElement.removeAttribute(key);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          null != value &&
          "function" !== typeof value &&
          "symbol" !== typeof value &&
          !isNaN(value) &&
          1 <= value
            ? (checkAttributeStringCoercion(value, key),
              domElement.setAttribute(key, value))
            : domElement.removeAttribute(key);
          break;
        case "rowSpan":
        case "start":
          null == value ||
          "function" === typeof value ||
          "symbol" === typeof value ||
          isNaN(value)
            ? domElement.removeAttribute(key)
            : (checkAttributeStringCoercion(value, key),
              domElement.setAttribute(key, value));
          break;
        case "popover":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          setValueForAttribute(domElement, "popover", value);
          break;
        case "xlinkActuate":
          setValueForNamespacedAttribute(
            domElement,
            xlinkNamespace,
            "xlink:actuate",
            value
          );
          break;
        case "xlinkArcrole":
          setValueForNamespacedAttribute(
            domElement,
            xlinkNamespace,
            "xlink:arcrole",
            value
          );
          break;
        case "xlinkRole":
          setValueForNamespacedAttribute(
            domElement,
            xlinkNamespace,
            "xlink:role",
            value
          );
          break;
        case "xlinkShow":
          setValueForNamespacedAttribute(
            domElement,
            xlinkNamespace,
            "xlink:show",
            value
          );
          break;
        case "xlinkTitle":
          setValueForNamespacedAttribute(
            domElement,
            xlinkNamespace,
            "xlink:title",
            value
          );
          break;
        case "xlinkType":
          setValueForNamespacedAttribute(
            domElement,
            xlinkNamespace,
            "xlink:type",
            value
          );
          break;
        case "xmlBase":
          setValueForNamespacedAttribute(
            domElement,
            xmlNamespace,
            "xml:base",
            value
          );
          break;
        case "xmlLang":
          setValueForNamespacedAttribute(
            domElement,
            xmlNamespace,
            "xml:lang",
            value
          );
          break;
        case "xmlSpace":
          setValueForNamespacedAttribute(
            domElement,
            xmlNamespace,
            "xml:space",
            value
          );
          break;
        case "is":
          null != prevValue &&
            console.error(
              'Cannot update the "is" prop after it has been initialized.'
            );
          setValueForAttribute(domElement, "is", value);
          break;
        case "innerText":
        case "textContent":
          break;
        case "popoverTarget":
          didWarnPopoverTargetObject ||
            null == value ||
            "object" !== typeof value ||
            ((didWarnPopoverTargetObject = !0),
            console.error(
              "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
              value
            ));
        default:
          !(2 < key.length) ||
          ("o" !== key[0] && "O" !== key[0]) ||
          ("n" !== key[1] && "N" !== key[1])
            ? ((key = getAttributeAlias(key)),
              setValueForAttribute(domElement, key, value))
            : registrationNameDependencies.hasOwnProperty(key) &&
              null != value &&
              "function" !== typeof value &&
              warnForInvalidEventListener(key, value);
      }
    }
    function setPropOnCustomElement(
      domElement,
      tag,
      key,
      value,
      props,
      prevValue
    ) {
      switch (key) {
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value))
              throw Error(
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
              );
            key = value.__html;
            if (null != key) {
              if (null != props.children)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              domElement.innerHTML = key;
            }
          }
          break;
        case "children":
          "string" === typeof value
            ? setTextContent(domElement, value)
            : ("number" === typeof value || "bigint" === typeof value) &&
              setTextContent(domElement, "" + value);
          break;
        case "onScroll":
          null != value &&
            ("function" !== typeof value &&
              warnForInvalidEventListener(key, value),
            listenToNonDelegatedEvent("scroll", domElement));
          break;
        case "onScrollEnd":
          null != value &&
            ("function" !== typeof value &&
              warnForInvalidEventListener(key, value),
            listenToNonDelegatedEvent("scrollend", domElement));
          break;
        case "onClick":
          null != value &&
            ("function" !== typeof value &&
              warnForInvalidEventListener(key, value),
            (domElement.onclick = noop$1));
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (registrationNameDependencies.hasOwnProperty(key))
            null != value &&
              "function" !== typeof value &&
              warnForInvalidEventListener(key, value);
          else
            a: {
              if (
                "o" === key[0] &&
                "n" === key[1] &&
                ((props = key.endsWith("Capture")),
                (tag = key.slice(2, props ? key.length - 7 : void 0)),
                (prevValue = domElement[internalPropsKey] || null),
                (prevValue = null != prevValue ? prevValue[key] : null),
                "function" === typeof prevValue &&
                  domElement.removeEventListener(tag, prevValue, props),
                "function" === typeof value)
              ) {
                "function" !== typeof prevValue &&
                  null !== prevValue &&
                  (key in domElement
                    ? (domElement[key] = null)
                    : domElement.hasAttribute(key) &&
                      domElement.removeAttribute(key));
                domElement.addEventListener(tag, value, props);
                break a;
              }
              key in domElement
                ? (domElement[key] = value)
                : !0 === value
                  ? domElement.setAttribute(key, "")
                  : setValueForAttribute(domElement, key, value);
            }
      }
    }
    function setInitialProperties(domElement, tag, props) {
      validatePropertiesInDevelopment(tag, props);
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          var hasSrc = !1,
            hasSrcSet = !1,
            propKey;
          for (propKey in props)
            if (props.hasOwnProperty(propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "src":
                    hasSrc = !0;
                    break;
                  case "srcSet":
                    hasSrcSet = !0;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(
                      tag +
                        " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  default:
                    setProp(domElement, tag, propKey, propValue, props, null);
                }
            }
          hasSrcSet &&
            setProp(domElement, tag, "srcSet", props.srcSet, props, null);
          hasSrc && setProp(domElement, tag, "src", props.src, props, null);
          return;
        case "input":
          checkControlledValueProps("input", props);
          listenToNonDelegatedEvent("invalid", domElement);
          var defaultValue = (propKey = propValue = hasSrcSet = null),
            checked = null,
            defaultChecked = null;
          for (hasSrc in props)
            if (props.hasOwnProperty(hasSrc)) {
              var _propValue = props[hasSrc];
              if (null != _propValue)
                switch (hasSrc) {
                  case "name":
                    hasSrcSet = _propValue;
                    break;
                  case "type":
                    propValue = _propValue;
                    break;
                  case "checked":
                    checked = _propValue;
                    break;
                  case "defaultChecked":
                    defaultChecked = _propValue;
                    break;
                  case "value":
                    propKey = _propValue;
                    break;
                  case "defaultValue":
                    defaultValue = _propValue;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != _propValue)
                      throw Error(
                        tag +
                          " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    break;
                  default:
                    setProp(domElement, tag, hasSrc, _propValue, props, null);
                }
            }
          validateInputProps(domElement, props);
          initInput(
            domElement,
            propKey,
            defaultValue,
            checked,
            defaultChecked,
            propValue,
            hasSrcSet,
            !1
          );
          track(domElement);
          return;
        case "select":
          checkControlledValueProps("select", props);
          listenToNonDelegatedEvent("invalid", domElement);
          hasSrc = propValue = propKey = null;
          for (hasSrcSet in props)
            if (
              props.hasOwnProperty(hasSrcSet) &&
              ((defaultValue = props[hasSrcSet]), null != defaultValue)
            )
              switch (hasSrcSet) {
                case "value":
                  propKey = defaultValue;
                  break;
                case "defaultValue":
                  propValue = defaultValue;
                  break;
                case "multiple":
                  hasSrc = defaultValue;
                default:
                  setProp(
                    domElement,
                    tag,
                    hasSrcSet,
                    defaultValue,
                    props,
                    null
                  );
              }
          validateSelectProps(domElement, props);
          tag = propKey;
          props = propValue;
          domElement.multiple = !!hasSrc;
          null != tag
            ? updateOptions(domElement, !!hasSrc, tag, !1)
            : null != props && updateOptions(domElement, !!hasSrc, props, !0);
          return;
        case "textarea":
          checkControlledValueProps("textarea", props);
          listenToNonDelegatedEvent("invalid", domElement);
          propKey = hasSrcSet = hasSrc = null;
          for (propValue in props)
            if (
              props.hasOwnProperty(propValue) &&
              ((defaultValue = props[propValue]), null != defaultValue)
            )
              switch (propValue) {
                case "value":
                  hasSrc = defaultValue;
                  break;
                case "defaultValue":
                  hasSrcSet = defaultValue;
                  break;
                case "children":
                  propKey = defaultValue;
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != defaultValue)
                    throw Error(
                      "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                    );
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    propValue,
                    defaultValue,
                    props,
                    null
                  );
              }
          validateTextareaProps(domElement, props);
          initTextarea(domElement, hasSrc, hasSrcSet, propKey);
          track(domElement);
          return;
        case "option":
          validateOptionProps(domElement, props);
          for (checked in props)
            if (
              props.hasOwnProperty(checked) &&
              ((hasSrc = props[checked]), null != hasSrc)
            )
              switch (checked) {
                case "selected":
                  domElement.selected =
                    hasSrc &&
                    "function" !== typeof hasSrc &&
                    "symbol" !== typeof hasSrc;
                  break;
                default:
                  setProp(domElement, tag, checked, hasSrc, props, null);
              }
          return;
        case "dialog":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          listenToNonDelegatedEvent("cancel", domElement);
          listenToNonDelegatedEvent("close", domElement);
          break;
        case "iframe":
        case "object":
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "video":
        case "audio":
          for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
            listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
          break;
        case "image":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", domElement);
          break;
        case "embed":
        case "source":
        case "link":
          listenToNonDelegatedEvent("error", domElement),
            listenToNonDelegatedEvent("load", domElement);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (defaultChecked in props)
            if (
              props.hasOwnProperty(defaultChecked) &&
              ((hasSrc = props[defaultChecked]), null != hasSrc)
            )
              switch (defaultChecked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(
                    tag +
                      " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                  );
                default:
                  setProp(domElement, tag, defaultChecked, hasSrc, props, null);
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (_propValue in props)
              props.hasOwnProperty(_propValue) &&
                ((hasSrc = props[_propValue]),
                void 0 !== hasSrc &&
                  setPropOnCustomElement(
                    domElement,
                    tag,
                    _propValue,
                    hasSrc,
                    props,
                    void 0
                  ));
            return;
          }
      }
      for (defaultValue in props)
        props.hasOwnProperty(defaultValue) &&
          ((hasSrc = props[defaultValue]),
          null != hasSrc &&
            setProp(domElement, tag, defaultValue, hasSrc, props, null));
    }
    function updateProperties(domElement, tag, lastProps, nextProps) {
      validatePropertiesInDevelopment(tag, nextProps);
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var name = null,
            type = null,
            value = null,
            defaultValue = null,
            lastDefaultValue = null,
            checked = null,
            defaultChecked = null;
          for (propKey in lastProps) {
            var lastProp = lastProps[propKey];
            if (lastProps.hasOwnProperty(propKey) && null != lastProp)
              switch (propKey) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  lastDefaultValue = lastProp;
                default:
                  nextProps.hasOwnProperty(propKey) ||
                    setProp(
                      domElement,
                      tag,
                      propKey,
                      null,
                      nextProps,
                      lastProp
                    );
              }
          }
          for (var _propKey8 in nextProps) {
            var propKey = nextProps[_propKey8];
            lastProp = lastProps[_propKey8];
            if (
              nextProps.hasOwnProperty(_propKey8) &&
              (null != propKey || null != lastProp)
            )
              switch (_propKey8) {
                case "type":
                  type = propKey;
                  break;
                case "name":
                  name = propKey;
                  break;
                case "checked":
                  checked = propKey;
                  break;
                case "defaultChecked":
                  defaultChecked = propKey;
                  break;
                case "value":
                  value = propKey;
                  break;
                case "defaultValue":
                  defaultValue = propKey;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != propKey)
                    throw Error(
                      tag +
                        " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  break;
                default:
                  propKey !== lastProp &&
                    setProp(
                      domElement,
                      tag,
                      _propKey8,
                      propKey,
                      nextProps,
                      lastProp
                    );
              }
          }
          tag =
            "checkbox" === lastProps.type || "radio" === lastProps.type
              ? null != lastProps.checked
              : null != lastProps.value;
          nextProps =
            "checkbox" === nextProps.type || "radio" === nextProps.type
              ? null != nextProps.checked
              : null != nextProps.value;
          tag ||
            !nextProps ||
            didWarnUncontrolledToControlled ||
            (console.error(
              "A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
            ),
            (didWarnUncontrolledToControlled = !0));
          !tag ||
            nextProps ||
            didWarnControlledToUncontrolled ||
            (console.error(
              "A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
            ),
            (didWarnControlledToUncontrolled = !0));
          updateInput(
            domElement,
            value,
            defaultValue,
            lastDefaultValue,
            checked,
            defaultChecked,
            type,
            name
          );
          return;
        case "select":
          propKey = value = defaultValue = _propKey8 = null;
          for (type in lastProps)
            if (
              ((lastDefaultValue = lastProps[type]),
              lastProps.hasOwnProperty(type) && null != lastDefaultValue)
            )
              switch (type) {
                case "value":
                  break;
                case "multiple":
                  propKey = lastDefaultValue;
                default:
                  nextProps.hasOwnProperty(type) ||
                    setProp(
                      domElement,
                      tag,
                      type,
                      null,
                      nextProps,
                      lastDefaultValue
                    );
              }
          for (name in nextProps)
            if (
              ((type = nextProps[name]),
              (lastDefaultValue = lastProps[name]),
              nextProps.hasOwnProperty(name) &&
                (null != type || null != lastDefaultValue))
            )
              switch (name) {
                case "value":
                  _propKey8 = type;
                  break;
                case "defaultValue":
                  defaultValue = type;
                  break;
                case "multiple":
                  value = type;
                default:
                  type !== lastDefaultValue &&
                    setProp(
                      domElement,
                      tag,
                      name,
                      type,
                      nextProps,
                      lastDefaultValue
                    );
              }
          nextProps = defaultValue;
          tag = value;
          lastProps = propKey;
          null != _propKey8
            ? updateOptions(domElement, !!tag, _propKey8, !1)
            : !!lastProps !== !!tag &&
              (null != nextProps
                ? updateOptions(domElement, !!tag, nextProps, !0)
                : updateOptions(domElement, !!tag, tag ? [] : "", !1));
          return;
        case "textarea":
          propKey = _propKey8 = null;
          for (defaultValue in lastProps)
            if (
              ((name = lastProps[defaultValue]),
              lastProps.hasOwnProperty(defaultValue) &&
                null != name &&
                !nextProps.hasOwnProperty(defaultValue))
            )
              switch (defaultValue) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  setProp(domElement, tag, defaultValue, null, nextProps, name);
              }
          for (value in nextProps)
            if (
              ((name = nextProps[value]),
              (type = lastProps[value]),
              nextProps.hasOwnProperty(value) && (null != name || null != type))
            )
              switch (value) {
                case "value":
                  _propKey8 = name;
                  break;
                case "defaultValue":
                  propKey = name;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != name)
                    throw Error(
                      "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                    );
                  break;
                default:
                  name !== type &&
                    setProp(domElement, tag, value, name, nextProps, type);
              }
          updateTextarea(domElement, _propKey8, propKey);
          return;
        case "option":
          for (var _propKey13 in lastProps)
            if (
              ((_propKey8 = lastProps[_propKey13]),
              lastProps.hasOwnProperty(_propKey13) &&
                null != _propKey8 &&
                !nextProps.hasOwnProperty(_propKey13))
            )
              switch (_propKey13) {
                case "selected":
                  domElement.selected = !1;
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    _propKey13,
                    null,
                    nextProps,
                    _propKey8
                  );
              }
          for (lastDefaultValue in nextProps)
            if (
              ((_propKey8 = nextProps[lastDefaultValue]),
              (propKey = lastProps[lastDefaultValue]),
              nextProps.hasOwnProperty(lastDefaultValue) &&
                _propKey8 !== propKey &&
                (null != _propKey8 || null != propKey))
            )
              switch (lastDefaultValue) {
                case "selected":
                  domElement.selected =
                    _propKey8 &&
                    "function" !== typeof _propKey8 &&
                    "symbol" !== typeof _propKey8;
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    lastDefaultValue,
                    _propKey8,
                    nextProps,
                    propKey
                  );
              }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var _propKey15 in lastProps)
            (_propKey8 = lastProps[_propKey15]),
              lastProps.hasOwnProperty(_propKey15) &&
                null != _propKey8 &&
                !nextProps.hasOwnProperty(_propKey15) &&
                setProp(
                  domElement,
                  tag,
                  _propKey15,
                  null,
                  nextProps,
                  _propKey8
                );
          for (checked in nextProps)
            if (
              ((_propKey8 = nextProps[checked]),
              (propKey = lastProps[checked]),
              nextProps.hasOwnProperty(checked) &&
                _propKey8 !== propKey &&
                (null != _propKey8 || null != propKey))
            )
              switch (checked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != _propKey8)
                    throw Error(
                      tag +
                        " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    checked,
                    _propKey8,
                    nextProps,
                    propKey
                  );
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (var _propKey17 in lastProps)
              (_propKey8 = lastProps[_propKey17]),
                lastProps.hasOwnProperty(_propKey17) &&
                  void 0 !== _propKey8 &&
                  !nextProps.hasOwnProperty(_propKey17) &&
                  setPropOnCustomElement(
                    domElement,
                    tag,
                    _propKey17,
                    void 0,
                    nextProps,
                    _propKey8
                  );
            for (defaultChecked in nextProps)
              (_propKey8 = nextProps[defaultChecked]),
                (propKey = lastProps[defaultChecked]),
                !nextProps.hasOwnProperty(defaultChecked) ||
                  _propKey8 === propKey ||
                  (void 0 === _propKey8 && void 0 === propKey) ||
                  setPropOnCustomElement(
                    domElement,
                    tag,
                    defaultChecked,
                    _propKey8,
                    nextProps,
                    propKey
                  );
            return;
          }
      }
      for (var _propKey19 in lastProps)
        (_propKey8 = lastProps[_propKey19]),
          lastProps.hasOwnProperty(_propKey19) &&
            null != _propKey8 &&
            !nextProps.hasOwnProperty(_propKey19) &&
            setProp(domElement, tag, _propKey19, null, nextProps, _propKey8);
      for (lastProp in nextProps)
        (_propKey8 = nextProps[lastProp]),
          (propKey = lastProps[lastProp]),
          !nextProps.hasOwnProperty(lastProp) ||
            _propKey8 === propKey ||
            (null == _propKey8 && null == propKey) ||
            setProp(domElement, tag, lastProp, _propKey8, nextProps, propKey);
    }
    function getPropNameFromAttributeName(attrName) {
      switch (attrName) {
        case "class":
          return "className";
        case "for":
          return "htmlFor";
        default:
          return attrName;
      }
    }
    function getStylesObjectFromElement(domElement) {
      var serverValueInObjectForm = {};
      domElement = domElement.style;
      for (var i = 0; i < domElement.length; i++) {
        var styleName = domElement[i];
        serverValueInObjectForm[styleName] =
          domElement.getPropertyValue(styleName);
      }
      return serverValueInObjectForm;
    }
    function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {
      if (null != value$jscomp$0 && "object" !== typeof value$jscomp$0)
        console.error(
          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
        );
      else {
        var clientValue;
        var delimiter = (clientValue = ""),
          styleName;
        for (styleName in value$jscomp$0)
          if (value$jscomp$0.hasOwnProperty(styleName)) {
            var value = value$jscomp$0[styleName];
            null != value &&
              "boolean" !== typeof value &&
              "" !== value &&
              (0 === styleName.indexOf("--")
                ? (checkCSSPropertyStringCoercion(value, styleName),
                  (clientValue +=
                    delimiter + styleName + ":" + ("" + value).trim()))
                : "number" !== typeof value ||
                    0 === value ||
                    unitlessNumbers.has(styleName)
                  ? (checkCSSPropertyStringCoercion(value, styleName),
                    (clientValue +=
                      delimiter +
                      styleName
                        .replace(uppercasePattern, "-$1")
                        .toLowerCase()
                        .replace(msPattern$1, "-ms-") +
                      ":" +
                      ("" + value).trim()))
                  : (clientValue +=
                      delimiter +
                      styleName
                        .replace(uppercasePattern, "-$1")
                        .toLowerCase()
                        .replace(msPattern$1, "-ms-") +
                      ":" +
                      value +
                      "px"),
              (delimiter = ";"));
          }
        clientValue = clientValue || null;
        value$jscomp$0 = domElement.getAttribute("style");
        value$jscomp$0 !== clientValue &&
          ((clientValue = normalizeMarkupForTextOrAttribute(clientValue)),
          normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue &&
            (serverDifferences.style = getStylesObjectFromElement(domElement)));
      }
    }
    function hydrateAttribute(
      domElement,
      propKey,
      attributeName,
      value,
      extraAttributes,
      serverDifferences
    ) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement)
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
        }
      else if (null != value)
        switch (typeof value) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (
              (checkAttributeStringCoercion(value, propKey),
              domElement === "" + value)
            )
              return;
        }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateBooleanAttribute(
      domElement,
      propKey,
      attributeName,
      value,
      extraAttributes,
      serverDifferences
    ) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement) {
        switch (typeof value) {
          case "function":
          case "symbol":
            return;
        }
        if (!value) return;
      } else
        switch (typeof value) {
          case "function":
          case "symbol":
            break;
          default:
            if (value) return;
        }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateBooleanishAttribute(
      domElement,
      propKey,
      attributeName,
      value,
      extraAttributes,
      serverDifferences
    ) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement)
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
            return;
        }
      else if (null != value)
        switch (typeof value) {
          case "function":
          case "symbol":
            break;
          default:
            if (
              (checkAttributeStringCoercion(value, attributeName),
              domElement === "" + value)
            )
              return;
        }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateNumericAttribute(
      domElement,
      propKey,
      attributeName,
      value,
      extraAttributes,
      serverDifferences
    ) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement)
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
          default:
            if (isNaN(value)) return;
        }
      else if (null != value)
        switch (typeof value) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (
              !isNaN(value) &&
              (checkAttributeStringCoercion(value, propKey),
              domElement === "" + value)
            )
              return;
        }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateSanitizedAttribute(
      domElement,
      propKey,
      attributeName,
      value,
      extraAttributes,
      serverDifferences
    ) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement)
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
        }
      else if (null != value)
        switch (typeof value) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (
              (checkAttributeStringCoercion(value, propKey),
              (attributeName = sanitizeURL("" + value)),
              domElement === attributeName)
            )
              return;
        }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function diffHydratedProperties(domElement, tag, props, hostContext) {
      for (
        var serverDifferences = {},
          extraAttributes = new Set(),
          attributes = domElement.attributes,
          i = 0;
        i < attributes.length;
        i++
      )
        switch (attributes[i].name.toLowerCase()) {
          case "value":
            break;
          case "checked":
            break;
          case "selected":
            break;
          default:
            extraAttributes.add(attributes[i].name);
        }
      if (isCustomElement(tag))
        for (var propKey in props) {
          if (props.hasOwnProperty(propKey)) {
            var value = props[propKey];
            if (null != value)
              if (registrationNameDependencies.hasOwnProperty(propKey))
                "function" !== typeof value &&
                  warnForInvalidEventListener(propKey, value);
              else if (!0 !== props.suppressHydrationWarning)
                switch (propKey) {
                  case "children":
                    ("string" !== typeof value && "number" !== typeof value) ||
                      warnForPropDifference(
                        "children",
                        domElement.textContent,
                        value,
                        serverDifferences
                      );
                    continue;
                  case "suppressContentEditableWarning":
                  case "suppressHydrationWarning":
                  case "defaultValue":
                  case "defaultChecked":
                  case "innerHTML":
                  case "ref":
                    continue;
                  case "dangerouslySetInnerHTML":
                    attributes = domElement.innerHTML;
                    value = value ? value.__html : void 0;
                    null != value &&
                      ((value = normalizeHTML(domElement, value)),
                      warnForPropDifference(
                        propKey,
                        attributes,
                        value,
                        serverDifferences
                      ));
                    continue;
                  case "style":
                    extraAttributes.delete(propKey);
                    diffHydratedStyles(domElement, value, serverDifferences);
                    continue;
                  case "offsetParent":
                  case "offsetTop":
                  case "offsetLeft":
                  case "offsetWidth":
                  case "offsetHeight":
                  case "isContentEditable":
                  case "outerText":
                  case "outerHTML":
                    extraAttributes.delete(propKey.toLowerCase());
                    console.error(
                      "Assignment to read-only property will result in a no-op: `%s`",
                      propKey
                    );
                    continue;
                  case "className":
                    extraAttributes.delete("class");
                    attributes = getValueForAttributeOnCustomComponent(
                      domElement,
                      "class",
                      value
                    );
                    warnForPropDifference(
                      "className",
                      attributes,
                      value,
                      serverDifferences
                    );
                    continue;
                  default:
                    hostContext.context === HostContextNamespaceNone &&
                    "svg" !== tag &&
                    "math" !== tag
                      ? extraAttributes.delete(propKey.toLowerCase())
                      : extraAttributes.delete(propKey),
                      (attributes = getValueForAttributeOnCustomComponent(
                        domElement,
                        propKey,
                        value
                      )),
                      warnForPropDifference(
                        propKey,
                        attributes,
                        value,
                        serverDifferences
                      );
                }
          }
        }
      else
        for (value in props)
          if (
            props.hasOwnProperty(value) &&
            ((propKey = props[value]), null != propKey)
          )
            if (registrationNameDependencies.hasOwnProperty(value))
              "function" !== typeof propKey &&
                warnForInvalidEventListener(value, propKey);
            else if (!0 !== props.suppressHydrationWarning)
              switch (value) {
                case "children":
                  ("string" !== typeof propKey &&
                    "number" !== typeof propKey) ||
                    warnForPropDifference(
                      "children",
                      domElement.textContent,
                      propKey,
                      serverDifferences
                    );
                  continue;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "value":
                case "checked":
                case "selected":
                case "defaultValue":
                case "defaultChecked":
                case "innerHTML":
                case "ref":
                  continue;
                case "dangerouslySetInnerHTML":
                  attributes = domElement.innerHTML;
                  propKey = propKey ? propKey.__html : void 0;
                  null != propKey &&
                    ((propKey = normalizeHTML(domElement, propKey)),
                    attributes !== propKey &&
                      (serverDifferences[value] = { __html: attributes }));
                  continue;
                case "className":
                  hydrateAttribute(
                    domElement,
                    value,
                    "class",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "tabIndex":
                  hydrateAttribute(
                    domElement,
                    value,
                    "tabindex",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "style":
                  extraAttributes.delete(value);
                  diffHydratedStyles(domElement, propKey, serverDifferences);
                  continue;
                case "multiple":
                  extraAttributes.delete(value);
                  warnForPropDifference(
                    value,
                    domElement.multiple,
                    propKey,
                    serverDifferences
                  );
                  continue;
                case "muted":
                  extraAttributes.delete(value);
                  warnForPropDifference(
                    value,
                    domElement.muted,
                    propKey,
                    serverDifferences
                  );
                  continue;
                case "autoFocus":
                  extraAttributes.delete("autofocus");
                  warnForPropDifference(
                    value,
                    domElement.autofocus,
                    propKey,
                    serverDifferences
                  );
                  continue;
                case "data":
                  if ("object" !== tag) {
                    extraAttributes.delete(value);
                    attributes = domElement.getAttribute("data");
                    warnForPropDifference(
                      value,
                      attributes,
                      propKey,
                      serverDifferences
                    );
                    continue;
                  }
                case "src":
                case "href":
                  if (
                    !(
                      "" !== propKey ||
                      ("a" === tag && "href" === value) ||
                      ("object" === tag && "data" === value)
                    )
                  ) {
                    "src" === value
                      ? console.error(
                          'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        )
                      : console.error(
                          'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        );
                    continue;
                  }
                  hydrateSanitizedAttribute(
                    domElement,
                    value,
                    value,
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "action":
                case "formAction":
                  attributes = domElement.getAttribute(value);
                  if ("function" === typeof propKey) {
                    extraAttributes.delete(value.toLowerCase());
                    "formAction" === value
                      ? (extraAttributes.delete("name"),
                        extraAttributes.delete("formenctype"),
                        extraAttributes.delete("formmethod"),
                        extraAttributes.delete("formtarget"))
                      : (extraAttributes.delete("enctype"),
                        extraAttributes.delete("method"),
                        extraAttributes.delete("target"));
                    continue;
                  } else if (attributes === EXPECTED_FORM_ACTION_URL) {
                    extraAttributes.delete(value.toLowerCase());
                    warnForPropDifference(
                      value,
                      "function",
                      propKey,
                      serverDifferences
                    );
                    continue;
                  }
                  hydrateSanitizedAttribute(
                    domElement,
                    value,
                    value.toLowerCase(),
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xlinkHref":
                  hydrateSanitizedAttribute(
                    domElement,
                    value,
                    "xlink:href",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "contentEditable":
                  hydrateBooleanishAttribute(
                    domElement,
                    value,
                    "contenteditable",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "spellCheck":
                  hydrateBooleanishAttribute(
                    domElement,
                    value,
                    "spellcheck",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "draggable":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                  hydrateBooleanishAttribute(
                    domElement,
                    value,
                    value,
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                  hydrateBooleanAttribute(
                    domElement,
                    value,
                    value.toLowerCase(),
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "capture":
                case "download":
                  a: {
                    i = domElement;
                    var attributeName = (attributes = value),
                      serverDifferences$jscomp$0 = serverDifferences;
                    extraAttributes.delete(attributeName);
                    i = i.getAttribute(attributeName);
                    if (null === i)
                      switch (typeof propKey) {
                        case "undefined":
                        case "function":
                        case "symbol":
                          break a;
                        default:
                          if (!1 === propKey) break a;
                      }
                    else if (null != propKey)
                      switch (typeof propKey) {
                        case "function":
                        case "symbol":
                          break;
                        case "boolean":
                          if (!0 === propKey && "" === i) break a;
                          break;
                        default:
                          if (
                            (checkAttributeStringCoercion(propKey, attributes),
                            i === "" + propKey)
                          )
                            break a;
                      }
                    warnForPropDifference(
                      attributes,
                      i,
                      propKey,
                      serverDifferences$jscomp$0
                    );
                  }
                  continue;
                case "cols":
                case "rows":
                case "size":
                case "span":
                  a: {
                    i = domElement;
                    attributeName = attributes = value;
                    serverDifferences$jscomp$0 = serverDifferences;
                    extraAttributes.delete(attributeName);
                    i = i.getAttribute(attributeName);
                    if (null === i)
                      switch (typeof propKey) {
                        case "undefined":
                        case "function":
                        case "symbol":
                        case "boolean":
                          break a;
                        default:
                          if (isNaN(propKey) || 1 > propKey) break a;
                      }
                    else if (null != propKey)
                      switch (typeof propKey) {
                        case "function":
                        case "symbol":
                        case "boolean":
                          break;
                        default:
                          if (
                            !(isNaN(propKey) || 1 > propKey) &&
                            (checkAttributeStringCoercion(propKey, attributes),
                            i === "" + propKey)
                          )
                            break a;
                      }
                    warnForPropDifference(
                      attributes,
                      i,
                      propKey,
                      serverDifferences$jscomp$0
                    );
                  }
                  continue;
                case "rowSpan":
                  hydrateNumericAttribute(
                    domElement,
                    value,
                    "rowspan",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "start":
                  hydrateNumericAttribute(
                    domElement,
                    value,
                    value,
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xHeight":
                  hydrateAttribute(
                    domElement,
                    value,
                    "x-height",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xlinkActuate":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xlink:actuate",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xlinkArcrole":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xlink:arcrole",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xlinkRole":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xlink:role",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xlinkShow":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xlink:show",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xlinkTitle":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xlink:title",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xlinkType":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xlink:type",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xmlBase":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xml:base",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xmlLang":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xml:lang",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xmlSpace":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xml:space",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "inert":
                  "" !== propKey ||
                    didWarnForNewBooleanPropsWithEmptyValue[value] ||
                    ((didWarnForNewBooleanPropsWithEmptyValue[value] = !0),
                    console.error(
                      "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                      value
                    ));
                  hydrateBooleanAttribute(
                    domElement,
                    value,
                    value,
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                default:
                  if (
                    !(2 < value.length) ||
                    ("o" !== value[0] && "O" !== value[0]) ||
                    ("n" !== value[1] && "N" !== value[1])
                  ) {
                    i = getAttributeAlias(value);
                    attributes = !1;
                    hostContext.context === HostContextNamespaceNone &&
                    "svg" !== tag &&
                    "math" !== tag
                      ? extraAttributes.delete(i.toLowerCase())
                      : ((attributeName = value.toLowerCase()),
                        (attributeName = possibleStandardNames.hasOwnProperty(
                          attributeName
                        )
                          ? possibleStandardNames[attributeName] || null
                          : null),
                        null !== attributeName &&
                          attributeName !== value &&
                          ((attributes = !0),
                          extraAttributes.delete(attributeName)),
                        extraAttributes.delete(i));
                    a: if (
                      ((attributeName = domElement),
                      (serverDifferences$jscomp$0 = i),
                      (i = propKey),
                      isAttributeNameSafe(serverDifferences$jscomp$0))
                    )
                      if (
                        attributeName.hasAttribute(serverDifferences$jscomp$0)
                      )
                        (attributeName = attributeName.getAttribute(
                          serverDifferences$jscomp$0
                        )),
                          checkAttributeStringCoercion(
                            i,
                            serverDifferences$jscomp$0
                          ),
                          (i = attributeName === "" + i ? i : attributeName);
                      else {
                        switch (typeof i) {
                          case "function":
                          case "symbol":
                            break a;
                          case "boolean":
                            if (
                              ((attributeName = serverDifferences$jscomp$0
                                .toLowerCase()
                                .slice(0, 5)),
                              "data-" !== attributeName &&
                                "aria-" !== attributeName)
                            )
                              break a;
                        }
                        i = void 0 === i ? void 0 : null;
                      }
                    else i = void 0;
                    attributes ||
                      warnForPropDifference(
                        value,
                        i,
                        propKey,
                        serverDifferences
                      );
                  }
              }
      0 < extraAttributes.size &&
        !0 !== props.suppressHydrationWarning &&
        warnForExtraAttributes(domElement, extraAttributes, serverDifferences);
      return 0 === Object.keys(serverDifferences).length
        ? null
        : serverDifferences;
    }
    function propNamesListJoin(list, combinator) {
      switch (list.length) {
        case 0:
          return "";
        case 1:
          return list[0];
        case 2:
          return list[0] + " " + combinator + " " + list[1];
        default:
          return (
            list.slice(0, -1).join(", ") +
            ", " +
            combinator +
            " " +
            list[list.length - 1]
          );
      }
    }
    function getOwnerDocumentFromRootContainer(rootContainerElement) {
      return 9 === rootContainerElement.nodeType
        ? rootContainerElement
        : rootContainerElement.ownerDocument;
    }
    function getOwnHostContext(namespaceURI) {
      switch (namespaceURI) {
        case SVG_NAMESPACE:
          return HostContextNamespaceSvg;
        case MATH_NAMESPACE:
          return HostContextNamespaceMath;
        default:
          return HostContextNamespaceNone;
      }
    }
    function getChildHostContextProd(parentNamespace, type) {
      if (parentNamespace === HostContextNamespaceNone)
        switch (type) {
          case "svg":
            return HostContextNamespaceSvg;
          case "math":
            return HostContextNamespaceMath;
          default:
            return HostContextNamespaceNone;
        }
      return parentNamespace === HostContextNamespaceSvg &&
        "foreignObject" === type
        ? HostContextNamespaceNone
        : parentNamespace;
    }
    function shouldSetTextContent(type, props) {
      return (
        "textarea" === type ||
        "noscript" === type ||
        "string" === typeof props.children ||
        "number" === typeof props.children ||
        "bigint" === typeof props.children ||
        ("object" === typeof props.dangerouslySetInnerHTML &&
          null !== props.dangerouslySetInnerHTML &&
          null != props.dangerouslySetInnerHTML.__html)
      );
    }
    function shouldAttemptEagerTransition() {
      var event = window.event;
      if (event && "popstate" === event.type) {
        if (event === currentPopstateTransitionEvent) return !1;
        currentPopstateTransitionEvent = event;
        return !0;
      }
      currentPopstateTransitionEvent = null;
      return !1;
    }
    function handleErrorInNextTick(error) {
      setTimeout(function () {
        throw error;
      });
    }
    function commitMount(domElement, type, newProps) {
      switch (type) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          newProps.autoFocus && domElement.focus();
          break;
        case "img":
          newProps.src
            ? (domElement.src = newProps.src)
            : newProps.srcSet && (domElement.srcset = newProps.srcSet);
      }
    }
    function commitUpdate(domElement, type, oldProps, newProps) {
      updateProperties(domElement, type, oldProps, newProps);
      domElement[internalPropsKey] = newProps;
    }
    function resetTextContent(domElement) {
      setTextContent(domElement, "");
    }
    function commitTextUpdate(textInstance, oldText, newText) {
      textInstance.nodeValue = newText;
    }
    function isSingletonScope(type) {
      return "head" === type;
    }
    function removeChild(parentInstance, child) {
      parentInstance.removeChild(child);
    }
    function removeChildFromContainer(container, child) {
      (9 === container.nodeType
        ? container.body
        : "HTML" === container.nodeName
          ? container.ownerDocument.body
          : container
      ).removeChild(child);
    }
    function clearSuspenseBoundary(parentInstance, suspenseInstance) {
      var node = suspenseInstance,
        possiblePreambleContribution = 0,
        depth = 0;
      do {
        var nextNode = node.nextSibling;
        parentInstance.removeChild(node);
        if (nextNode && 8 === nextNode.nodeType)
          if (((node = nextNode.data), node === SUSPENSE_END_DATA)) {
            if (
              0 < possiblePreambleContribution &&
              8 > possiblePreambleContribution
            ) {
              node = possiblePreambleContribution;
              var ownerDocument = parentInstance.ownerDocument;
              node & PREAMBLE_CONTRIBUTION_HTML &&
                releaseSingletonInstance(ownerDocument.documentElement);
              node & PREAMBLE_CONTRIBUTION_BODY &&
                releaseSingletonInstance(ownerDocument.body);
              if (node & PREAMBLE_CONTRIBUTION_HEAD)
                for (
                  node = ownerDocument.head,
                    releaseSingletonInstance(node),
                    ownerDocument = node.firstChild;
                  ownerDocument;

                ) {
                  var nextNode$jscomp$0 = ownerDocument.nextSibling,
                    nodeName = ownerDocument.nodeName;
                  ownerDocument[internalHoistableMarker] ||
                    "SCRIPT" === nodeName ||
                    "STYLE" === nodeName ||
                    ("LINK" === nodeName &&
                      "stylesheet" === ownerDocument.rel.toLowerCase()) ||
                    node.removeChild(ownerDocument);
                  ownerDocument = nextNode$jscomp$0;
                }
            }
            if (0 === depth) {
              parentInstance.removeChild(nextNode);
              retryIfBlockedOn(suspenseInstance);
              return;
            }
            depth--;
          } else
            node === SUSPENSE_START_DATA ||
            node === SUSPENSE_PENDING_START_DATA ||
            node === SUSPENSE_FALLBACK_START_DATA
              ? depth++
              : (possiblePreambleContribution = node.charCodeAt(0) - 48);
        else possiblePreambleContribution = 0;
        node = nextNode;
      } while (node);
      retryIfBlockedOn(suspenseInstance);
    }
    function hideInstance(instance) {
      instance = instance.style;
      "function" === typeof instance.setProperty
        ? instance.setProperty("display", "none", "important")
        : (instance.display = "none");
    }
    function hideTextInstance(textInstance) {
      textInstance.nodeValue = "";
    }
    function unhideInstance(instance, props) {
      props = props[STYLE];
      props =
        void 0 !== props && null !== props && props.hasOwnProperty("display")
          ? props.display
          : null;
      instance.style.display =
        null == props || "boolean" === typeof props ? "" : ("" + props).trim();
    }
    function unhideTextInstance(textInstance, text) {
      textInstance.nodeValue = text;
    }
    function clearContainerSparingly(container) {
      var nextNode = container.firstChild;
      nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
      for (; nextNode; ) {
        var node = nextNode;
        nextNode = nextNode.nextSibling;
        switch (node.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            clearContainerSparingly(node);
            detachDeletedInstance(node);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if ("stylesheet" === node.rel.toLowerCase()) continue;
        }
        container.removeChild(node);
      }
    }
    function canHydrateInstance(instance, type, props, inRootOrSingleton) {
      for (; 1 === instance.nodeType; ) {
        var anyProps = props;
        if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
          if (
            !inRootOrSingleton &&
            ("INPUT" !== instance.nodeName || "hidden" !== instance.type)
          )
            break;
        } else if (!inRootOrSingleton)
          if ("input" === type && "hidden" === instance.type) {
            checkAttributeStringCoercion(anyProps.name, "name");
            var name = null == anyProps.name ? null : "" + anyProps.name;
            if (
              "hidden" === anyProps.type &&
              instance.getAttribute("name") === name
            )
              return instance;
          } else return instance;
        else if (!instance[internalHoistableMarker])
          switch (type) {
            case "meta":
              if (!instance.hasAttribute("itemprop")) break;
              return instance;
            case "link":
              name = instance.getAttribute("rel");
              if (
                "stylesheet" === name &&
                instance.hasAttribute("data-precedence")
              )
                break;
              else if (
                name !== anyProps.rel ||
                instance.getAttribute("href") !==
                  (null == anyProps.href || "" === anyProps.href
                    ? null
                    : anyProps.href) ||
                instance.getAttribute("crossorigin") !==
                  (null == anyProps.crossOrigin
                    ? null
                    : anyProps.crossOrigin) ||
                instance.getAttribute("title") !==
                  (null == anyProps.title ? null : anyProps.title)
              )
                break;
              return instance;
            case "style":
              if (instance.hasAttribute("data-precedence")) break;
              return instance;
            case "script":
              name = instance.getAttribute("src");
              if (
                (name !== (null == anyProps.src ? null : anyProps.src) ||
                  instance.getAttribute("type") !==
                    (null == anyProps.type ? null : anyProps.type) ||
                  instance.getAttribute("crossorigin") !==
                    (null == anyProps.crossOrigin
                      ? null
                      : anyProps.crossOrigin)) &&
                name &&
                instance.hasAttribute("async") &&
                !instance.hasAttribute("itemprop")
              )
                break;
              return instance;
            default:
              return instance;
          }
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) break;
      }
      return null;
    }
    function canHydrateTextInstance(instance, text, inRootOrSingleton) {
      if ("" === text) return null;
      for (; 3 !== instance.nodeType; ) {
        if (
          (1 !== instance.nodeType ||
            "INPUT" !== instance.nodeName ||
            "hidden" !== instance.type) &&
          !inRootOrSingleton
        )
          return null;
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) return null;
      }
      return instance;
    }
    function isSuspenseInstanceFallback(instance) {
      return (
        instance.data === SUSPENSE_FALLBACK_START_DATA ||
        (instance.data === SUSPENSE_PENDING_START_DATA &&
          instance.ownerDocument.readyState === DOCUMENT_READY_STATE_COMPLETE)
      );
    }
    function registerSuspenseInstanceRetry(instance, callback) {
      var ownerDocument = instance.ownerDocument;
      if (
        instance.data !== SUSPENSE_PENDING_START_DATA ||
        ownerDocument.readyState === DOCUMENT_READY_STATE_COMPLETE
      )
        callback();
      else {
        var listener = function () {
          callback();
          ownerDocument.removeEventListener("DOMContentLoaded", listener);
        };
        ownerDocument.addEventListener("DOMContentLoaded", listener);
        instance._reactRetry = listener;
      }
    }
    function getNextHydratable(node) {
      for (; null != node; node = node.nextSibling) {
        var nodeType = node.nodeType;
        if (1 === nodeType || 3 === nodeType) break;
        if (8 === nodeType) {
          nodeType = node.data;
          if (
            nodeType === SUSPENSE_START_DATA ||
            nodeType === SUSPENSE_FALLBACK_START_DATA ||
            nodeType === SUSPENSE_PENDING_START_DATA ||
            nodeType === FORM_STATE_IS_MATCHING ||
            nodeType === FORM_STATE_IS_NOT_MATCHING
          )
            break;
          if (nodeType === SUSPENSE_END_DATA) return null;
        }
      }
      return node;
    }
    function describeHydratableInstanceForDevWarnings(instance) {
      if (1 === instance.nodeType) {
        for (
          var JSCompiler_temp_const = instance.nodeName.toLowerCase(),
            serverDifferences = {},
            attributes = instance.attributes,
            i = 0;
          i < attributes.length;
          i++
        ) {
          var attr = attributes[i];
          serverDifferences[getPropNameFromAttributeName(attr.name)] =
            "style" === attr.name.toLowerCase()
              ? getStylesObjectFromElement(instance)
              : attr.value;
        }
        return { type: JSCompiler_temp_const, props: serverDifferences };
      }
      return 8 === instance.nodeType
        ? { type: "Suspense", props: {} }
        : instance.nodeValue;
    }
    function diffHydratedTextForDevWarnings(textInstance, text, parentProps) {
      return null === parentProps ||
        !0 !== parentProps[SUPPRESS_HYDRATION_WARNING]
        ? (textInstance.nodeValue === text
            ? (textInstance = null)
            : ((text = normalizeMarkupForTextOrAttribute(text)),
              (textInstance =
                normalizeMarkupForTextOrAttribute(textInstance.nodeValue) ===
                text
                  ? null
                  : textInstance.nodeValue)),
          textInstance)
        : null;
    }
    function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
      suspenseInstance = suspenseInstance.nextSibling;
      for (var depth = 0; suspenseInstance; ) {
        if (8 === suspenseInstance.nodeType) {
          var data = suspenseInstance.data;
          if (data === SUSPENSE_END_DATA) {
            if (0 === depth)
              return getNextHydratable(suspenseInstance.nextSibling);
            depth--;
          } else
            (data !== SUSPENSE_START_DATA &&
              data !== SUSPENSE_FALLBACK_START_DATA &&
              data !== SUSPENSE_PENDING_START_DATA) ||
              depth++;
        }
        suspenseInstance = suspenseInstance.nextSibling;
      }
      return null;
    }
    function getParentSuspenseInstance(targetInstance) {
      targetInstance = targetInstance.previousSibling;
      for (var depth = 0; targetInstance; ) {
        if (8 === targetInstance.nodeType) {
          var data = targetInstance.data;
          if (
            data === SUSPENSE_START_DATA ||
            data === SUSPENSE_FALLBACK_START_DATA ||
            data === SUSPENSE_PENDING_START_DATA
          ) {
            if (0 === depth) return targetInstance;
            depth--;
          } else data === SUSPENSE_END_DATA && depth++;
        }
        targetInstance = targetInstance.previousSibling;
      }
      return null;
    }
    function commitHydratedContainer(container) {
      retryIfBlockedOn(container);
    }
    function commitHydratedSuspenseInstance(suspenseInstance) {
      retryIfBlockedOn(suspenseInstance);
    }
    function resolveSingletonInstance(
      type,
      props,
      rootContainerInstance,
      hostContext,
      validateDOMNestingDev
    ) {
      validateDOMNestingDev &&
        validateDOMNesting(type, hostContext.ancestorInfo);
      props = getOwnerDocumentFromRootContainer(rootContainerInstance);
      switch (type) {
        case "html":
          type = props.documentElement;
          if (!type)
            throw Error(
              "React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return type;
        case "head":
          type = props.head;
          if (!type)
            throw Error(
              "React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return type;
        case "body":
          type = props.body;
          if (!type)
            throw Error(
              "React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return type;
        default:
          throw Error(
            "resolveSingletonInstance was called with an element type that is not supported. This is a bug in React."
          );
      }
    }
    function acquireSingletonInstance(
      type,
      props,
      instance,
      internalInstanceHandle
    ) {
      if (
        !instance[internalContainerInstanceKey] &&
        getInstanceFromNode(instance)
      ) {
        var tagName = instance.tagName.toLowerCase();
        console.error(
          "You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",
          tagName,
          tagName,
          tagName
        );
      }
      switch (type) {
        case "html":
        case "head":
        case "body":
          break;
        default:
          console.error(
            "acquireSingletonInstance was called with an element type that is not supported. This is a bug in React."
          );
      }
      for (tagName = instance.attributes; tagName.length; )
        instance.removeAttributeNode(tagName[0]);
      setInitialProperties(instance, type, props);
      instance[internalInstanceKey] = internalInstanceHandle;
      instance[internalPropsKey] = props;
    }
    function releaseSingletonInstance(instance) {
      for (var attributes = instance.attributes; attributes.length; )
        instance.removeAttributeNode(attributes[0]);
      detachDeletedInstance(instance);
    }
    function getHoistableRoot(container) {
      return "function" === typeof container.getRootNode
        ? container.getRootNode()
        : 9 === container.nodeType
          ? container
          : container.ownerDocument;
    }
    function preconnectAs(rel, href, crossOrigin) {
      var ownerDocument = globalDocument;
      if (ownerDocument && "string" === typeof href && href) {
        var limitedEscapedHref =
          escapeSelectorAttributeValueInsideDoubleQuotes(href);
        limitedEscapedHref =
          'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
        "string" === typeof crossOrigin &&
          (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
        preconnectsSet.has(limitedEscapedHref) ||
          (preconnectsSet.add(limitedEscapedHref),
          (rel = { rel: rel, crossOrigin: crossOrigin, href: href }),
          null === ownerDocument.querySelector(limitedEscapedHref) &&
            ((href = ownerDocument.createElement("link")),
            setInitialProperties(href, "link", rel),
            markNodeAsHoistable(href),
            ownerDocument.head.appendChild(href)));
      }
    }
    function getResource(type, currentProps, pendingProps, currentResource) {
      var resourceRoot = (resourceRoot = rootInstanceStackCursor.current)
        ? getHoistableRoot(resourceRoot)
        : null;
      if (!resourceRoot)
        throw Error(
          '"resourceRoot" was expected to exist. This is a bug in React.'
        );
      switch (type) {
        case "meta":
        case "title":
          return null;
        case "style":
          return "string" === typeof pendingProps.precedence &&
            "string" === typeof pendingProps.href
            ? ((pendingProps = getStyleKey(pendingProps.href)),
              (currentProps =
                getResourcesFromRoot(resourceRoot).hoistableStyles),
              (currentResource = currentProps.get(pendingProps)),
              currentResource ||
                ((currentResource = {
                  type: "style",
                  instance: null,
                  count: 0,
                  state: null
                }),
                currentProps.set(pendingProps, currentResource)),
              currentResource)
            : { type: "void", instance: null, count: 0, state: null };
        case "link":
          if (
            "stylesheet" === pendingProps.rel &&
            "string" === typeof pendingProps.href &&
            "string" === typeof pendingProps.precedence
          ) {
            type = getStyleKey(pendingProps.href);
            var _styles = getResourcesFromRoot(resourceRoot).hoistableStyles,
              _resource = _styles.get(type);
            if (
              !_resource &&
              ((resourceRoot = resourceRoot.ownerDocument || resourceRoot),
              (_resource = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: { loading: NotLoaded, preload: null }
              }),
              _styles.set(type, _resource),
              (_styles = resourceRoot.querySelector(
                getStylesheetSelectorFromKey(type)
              )) &&
                !_styles._p &&
                ((_resource.instance = _styles),
                (_resource.state.loading = Loaded | Inserted)),
              !preloadPropsMap.has(type))
            ) {
              var preloadProps = {
                rel: "preload",
                as: "style",
                href: pendingProps.href,
                crossOrigin: pendingProps.crossOrigin,
                integrity: pendingProps.integrity,
                media: pendingProps.media,
                hrefLang: pendingProps.hrefLang,
                referrerPolicy: pendingProps.referrerPolicy
              };
              preloadPropsMap.set(type, preloadProps);
              _styles ||
                preloadStylesheet(
                  resourceRoot,
                  type,
                  preloadProps,
                  _resource.state
                );
            }
            if (currentProps && null === currentResource)
              throw (
                ((pendingProps =
                  "\n\n  - " +
                  describeLinkForResourceErrorDEV(currentProps) +
                  "\n  + " +
                  describeLinkForResourceErrorDEV(pendingProps)),
                Error(
                  "Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." +
                    pendingProps
                ))
              );
            return _resource;
          }
          if (currentProps && null !== currentResource)
            throw (
              ((pendingProps =
                "\n\n  - " +
                describeLinkForResourceErrorDEV(currentProps) +
                "\n  + " +
                describeLinkForResourceErrorDEV(pendingProps)),
              Error(
                "Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." +
                  pendingProps
              ))
            );
          return null;
        case "script":
          return (
            (currentProps = pendingProps.async),
            (pendingProps = pendingProps.src),
            "string" === typeof pendingProps &&
            currentProps &&
            "function" !== typeof currentProps &&
            "symbol" !== typeof currentProps
              ? ((pendingProps = getScriptKey(pendingProps)),
                (currentProps =
                  getResourcesFromRoot(resourceRoot).hoistableScripts),
                (currentResource = currentProps.get(pendingProps)),
                currentResource ||
                  ((currentResource = {
                    type: "script",
                    instance: null,
                    count: 0,
                    state: null
                  }),
                  currentProps.set(pendingProps, currentResource)),
                currentResource)
              : { type: "void", instance: null, count: 0, state: null }
          );
        default:
          throw Error(
            'getResource encountered a type it did not expect: "' +
              type +
              '". this is a bug in React.'
          );
      }
    }
    function describeLinkForResourceErrorDEV(props) {
      var describedProps = 0,
        description = "<link";
      "string" === typeof props.rel
        ? (describedProps++, (description += ' rel="' + props.rel + '"'))
        : hasOwnProperty.call(props, "rel") &&
          (describedProps++,
          (description +=
            ' rel="' +
            (null === props.rel ? "null" : "invalid type " + typeof props.rel) +
            '"'));
      "string" === typeof props.href
        ? (describedProps++, (description += ' href="' + props.href + '"'))
        : hasOwnProperty.call(props, "href") &&
          (describedProps++,
          (description +=
            ' href="' +
            (null === props.href
              ? "null"
              : "invalid type " + typeof props.href) +
            '"'));
      "string" === typeof props.precedence
        ? (describedProps++,
          (description += ' precedence="' + props.precedence + '"'))
        : hasOwnProperty.call(props, "precedence") &&
          (describedProps++,
          (description +=
            " precedence={" +
            (null === props.precedence
              ? "null"
              : "invalid type " + typeof props.precedence) +
            "}"));
      Object.getOwnPropertyNames(props).length > describedProps &&
        (description += " ...");
      return description + " />";
    }
    function getStyleKey(href) {
      return (
        'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"'
      );
    }
    function getStylesheetSelectorFromKey(key) {
      return 'link[rel="stylesheet"][' + key + "]";
    }
    function stylesheetPropsFromRawProps(rawProps) {
      return assign({}, rawProps, {
        "data-precedence": rawProps.precedence,
        precedence: null
      });
    }
    function preloadStylesheet(ownerDocument, key, preloadProps, state) {
      ownerDocument.querySelector(
        'link[rel="preload"][as="style"][' + key + "]"
      )
        ? (state.loading = Loaded)
        : ((key = ownerDocument.createElement("link")),
          (state.preload = key),
          key.addEventListener("load", function () {
            return (state.loading |= Loaded);
          }),
          key.addEventListener("error", function () {
            return (state.loading |= Errored);
          }),
          setInitialProperties(key, "link", preloadProps),
          markNodeAsHoistable(key),
          ownerDocument.head.appendChild(key));
    }
    function getScriptKey(src) {
      return (
        '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]'
      );
    }
    function getScriptSelectorFromKey(key) {
      return "script[async]" + key;
    }
    function acquireResource(hoistableRoot, resource, props) {
      resource.count++;
      if (null === resource.instance)
        switch (resource.type) {
          case "style":
            var instance = hoistableRoot.querySelector(
              'style[data-href~="' +
                escapeSelectorAttributeValueInsideDoubleQuotes(props.href) +
                '"]'
            );
            if (instance)
              return (
                (resource.instance = instance),
                markNodeAsHoistable(instance),
                instance
              );
            var styleProps = assign({}, props, {
              "data-href": props.href,
              "data-precedence": props.precedence,
              href: null,
              precedence: null
            });
            instance = (
              hoistableRoot.ownerDocument || hoistableRoot
            ).createElement("style");
            markNodeAsHoistable(instance);
            setInitialProperties(instance, "style", styleProps);
            insertStylesheet(instance, props.precedence, hoistableRoot);
            return (resource.instance = instance);
          case "stylesheet":
            styleProps = getStyleKey(props.href);
            var _instance = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(styleProps)
            );
            if (_instance)
              return (
                (resource.state.loading |= Inserted),
                (resource.instance = _instance),
                markNodeAsHoistable(_instance),
                _instance
              );
            instance = stylesheetPropsFromRawProps(props);
            (styleProps = preloadPropsMap.get(styleProps)) &&
              adoptPreloadPropsForStylesheet(instance, styleProps);
            _instance = (
              hoistableRoot.ownerDocument || hoistableRoot
            ).createElement("link");
            markNodeAsHoistable(_instance);
            var linkInstance = _instance;
            linkInstance._p = new Promise(function (resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(_instance, "link", instance);
            resource.state.loading |= Inserted;
            insertStylesheet(_instance, props.precedence, hoistableRoot);
            return (resource.instance = _instance);
          case "script":
            _instance = getScriptKey(props.src);
            if (
              (styleProps = hoistableRoot.querySelector(
                getScriptSelectorFromKey(_instance)
              ))
            )
              return (
                (resource.instance = styleProps),
                markNodeAsHoistable(styleProps),
                styleProps
              );
            instance = props;
            if ((styleProps = preloadPropsMap.get(_instance)))
              (instance = assign({}, props)),
                adoptPreloadPropsForScript(instance, styleProps);
            hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
            styleProps = hoistableRoot.createElement("script");
            markNodeAsHoistable(styleProps);
            setInitialProperties(styleProps, "link", instance);
            hoistableRoot.head.appendChild(styleProps);
            return (resource.instance = styleProps);
          case "void":
            return null;
          default:
            throw Error(
              'acquireResource encountered a resource type it did not expect: "' +
                resource.type +
                '". this is a bug in React.'
            );
        }
      else
        "stylesheet" === resource.type &&
          (resource.state.loading & Inserted) === NotLoaded &&
          ((instance = resource.instance),
          (resource.state.loading |= Inserted),
          insertStylesheet(instance, props.precedence, hoistableRoot));
      return resource.instance;
    }
    function insertStylesheet(instance, precedence, root) {
      for (
        var nodes = root.querySelectorAll(
            'link[rel="stylesheet"][data-precedence],style[data-precedence]'
          ),
          last = nodes.length ? nodes[nodes.length - 1] : null,
          prior = last,
          i = 0;
        i < nodes.length;
        i++
      ) {
        var node = nodes[i];
        if (node.dataset.precedence === precedence) prior = node;
        else if (prior !== last) break;
      }
      prior
        ? prior.parentNode.insertBefore(instance, prior.nextSibling)
        : ((precedence = 9 === root.nodeType ? root.head : root),
          precedence.insertBefore(instance, precedence.firstChild));
    }
    function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
      null == stylesheetProps.crossOrigin &&
        (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
      null == stylesheetProps.referrerPolicy &&
        (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
      null == stylesheetProps.title &&
        (stylesheetProps.title = preloadProps.title);
    }
    function adoptPreloadPropsForScript(scriptProps, preloadProps) {
      null == scriptProps.crossOrigin &&
        (scriptProps.crossOrigin = preloadProps.crossOrigin);
      null == scriptProps.referrerPolicy &&
        (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
      null == scriptProps.integrity &&
        (scriptProps.integrity = preloadProps.integrity);
    }
    function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
      if (null === tagCaches) {
        var cache = new Map();
        var caches = (tagCaches = new Map());
        caches.set(ownerDocument, cache);
      } else
        (caches = tagCaches),
          (cache = caches.get(ownerDocument)),
          cache || ((cache = new Map()), caches.set(ownerDocument, cache));
      if (cache.has(type)) return cache;
      cache.set(type, null);
      ownerDocument = ownerDocument.getElementsByTagName(type);
      for (caches = 0; caches < ownerDocument.length; caches++) {
        var node = ownerDocument[caches];
        if (
          !(
            node[internalHoistableMarker] ||
            node[internalInstanceKey] ||
            ("link" === type && "stylesheet" === node.getAttribute("rel"))
          ) &&
          node.namespaceURI !== SVG_NAMESPACE
        ) {
          var nodeKey = node.getAttribute(keyAttribute) || "";
          nodeKey = type + nodeKey;
          var existing = cache.get(nodeKey);
          existing ? existing.push(node) : cache.set(nodeKey, [node]);
        }
      }
      return cache;
    }
    function mountHoistable(hoistableRoot, type, instance) {
      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
      hoistableRoot.head.insertBefore(
        instance,
        "title" === type ? hoistableRoot.querySelector("head > title") : null
      );
    }
    function isHostHoistableType(type, props, hostContext) {
      var outsideHostContainerContext =
        !hostContext.ancestorInfo.containerTagInScope;
      if (
        hostContext.context === HostContextNamespaceSvg ||
        null != props.itemProp
      )
        return (
          !outsideHostContainerContext ||
            null == props.itemProp ||
            ("meta" !== type &&
              "title" !== type &&
              "style" !== type &&
              "link" !== type &&
              "script" !== type) ||
            console.error(
              "Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",
              type,
              type
            ),
          !1
        );
      switch (type) {
        case "meta":
        case "title":
          return !0;
        case "style":
          if (
            "string" !== typeof props.precedence ||
            "string" !== typeof props.href ||
            "" === props.href
          ) {
            outsideHostContainerContext &&
              console.error(
                'Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.'
              );
            break;
          }
          return !0;
        case "link":
          if (
            "string" !== typeof props.rel ||
            "string" !== typeof props.href ||
            "" === props.href ||
            props.onLoad ||
            props.onError
          ) {
            if (
              "stylesheet" === props.rel &&
              "string" === typeof props.precedence
            ) {
              type = props.href;
              var onError = props.onError,
                disabled = props.disabled;
              hostContext = [];
              props.onLoad && hostContext.push("`onLoad`");
              onError && hostContext.push("`onError`");
              null != disabled && hostContext.push("`disabled`");
              onError = propNamesListJoin(hostContext, "and");
              onError += 1 === hostContext.length ? " prop" : " props";
              disabled =
                1 === hostContext.length ? "an " + onError : "the " + onError;
              hostContext.length &&
                console.error(
                  'React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                  type,
                  disabled,
                  onError
                );
            }
            outsideHostContainerContext &&
              ("string" !== typeof props.rel ||
              "string" !== typeof props.href ||
              "" === props.href
                ? console.error(
                    "Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"
                  )
                : (props.onError || props.onLoad) &&
                  console.error(
                    "Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                  ));
            break;
          }
          switch (props.rel) {
            case "stylesheet":
              return (
                (type = props.precedence),
                (props = props.disabled),
                "string" !== typeof type &&
                  outsideHostContainerContext &&
                  console.error(
                    'Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'
                  ),
                "string" === typeof type && null == props
              );
            default:
              return !0;
          }
        case "script":
          type =
            props.async &&
            "function" !== typeof props.async &&
            "symbol" !== typeof props.async;
          if (
            !type ||
            props.onLoad ||
            props.onError ||
            !props.src ||
            "string" !== typeof props.src
          ) {
            outsideHostContainerContext &&
              (type
                ? props.onLoad || props.onError
                  ? console.error(
                      "Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                    )
                  : console.error(
                      "Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."
                    )
                : console.error(
                    'Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'
                  ));
            break;
          }
          return !0;
        case "noscript":
        case "template":
          outsideHostContainerContext &&
            console.error(
              "Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",
              type
            );
      }
      return !1;
    }
    function preloadResource(resource) {
      return "stylesheet" === resource.type &&
        (resource.state.loading & Settled) === NotLoaded
        ? !1
        : !0;
    }
    function noop() {}
    function suspendResource(hoistableRoot, resource, props) {
      if (null === suspendedState)
        throw Error(
          "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
        );
      var state = suspendedState;
      if (
        "stylesheet" === resource.type &&
        ("string" !== typeof props.media ||
          !1 !== matchMedia(props.media).matches) &&
        (resource.state.loading & Inserted) === NotLoaded
      ) {
        if (null === resource.instance) {
          var key = getStyleKey(props.href),
            instance = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(key)
            );
          if (instance) {
            hoistableRoot = instance._p;
            null !== hoistableRoot &&
              "object" === typeof hoistableRoot &&
              "function" === typeof hoistableRoot.then &&
              (state.count++,
              (state = onUnsuspend.bind(state)),
              hoistableRoot.then(state, state));
            resource.state.loading |= Inserted;
            resource.instance = instance;
            markNodeAsHoistable(instance);
            return;
          }
          instance = hoistableRoot.ownerDocument || hoistableRoot;
          props = stylesheetPropsFromRawProps(props);
          (key = preloadPropsMap.get(key)) &&
            adoptPreloadPropsForStylesheet(props, key);
          instance = instance.createElement("link");
          markNodeAsHoistable(instance);
          var linkInstance = instance;
          linkInstance._p = new Promise(function (resolve, reject) {
            linkInstance.onload = resolve;
            linkInstance.onerror = reject;
          });
          setInitialProperties(instance, "link", props);
          resource.instance = instance;
        }
        null === state.stylesheets && (state.stylesheets = new Map());
        state.stylesheets.set(resource, hoistableRoot);
        (hoistableRoot = resource.state.preload) &&
          (resource.state.loading & Settled) === NotLoaded &&
          (state.count++,
          (resource = onUnsuspend.bind(state)),
          hoistableRoot.addEventListener("load", resource),
          hoistableRoot.addEventListener("error", resource));
      }
    }
    function waitForCommitToBeReady() {
      if (null === suspendedState)
        throw Error(
          "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
        );
      var state = suspendedState;
      state.stylesheets &&
        0 === state.count &&
        insertSuspendedStylesheets(state, state.stylesheets);
      return 0 < state.count
        ? function (commit) {
            var stylesheetTimer = setTimeout(function () {
              state.stylesheets &&
                insertSuspendedStylesheets(state, state.stylesheets);
              if (state.unsuspend) {
                var unsuspend = state.unsuspend;
                state.unsuspend = null;
                unsuspend();
              }
            }, 6e4);
            state.unsuspend = commit;
            return function () {
              state.unsuspend = null;
              clearTimeout(stylesheetTimer);
            };
          }
        : null;
    }
    function onUnsuspend() {
      this.count--;
      if (0 === this.count)
        if (this.stylesheets)
          insertSuspendedStylesheets(this, this.stylesheets);
        else if (this.unsuspend) {
          var unsuspend = this.unsuspend;
          this.unsuspend = null;
          unsuspend();
        }
    }
    function insertSuspendedStylesheets(state, resources) {
      state.stylesheets = null;
      null !== state.unsuspend &&
        (state.count++,
        (precedencesByRoot = new Map()),
        resources.forEach(insertStylesheetIntoRoot, state),
        (precedencesByRoot = null),
        onUnsuspend.call(state));
    }
    function insertStylesheetIntoRoot(root, resource) {
      if (!(resource.state.loading & Inserted)) {
        var precedences = precedencesByRoot.get(root);
        if (precedences) var last = precedences.get(LAST_PRECEDENCE);
        else {
          precedences = new Map();
          precedencesByRoot.set(root, precedences);
          for (
            var nodes = root.querySelectorAll(
                "link[data-precedence],style[data-precedence]"
              ),
              i = 0;
            i < nodes.length;
            i++
          ) {
            var node = nodes[i];
            if (
              "LINK" === node.nodeName ||
              "not all" !== node.getAttribute("media")
            )
              precedences.set(node.dataset.precedence, node), (last = node);
          }
          last && precedences.set(LAST_PRECEDENCE, last);
        }
        nodes = resource.instance;
        node = nodes.getAttribute("data-precedence");
        i = precedences.get(node) || last;
        i === last && precedences.set(LAST_PRECEDENCE, nodes);
        precedences.set(node, nodes);
        this.count++;
        last = onUnsuspend.bind(this);
        nodes.addEventListener("load", last);
        nodes.addEventListener("error", last);
        i
          ? i.parentNode.insertBefore(nodes, i.nextSibling)
          : ((root = 9 === root.nodeType ? root.head : root),
            root.insertBefore(nodes, root.firstChild));
        resource.state.loading |= Inserted;
      }
    }
    function FiberRootNode(
      containerInfo,
      tag,
      hydrate,
      identifierPrefix,
      onUncaughtError,
      onCaughtError,
      onRecoverableError,
      formState
    ) {
      this.tag = 1;
      this.containerInfo = containerInfo;
      this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = noTimeout;
      this.callbackNode =
        this.next =
        this.pendingContext =
        this.context =
        this.cancelPendingCommit =
          null;
      this.callbackPriority = 0;
      this.expirationTimes = createLaneMap(-1);
      this.entangledLanes =
        this.shellSuspendCounter =
        this.errorRecoveryDisabledLanes =
        this.expiredLanes =
        this.warmLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0;
      this.entanglements = createLaneMap(0);
      this.hiddenUpdates = createLaneMap(null);
      this.identifierPrefix = identifierPrefix;
      this.onUncaughtError = onUncaughtError;
      this.onCaughtError = onCaughtError;
      this.onRecoverableError = onRecoverableError;
      this.pooledCache = null;
      this.pooledCacheLanes = 0;
      this.formState = formState;
      this.incompleteTransitions = new Map();
      this.passiveEffectDuration = this.effectDuration = -0;
      this.memoizedUpdaters = new Set();
      containerInfo = this.pendingUpdatersLaneMap = [];
      for (tag = 0; 31 > tag; tag++) containerInfo.push(new Set());
      this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
    }
    function createFiberRoot(
      containerInfo,
      tag,
      hydrate,
      initialChildren,
      hydrationCallbacks,
      isStrictMode,
      identifierPrefix,
      onUncaughtError,
      onCaughtError,
      onRecoverableError,
      transitionCallbacks,
      formState
    ) {
      containerInfo = new FiberRootNode(
        containerInfo,
        tag,
        hydrate,
        identifierPrefix,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        formState
      );
      tag = ConcurrentMode;
      !0 === isStrictMode && (tag |= StrictLegacyMode | StrictEffectsMode);
      isDevToolsPresent && (tag |= ProfileMode);
      isStrictMode = createFiber(3, null, null, tag);
      containerInfo.current = isStrictMode;
      isStrictMode.stateNode = containerInfo;
      tag = createCache();
      retainCache(tag);
      containerInfo.pooledCache = tag;
      retainCache(tag);
      isStrictMode.memoizedState = {
        element: initialChildren,
        isDehydrated: hydrate,
        cache: tag
      };
      initializeUpdateQueue(isStrictMode);
      return containerInfo;
    }
    function getContextForSubtree(parentComponent) {
      if (!parentComponent) return emptyContextObject;
      parentComponent = emptyContextObject;
      return parentComponent;
    }
    function updateContainerImpl(
      rootFiber,
      lane,
      element,
      container,
      parentComponent,
      callback
    ) {
      if (
        injectedHook &&
        "function" === typeof injectedHook.onScheduleFiberRoot
      )
        try {
          injectedHook.onScheduleFiberRoot(rendererID, container, element);
        } catch (err) {
          hasLoggedError ||
            ((hasLoggedError = !0),
            console.error(
              "React instrumentation encountered an error: %s",
              err
            ));
        }
      null !== injectedProfilingHooks &&
        "function" === typeof injectedProfilingHooks.markRenderScheduled &&
        injectedProfilingHooks.markRenderScheduled(lane);
      parentComponent = getContextForSubtree(parentComponent);
      null === container.context
        ? (container.context = parentComponent)
        : (container.pendingContext = parentComponent);
      isRendering &&
        null !== current &&
        !didWarnAboutNestedUpdates &&
        ((didWarnAboutNestedUpdates = !0),
        console.error(
          "Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.",
          getComponentNameFromFiber(current) || "Unknown"
        ));
      container = createUpdate(lane);
      container.payload = { element: element };
      callback = void 0 === callback ? null : callback;
      null !== callback &&
        ("function" !== typeof callback &&
          console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback
          ),
        (container.callback = callback));
      element = enqueueUpdate(rootFiber, container, lane);
      null !== element &&
        (scheduleUpdateOnFiber(element, rootFiber, lane),
        entangleTransitions(element, rootFiber, lane));
    }
    function markRetryLaneImpl(fiber, retryLane) {
      fiber = fiber.memoizedState;
      if (null !== fiber && null !== fiber.dehydrated) {
        var a = fiber.retryLane;
        fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
      }
    }
    function markRetryLaneIfNotHydrated(fiber, retryLane) {
      markRetryLaneImpl(fiber, retryLane);
      (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
    }
    function attemptContinuousHydration(fiber) {
      if (13 === fiber.tag) {
        var root = enqueueConcurrentRenderForLane(fiber, 67108864);
        null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
        markRetryLaneIfNotHydrated(fiber, 67108864);
      }
    }
    function getCurrentFiberForDevTools() {
      return current;
    }
    function getLaneLabelMap() {
      for (var map = new Map(), lane = 1, index = 0; 31 > index; index++) {
        var label = getLabelForLane(lane);
        map.set(lane, label);
        lane *= 2;
      }
      return map;
    }
    function dispatchDiscreteEvent(
      domEventName,
      eventSystemFlags,
      container,
      nativeEvent
    ) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        (ReactDOMSharedInternals.p = DiscreteEventPriority),
          dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        (ReactDOMSharedInternals.p = previousPriority),
          (ReactSharedInternals.T = prevTransition);
      }
    }
    function dispatchContinuousEvent(
      domEventName,
      eventSystemFlags,
      container,
      nativeEvent
    ) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        (ReactDOMSharedInternals.p = ContinuousEventPriority),
          dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        (ReactDOMSharedInternals.p = previousPriority),
          (ReactSharedInternals.T = prevTransition);
      }
    }
    function dispatchEvent(
      domEventName,
      eventSystemFlags,
      targetContainer,
      nativeEvent
    ) {
      if (_enabled) {
        var blockedOn = findInstanceBlockingEvent(nativeEvent);
        if (null === blockedOn)
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            return_targetInst,
            targetContainer
          ),
            clearIfContinuousEvent(domEventName, nativeEvent);
        else if (
          queueIfContinuousEvent(
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          )
        )
          nativeEvent.stopPropagation();
        else if (
          (clearIfContinuousEvent(domEventName, nativeEvent),
          eventSystemFlags & 4 &&
            -1 < discreteReplayableEvents.indexOf(domEventName))
        ) {
          for (; null !== blockedOn; ) {
            var fiber = getInstanceFromNode(blockedOn);
            if (null !== fiber)
              switch (fiber.tag) {
                case 3:
                  fiber = fiber.stateNode;
                  if (fiber.current.memoizedState.isDehydrated) {
                    var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                    if (0 !== lanes) {
                      var root = fiber;
                      root.pendingLanes |= 2;
                      for (root.entangledLanes |= 2; lanes; ) {
                        var lane = 1 << (31 - clz32(lanes));
                        root.entanglements[1] |= lane;
                        lanes &= ~lane;
                      }
                      ensureRootIsScheduled(fiber);
                      (executionContext & (RenderContext | CommitContext)) ===
                        NoContext &&
                        ((workInProgressRootRenderTargetTime =
                          now$1() + RENDER_TIMEOUT_MS),
                        flushSyncWorkAcrossRoots_impl(0, !1));
                    }
                  }
                  break;
                case 13:
                  (root = enqueueConcurrentRenderForLane(fiber, 2)),
                    null !== root && scheduleUpdateOnFiber(root, fiber, 2),
                    flushSyncWork$1(),
                    markRetryLaneIfNotHydrated(fiber, 2);
              }
            fiber = findInstanceBlockingEvent(nativeEvent);
            null === fiber &&
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              );
            if (fiber === blockedOn) break;
            blockedOn = fiber;
          }
          null !== blockedOn && nativeEvent.stopPropagation();
        } else
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            null,
            targetContainer
          );
      }
    }
    function findInstanceBlockingEvent(nativeEvent) {
      nativeEvent = getEventTarget(nativeEvent);
      return findInstanceBlockingTarget(nativeEvent);
    }
    function findInstanceBlockingTarget(targetNode) {
      return_targetInst = null;
      targetNode = getClosestInstanceFromNode(targetNode);
      if (null !== targetNode) {
        var nearestMounted = getNearestMountedFiber(targetNode);
        if (null === nearestMounted) targetNode = null;
        else {
          var tag = nearestMounted.tag;
          if (13 === tag) {
            targetNode = getSuspenseInstanceFromFiber(nearestMounted);
            if (null !== targetNode) return targetNode;
            targetNode = null;
          } else if (3 === tag) {
            if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
              return 3 === nearestMounted.tag
                ? nearestMounted.stateNode.containerInfo
                : null;
            targetNode = null;
          } else nearestMounted !== targetNode && (targetNode = null);
        }
      }
      return_targetInst = targetNode;
      return null;
    }
    function getEventPriority(domEventName) {
      switch (domEventName) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return DiscreteEventPriority;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return ContinuousEventPriority;
        case "message":
          switch (getCurrentPriorityLevel()) {
            case ImmediatePriority:
              return DiscreteEventPriority;
            case UserBlockingPriority:
              return ContinuousEventPriority;
            case NormalPriority$1:
            case LowPriority:
              return DefaultEventPriority;
            case IdlePriority:
              return IdleEventPriority;
            default:
              return DefaultEventPriority;
          }
        default:
          return DefaultEventPriority;
      }
    }
    function clearIfContinuousEvent(domEventName, nativeEvent) {
      switch (domEventName) {
        case "focusin":
        case "focusout":
          queuedFocus = null;
          break;
        case "dragenter":
        case "dragleave":
          queuedDrag = null;
          break;
        case "mouseover":
        case "mouseout":
          queuedMouse = null;
          break;
        case "pointerover":
        case "pointerout":
          queuedPointers.delete(nativeEvent.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          queuedPointerCaptures.delete(nativeEvent.pointerId);
      }
    }
    function accumulateOrCreateContinuousQueuedReplayableEvent(
      existingQueuedEvent,
      blockedOn,
      domEventName,
      eventSystemFlags,
      targetContainer,
      nativeEvent
    ) {
      if (
        null === existingQueuedEvent ||
        existingQueuedEvent.nativeEvent !== nativeEvent
      )
        return (
          (existingQueuedEvent = {
            blockedOn: blockedOn,
            domEventName: domEventName,
            eventSystemFlags: eventSystemFlags,
            nativeEvent: nativeEvent,
            targetContainers: [targetContainer]
          }),
          null !== blockedOn &&
            ((blockedOn = getInstanceFromNode(blockedOn)),
            null !== blockedOn && attemptContinuousHydration(blockedOn)),
          existingQueuedEvent
        );
      existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
      blockedOn = existingQueuedEvent.targetContainers;
      null !== targetContainer &&
        -1 === blockedOn.indexOf(targetContainer) &&
        blockedOn.push(targetContainer);
      return existingQueuedEvent;
    }
    function queueIfContinuousEvent(
      blockedOn,
      domEventName,
      eventSystemFlags,
      targetContainer,
      nativeEvent
    ) {
      switch (domEventName) {
        case "focusin":
          return (
            (queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedFocus,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )),
            !0
          );
        case "dragenter":
          return (
            (queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedDrag,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )),
            !0
          );
        case "mouseover":
          return (
            (queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedMouse,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )),
            !0
          );
        case "pointerover":
          var pointerId = nativeEvent.pointerId;
          queuedPointers.set(
            pointerId,
            accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedPointers.get(pointerId) || null,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )
          );
          return !0;
        case "gotpointercapture":
          return (
            (pointerId = nativeEvent.pointerId),
            queuedPointerCaptures.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointerCaptures.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            ),
            !0
          );
      }
      return !1;
    }
    function attemptExplicitHydrationTarget(queuedTarget) {
      var targetInst = getClosestInstanceFromNode(queuedTarget.target);
      if (null !== targetInst) {
        var nearestMounted = getNearestMountedFiber(targetInst);
        if (null !== nearestMounted)
          if (((targetInst = nearestMounted.tag), 13 === targetInst)) {
            if (
              ((targetInst = getSuspenseInstanceFromFiber(nearestMounted)),
              null !== targetInst)
            ) {
              queuedTarget.blockedOn = targetInst;
              runWithPriority(queuedTarget.priority, function () {
                if (13 === nearestMounted.tag) {
                  var lane = requestUpdateLane(nearestMounted);
                  lane = getBumpedLaneForHydrationByLane(lane);
                  var root = enqueueConcurrentRenderForLane(
                    nearestMounted,
                    lane
                  );
                  null !== root &&
                    scheduleUpdateOnFiber(root, nearestMounted, lane);
                  markRetryLaneIfNotHydrated(nearestMounted, lane);
                }
              });
              return;
            }
          } else if (
            3 === targetInst &&
            nearestMounted.stateNode.current.memoizedState.isDehydrated
          ) {
            queuedTarget.blockedOn =
              3 === nearestMounted.tag
                ? nearestMounted.stateNode.containerInfo
                : null;
            return;
          }
      }
      queuedTarget.blockedOn = null;
    }
    function attemptReplayContinuousQueuedEvent(queuedEvent) {
      if (null !== queuedEvent.blockedOn) return !1;
      for (
        var targetContainers = queuedEvent.targetContainers;
        0 < targetContainers.length;

      ) {
        var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
        if (null === nextBlockedOn) {
          nextBlockedOn = queuedEvent.nativeEvent;
          var nativeEventClone = new nextBlockedOn.constructor(
              nextBlockedOn.type,
              nextBlockedOn
            ),
            event = nativeEventClone;
          null !== currentReplayingEvent &&
            console.error(
              "Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."
            );
          currentReplayingEvent = event;
          nextBlockedOn.target.dispatchEvent(nativeEventClone);
          null === currentReplayingEvent &&
            console.error(
              "Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."
            );
          currentReplayingEvent = null;
        } else
          return (
            (targetContainers = getInstanceFromNode(nextBlockedOn)),
            null !== targetContainers &&
              attemptContinuousHydration(targetContainers),
            (queuedEvent.blockedOn = nextBlockedOn),
            !1
          );
        targetContainers.shift();
      }
      return !0;
    }
    function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
      attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
    }
    function replayUnblockedEvents() {
      hasScheduledReplayAttempt = !1;
      null !== queuedFocus &&
        attemptReplayContinuousQueuedEvent(queuedFocus) &&
        (queuedFocus = null);
      null !== queuedDrag &&
        attemptReplayContinuousQueuedEvent(queuedDrag) &&
        (queuedDrag = null);
      null !== queuedMouse &&
        attemptReplayContinuousQueuedEvent(queuedMouse) &&
        (queuedMouse = null);
      queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
      queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
    }
    function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
      queuedEvent.blockedOn === unblocked &&
        ((queuedEvent.blockedOn = null),
        hasScheduledReplayAttempt ||
          ((hasScheduledReplayAttempt = !0),
          Scheduler.unstable_scheduleCallback(
            Scheduler.unstable_NormalPriority,
            replayUnblockedEvents
          )));
    }
    function scheduleReplayQueueIfNeeded(formReplayingQueue) {
      lastScheduledReplayQueue !== formReplayingQueue &&
        ((lastScheduledReplayQueue = formReplayingQueue),
        Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          function () {
            lastScheduledReplayQueue === formReplayingQueue &&
              (lastScheduledReplayQueue = null);
            for (var i = 0; i < formReplayingQueue.length; i += 3) {
              var form = formReplayingQueue[i],
                submitterOrAction = formReplayingQueue[i + 1],
                formData = formReplayingQueue[i + 2];
              if ("function" !== typeof submitterOrAction)
                if (
                  null === findInstanceBlockingTarget(submitterOrAction || form)
                )
                  continue;
                else break;
              var formInst = getInstanceFromNode(form);
              null !== formInst &&
                (formReplayingQueue.splice(i, 3),
                (i -= 3),
                (form = {
                  pending: !0,
                  data: formData,
                  method: form.method,
                  action: submitterOrAction
                }),
                Object.freeze(form),
                startHostTransition(
                  formInst,
                  form,
                  submitterOrAction,
                  formData
                ));
            }
          }
        ));
    }
    function retryIfBlockedOn(unblocked) {
      function unblock(queuedEvent) {
        return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
      }
      null !== queuedFocus &&
        scheduleCallbackIfUnblocked(queuedFocus, unblocked);
      null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
      null !== queuedMouse &&
        scheduleCallbackIfUnblocked(queuedMouse, unblocked);
      queuedPointers.forEach(unblock);
      queuedPointerCaptures.forEach(unblock);
      for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
        var queuedTarget = queuedExplicitHydrationTargets[i];
        queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
      }
      for (
        ;
        0 < queuedExplicitHydrationTargets.length &&
        ((i = queuedExplicitHydrationTargets[0]), null === i.blockedOn);

      )
        attemptExplicitHydrationTarget(i),
          null === i.blockedOn && queuedExplicitHydrationTargets.shift();
      i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
      if (null != i)
        for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
          var form = i[queuedTarget],
            submitterOrAction = i[queuedTarget + 1],
            formProps = form[internalPropsKey] || null;
          if ("function" === typeof submitterOrAction)
            formProps || scheduleReplayQueueIfNeeded(i);
          else if (formProps) {
            var action = null;
            if (
              submitterOrAction &&
              submitterOrAction.hasAttribute("formAction")
            )
              if (
                ((form = submitterOrAction),
                (formProps = submitterOrAction[internalPropsKey] || null))
              )
                action = formProps.formAction;
              else {
                if (null !== findInstanceBlockingTarget(form)) continue;
              }
            else action = formProps.action;
            "function" === typeof action
              ? (i[queuedTarget + 1] = action)
              : (i.splice(queuedTarget, 3), (queuedTarget -= 3));
            scheduleReplayQueueIfNeeded(i);
          }
        }
    }
    function ReactDOMRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    function ReactDOMHydrationRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    function warnIfReactDOMContainerInDEV(container) {
      container[internalContainerInstanceKey] &&
        (container._reactRootContainer
          ? console.error(
              "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
            )
          : console.error(
              "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
            ));
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var Scheduler = __webpack_require__(/*! scheduler */ "./node_modules/scheduler/index.js"),
      React = __webpack_require__(/*! react */ "./node_modules/react/index.js"),
      ReactDOM = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js"),
      assign = Object.assign,
      REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
      REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
      REACT_PROVIDER_TYPE = Symbol.for("react.provider"),
      REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
      REACT_MEMO_TYPE = Symbol.for("react.memo"),
      REACT_LAZY_TYPE = Symbol.for("react.lazy");
    Symbol.for("react.scope");
    var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
    Symbol.for("react.legacy_hidden");
    Symbol.for("react.tracing_marker");
    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
    Symbol.for("react.view_transition");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
      isArrayImpl = Array.isArray,
      ReactSharedInternals =
        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      ReactDOMSharedInternals =
        ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      NotPending = Object.freeze({
        pending: !1,
        data: null,
        method: null,
        action: null
      }),
      valueStack = [];
    var fiberStack = [];
    var index$jscomp$0 = -1,
      contextStackCursor = createCursor(null),
      contextFiberStackCursor = createCursor(null),
      rootInstanceStackCursor = createCursor(null),
      hostTransitionProviderCursor = createCursor(null),
      hasOwnProperty = Object.prototype.hasOwnProperty,
      scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
      cancelCallback$1 = Scheduler.unstable_cancelCallback,
      shouldYield = Scheduler.unstable_shouldYield,
      requestPaint = Scheduler.unstable_requestPaint,
      now$1 = Scheduler.unstable_now,
      getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
      ImmediatePriority = Scheduler.unstable_ImmediatePriority,
      UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
      NormalPriority$1 = Scheduler.unstable_NormalPriority,
      LowPriority = Scheduler.unstable_LowPriority,
      IdlePriority = Scheduler.unstable_IdlePriority,
      log$1 = Scheduler.log,
      unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
      rendererID = null,
      injectedHook = null,
      injectedProfilingHooks = null,
      hasLoggedError = !1,
      isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__,
      clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
      log = Math.log,
      LN2 = Math.LN2,
      nextTransitionLane = 256,
      nextRetryLane = 4194304,
      DiscreteEventPriority = 2,
      ContinuousEventPriority = 8,
      DefaultEventPriority = 32,
      IdleEventPriority = 268435456,
      randomKey = Math.random().toString(36).slice(2),
      internalInstanceKey = "__reactFiber$" + randomKey,
      internalPropsKey = "__reactProps$" + randomKey,
      internalContainerInstanceKey = "__reactContainer$" + randomKey,
      internalEventHandlersKey = "__reactEvents$" + randomKey,
      internalEventHandlerListenersKey = "__reactListeners$" + randomKey,
      internalEventHandlesSetKey = "__reactHandles$" + randomKey,
      internalRootNodeResourcesKey = "__reactResources$" + randomKey,
      internalHoistableMarker = "__reactMarker$" + randomKey,
      allNativeEvents = new Set(),
      registrationNameDependencies = {},
      possibleRegistrationNames = {},
      hasReadOnlyValue = {
        button: !0,
        checkbox: !0,
        image: !0,
        hidden: !0,
        radio: !0,
        reset: !0,
        submit: !0
      },
      VALID_ATTRIBUTE_NAME_REGEX = RegExp(
        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ),
      illegalAttributeNameCache = {},
      validatedAttributeNameCache = {},
      disabledDepth = 0,
      prevLog,
      prevInfo,
      prevWarn,
      prevError,
      prevGroup,
      prevGroupCollapsed,
      prevGroupEnd;
    disabledLog.__reactDisabledLog = !0;
    var prefix,
      suffix,
      reentry = !1;
    var componentFrameCache = new (
      "function" === typeof WeakMap ? WeakMap : Map
    )();
    var current = null,
      isRendering = !1,
      escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g,
      didWarnValueDefaultValue$1 = !1,
      didWarnCheckedDefaultChecked = !1,
      didWarnSelectedSetOnOption = !1,
      didWarnInvalidChild = !1,
      didWarnInvalidInnerHTML = !1;
    var didWarnValueDefaultValue = !1;
    var valuePropNames = ["value", "defaultValue"],
      didWarnValDefaultVal = !1,
      needsEscaping = /["'&<>\n\t]|^\s|\s$/,
      specialTags =
        "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(
          " "
        ),
      inScopeTags =
        "applet caption html table td th marquee object template foreignObject desc title".split(
          " "
        ),
      buttonScopeTags = inScopeTags.concat(["button"]),
      impliedEndTags = "dd dt li option optgroup p rp rt".split(" "),
      emptyAncestorInfoDev = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null,
        containerTagInScope: null,
        implicitRootScope: !1
      },
      didWarn = {},
      shorthandToLonghand = {
        animation:
          "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(
            " "
          ),
        background:
          "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(
            " "
          ),
        backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
        border:
          "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(
            " "
          ),
        borderBlockEnd: [
          "borderBlockEndColor",
          "borderBlockEndStyle",
          "borderBlockEndWidth"
        ],
        borderBlockStart: [
          "borderBlockStartColor",
          "borderBlockStartStyle",
          "borderBlockStartWidth"
        ],
        borderBottom: [
          "borderBottomColor",
          "borderBottomStyle",
          "borderBottomWidth"
        ],
        borderColor: [
          "borderBottomColor",
          "borderLeftColor",
          "borderRightColor",
          "borderTopColor"
        ],
        borderImage: [
          "borderImageOutset",
          "borderImageRepeat",
          "borderImageSlice",
          "borderImageSource",
          "borderImageWidth"
        ],
        borderInlineEnd: [
          "borderInlineEndColor",
          "borderInlineEndStyle",
          "borderInlineEndWidth"
        ],
        borderInlineStart: [
          "borderInlineStartColor",
          "borderInlineStartStyle",
          "borderInlineStartWidth"
        ],
        borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
        borderRadius: [
          "borderBottomLeftRadius",
          "borderBottomRightRadius",
          "borderTopLeftRadius",
          "borderTopRightRadius"
        ],
        borderRight: [
          "borderRightColor",
          "borderRightStyle",
          "borderRightWidth"
        ],
        borderStyle: [
          "borderBottomStyle",
          "borderLeftStyle",
          "borderRightStyle",
          "borderTopStyle"
        ],
        borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
        borderWidth: [
          "borderBottomWidth",
          "borderLeftWidth",
          "borderRightWidth",
          "borderTopWidth"
        ],
        columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
        columns: ["columnCount", "columnWidth"],
        flex: ["flexBasis", "flexGrow", "flexShrink"],
        flexFlow: ["flexDirection", "flexWrap"],
        font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(
          " "
        ),
        fontVariant:
          "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(
            " "
          ),
        gap: ["columnGap", "rowGap"],
        grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(
          " "
        ),
        gridArea: [
          "gridColumnEnd",
          "gridColumnStart",
          "gridRowEnd",
          "gridRowStart"
        ],
        gridColumn: ["gridColumnEnd", "gridColumnStart"],
        gridColumnGap: ["columnGap"],
        gridGap: ["columnGap", "rowGap"],
        gridRow: ["gridRowEnd", "gridRowStart"],
        gridRowGap: ["rowGap"],
        gridTemplate: [
          "gridTemplateAreas",
          "gridTemplateColumns",
          "gridTemplateRows"
        ],
        listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
        margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
        marker: ["markerEnd", "markerMid", "markerStart"],
        mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(
          " "
        ),
        maskPosition: ["maskPositionX", "maskPositionY"],
        outline: ["outlineColor", "outlineStyle", "outlineWidth"],
        overflow: ["overflowX", "overflowY"],
        padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
        placeContent: ["alignContent", "justifyContent"],
        placeItems: ["alignItems", "justifyItems"],
        placeSelf: ["alignSelf", "justifySelf"],
        textDecoration: [
          "textDecorationColor",
          "textDecorationLine",
          "textDecorationStyle"
        ],
        textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
        transition: [
          "transitionDelay",
          "transitionDuration",
          "transitionProperty",
          "transitionTimingFunction"
        ],
        wordWrap: ["overflowWrap"]
      },
      uppercasePattern = /([A-Z])/g,
      msPattern$1 = /^ms-/,
      badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/,
      msPattern = /^-ms-/,
      hyphenPattern = /-(.)/g,
      badStyleValueWithSemicolonPattern = /;\s*$/,
      warnedStyleNames = {},
      warnedStyleValues = {},
      warnedForNaNValue = !1,
      warnedForInfinityValue = !1,
      unitlessNumbers = new Set(
        "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
          " "
        )
      ),
      MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML",
      SVG_NAMESPACE = "http://www.w3.org/2000/svg",
      aliases = new Map([
        ["acceptCharset", "accept-charset"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
        ["crossOrigin", "crossorigin"],
        ["accentHeight", "accent-height"],
        ["alignmentBaseline", "alignment-baseline"],
        ["arabicForm", "arabic-form"],
        ["baselineShift", "baseline-shift"],
        ["capHeight", "cap-height"],
        ["clipPath", "clip-path"],
        ["clipRule", "clip-rule"],
        ["colorInterpolation", "color-interpolation"],
        ["colorInterpolationFilters", "color-interpolation-filters"],
        ["colorProfile", "color-profile"],
        ["colorRendering", "color-rendering"],
        ["dominantBaseline", "dominant-baseline"],
        ["enableBackground", "enable-background"],
        ["fillOpacity", "fill-opacity"],
        ["fillRule", "fill-rule"],
        ["floodColor", "flood-color"],
        ["floodOpacity", "flood-opacity"],
        ["fontFamily", "font-family"],
        ["fontSize", "font-size"],
        ["fontSizeAdjust", "font-size-adjust"],
        ["fontStretch", "font-stretch"],
        ["fontStyle", "font-style"],
        ["fontVariant", "font-variant"],
        ["fontWeight", "font-weight"],
        ["glyphName", "glyph-name"],
        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
        ["glyphOrientationVertical", "glyph-orientation-vertical"],
        ["horizAdvX", "horiz-adv-x"],
        ["horizOriginX", "horiz-origin-x"],
        ["imageRendering", "image-rendering"],
        ["letterSpacing", "letter-spacing"],
        ["lightingColor", "lighting-color"],
        ["markerEnd", "marker-end"],
        ["markerMid", "marker-mid"],
        ["markerStart", "marker-start"],
        ["overlinePosition", "overline-position"],
        ["overlineThickness", "overline-thickness"],
        ["paintOrder", "paint-order"],
        ["panose-1", "panose-1"],
        ["pointerEvents", "pointer-events"],
        ["renderingIntent", "rendering-intent"],
        ["shapeRendering", "shape-rendering"],
        ["stopColor", "stop-color"],
        ["stopOpacity", "stop-opacity"],
        ["strikethroughPosition", "strikethrough-position"],
        ["strikethroughThickness", "strikethrough-thickness"],
        ["strokeDasharray", "stroke-dasharray"],
        ["strokeDashoffset", "stroke-dashoffset"],
        ["strokeLinecap", "stroke-linecap"],
        ["strokeLinejoin", "stroke-linejoin"],
        ["strokeMiterlimit", "stroke-miterlimit"],
        ["strokeOpacity", "stroke-opacity"],
        ["strokeWidth", "stroke-width"],
        ["textAnchor", "text-anchor"],
        ["textDecoration", "text-decoration"],
        ["textRendering", "text-rendering"],
        ["transformOrigin", "transform-origin"],
        ["underlinePosition", "underline-position"],
        ["underlineThickness", "underline-thickness"],
        ["unicodeBidi", "unicode-bidi"],
        ["unicodeRange", "unicode-range"],
        ["unitsPerEm", "units-per-em"],
        ["vAlphabetic", "v-alphabetic"],
        ["vHanging", "v-hanging"],
        ["vIdeographic", "v-ideographic"],
        ["vMathematical", "v-mathematical"],
        ["vectorEffect", "vector-effect"],
        ["vertAdvY", "vert-adv-y"],
        ["vertOriginX", "vert-origin-x"],
        ["vertOriginY", "vert-origin-y"],
        ["wordSpacing", "word-spacing"],
        ["writingMode", "writing-mode"],
        ["xmlnsXlink", "xmlns:xlink"],
        ["xHeight", "x-height"]
      ]),
      possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        fetchpriority: "fetchPriority",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        inert: "inert",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        popover: "popover",
        popovertarget: "popoverTarget",
        popovertargetaction: "popoverTargetAction",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        transformorigin: "transformOrigin",
        "transform-origin": "transformOrigin",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      },
      ariaProperties = {
        "aria-current": 0,
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      },
      warnedProperties$1 = {},
      rARIA$1 = RegExp(
        "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ),
      rARIACamel$1 = RegExp(
        "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ),
      didWarnValueNull = !1,
      warnedProperties = {},
      EVENT_NAME_REGEX = /^on./,
      INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/,
      rARIA = RegExp(
        "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ),
      rARIACamel = RegExp(
        "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ),
      isJavaScriptProtocol =
        /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i,
      currentReplayingEvent = null,
      restoreTarget = null,
      restoreQueue = null,
      isInsideEventHandler = !1,
      canUseDOM = !(
        "undefined" === typeof window ||
        "undefined" === typeof window.document ||
        "undefined" === typeof window.document.createElement
      ),
      passiveBrowserEventsSupported = !1;
    if (canUseDOM)
      try {
        var options$jscomp$0 = {};
        Object.defineProperty(options$jscomp$0, "passive", {
          get: function () {
            passiveBrowserEventsSupported = !0;
          }
        });
        window.addEventListener("test", options$jscomp$0, options$jscomp$0);
        window.removeEventListener("test", options$jscomp$0, options$jscomp$0);
      } catch (e) {
        passiveBrowserEventsSupported = !1;
      }
    var root = null,
      startText = null,
      fallbackText = null,
      EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function (event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      },
      SyntheticEvent = createSyntheticEvent(EventInterface),
      UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),
      SyntheticUIEvent = createSyntheticEvent(UIEventInterface),
      lastMovementX,
      lastMovementY,
      lastMouseEvent,
      MouseEventInterface = assign({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function (event) {
          return void 0 === event.relatedTarget
            ? event.fromElement === event.srcElement
              ? event.toElement
              : event.fromElement
            : event.relatedTarget;
        },
        movementX: function (event) {
          if ("movementX" in event) return event.movementX;
          event !== lastMouseEvent &&
            (lastMouseEvent && "mousemove" === event.type
              ? ((lastMovementX = event.screenX - lastMouseEvent.screenX),
                (lastMovementY = event.screenY - lastMouseEvent.screenY))
              : (lastMovementY = lastMovementX = 0),
            (lastMouseEvent = event));
          return lastMovementX;
        },
        movementY: function (event) {
          return "movementY" in event ? event.movementY : lastMovementY;
        }
      }),
      SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),
      DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }),
      SyntheticDragEvent = createSyntheticEvent(DragEventInterface),
      FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }),
      SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),
      AnimationEventInterface = assign({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }),
      SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),
      ClipboardEventInterface = assign({}, EventInterface, {
        clipboardData: function (event) {
          return "clipboardData" in event
            ? event.clipboardData
            : window.clipboardData;
        }
      }),
      SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),
      CompositionEventInterface = assign({}, EventInterface, { data: 0 }),
      SyntheticCompositionEvent = createSyntheticEvent(
        CompositionEventInterface
      ),
      SyntheticInputEvent = SyntheticCompositionEvent,
      normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      },
      translateToKey = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      },
      modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      },
      KeyboardEventInterface = assign({}, UIEventInterface, {
        key: function (nativeEvent) {
          if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if ("Unidentified" !== key) return key;
          }
          return "keypress" === nativeEvent.type
            ? ((nativeEvent = getEventCharCode(nativeEvent)),
              13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent))
            : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type
              ? translateToKey[nativeEvent.keyCode] || "Unidentified"
              : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        charCode: function (event) {
          return "keypress" === event.type ? getEventCharCode(event) : 0;
        },
        keyCode: function (event) {
          return "keydown" === event.type || "keyup" === event.type
            ? event.keyCode
            : 0;
        },
        which: function (event) {
          return "keypress" === event.type
            ? getEventCharCode(event)
            : "keydown" === event.type || "keyup" === event.type
              ? event.keyCode
              : 0;
        }
      }),
      SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),
      PointerEventInterface = assign({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      }),
      SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),
      TouchEventInterface = assign({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
      }),
      SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),
      TransitionEventInterface = assign({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }),
      SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),
      WheelEventInterface = assign({}, MouseEventInterface, {
        deltaX: function (event) {
          return "deltaX" in event
            ? event.deltaX
            : "wheelDeltaX" in event
              ? -event.wheelDeltaX
              : 0;
        },
        deltaY: function (event) {
          return "deltaY" in event
            ? event.deltaY
            : "wheelDeltaY" in event
              ? -event.wheelDeltaY
              : "wheelDelta" in event
                ? -event.wheelDelta
                : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      }),
      SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),
      ToggleEventInterface = assign({}, EventInterface, {
        newState: 0,
        oldState: 0
      }),
      SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),
      END_KEYCODES = [9, 13, 27, 32],
      START_KEYCODE = 229,
      canUseCompositionEvent = canUseDOM && "CompositionEvent" in window,
      documentMode = null;
    canUseDOM &&
      "documentMode" in document &&
      (documentMode = document.documentMode);
    var canUseTextInputEvent =
        canUseDOM && "TextEvent" in window && !documentMode,
      useFallbackCompositionData =
        canUseDOM &&
        (!canUseCompositionEvent ||
          (documentMode && 8 < documentMode && 11 >= documentMode)),
      SPACEBAR_CODE = 32,
      SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE),
      hasSpaceKeypress = !1,
      isComposing = !1,
      supportedInputTypes = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
      },
      activeElement$1 = null,
      activeElementInst$1 = null,
      isInputEventSupported = !1;
    canUseDOM &&
      (isInputEventSupported =
        isEventSupported("input") &&
        (!document.documentMode || 9 < document.documentMode));
    var objectIs = "function" === typeof Object.is ? Object.is : is,
      skipSelectionChangeEvent =
        canUseDOM && "documentMode" in document && 11 >= document.documentMode,
      activeElement = null,
      activeElementInst = null,
      lastSelection = null,
      mouseDown = !1,
      vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionrun: makePrefixMap("Transition", "TransitionRun"),
        transitionstart: makePrefixMap("Transition", "TransitionStart"),
        transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      },
      prefixedEventNames = {},
      style = {};
    canUseDOM &&
      ((style = document.createElement("div").style),
      "AnimationEvent" in window ||
        (delete vendorPrefixes.animationend.animation,
        delete vendorPrefixes.animationiteration.animation,
        delete vendorPrefixes.animationstart.animation),
      "TransitionEvent" in window ||
        delete vendorPrefixes.transitionend.transition);
    var ANIMATION_END = getVendorPrefixedEventName("animationend"),
      ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"),
      ANIMATION_START = getVendorPrefixedEventName("animationstart"),
      TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"),
      TRANSITION_START = getVendorPrefixedEventName("transitionstart"),
      TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"),
      TRANSITION_END = getVendorPrefixedEventName("transitionend"),
      topLevelEventsToReactNames = new Map(),
      simpleEventPluginEvents =
        "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
          " "
        );
    simpleEventPluginEvents.push("scrollEnd");
    var CapturedStacks = new WeakMap(),
      OffscreenVisible = 1,
      OffscreenPassiveEffectsConnected = 2,
      concurrentQueues = [],
      concurrentQueuesIndex = 0,
      concurrentlyUpdatedLanes = 0,
      emptyContextObject = {};
    Object.freeze(emptyContextObject);
    var resolveFamily = null,
      failedBoundaries = null,
      NoMode = 0,
      ConcurrentMode = 1,
      ProfileMode = 2,
      StrictLegacyMode = 8,
      StrictEffectsMode = 16,
      NoStrictPassiveEffectsMode = 64;
    var hasBadMapPolyfill = !1;
    try {
      var nonExtensibleObject = Object.preventExtensions({});
      new Map([[nonExtensibleObject, null]]);
      new Set([nonExtensibleObject]);
    } catch (e$3) {
      hasBadMapPolyfill = !0;
    }
    var forkStack = [],
      forkStackIndex = 0,
      treeForkProvider = null,
      treeForkCount = 0,
      idStack = [],
      idStackIndex = 0,
      treeContextProvider = null,
      treeContextId = 1,
      treeContextOverflow = "",
      hydrationParentFiber = null,
      nextHydratableInstance = null,
      isHydrating = !1,
      didSuspendOrErrorDEV = !1,
      hydrationDiffRootDEV = null,
      hydrationErrors = null,
      rootOrSingletonContext = !1,
      HydrationMismatchException = Error(
        "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
      ),
      lastResetTime = 0;
    if (
      "object" === typeof performance &&
      "function" === typeof performance.now
    ) {
      var localPerformance = performance;
      var getCurrentTime = function () {
        return localPerformance.now();
      };
    } else {
      var localDate = Date;
      getCurrentTime = function () {
        return localDate.now();
      };
    }
    var valueCursor = createCursor(null);
    var rendererCursorDEV = createCursor(null);
    var rendererSigil = {};
    var currentlyRenderingFiber$1 = null,
      lastContextDependency = null,
      isDisallowedContextReadInDEV = !1,
      AbortControllerLocal =
        "undefined" !== typeof AbortController
          ? AbortController
          : function () {
              var listeners = [],
                signal = (this.signal = {
                  aborted: !1,
                  addEventListener: function (type, listener) {
                    listeners.push(listener);
                  }
                });
              this.abort = function () {
                signal.aborted = !0;
                listeners.forEach(function (listener) {
                  return listener();
                });
              };
            },
      scheduleCallback$2 = Scheduler.unstable_scheduleCallback,
      NormalPriority = Scheduler.unstable_NormalPriority,
      CacheContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0,
        _currentRenderer: null,
        _currentRenderer2: null
      },
      now = Scheduler.unstable_now,
      renderStartTime = -0,
      commitStartTime = -0,
      profilerStartTime = -1.1,
      profilerEffectDuration = -0,
      currentUpdateIsNested = !1,
      nestedUpdateScheduled = !1,
      currentEntangledListeners = null,
      currentEntangledPendingCount = 0,
      currentEntangledLane = 0,
      currentEntangledActionThenable = null,
      prevOnStartTransitionFinish = ReactSharedInternals.S;
    ReactSharedInternals.S = function (transition, returnValue) {
      "object" === typeof returnValue &&
        null !== returnValue &&
        "function" === typeof returnValue.then &&
        entangleAsyncAction(transition, returnValue);
      null !== prevOnStartTransitionFinish &&
        prevOnStartTransitionFinish(transition, returnValue);
    };
    var resumedCache = createCursor(null),
      ReactStrictModeWarnings = {
        recordUnsafeLifecycleWarnings: function () {},
        flushPendingUnsafeLifecycleWarnings: function () {},
        recordLegacyContextWarning: function () {},
        flushLegacyContextWarning: function () {},
        discardPendingWarnings: function () {}
      },
      pendingComponentWillMountWarnings = [],
      pendingUNSAFE_ComponentWillMountWarnings = [],
      pendingComponentWillReceivePropsWarnings = [],
      pendingUNSAFE_ComponentWillReceivePropsWarnings = [],
      pendingComponentWillUpdateWarnings = [],
      pendingUNSAFE_ComponentWillUpdateWarnings = [],
      didWarnAboutUnsafeLifecycles = new Set();
    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (
      fiber,
      instance
    ) {
      didWarnAboutUnsafeLifecycles.has(fiber.type) ||
        ("function" === typeof instance.componentWillMount &&
          !0 !== instance.componentWillMount.__suppressDeprecationWarning &&
          pendingComponentWillMountWarnings.push(fiber),
        fiber.mode & StrictLegacyMode &&
          "function" === typeof instance.UNSAFE_componentWillMount &&
          pendingUNSAFE_ComponentWillMountWarnings.push(fiber),
        "function" === typeof instance.componentWillReceiveProps &&
          !0 !==
            instance.componentWillReceiveProps.__suppressDeprecationWarning &&
          pendingComponentWillReceivePropsWarnings.push(fiber),
        fiber.mode & StrictLegacyMode &&
          "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
          pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber),
        "function" === typeof instance.componentWillUpdate &&
          !0 !== instance.componentWillUpdate.__suppressDeprecationWarning &&
          pendingComponentWillUpdateWarnings.push(fiber),
        fiber.mode & StrictLegacyMode &&
          "function" === typeof instance.UNSAFE_componentWillUpdate &&
          pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
    };
    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
      var componentWillMountUniqueNames = new Set();
      0 < pendingComponentWillMountWarnings.length &&
        (pendingComponentWillMountWarnings.forEach(function (fiber) {
          componentWillMountUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }),
        (pendingComponentWillMountWarnings = []));
      var UNSAFE_componentWillMountUniqueNames = new Set();
      0 < pendingUNSAFE_ComponentWillMountWarnings.length &&
        (pendingUNSAFE_ComponentWillMountWarnings.forEach(function (fiber) {
          UNSAFE_componentWillMountUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }),
        (pendingUNSAFE_ComponentWillMountWarnings = []));
      var componentWillReceivePropsUniqueNames = new Set();
      0 < pendingComponentWillReceivePropsWarnings.length &&
        (pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
          componentWillReceivePropsUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }),
        (pendingComponentWillReceivePropsWarnings = []));
      var UNSAFE_componentWillReceivePropsUniqueNames = new Set();
      0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length &&
        (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(
          function (fiber) {
            UNSAFE_componentWillReceivePropsUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }
        ),
        (pendingUNSAFE_ComponentWillReceivePropsWarnings = []));
      var componentWillUpdateUniqueNames = new Set();
      0 < pendingComponentWillUpdateWarnings.length &&
        (pendingComponentWillUpdateWarnings.forEach(function (fiber) {
          componentWillUpdateUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }),
        (pendingComponentWillUpdateWarnings = []));
      var UNSAFE_componentWillUpdateUniqueNames = new Set();
      0 < pendingUNSAFE_ComponentWillUpdateWarnings.length &&
        (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function (fiber) {
          UNSAFE_componentWillUpdateUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }),
        (pendingUNSAFE_ComponentWillUpdateWarnings = []));
      if (0 < UNSAFE_componentWillMountUniqueNames.size) {
        var sortedNames = setToSortedString(
          UNSAFE_componentWillMountUniqueNames
        );
        console.error(
          "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s",
          sortedNames
        );
      }
      0 < UNSAFE_componentWillReceivePropsUniqueNames.size &&
        ((sortedNames = setToSortedString(
          UNSAFE_componentWillReceivePropsUniqueNames
        )),
        console.error(
          "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s",
          sortedNames
        ));
      0 < UNSAFE_componentWillUpdateUniqueNames.size &&
        ((sortedNames = setToSortedString(
          UNSAFE_componentWillUpdateUniqueNames
        )),
        console.error(
          "Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s",
          sortedNames
        ));
      0 < componentWillMountUniqueNames.size &&
        ((sortedNames = setToSortedString(componentWillMountUniqueNames)),
        console.warn(
          "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
          sortedNames
        ));
      0 < componentWillReceivePropsUniqueNames.size &&
        ((sortedNames = setToSortedString(
          componentWillReceivePropsUniqueNames
        )),
        console.warn(
          "componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
          sortedNames
        ));
      0 < componentWillUpdateUniqueNames.size &&
        ((sortedNames = setToSortedString(componentWillUpdateUniqueNames)),
        console.warn(
          "componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
          sortedNames
        ));
    };
    var pendingLegacyContextWarning = new Map(),
      didWarnAboutLegacyContext = new Set();
    ReactStrictModeWarnings.recordLegacyContextWarning = function (
      fiber,
      instance
    ) {
      var strictRoot = null;
      for (var node = fiber; null !== node; )
        node.mode & StrictLegacyMode && (strictRoot = node),
          (node = node.return);
      null === strictRoot
        ? console.error(
            "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
          )
        : !didWarnAboutLegacyContext.has(fiber.type) &&
          ((node = pendingLegacyContextWarning.get(strictRoot)),
          null != fiber.type.contextTypes ||
            null != fiber.type.childContextTypes ||
            (null !== instance &&
              "function" === typeof instance.getChildContext)) &&
          (void 0 === node &&
            ((node = []), pendingLegacyContextWarning.set(strictRoot, node)),
          node.push(fiber));
    };
    ReactStrictModeWarnings.flushLegacyContextWarning = function () {
      pendingLegacyContextWarning.forEach(function (fiberArray) {
        if (0 !== fiberArray.length) {
          var firstFiber = fiberArray[0],
            uniqueNames = new Set();
          fiberArray.forEach(function (fiber) {
            uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
            didWarnAboutLegacyContext.add(fiber.type);
          });
          var sortedNames = setToSortedString(uniqueNames);
          runWithFiberInDEV(firstFiber, function () {
            console.error(
              "Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context",
              sortedNames
            );
          });
        }
      });
    };
    ReactStrictModeWarnings.discardPendingWarnings = function () {
      pendingComponentWillMountWarnings = [];
      pendingUNSAFE_ComponentWillMountWarnings = [];
      pendingComponentWillReceivePropsWarnings = [];
      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
      pendingComponentWillUpdateWarnings = [];
      pendingUNSAFE_ComponentWillUpdateWarnings = [];
      pendingLegacyContextWarning = new Map();
    };
    var SuspenseException = Error(
        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
      ),
      SuspenseyCommitException = Error(
        "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
      ),
      SuspenseActionException = Error(
        "Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."
      ),
      noopSuspenseyCommitThenable = {
        then: function () {
          console.error(
            'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
          );
        }
      },
      suspendedThenable = null,
      needsToResetSuspendedThenableDEV = !1,
      NoFlags = 0,
      HasEffect = 1,
      Insertion = 2,
      Layout = 4,
      Passive = 8,
      UpdateState = 0,
      ReplaceState = 1,
      ForceUpdate = 2,
      CaptureUpdate = 3,
      hasForceUpdate = !1;
    var didWarnUpdateInsideUpdate = !1;
    var currentlyProcessingQueue = null;
    var didReadFromEntangledAsyncAction = !1,
      currentTreeHiddenStackCursor = createCursor(null),
      prevEntangledRenderLanesCursor = createCursor(0),
      didWarnUncachedGetSnapshot;
    var didWarnAboutMismatchedHooksForComponent = new Set();
    var didWarnAboutUseWrappedInTryCatch = new Set();
    var didWarnAboutAsyncClientComponent = new Set();
    var didWarnAboutUseFormState = new Set();
    var renderLanes = 0,
      currentlyRenderingFiber = null,
      currentHook = null,
      workInProgressHook = null,
      didScheduleRenderPhaseUpdate = !1,
      didScheduleRenderPhaseUpdateDuringThisPass = !1,
      shouldDoubleInvokeUserFnsInHooksDEV = !1,
      localIdCounter = 0,
      thenableIndexCounter$1 = 0,
      thenableState$1 = null,
      globalClientIdCounter = 0,
      RE_RENDER_LIMIT = 25,
      currentHookNameInDev = null,
      hookTypesDev = null,
      hookTypesUpdateIndexDev = -1,
      ignorePreviousDependencies = !1,
      ContextOnlyDispatcher = {
        readContext: readContext,
        use: use,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError,
        useHostTransitionStatus: throwInvalidHookError,
        useFormState: throwInvalidHookError,
        useActionState: throwInvalidHookError,
        useOptimistic: throwInvalidHookError,
        useMemoCache: throwInvalidHookError,
        useCacheRefresh: throwInvalidHookError
      },
      HooksDispatcherOnMountInDEV = null,
      HooksDispatcherOnMountWithHookTypesInDEV = null,
      HooksDispatcherOnUpdateInDEV = null,
      HooksDispatcherOnRerenderInDEV = null,
      InvalidNestedHooksDispatcherOnMountInDEV = null,
      InvalidNestedHooksDispatcherOnUpdateInDEV = null,
      InvalidNestedHooksDispatcherOnRerenderInDEV = null;
    HooksDispatcherOnMountInDEV = {
      readContext: function (context) {
        return readContext(context);
      },
      use: use,
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        mountHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, createDeps) {
        currentHookNameInDev = "useEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(createDeps);
        return mountEffect(create, createDeps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountLayoutEffect(create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function (initialValue) {
        currentHookNameInDev = "useRef";
        mountHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function (initialState) {
        currentHookNameInDev = "useState";
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        mountHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        mountHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        mountHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function (
        subscribe,
        getSnapshot,
        getServerSnapshot
      ) {
        currentHookNameInDev = "useSyncExternalStore";
        mountHookTypesDev();
        return mountSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      },
      useId: function () {
        currentHookNameInDev = "useId";
        mountHookTypesDev();
        return mountId();
      },
      useFormState: function (action, initialState) {
        currentHookNameInDev = "useFormState";
        mountHookTypesDev();
        warnOnUseFormStateInDev();
        return mountActionState(action, initialState);
      },
      useActionState: function (action, initialState) {
        currentHookNameInDev = "useActionState";
        mountHookTypesDev();
        return mountActionState(action, initialState);
      },
      useOptimistic: function (passthrough) {
        currentHookNameInDev = "useOptimistic";
        mountHookTypesDev();
        return mountOptimistic(passthrough);
      },
      useHostTransitionStatus: useHostTransitionStatus,
      useMemoCache: useMemoCache,
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        mountHookTypesDev();
        return mountRefresh();
      }
    };
    HooksDispatcherOnMountWithHookTypesInDEV = {
      readContext: function (context) {
        return readContext(context);
      },
      use: use,
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return mountCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, createDeps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        return mountEffect(create, createDeps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return mountLayoutEffect(create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function (initialValue) {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function (initialState) {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function (
        subscribe,
        getSnapshot,
        getServerSnapshot
      ) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return mountSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      },
      useId: function () {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return mountId();
      },
      useActionState: function (action, initialState) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return mountActionState(action, initialState);
      },
      useFormState: function (action, initialState) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return mountActionState(action, initialState);
      },
      useOptimistic: function (passthrough) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return mountOptimistic(passthrough);
      },
      useHostTransitionStatus: useHostTransitionStatus,
      useMemoCache: useMemoCache,
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return mountRefresh();
      }
    };
    HooksDispatcherOnUpdateInDEV = {
      readContext: function (context) {
        return readContext(context);
      },
      use: use,
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, createDeps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, createDeps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function () {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function () {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return updateDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return updateTransition();
      },
      useSyncExternalStore: function (
        subscribe,
        getSnapshot,
        getServerSnapshot
      ) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return updateSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      },
      useId: function () {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function (action) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return updateActionState(action);
      },
      useActionState: function (action) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return updateActionState(action);
      },
      useOptimistic: function (passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return updateOptimistic(passthrough, reducer);
      },
      useHostTransitionStatus: useHostTransitionStatus,
      useMemoCache: useMemoCache,
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      }
    };
    HooksDispatcherOnRerenderInDEV = {
      readContext: function (context) {
        return readContext(context);
      },
      use: use,
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, createDeps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, createDeps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return rerenderReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function () {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function () {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return rerenderReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return rerenderDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return rerenderTransition();
      },
      useSyncExternalStore: function (
        subscribe,
        getSnapshot,
        getServerSnapshot
      ) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return updateSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      },
      useId: function () {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function (action) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return rerenderActionState(action);
      },
      useActionState: function (action) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return rerenderActionState(action);
      },
      useOptimistic: function (passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return rerenderOptimistic(passthrough, reducer);
      },
      useHostTransitionStatus: useHostTransitionStatus,
      useMemoCache: useMemoCache,
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      }
    };
    InvalidNestedHooksDispatcherOnMountInDEV = {
      readContext: function (context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function (usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, createDeps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountEffect(create, createDeps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountLayoutEffect(create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function (initialValue) {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function (initialState) {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        mountHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function (
        subscribe,
        getSnapshot,
        getServerSnapshot
      ) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      },
      useId: function () {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountId();
      },
      useFormState: function (action, initialState) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountActionState(action, initialState);
      },
      useActionState: function (action, initialState) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountActionState(action, initialState);
      },
      useOptimistic: function (passthrough) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountOptimistic(passthrough);
      },
      useMemoCache: function (size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      },
      useHostTransitionStatus: useHostTransitionStatus,
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        mountHookTypesDev();
        return mountRefresh();
      }
    };
    InvalidNestedHooksDispatcherOnUpdateInDEV = {
      readContext: function (context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function (usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, createDeps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, createDeps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function () {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function () {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateTransition();
      },
      useSyncExternalStore: function (
        subscribe,
        getSnapshot,
        getServerSnapshot
      ) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      },
      useId: function () {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function (action) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateActionState(action);
      },
      useActionState: function (action) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateActionState(action);
      },
      useOptimistic: function (passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateOptimistic(passthrough, reducer);
      },
      useMemoCache: function (size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      },
      useHostTransitionStatus: useHostTransitionStatus,
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      }
    };
    InvalidNestedHooksDispatcherOnRerenderInDEV = {
      readContext: function (context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function (usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, createDeps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, createDeps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return rerenderReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function () {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function () {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return rerenderReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderTransition();
      },
      useSyncExternalStore: function (
        subscribe,
        getSnapshot,
        getServerSnapshot
      ) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      },
      useId: function () {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function (action) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderActionState(action);
      },
      useActionState: function (action) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderActionState(action);
      },
      useOptimistic: function (passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderOptimistic(passthrough, reducer);
      },
      useMemoCache: function (size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      },
      useHostTransitionStatus: useHostTransitionStatus,
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      }
    };
    var callComponent = {
        "react-stack-bottom-frame": function (Component, props, secondArg) {
          var wasRendering = isRendering;
          isRendering = !0;
          try {
            return Component(props, secondArg);
          } finally {
            isRendering = wasRendering;
          }
        }
      },
      callComponentInDEV =
        callComponent["react-stack-bottom-frame"].bind(callComponent),
      callRender = {
        "react-stack-bottom-frame": function (instance) {
          var wasRendering = isRendering;
          isRendering = !0;
          try {
            return instance.render();
          } finally {
            isRendering = wasRendering;
          }
        }
      },
      callRenderInDEV = callRender["react-stack-bottom-frame"].bind(callRender),
      callComponentDidMount = {
        "react-stack-bottom-frame": function (finishedWork, instance) {
          try {
            instance.componentDidMount();
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      },
      callComponentDidMountInDEV = callComponentDidMount[
        "react-stack-bottom-frame"
      ].bind(callComponentDidMount),
      callComponentDidUpdate = {
        "react-stack-bottom-frame": function (
          finishedWork,
          instance,
          prevProps,
          prevState,
          snapshot
        ) {
          try {
            instance.componentDidUpdate(prevProps, prevState, snapshot);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      },
      callComponentDidUpdateInDEV = callComponentDidUpdate[
        "react-stack-bottom-frame"
      ].bind(callComponentDidUpdate),
      callComponentDidCatch = {
        "react-stack-bottom-frame": function (instance, errorInfo) {
          var stack = errorInfo.stack;
          instance.componentDidCatch(errorInfo.value, {
            componentStack: null !== stack ? stack : ""
          });
        }
      },
      callComponentDidCatchInDEV = callComponentDidCatch[
        "react-stack-bottom-frame"
      ].bind(callComponentDidCatch),
      callComponentWillUnmount = {
        "react-stack-bottom-frame": function (
          current,
          nearestMountedAncestor,
          instance
        ) {
          try {
            instance.componentWillUnmount();
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          }
        }
      },
      callComponentWillUnmountInDEV = callComponentWillUnmount[
        "react-stack-bottom-frame"
      ].bind(callComponentWillUnmount),
      callCreate = {
        "react-stack-bottom-frame": function (effect) {
          null != effect.resourceKind &&
            console.error(
              "Expected only SimpleEffects when enableUseEffectCRUDOverload is disabled, got %s",
              effect.resourceKind
            );
          var create = effect.create;
          effect = effect.inst;
          create = create();
          return (effect.destroy = create);
        }
      },
      callCreateInDEV = callCreate["react-stack-bottom-frame"].bind(callCreate),
      callDestroy = {
        "react-stack-bottom-frame": function (
          current,
          nearestMountedAncestor,
          destroy
        ) {
          try {
            destroy();
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          }
        }
      },
      callDestroyInDEV =
        callDestroy["react-stack-bottom-frame"].bind(callDestroy),
      callLazyInit = {
        "react-stack-bottom-frame": function (lazy) {
          var init = lazy._init;
          return init(lazy._payload);
        }
      },
      callLazyInitInDEV =
        callLazyInit["react-stack-bottom-frame"].bind(callLazyInit),
      thenableState = null,
      thenableIndexCounter = 0,
      currentDebugInfo = null,
      didWarnAboutMaps;
    var didWarnAboutGenerators = (didWarnAboutMaps = !1);
    var ownerHasKeyUseWarning = {};
    var ownerHasFunctionTypeWarning = {};
    var ownerHasSymbolTypeWarning = {};
    warnForMissingKey = function (returnFiber, workInProgress, child) {
      if (
        null !== child &&
        "object" === typeof child &&
        child._store &&
        ((!child._store.validated && null == child.key) ||
          2 === child._store.validated)
      ) {
        if ("object" !== typeof child._store)
          throw Error(
            "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
          );
        child._store.validated = 1;
        var componentName = getComponentNameFromFiber(returnFiber),
          componentKey = componentName || "null";
        if (!ownerHasKeyUseWarning[componentKey]) {
          ownerHasKeyUseWarning[componentKey] = !0;
          child = child._owner;
          returnFiber = returnFiber._debugOwner;
          var currentComponentErrorInfo = "";
          returnFiber &&
            "number" === typeof returnFiber.tag &&
            (componentKey = getComponentNameFromFiber(returnFiber)) &&
            (currentComponentErrorInfo =
              "\n\nCheck the render method of `" + componentKey + "`.");
          currentComponentErrorInfo ||
            (componentName &&
              (currentComponentErrorInfo =
                "\n\nCheck the top-level render call using <" +
                componentName +
                ">."));
          var childOwnerAppendix = "";
          null != child &&
            returnFiber !== child &&
            ((componentName = null),
            "number" === typeof child.tag
              ? (componentName = getComponentNameFromFiber(child))
              : "string" === typeof child.name && (componentName = child.name),
            componentName &&
              (childOwnerAppendix =
                " It was passed a child from " + componentName + "."));
          runWithFiberInDEV(workInProgress, function () {
            console.error(
              'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
              currentComponentErrorInfo,
              childOwnerAppendix
            );
          });
        }
      }
    };
    var reconcileChildFibers = createChildReconciler(!0),
      mountChildFibers = createChildReconciler(!1),
      suspenseHandlerStackCursor = createCursor(null),
      shellBoundary = null,
      SubtreeSuspenseContextMask = 1,
      ForceSuspenseFallback = 2,
      suspenseStackCursor = createCursor(0),
      fakeInternalInstance = {};
    var didWarnAboutStateAssignmentForComponent = new Set();
    var didWarnAboutUninitializedState = new Set();
    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
    var didWarnAboutDirectlyAssigningPropsToState = new Set();
    var didWarnAboutUndefinedDerivedState = new Set();
    var didWarnAboutContextTypes$1 = new Set();
    var didWarnAboutChildContextTypes = new Set();
    var didWarnAboutInvalidateContextType = new Set();
    var didWarnOnInvalidCallback = new Set();
    Object.freeze(fakeInternalInstance);
    var classComponentUpdater = {
        enqueueSetState: function (inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(inst),
            update = createUpdate(lane);
          update.payload = payload;
          void 0 !== callback &&
            null !== callback &&
            (warnOnInvalidCallback(callback), (update.callback = callback));
          payload = enqueueUpdate(inst, update, lane);
          null !== payload &&
            (scheduleUpdateOnFiber(payload, inst, lane),
            entangleTransitions(payload, inst, lane));
          markStateUpdateScheduled(inst, lane);
        },
        enqueueReplaceState: function (inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(inst),
            update = createUpdate(lane);
          update.tag = ReplaceState;
          update.payload = payload;
          void 0 !== callback &&
            null !== callback &&
            (warnOnInvalidCallback(callback), (update.callback = callback));
          payload = enqueueUpdate(inst, update, lane);
          null !== payload &&
            (scheduleUpdateOnFiber(payload, inst, lane),
            entangleTransitions(payload, inst, lane));
          markStateUpdateScheduled(inst, lane);
        },
        enqueueForceUpdate: function (inst, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(inst),
            update = createUpdate(lane);
          update.tag = ForceUpdate;
          void 0 !== callback &&
            null !== callback &&
            (warnOnInvalidCallback(callback), (update.callback = callback));
          callback = enqueueUpdate(inst, update, lane);
          null !== callback &&
            (scheduleUpdateOnFiber(callback, inst, lane),
            entangleTransitions(callback, inst, lane));
          null !== injectedProfilingHooks &&
            "function" ===
              typeof injectedProfilingHooks.markForceUpdateScheduled &&
            injectedProfilingHooks.markForceUpdateScheduled(inst, lane);
        }
      },
      reportGlobalError =
        "function" === typeof reportError
          ? reportError
          : function (error) {
              if (
                "object" === typeof window &&
                "function" === typeof window.ErrorEvent
              ) {
                var event = new window.ErrorEvent("error", {
                  bubbles: !0,
                  cancelable: !0,
                  message:
                    "object" === typeof error &&
                    null !== error &&
                    "string" === typeof error.message
                      ? String(error.message)
                      : String(error),
                  error: error
                });
                if (!window.dispatchEvent(event)) return;
              } else if (
                "object" === typeof process &&
                "function" === typeof process.emit
              ) {
                process.emit("uncaughtException", error);
                return;
              }
              console.error(error);
            },
      componentName = null,
      errorBoundaryName = null,
      SelectiveHydrationException = Error(
        "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
      ),
      didReceiveUpdate = !1;
    var didWarnAboutBadClass = {};
    var didWarnAboutContextTypeOnFunctionComponent = {};
    var didWarnAboutContextTypes = {};
    var didWarnAboutGetDerivedStateOnFunctionComponent = {};
    var didWarnAboutReassigningProps = !1;
    var didWarnAboutRevealOrder = {};
    var didWarnAboutTailOptions = {};
    var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
      },
      hasWarnedAboutUsingNoValuePropOnContextProvider = !1,
      didWarnAboutUndefinedSnapshotBeforeUpdate = null;
    didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
    var offscreenSubtreeIsHidden = !1,
      offscreenSubtreeWasHidden = !1,
      needsFormReset = !1,
      PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
      nextEffect = null,
      inProgressLanes = null,
      inProgressRoot = null,
      hostParent = null,
      hostParentIsContainer = !1,
      currentHoistableRoot = null,
      suspenseyCommitFlag = 8192,
      DefaultAsyncDispatcher = {
        getCacheForType: function (resourceType) {
          var cache = readContext(CacheContext),
            cacheForType = cache.data.get(resourceType);
          void 0 === cacheForType &&
            ((cacheForType = resourceType()),
            cache.data.set(resourceType, cacheForType));
          return cacheForType;
        },
        getOwner: function () {
          return current;
        }
      };
    if ("function" === typeof Symbol && Symbol.for) {
      var symbolFor = Symbol.for;
      symbolFor("selector.component");
      symbolFor("selector.has_pseudo_class");
      symbolFor("selector.role");
      symbolFor("selector.test_id");
      symbolFor("selector.text");
    }
    var commitHooks = [],
      PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
      NoContext = 0,
      RenderContext = 2,
      CommitContext = 4,
      RootInProgress = 0,
      RootFatalErrored = 1,
      RootErrored = 2,
      RootSuspended = 3,
      RootSuspendedWithDelay = 4,
      RootSuspendedAtTheShell = 6,
      RootCompleted = 5,
      executionContext = NoContext,
      workInProgressRoot = null,
      workInProgress = null,
      workInProgressRootRenderLanes = 0,
      NotSuspended = 0,
      SuspendedOnError = 1,
      SuspendedOnData = 2,
      SuspendedOnImmediate = 3,
      SuspendedOnInstance = 4,
      SuspendedOnInstanceAndReadyToContinue = 5,
      SuspendedOnDeprecatedThrowPromise = 6,
      SuspendedAndReadyToContinue = 7,
      SuspendedOnHydration = 8,
      SuspendedOnAction = 9,
      workInProgressSuspendedReason = NotSuspended,
      workInProgressThrownValue = null,
      workInProgressRootDidSkipSuspendedSiblings = !1,
      workInProgressRootIsPrerendering = !1,
      workInProgressRootDidAttachPingListener = !1,
      entangledRenderLanes = 0,
      workInProgressRootExitStatus = RootInProgress,
      workInProgressRootSkippedLanes = 0,
      workInProgressRootInterleavedUpdatedLanes = 0,
      workInProgressRootPingedLanes = 0,
      workInProgressDeferredLane = 0,
      workInProgressSuspendedRetryLanes = 0,
      workInProgressRootConcurrentErrors = null,
      workInProgressRootRecoverableErrors = null,
      workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
      globalMostRecentFallbackTime = 0,
      FALLBACK_THROTTLE_MS = 300,
      workInProgressRootRenderTargetTime = Infinity,
      RENDER_TIMEOUT_MS = 500,
      workInProgressTransitions = null,
      legacyErrorBoundariesThatAlreadyFailed = null,
      IMMEDIATE_COMMIT = 0,
      SUSPENDED_COMMIT = 1,
      THROTTLED_COMMIT = 2,
      NO_PENDING_EFFECTS = 0,
      PENDING_MUTATION_PHASE = 1,
      PENDING_LAYOUT_PHASE = 2,
      PENDING_AFTER_MUTATION_PHASE = 3,
      PENDING_SPAWNED_WORK = 4,
      PENDING_PASSIVE_PHASE = 5,
      pendingEffectsStatus = 0,
      pendingEffectsRoot = null,
      pendingFinishedWork = null,
      pendingEffectsLanes = 0,
      pendingEffectsRemainingLanes = 0,
      pendingPassiveTransitions = null,
      pendingRecoverableErrors = null,
      NESTED_UPDATE_LIMIT = 50,
      nestedUpdateCount = 0,
      rootWithNestedUpdates = null,
      isFlushingPassiveEffects = !1,
      didScheduleUpdateDuringPassiveEffects = !1,
      NESTED_PASSIVE_UPDATE_LIMIT = 50,
      nestedPassiveUpdateCount = 0,
      rootWithPassiveNestedUpdates = null,
      isRunningInsertionEffect = !1,
      didWarnStateUpdateForNotYetMountedComponent = null,
      didWarnAboutUpdateInRender = !1;
    var didWarnAboutUpdateInRenderForAnotherComponent = new Set();
    var fakeActCallbackNode$1 = {},
      firstScheduledRoot = null,
      lastScheduledRoot = null,
      didScheduleMicrotask = !1,
      didScheduleMicrotask_act = !1,
      mightHavePendingSyncWork = !1,
      isFlushingWork = !1,
      currentEventTransitionLane = 0,
      fakeActCallbackNode = {};
    (function () {
      for (var i = 0; i < simpleEventPluginEvents.length; i++) {
        var eventName = simpleEventPluginEvents[i],
          domEventName = eventName.toLowerCase();
        eventName = eventName[0].toUpperCase() + eventName.slice(1);
        registerSimpleEvent(domEventName, "on" + eventName);
      }
      registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
      registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
      registerSimpleEvent(ANIMATION_START, "onAnimationStart");
      registerSimpleEvent("dblclick", "onDoubleClick");
      registerSimpleEvent("focusin", "onFocus");
      registerSimpleEvent("focusout", "onBlur");
      registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
      registerSimpleEvent(TRANSITION_START, "onTransitionStart");
      registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
      registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
    })();
    registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
    registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
    registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
    registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
    registerTwoPhaseEvent(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " "
      )
    );
    registerTwoPhaseEvent(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    );
    registerTwoPhaseEvent("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]);
    registerTwoPhaseEvent(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    );
    registerTwoPhaseEvent(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    );
    registerTwoPhaseEvent(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
    var mediaEventTypes =
        "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
          " "
        ),
      nonDelegatedEvents = new Set(
        "beforetoggle cancel close invalid load scroll scrollend toggle"
          .split(" ")
          .concat(mediaEventTypes)
      ),
      listeningMarker = "_reactListening" + Math.random().toString(36).slice(2),
      didWarnControlledToUncontrolled = !1,
      didWarnUncontrolledToControlled = !1,
      didWarnFormActionType = !1,
      didWarnFormActionName = !1,
      didWarnFormActionTarget = !1,
      didWarnFormActionMethod = !1,
      didWarnPopoverTargetObject = !1;
    var didWarnForNewBooleanPropsWithEmptyValue = {};
    var NORMALIZE_NEWLINES_REGEX = /\r\n?/g,
      NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g,
      xlinkNamespace = "http://www.w3.org/1999/xlink",
      xmlNamespace = "http://www.w3.org/XML/1998/namespace",
      EXPECTED_FORM_ACTION_URL =
        "javascript:throw new Error('React form unexpectedly submitted.')",
      SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning",
      SUSPENSE_START_DATA = "$",
      SUSPENSE_END_DATA = "/$",
      SUSPENSE_PENDING_START_DATA = "$?",
      SUSPENSE_FALLBACK_START_DATA = "$!",
      PREAMBLE_CONTRIBUTION_HTML = 1,
      PREAMBLE_CONTRIBUTION_BODY = 2,
      PREAMBLE_CONTRIBUTION_HEAD = 4,
      FORM_STATE_IS_MATCHING = "F!",
      FORM_STATE_IS_NOT_MATCHING = "F",
      DOCUMENT_READY_STATE_COMPLETE = "complete",
      STYLE = "style",
      HostContextNamespaceNone = 0,
      HostContextNamespaceSvg = 1,
      HostContextNamespaceMath = 2,
      eventsEnabled = null,
      selectionInformation = null,
      warnedUnknownTags = { dialog: !0, webview: !0 },
      currentPopstateTransitionEvent = null,
      scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0,
      cancelTimeout =
        "function" === typeof clearTimeout ? clearTimeout : void 0,
      noTimeout = -1,
      localPromise = "function" === typeof Promise ? Promise : void 0,
      scheduleMicrotask =
        "function" === typeof queueMicrotask
          ? queueMicrotask
          : "undefined" !== typeof localPromise
            ? function (callback) {
                return localPromise
                  .resolve(null)
                  .then(callback)
                  .catch(handleErrorInNextTick);
              }
            : scheduleTimeout,
      previousHydratableOnEnteringScopedSingleton = null,
      NotLoaded = 0,
      Loaded = 1,
      Errored = 2,
      Settled = 3,
      Inserted = 4,
      preloadPropsMap = new Map(),
      preconnectsSet = new Set(),
      previousDispatcher = ReactDOMSharedInternals.d;
    ReactDOMSharedInternals.d = {
      f: function () {
        var previousWasRendering = previousDispatcher.f(),
          wasRendering = flushSyncWork$1();
        return previousWasRendering || wasRendering;
      },
      r: function (form) {
        var formInst = getInstanceFromNode(form);
        null !== formInst && 5 === formInst.tag && "form" === formInst.type
          ? requestFormReset$1(formInst)
          : previousDispatcher.r(form);
      },
      D: function (href) {
        previousDispatcher.D(href);
        preconnectAs("dns-prefetch", href, null);
      },
      C: function (href, crossOrigin) {
        previousDispatcher.C(href, crossOrigin);
        preconnectAs("preconnect", href, crossOrigin);
      },
      L: function (href, as, options) {
        previousDispatcher.L(href, as, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && href && as) {
          var preloadSelector =
            'link[rel="preload"][as="' +
            escapeSelectorAttributeValueInsideDoubleQuotes(as) +
            '"]';
          "image" === as
            ? options && options.imageSrcSet
              ? ((preloadSelector +=
                  '[imagesrcset="' +
                  escapeSelectorAttributeValueInsideDoubleQuotes(
                    options.imageSrcSet
                  ) +
                  '"]'),
                "string" === typeof options.imageSizes &&
                  (preloadSelector +=
                    '[imagesizes="' +
                    escapeSelectorAttributeValueInsideDoubleQuotes(
                      options.imageSizes
                    ) +
                    '"]'))
              : (preloadSelector +=
                  '[href="' +
                  escapeSelectorAttributeValueInsideDoubleQuotes(href) +
                  '"]')
            : (preloadSelector +=
                '[href="' +
                escapeSelectorAttributeValueInsideDoubleQuotes(href) +
                '"]');
          var key = preloadSelector;
          switch (as) {
            case "style":
              key = getStyleKey(href);
              break;
            case "script":
              key = getScriptKey(href);
          }
          preloadPropsMap.has(key) ||
            ((href = assign(
              {
                rel: "preload",
                href:
                  "image" === as && options && options.imageSrcSet
                    ? void 0
                    : href,
                as: as
              },
              options
            )),
            preloadPropsMap.set(key, href),
            null !== ownerDocument.querySelector(preloadSelector) ||
              ("style" === as &&
                ownerDocument.querySelector(
                  getStylesheetSelectorFromKey(key)
                )) ||
              ("script" === as &&
                ownerDocument.querySelector(getScriptSelectorFromKey(key))) ||
              ((as = ownerDocument.createElement("link")),
              setInitialProperties(as, "link", href),
              markNodeAsHoistable(as),
              ownerDocument.head.appendChild(as)));
        }
      },
      m: function (href, options) {
        previousDispatcher.m(href, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var as =
              options && "string" === typeof options.as ? options.as : "script",
            preloadSelector =
              'link[rel="modulepreload"][as="' +
              escapeSelectorAttributeValueInsideDoubleQuotes(as) +
              '"][href="' +
              escapeSelectorAttributeValueInsideDoubleQuotes(href) +
              '"]',
            key = preloadSelector;
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              key = getScriptKey(href);
          }
          if (
            !preloadPropsMap.has(key) &&
            ((href = assign({ rel: "modulepreload", href: href }, options)),
            preloadPropsMap.set(key, href),
            null === ownerDocument.querySelector(preloadSelector))
          ) {
            switch (as) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                  return;
            }
            as = ownerDocument.createElement("link");
            setInitialProperties(as, "link", href);
            markNodeAsHoistable(as);
            ownerDocument.head.appendChild(as);
          }
        }
      },
      X: function (src, options) {
        previousDispatcher.X(src, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
            key = getScriptKey(src),
            resource = scripts.get(key);
          resource ||
            ((resource = ownerDocument.querySelector(
              getScriptSelectorFromKey(key)
            )),
            resource ||
              ((src = assign({ src: src, async: !0 }, options)),
              (options = preloadPropsMap.get(key)) &&
                adoptPreloadPropsForScript(src, options),
              (resource = ownerDocument.createElement("script")),
              markNodeAsHoistable(resource),
              setInitialProperties(resource, "link", src),
              ownerDocument.head.appendChild(resource)),
            (resource = {
              type: "script",
              instance: resource,
              count: 1,
              state: null
            }),
            scripts.set(key, resource));
        }
      },
      S: function (href, precedence, options) {
        previousDispatcher.S(href, precedence, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,
            key = getStyleKey(href);
          precedence = precedence || "default";
          var resource = styles.get(key);
          if (!resource) {
            var state = { loading: NotLoaded, preload: null };
            if (
              (resource = ownerDocument.querySelector(
                getStylesheetSelectorFromKey(key)
              ))
            )
              state.loading = Loaded | Inserted;
            else {
              href = assign(
                {
                  rel: "stylesheet",
                  href: href,
                  "data-precedence": precedence
                },
                options
              );
              (options = preloadPropsMap.get(key)) &&
                adoptPreloadPropsForStylesheet(href, options);
              var link = (resource = ownerDocument.createElement("link"));
              markNodeAsHoistable(link);
              setInitialProperties(link, "link", href);
              link._p = new Promise(function (resolve, reject) {
                link.onload = resolve;
                link.onerror = reject;
              });
              link.addEventListener("load", function () {
                state.loading |= Loaded;
              });
              link.addEventListener("error", function () {
                state.loading |= Errored;
              });
              state.loading |= Inserted;
              insertStylesheet(resource, precedence, ownerDocument);
            }
            resource = {
              type: "stylesheet",
              instance: resource,
              count: 1,
              state: state
            };
            styles.set(key, resource);
          }
        }
      },
      M: function (src, options) {
        previousDispatcher.M(src, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
            key = getScriptKey(src),
            resource = scripts.get(key);
          resource ||
            ((resource = ownerDocument.querySelector(
              getScriptSelectorFromKey(key)
            )),
            resource ||
              ((src = assign({ src: src, async: !0, type: "module" }, options)),
              (options = preloadPropsMap.get(key)) &&
                adoptPreloadPropsForScript(src, options),
              (resource = ownerDocument.createElement("script")),
              markNodeAsHoistable(resource),
              setInitialProperties(resource, "link", src),
              ownerDocument.head.appendChild(resource)),
            (resource = {
              type: "script",
              instance: resource,
              count: 1,
              state: null
            }),
            scripts.set(key, resource));
        }
      }
    };
    var globalDocument = "undefined" === typeof document ? null : document,
      tagCaches = null,
      suspendedState = null,
      LAST_PRECEDENCE = null,
      precedencesByRoot = null,
      NotPendingTransition = NotPending,
      HostTransitionContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Provider: null,
        Consumer: null,
        _currentValue: NotPendingTransition,
        _currentValue2: NotPendingTransition,
        _threadCount: 0
      },
      badgeFormat = "%c%s%c ",
      badgeStyle =
        "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
      resetStyle = "",
      pad = " ",
      bind = Function.prototype.bind;
    var didWarnAboutNestedUpdates = !1;
    var overrideHookState = null,
      overrideHookStateDeletePath = null,
      overrideHookStateRenamePath = null,
      overrideProps = null,
      overridePropsDeletePath = null,
      overridePropsRenamePath = null,
      scheduleUpdate = null,
      setErrorHandler = null,
      setSuspenseHandler = null;
    overrideHookState = function (fiber, id, path, value) {
      id = findHook(fiber, id);
      null !== id &&
        ((path = copyWithSetImpl(id.memoizedState, path, 0, value)),
        (id.memoizedState = path),
        (id.baseState = path),
        (fiber.memoizedProps = assign({}, fiber.memoizedProps)),
        (path = enqueueConcurrentRenderForLane(fiber, 2)),
        null !== path && scheduleUpdateOnFiber(path, fiber, 2));
    };
    overrideHookStateDeletePath = function (fiber, id, path) {
      id = findHook(fiber, id);
      null !== id &&
        ((path = copyWithDeleteImpl(id.memoizedState, path, 0)),
        (id.memoizedState = path),
        (id.baseState = path),
        (fiber.memoizedProps = assign({}, fiber.memoizedProps)),
        (path = enqueueConcurrentRenderForLane(fiber, 2)),
        null !== path && scheduleUpdateOnFiber(path, fiber, 2));
    };
    overrideHookStateRenamePath = function (fiber, id, oldPath, newPath) {
      id = findHook(fiber, id);
      null !== id &&
        ((oldPath = copyWithRename(id.memoizedState, oldPath, newPath)),
        (id.memoizedState = oldPath),
        (id.baseState = oldPath),
        (fiber.memoizedProps = assign({}, fiber.memoizedProps)),
        (oldPath = enqueueConcurrentRenderForLane(fiber, 2)),
        null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));
    };
    overrideProps = function (fiber, path, value) {
      fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      path = enqueueConcurrentRenderForLane(fiber, 2);
      null !== path && scheduleUpdateOnFiber(path, fiber, 2);
    };
    overridePropsDeletePath = function (fiber, path) {
      fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      path = enqueueConcurrentRenderForLane(fiber, 2);
      null !== path && scheduleUpdateOnFiber(path, fiber, 2);
    };
    overridePropsRenamePath = function (fiber, oldPath, newPath) {
      fiber.pendingProps = copyWithRename(
        fiber.memoizedProps,
        oldPath,
        newPath
      );
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      oldPath = enqueueConcurrentRenderForLane(fiber, 2);
      null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);
    };
    scheduleUpdate = function (fiber) {
      var root = enqueueConcurrentRenderForLane(fiber, 2);
      null !== root && scheduleUpdateOnFiber(root, fiber, 2);
    };
    setErrorHandler = function (newShouldErrorImpl) {
      shouldErrorImpl = newShouldErrorImpl;
    };
    setSuspenseHandler = function (newShouldSuspendImpl) {
      shouldSuspendImpl = newShouldSuspendImpl;
    };
    var _enabled = !0,
      return_targetInst = null,
      hasScheduledReplayAttempt = !1,
      queuedFocus = null,
      queuedDrag = null,
      queuedMouse = null,
      queuedPointers = new Map(),
      queuedPointerCaptures = new Map(),
      queuedExplicitHydrationTargets = [],
      discreteReplayableEvents =
        "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
          " "
        ),
      lastScheduledReplayQueue = null;
    ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
      function (children) {
        var root = this._internalRoot;
        if (null === root) throw Error("Cannot update an unmounted root.");
        var args = arguments;
        "function" === typeof args[1]
          ? console.error(
              "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
            )
          : isValidContainer(args[1])
            ? console.error(
                "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
              )
            : "undefined" !== typeof args[1] &&
              console.error(
                "You passed a second argument to root.render(...) but it only accepts one argument."
              );
        args = children;
        var current = root.current,
          lane = requestUpdateLane(current);
        updateContainerImpl(current, lane, args, root, null, null);
      };
    ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount =
      function () {
        var args = arguments;
        "function" === typeof args[0] &&
          console.error(
            "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
          );
        args = this._internalRoot;
        if (null !== args) {
          this._internalRoot = null;
          var container = args.containerInfo;
          (executionContext & (RenderContext | CommitContext)) !== NoContext &&
            console.error(
              "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
            );
          updateContainerImpl(args.current, 2, null, args, null, null);
          flushSyncWork$1();
          container[internalContainerInstanceKey] = null;
        }
      };
    ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (
      target
    ) {
      if (target) {
        var updatePriority = resolveUpdatePriority();
        target = { blockedOn: null, target: target, priority: updatePriority };
        for (
          var i = 0;
          i < queuedExplicitHydrationTargets.length &&
          0 !== updatePriority &&
          updatePriority < queuedExplicitHydrationTargets[i].priority;
          i++
        );
        queuedExplicitHydrationTargets.splice(i, 0, target);
        0 === i && attemptExplicitHydrationTarget(target);
      }
    };
    (function () {
      var isomorphicReactPackageVersion = React.version;
      if ("19.1.0" !== isomorphicReactPackageVersion)
        throw Error(
          'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' +
            (isomorphicReactPackageVersion +
              "\n  - react-dom:  19.1.0\nLearn more: https://react.dev/warnings/version-mismatch")
        );
    })();
    ("function" === typeof Map &&
      null != Map.prototype &&
      "function" === typeof Map.prototype.forEach &&
      "function" === typeof Set &&
      null != Set.prototype &&
      "function" === typeof Set.prototype.clear &&
      "function" === typeof Set.prototype.forEach) ||
      console.error(
        "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
      );
    ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
      var fiber = componentOrElement._reactInternals;
      if (void 0 === fiber) {
        if ("function" === typeof componentOrElement.render)
          throw Error("Unable to find node on an unmounted component.");
        componentOrElement = Object.keys(componentOrElement).join(",");
        throw Error(
          "Argument appears to not be a ReactComponent. Keys: " +
            componentOrElement
        );
      }
      componentOrElement = findCurrentFiberUsingSlowPath(fiber);
      componentOrElement =
        null !== componentOrElement
          ? findCurrentHostFiberImpl(componentOrElement)
          : null;
      componentOrElement =
        null === componentOrElement ? null : componentOrElement.stateNode;
      return componentOrElement;
    };
    if (
      !(function () {
        var internals = {
          bundleType: 1,
          version: "19.1.0",
          rendererPackageName: "react-dom",
          currentDispatcherRef: ReactSharedInternals,
          reconcilerVersion: "19.1.0"
        };
        internals.overrideHookState = overrideHookState;
        internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
        internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
        internals.overrideProps = overrideProps;
        internals.overridePropsDeletePath = overridePropsDeletePath;
        internals.overridePropsRenamePath = overridePropsRenamePath;
        internals.scheduleUpdate = scheduleUpdate;
        internals.setErrorHandler = setErrorHandler;
        internals.setSuspenseHandler = setSuspenseHandler;
        internals.scheduleRefresh = scheduleRefresh;
        internals.scheduleRoot = scheduleRoot;
        internals.setRefreshHandler = setRefreshHandler;
        internals.getCurrentFiber = getCurrentFiberForDevTools;
        internals.getLaneLabelMap = getLaneLabelMap;
        internals.injectProfilingHooks = injectProfilingHooks;
        return injectInternals(internals);
      })() &&
      canUseDOM &&
      window.top === window.self &&
      ((-1 < navigator.userAgent.indexOf("Chrome") &&
        -1 === navigator.userAgent.indexOf("Edge")) ||
        -1 < navigator.userAgent.indexOf("Firefox"))
    ) {
      var protocol = window.location.protocol;
      /^(https?|file):$/.test(protocol) &&
        console.info(
          "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" +
            ("file:" === protocol
              ? "\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq"
              : ""),
          "font-weight:bold"
        );
    }
    exports.createRoot = function (container, options) {
      if (!isValidContainer(container))
        throw Error("Target container is not a DOM element.");
      warnIfReactDOMContainerInDEV(container);
      var isStrictMode = !1,
        identifierPrefix = "",
        onUncaughtError = defaultOnUncaughtError,
        onCaughtError = defaultOnCaughtError,
        onRecoverableError = defaultOnRecoverableError,
        transitionCallbacks = null;
      null !== options &&
        void 0 !== options &&
        (options.hydrate
          ? console.warn(
              "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
            )
          : "object" === typeof options &&
            null !== options &&
            options.$$typeof === REACT_ELEMENT_TYPE &&
            console.error(
              "You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);"
            ),
        !0 === options.unstable_strictMode && (isStrictMode = !0),
        void 0 !== options.identifierPrefix &&
          (identifierPrefix = options.identifierPrefix),
        void 0 !== options.onUncaughtError &&
          (onUncaughtError = options.onUncaughtError),
        void 0 !== options.onCaughtError &&
          (onCaughtError = options.onCaughtError),
        void 0 !== options.onRecoverableError &&
          (onRecoverableError = options.onRecoverableError),
        void 0 !== options.unstable_transitionCallbacks &&
          (transitionCallbacks = options.unstable_transitionCallbacks));
      options = createFiberRoot(
        container,
        1,
        !1,
        null,
        null,
        isStrictMode,
        identifierPrefix,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        transitionCallbacks,
        null
      );
      container[internalContainerInstanceKey] = options.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMRoot(options);
    };
    exports.hydrateRoot = function (container, initialChildren, options) {
      if (!isValidContainer(container))
        throw Error("Target container is not a DOM element.");
      warnIfReactDOMContainerInDEV(container);
      void 0 === initialChildren &&
        console.error(
          "Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)"
        );
      var isStrictMode = !1,
        identifierPrefix = "",
        onUncaughtError = defaultOnUncaughtError,
        onCaughtError = defaultOnCaughtError,
        onRecoverableError = defaultOnRecoverableError,
        transitionCallbacks = null,
        formState = null;
      null !== options &&
        void 0 !== options &&
        (!0 === options.unstable_strictMode && (isStrictMode = !0),
        void 0 !== options.identifierPrefix &&
          (identifierPrefix = options.identifierPrefix),
        void 0 !== options.onUncaughtError &&
          (onUncaughtError = options.onUncaughtError),
        void 0 !== options.onCaughtError &&
          (onCaughtError = options.onCaughtError),
        void 0 !== options.onRecoverableError &&
          (onRecoverableError = options.onRecoverableError),
        void 0 !== options.unstable_transitionCallbacks &&
          (transitionCallbacks = options.unstable_transitionCallbacks),
        void 0 !== options.formState && (formState = options.formState));
      initialChildren = createFiberRoot(
        container,
        1,
        !0,
        initialChildren,
        null != options ? options : null,
        isStrictMode,
        identifierPrefix,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        transitionCallbacks,
        formState
      );
      initialChildren.context = getContextForSubtree(null);
      options = initialChildren.current;
      isStrictMode = requestUpdateLane(options);
      isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
      identifierPrefix = createUpdate(isStrictMode);
      identifierPrefix.callback = null;
      enqueueUpdate(options, identifierPrefix, isStrictMode);
      options = isStrictMode;
      initialChildren.current.lanes = options;
      markRootUpdated$1(initialChildren, options);
      ensureRootIsScheduled(initialChildren);
      container[internalContainerInstanceKey] = initialChildren.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMHydrationRoot(initialChildren);
    };
    exports.version = "19.1.0";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();


/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


 true &&
  (function () {
    function noop() {}
    function testStringCoercion(value) {
      return "" + value;
    }
    function createPortal$1(children, containerInfo, implementation) {
      var key =
        3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      try {
        testStringCoercion(key);
        var JSCompiler_inline_result = !1;
      } catch (e) {
        JSCompiler_inline_result = !0;
      }
      JSCompiler_inline_result &&
        (console.error(
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          ("function" === typeof Symbol &&
            Symbol.toStringTag &&
            key[Symbol.toStringTag]) ||
            key.constructor.name ||
            "Object"
        ),
        testStringCoercion(key));
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: null == key ? null : "" + key,
        children: children,
        containerInfo: containerInfo,
        implementation: implementation
      };
    }
    function getCrossOriginStringAs(as, input) {
      if ("font" === as) return "";
      if ("string" === typeof input)
        return "use-credentials" === input ? input : "";
    }
    function getValueDescriptorExpectingObjectForWarning(thing) {
      return null === thing
        ? "`null`"
        : void 0 === thing
          ? "`undefined`"
          : "" === thing
            ? "an empty string"
            : 'something with type "' + typeof thing + '"';
    }
    function getValueDescriptorExpectingEnumForWarning(thing) {
      return null === thing
        ? "`null`"
        : void 0 === thing
          ? "`undefined`"
          : "" === thing
            ? "an empty string"
            : "string" === typeof thing
              ? JSON.stringify(thing)
              : "number" === typeof thing
                ? "`" + thing + "`"
                : 'something with type "' + typeof thing + '"';
    }
    function resolveDispatcher() {
      var dispatcher = ReactSharedInternals.H;
      null === dispatcher &&
        console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
      return dispatcher;
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = __webpack_require__(/*! react */ "./node_modules/react/index.js"),
      Internals = {
        d: {
          f: noop,
          r: function () {
            throw Error(
              "Invalid form element. requestFormReset must be passed a form that was rendered by React."
            );
          },
          D: noop,
          C: noop,
          L: noop,
          m: noop,
          X: noop,
          S: noop,
          M: noop
        },
        p: 0,
        findDOMNode: null
      },
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      ReactSharedInternals =
        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    ("function" === typeof Map &&
      null != Map.prototype &&
      "function" === typeof Map.prototype.forEach &&
      "function" === typeof Set &&
      null != Set.prototype &&
      "function" === typeof Set.prototype.clear &&
      "function" === typeof Set.prototype.forEach) ||
      console.error(
        "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
      );
    exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
      Internals;
    exports.createPortal = function (children, container) {
      var key =
        2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (
        !container ||
        (1 !== container.nodeType &&
          9 !== container.nodeType &&
          11 !== container.nodeType)
      )
        throw Error("Target container is not a DOM element.");
      return createPortal$1(children, container, null, key);
    };
    exports.flushSync = function (fn) {
      var previousTransition = ReactSharedInternals.T,
        previousUpdatePriority = Internals.p;
      try {
        if (((ReactSharedInternals.T = null), (Internals.p = 2), fn))
          return fn();
      } finally {
        (ReactSharedInternals.T = previousTransition),
          (Internals.p = previousUpdatePriority),
          Internals.d.f() &&
            console.error(
              "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
            );
      }
    };
    exports.preconnect = function (href, options) {
      "string" === typeof href && href
        ? null != options && "object" !== typeof options
          ? console.error(
              "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
              getValueDescriptorExpectingEnumForWarning(options)
            )
          : null != options &&
            "string" !== typeof options.crossOrigin &&
            console.error(
              "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
              getValueDescriptorExpectingObjectForWarning(options.crossOrigin)
            )
        : console.error(
            "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
      "string" === typeof href &&
        (options
          ? ((options = options.crossOrigin),
            (options =
              "string" === typeof options
                ? "use-credentials" === options
                  ? options
                  : ""
                : void 0))
          : (options = null),
        Internals.d.C(href, options));
    };
    exports.prefetchDNS = function (href) {
      if ("string" !== typeof href || !href)
        console.error(
          "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          getValueDescriptorExpectingObjectForWarning(href)
        );
      else if (1 < arguments.length) {
        var options = arguments[1];
        "object" === typeof options && options.hasOwnProperty("crossOrigin")
          ? console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            )
          : console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            );
      }
      "string" === typeof href && Internals.d.D(href);
    };
    exports.preinit = function (href, options) {
      "string" === typeof href && href
        ? null == options || "object" !== typeof options
          ? console.error(
              "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
              getValueDescriptorExpectingEnumForWarning(options)
            )
          : "style" !== options.as &&
            "script" !== options.as &&
            console.error(
              'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
              getValueDescriptorExpectingEnumForWarning(options.as)
            )
        : console.error(
            "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
      if (
        "string" === typeof href &&
        options &&
        "string" === typeof options.as
      ) {
        var as = options.as,
          crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),
          integrity =
            "string" === typeof options.integrity ? options.integrity : void 0,
          fetchPriority =
            "string" === typeof options.fetchPriority
              ? options.fetchPriority
              : void 0;
        "style" === as
          ? Internals.d.S(
              href,
              "string" === typeof options.precedence
                ? options.precedence
                : void 0,
              {
                crossOrigin: crossOrigin,
                integrity: integrity,
                fetchPriority: fetchPriority
              }
            )
          : "script" === as &&
            Internals.d.X(href, {
              crossOrigin: crossOrigin,
              integrity: integrity,
              fetchPriority: fetchPriority,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
      }
    };
    exports.preinitModule = function (href, options) {
      var encountered = "";
      ("string" === typeof href && href) ||
        (encountered +=
          " The `href` argument encountered was " +
          getValueDescriptorExpectingObjectForWarning(href) +
          ".");
      void 0 !== options && "object" !== typeof options
        ? (encountered +=
            " The `options` argument encountered was " +
            getValueDescriptorExpectingObjectForWarning(options) +
            ".")
        : options &&
          "as" in options &&
          "script" !== options.as &&
          (encountered +=
            " The `as` option encountered was " +
            getValueDescriptorExpectingEnumForWarning(options.as) +
            ".");
      if (encountered)
        console.error(
          "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
          encountered
        );
      else
        switch (
          ((encountered =
            options && "string" === typeof options.as ? options.as : "script"),
          encountered)
        ) {
          case "script":
            break;
          default:
            (encountered =
              getValueDescriptorExpectingEnumForWarning(encountered)),
              console.error(
                'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
                encountered,
                href
              );
        }
      if ("string" === typeof href)
        if ("object" === typeof options && null !== options) {
          if (null == options.as || "script" === options.as)
            (encountered = getCrossOriginStringAs(
              options.as,
              options.crossOrigin
            )),
              Internals.d.M(href, {
                crossOrigin: encountered,
                integrity:
                  "string" === typeof options.integrity
                    ? options.integrity
                    : void 0,
                nonce:
                  "string" === typeof options.nonce ? options.nonce : void 0
              });
        } else null == options && Internals.d.M(href);
    };
    exports.preload = function (href, options) {
      var encountered = "";
      ("string" === typeof href && href) ||
        (encountered +=
          " The `href` argument encountered was " +
          getValueDescriptorExpectingObjectForWarning(href) +
          ".");
      null == options || "object" !== typeof options
        ? (encountered +=
            " The `options` argument encountered was " +
            getValueDescriptorExpectingObjectForWarning(options) +
            ".")
        : ("string" === typeof options.as && options.as) ||
          (encountered +=
            " The `as` option encountered was " +
            getValueDescriptorExpectingObjectForWarning(options.as) +
            ".");
      encountered &&
        console.error(
          'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
          encountered
        );
      if (
        "string" === typeof href &&
        "object" === typeof options &&
        null !== options &&
        "string" === typeof options.as
      ) {
        encountered = options.as;
        var crossOrigin = getCrossOriginStringAs(
          encountered,
          options.crossOrigin
        );
        Internals.d.L(href, encountered, {
          crossOrigin: crossOrigin,
          integrity:
            "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0,
          type: "string" === typeof options.type ? options.type : void 0,
          fetchPriority:
            "string" === typeof options.fetchPriority
              ? options.fetchPriority
              : void 0,
          referrerPolicy:
            "string" === typeof options.referrerPolicy
              ? options.referrerPolicy
              : void 0,
          imageSrcSet:
            "string" === typeof options.imageSrcSet
              ? options.imageSrcSet
              : void 0,
          imageSizes:
            "string" === typeof options.imageSizes
              ? options.imageSizes
              : void 0,
          media: "string" === typeof options.media ? options.media : void 0
        });
      }
    };
    exports.preloadModule = function (href, options) {
      var encountered = "";
      ("string" === typeof href && href) ||
        (encountered +=
          " The `href` argument encountered was " +
          getValueDescriptorExpectingObjectForWarning(href) +
          ".");
      void 0 !== options && "object" !== typeof options
        ? (encountered +=
            " The `options` argument encountered was " +
            getValueDescriptorExpectingObjectForWarning(options) +
            ".")
        : options &&
          "as" in options &&
          "string" !== typeof options.as &&
          (encountered +=
            " The `as` option encountered was " +
            getValueDescriptorExpectingObjectForWarning(options.as) +
            ".");
      encountered &&
        console.error(
          'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
          encountered
        );
      "string" === typeof href &&
        (options
          ? ((encountered = getCrossOriginStringAs(
              options.as,
              options.crossOrigin
            )),
            Internals.d.m(href, {
              as:
                "string" === typeof options.as && "script" !== options.as
                  ? options.as
                  : void 0,
              crossOrigin: encountered,
              integrity:
                "string" === typeof options.integrity
                  ? options.integrity
                  : void 0
            }))
          : Internals.d.m(href));
    };
    exports.requestFormReset = function (form) {
      Internals.d.r(form);
    };
    exports.unstable_batchedUpdates = function (fn, a) {
      return fn(a);
    };
    exports.useFormState = function (action, initialState, permalink) {
      return resolveDispatcher().useFormState(action, initialState, permalink);
    };
    exports.useFormStatus = function () {
      return resolveDispatcher().useHostTransitionStatus();
    };
    exports.version = "19.1.0";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();


/***/ }),

/***/ "./node_modules/react-dom/client.js":
/*!******************************************!*\
  !*** ./node_modules/react-dom/client.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (true) {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-dom-client.development.js */ "./node_modules/react-dom/cjs/react-dom-client.development.js");
}


/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (true) {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ "./node_modules/react-dom/cjs/react-dom.development.js");
}


/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-runtime.development.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


 true &&
  (function () {
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type)
        return type.$$typeof === REACT_CLIENT_REFERENCE
          ? null
          : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if ("object" === typeof type)
        switch (
          ("number" === typeof type.tag &&
            console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ),
          type.$$typeof)
        ) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return (type.displayName || "Context") + ".Provider";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type ||
              ((type = innerType.displayName || innerType.name || ""),
              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
            return type;
          case REACT_MEMO_TYPE:
            return (
              (innerType = type.displayName || null),
              null !== innerType
                ? innerType
                : getComponentNameFromType(type.type) || "Memo"
            );
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {}
        }
      return null;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = !1;
      } catch (e) {
        JSCompiler_inline_result = !0;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 =
          ("function" === typeof Symbol &&
            Symbol.toStringTag &&
            value[Symbol.toStringTag]) ||
          value.constructor.name ||
          "Object";
        JSCompiler_temp_const.call(
          JSCompiler_inline_result,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          JSCompiler_inline_result$jscomp$0
        );
        return testStringCoercion(value);
      }
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE) return "<>";
      if (
        "object" === typeof type &&
        null !== type &&
        type.$$typeof === REACT_LAZY_TYPE
      )
        return "<...>";
      try {
        var name = getComponentNameFromType(type);
        return name ? "<" + name + ">" : "<...>";
      } catch (x) {
        return "<...>";
      }
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning) return !1;
      }
      return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown ||
          ((specialPropKeyWarningShown = !0),
          console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
      }
      warnAboutAccessingKey.isReactWarning = !0;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: !0
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] ||
        ((didWarnAboutElementRef[componentName] = !0),
        console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
      componentName = this.props.ref;
      return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(
      type,
      key,
      self,
      source,
      owner,
      props,
      debugStack,
      debugTask
    ) {
      self = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type,
        key: key,
        props: props,
        _owner: owner
      };
      null !== (void 0 !== self ? self : null)
        ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
          })
        : Object.defineProperty(type, "ref", { enumerable: !1, value: null });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function jsxDEVImpl(
      type,
      config,
      maybeKey,
      isStaticChildren,
      source,
      self,
      debugStack,
      debugTask
    ) {
      var children = config.children;
      if (void 0 !== children)
        if (isStaticChildren)
          if (isArrayImpl(children)) {
            for (
              isStaticChildren = 0;
              isStaticChildren < children.length;
              isStaticChildren++
            )
              validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
          } else
            console.error(
              "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
            );
        else validateChildKeys(children);
      if (hasOwnProperty.call(config, "key")) {
        children = getComponentNameFromType(type);
        var keys = Object.keys(config).filter(function (k) {
          return "key" !== k;
        });
        isStaticChildren =
          0 < keys.length
            ? "{key: someKey, " + keys.join(": ..., ") + ": ...}"
            : "{key: someKey}";
        didWarnAboutKeySpread[children + isStaticChildren] ||
          ((keys =
            0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}"),
          console.error(
            'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
            isStaticChildren,
            children,
            keys,
            children
          ),
          (didWarnAboutKeySpread[children + isStaticChildren] = !0));
      }
      children = null;
      void 0 !== maybeKey &&
        (checkKeyStringCoercion(maybeKey), (children = "" + maybeKey));
      hasValidKey(config) &&
        (checkKeyStringCoercion(config.key), (children = "" + config.key));
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config)
          "key" !== propName && (maybeKey[propName] = config[propName]);
      } else maybeKey = config;
      children &&
        defineKeyPropWarningGetter(
          maybeKey,
          "function" === typeof type
            ? type.displayName || type.name || "Unknown"
            : type
        );
      return ReactElement(
        type,
        children,
        self,
        source,
        getOwner(),
        maybeKey,
        debugStack,
        debugTask
      );
    }
    function validateChildKeys(node) {
      "object" === typeof node &&
        null !== node &&
        node.$$typeof === REACT_ELEMENT_TYPE &&
        node._store &&
        (node._store.validated = 1);
    }
    var React = __webpack_require__(/*! react */ "./node_modules/react/index.js"),
      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
      REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
      REACT_MEMO_TYPE = Symbol.for("react.memo"),
      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
      REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
      ReactSharedInternals =
        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      hasOwnProperty = Object.prototype.hasOwnProperty,
      isArrayImpl = Array.isArray,
      createTask = console.createTask
        ? console.createTask
        : function () {
            return null;
          };
    React = {
      "react-stack-bottom-frame": function (callStackForError) {
        return callStackForError();
      }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React["react-stack-bottom-frame"].bind(
      React,
      UnknownOwner
    )();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsx = function (type, config, maybeKey, source, self) {
      var trackActualOwner =
        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(
        type,
        config,
        maybeKey,
        !1,
        source,
        self,
        trackActualOwner
          ? Error("react-stack-top-frame")
          : unknownOwnerDebugStack,
        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
      );
    };
    exports.jsxs = function (type, config, maybeKey, source, self) {
      var trackActualOwner =
        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(
        type,
        config,
        maybeKey,
        !0,
        source,
        self,
        trackActualOwner
          ? Error("react-stack-top-frame")
          : unknownOwnerDebugStack,
        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
      );
    };
  })();


/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


 true &&
  (function () {
    function defineDeprecationWarning(methodName, info) {
      Object.defineProperty(Component.prototype, methodName, {
        get: function () {
          console.warn(
            "%s(...) is deprecated in plain JavaScript React classes. %s",
            info[0],
            info[1]
          );
        }
      });
    }
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable)
        return null;
      maybeIterable =
        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
        maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    function warnNoop(publicInstance, callerName) {
      publicInstance =
        ((publicInstance = publicInstance.constructor) &&
          (publicInstance.displayName || publicInstance.name)) ||
        "ReactClass";
      var warningKey = publicInstance + "." + callerName;
      didWarnStateUpdateForUnmountedComponent[warningKey] ||
        (console.error(
          "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
          callerName,
          publicInstance
        ),
        (didWarnStateUpdateForUnmountedComponent[warningKey] = !0));
    }
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function ComponentDummy() {}
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = !1;
      } catch (e) {
        JSCompiler_inline_result = !0;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 =
          ("function" === typeof Symbol &&
            Symbol.toStringTag &&
            value[Symbol.toStringTag]) ||
          value.constructor.name ||
          "Object";
        JSCompiler_temp_const.call(
          JSCompiler_inline_result,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          JSCompiler_inline_result$jscomp$0
        );
        return testStringCoercion(value);
      }
    }
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type)
        return type.$$typeof === REACT_CLIENT_REFERENCE
          ? null
          : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if ("object" === typeof type)
        switch (
          ("number" === typeof type.tag &&
            console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ),
          type.$$typeof)
        ) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return (type.displayName || "Context") + ".Provider";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type ||
              ((type = innerType.displayName || innerType.name || ""),
              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
            return type;
          case REACT_MEMO_TYPE:
            return (
              (innerType = type.displayName || null),
              null !== innerType
                ? innerType
                : getComponentNameFromType(type.type) || "Memo"
            );
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {}
        }
      return null;
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE) return "<>";
      if (
        "object" === typeof type &&
        null !== type &&
        type.$$typeof === REACT_LAZY_TYPE
      )
        return "<...>";
      try {
        var name = getComponentNameFromType(type);
        return name ? "<" + name + ">" : "<...>";
      } catch (x) {
        return "<...>";
      }
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning) return !1;
      }
      return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown ||
          ((specialPropKeyWarningShown = !0),
          console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
      }
      warnAboutAccessingKey.isReactWarning = !0;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: !0
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] ||
        ((didWarnAboutElementRef[componentName] = !0),
        console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
      componentName = this.props.ref;
      return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(
      type,
      key,
      self,
      source,
      owner,
      props,
      debugStack,
      debugTask
    ) {
      self = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type,
        key: key,
        props: props,
        _owner: owner
      };
      null !== (void 0 !== self ? self : null)
        ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
          })
        : Object.defineProperty(type, "ref", { enumerable: !1, value: null });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      newKey = ReactElement(
        oldElement.type,
        newKey,
        void 0,
        void 0,
        oldElement._owner,
        oldElement.props,
        oldElement._debugStack,
        oldElement._debugTask
      );
      oldElement._store &&
        (newKey._store.validated = oldElement._store.validated);
      return newKey;
    }
    function isValidElement(object) {
      return (
        "object" === typeof object &&
        null !== object &&
        object.$$typeof === REACT_ELEMENT_TYPE
      );
    }
    function escape(key) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return (
        "$" +
        key.replace(/[=:]/g, function (match) {
          return escaperLookup[match];
        })
      );
    }
    function getElementKey(element, index) {
      return "object" === typeof element &&
        null !== element &&
        null != element.key
        ? (checkKeyStringCoercion(element.key), escape("" + element.key))
        : index.toString(36);
    }
    function noop$1() {}
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch (
            ("string" === typeof thenable.status
              ? thenable.then(noop$1, noop$1)
              : ((thenable.status = "pending"),
                thenable.then(
                  function (fulfilledValue) {
                    "pending" === thenable.status &&
                      ((thenable.status = "fulfilled"),
                      (thenable.value = fulfilledValue));
                  },
                  function (error) {
                    "pending" === thenable.status &&
                      ((thenable.status = "rejected"),
                      (thenable.reason = error));
                  }
                )),
            thenable.status)
          ) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type = typeof children;
      if ("undefined" === type || "boolean" === type) children = null;
      var invokeCallback = !1;
      if (null === children) invokeCallback = !0;
      else
        switch (type) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = !0;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = !0;
                break;
              case REACT_LAZY_TYPE:
                return (
                  (invokeCallback = children._init),
                  mapIntoArray(
                    invokeCallback(children._payload),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  )
                );
            }
        }
      if (invokeCallback) {
        invokeCallback = children;
        callback = callback(invokeCallback);
        var childKey =
          "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
        isArrayImpl(callback)
          ? ((escapedPrefix = ""),
            null != childKey &&
              (escapedPrefix =
                childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"),
            mapIntoArray(callback, array, escapedPrefix, "", function (c) {
              return c;
            }))
          : null != callback &&
            (isValidElement(callback) &&
              (null != callback.key &&
                ((invokeCallback && invokeCallback.key === callback.key) ||
                  checkKeyStringCoercion(callback.key)),
              (escapedPrefix = cloneAndReplaceKey(
                callback,
                escapedPrefix +
                  (null == callback.key ||
                  (invokeCallback && invokeCallback.key === callback.key)
                    ? ""
                    : ("" + callback.key).replace(
                        userProvidedKeyEscapeRegex,
                        "$&/"
                      ) + "/") +
                  childKey
              )),
              "" !== nameSoFar &&
                null != invokeCallback &&
                isValidElement(invokeCallback) &&
                null == invokeCallback.key &&
                invokeCallback._store &&
                !invokeCallback._store.validated &&
                (escapedPrefix._store.validated = 2),
              (callback = escapedPrefix)),
            array.push(callback));
        return 1;
      }
      invokeCallback = 0;
      childKey = "" === nameSoFar ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var i = 0; i < children.length; i++)
          (nameSoFar = children[i]),
            (type = childKey + getElementKey(nameSoFar, i)),
            (invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            ));
      else if (((i = getIteratorFn(children)), "function" === typeof i))
        for (
          i === children.entries &&
            (didWarnAboutMaps ||
              console.warn(
                "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
              ),
            (didWarnAboutMaps = !0)),
            children = i.call(children),
            i = 0;
          !(nameSoFar = children.next()).done;

        )
          (nameSoFar = nameSoFar.value),
            (type = childKey + getElementKey(nameSoFar, i++)),
            (invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            ));
      else if ("object" === type) {
        if ("function" === typeof children.then)
          return mapIntoArray(
            resolveThenable(children),
            array,
            escapedPrefix,
            nameSoFar,
            callback
          );
        array = String(children);
        throw Error(
          "Objects are not valid as a React child (found: " +
            ("[object Object]" === array
              ? "object with keys {" + Object.keys(children).join(", ") + "}"
              : array) +
            "). If you meant to render a collection of children, use an array instead."
        );
      }
      return invokeCallback;
    }
    function mapChildren(children, func, context) {
      if (null == children) return children;
      var result = [],
        count = 0;
      mapIntoArray(children, result, "", "", function (child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (-1 === payload._status) {
        var ctor = payload._result;
        ctor = ctor();
        ctor.then(
          function (moduleObject) {
            if (0 === payload._status || -1 === payload._status)
              (payload._status = 1), (payload._result = moduleObject);
          },
          function (error) {
            if (0 === payload._status || -1 === payload._status)
              (payload._status = 2), (payload._result = error);
          }
        );
        -1 === payload._status &&
          ((payload._status = 0), (payload._result = ctor));
      }
      if (1 === payload._status)
        return (
          (ctor = payload._result),
          void 0 === ctor &&
            console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
              ctor
            ),
          "default" in ctor ||
            console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
              ctor
            ),
          ctor.default
        );
      throw payload._result;
    }
    function resolveDispatcher() {
      var dispatcher = ReactSharedInternals.H;
      null === dispatcher &&
        console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
      return dispatcher;
    }
    function noop() {}
    function enqueueTask(task) {
      if (null === enqueueTaskImpl)
        try {
          var requireString = ("require" + Math.random()).slice(0, 7);
          enqueueTaskImpl = (module && module[requireString]).call(
            module,
            "timers"
          ).setImmediate;
        } catch (_err) {
          enqueueTaskImpl = function (callback) {
            !1 === didWarnAboutMessageChannel &&
              ((didWarnAboutMessageChannel = !0),
              "undefined" === typeof MessageChannel &&
                console.error(
                  "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
                ));
            var channel = new MessageChannel();
            channel.port1.onmessage = callback;
            channel.port2.postMessage(void 0);
          };
        }
      return enqueueTaskImpl(task);
    }
    function aggregateErrors(errors) {
      return 1 < errors.length && "function" === typeof AggregateError
        ? new AggregateError(errors)
        : errors[0];
    }
    function popActScope(prevActQueue, prevActScopeDepth) {
      prevActScopeDepth !== actScopeDepth - 1 &&
        console.error(
          "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
        );
      actScopeDepth = prevActScopeDepth;
    }
    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
      var queue = ReactSharedInternals.actQueue;
      if (null !== queue)
        if (0 !== queue.length)
          try {
            flushActQueue(queue);
            enqueueTask(function () {
              return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
            });
            return;
          } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
          }
        else ReactSharedInternals.actQueue = null;
      0 < ReactSharedInternals.thrownErrors.length
        ? ((queue = aggregateErrors(ReactSharedInternals.thrownErrors)),
          (ReactSharedInternals.thrownErrors.length = 0),
          reject(queue))
        : resolve(returnValue);
    }
    function flushActQueue(queue) {
      if (!isFlushing) {
        isFlushing = !0;
        var i = 0;
        try {
          for (; i < queue.length; i++) {
            var callback = queue[i];
            do {
              ReactSharedInternals.didUsePromise = !1;
              var continuation = callback(!1);
              if (null !== continuation) {
                if (ReactSharedInternals.didUsePromise) {
                  queue[i] = callback;
                  queue.splice(0, i);
                  return;
                }
                callback = continuation;
              } else break;
            } while (1);
          }
          queue.length = 0;
        } catch (error) {
          queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
        } finally {
          isFlushing = !1;
        }
      }
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
      REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
      REACT_MEMO_TYPE = Symbol.for("react.memo"),
      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
      REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
      didWarnStateUpdateForUnmountedComponent = {},
      ReactNoopUpdateQueue = {
        isMounted: function () {
          return !1;
        },
        enqueueForceUpdate: function (publicInstance) {
          warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function (publicInstance) {
          warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function (publicInstance) {
          warnNoop(publicInstance, "setState");
        }
      },
      assign = Object.assign,
      emptyObject = {};
    Object.freeze(emptyObject);
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function (partialState, callback) {
      if (
        "object" !== typeof partialState &&
        "function" !== typeof partialState &&
        null != partialState
      )
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function (callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    var deprecatedAPIs = {
        isMounted: [
          "isMounted",
          "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
          "replaceState",
          "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
      },
      fnName;
    for (fnName in deprecatedAPIs)
      deprecatedAPIs.hasOwnProperty(fnName) &&
        defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    ComponentDummy.prototype = Component.prototype;
    deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
    deprecatedAPIs.constructor = PureComponent;
    assign(deprecatedAPIs, Component.prototype);
    deprecatedAPIs.isPureReactComponent = !0;
    var isArrayImpl = Array.isArray,
      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
      ReactSharedInternals = {
        H: null,
        A: null,
        T: null,
        S: null,
        V: null,
        actQueue: null,
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1,
        didUsePromise: !1,
        thrownErrors: [],
        getCurrentStack: null,
        recentlyCreatedOwnerStacks: 0
      },
      hasOwnProperty = Object.prototype.hasOwnProperty,
      createTask = console.createTask
        ? console.createTask
        : function () {
            return null;
          };
    deprecatedAPIs = {
      "react-stack-bottom-frame": function (callStackForError) {
        return callStackForError();
      }
    };
    var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = deprecatedAPIs[
      "react-stack-bottom-frame"
    ].bind(deprecatedAPIs, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutMaps = !1,
      userProvidedKeyEscapeRegex = /\/+/g,
      reportGlobalError =
        "function" === typeof reportError
          ? reportError
          : function (error) {
              if (
                "object" === typeof window &&
                "function" === typeof window.ErrorEvent
              ) {
                var event = new window.ErrorEvent("error", {
                  bubbles: !0,
                  cancelable: !0,
                  message:
                    "object" === typeof error &&
                    null !== error &&
                    "string" === typeof error.message
                      ? String(error.message)
                      : String(error),
                  error: error
                });
                if (!window.dispatchEvent(event)) return;
              } else if (
                "object" === typeof process &&
                "function" === typeof process.emit
              ) {
                process.emit("uncaughtException", error);
                return;
              }
              console.error(error);
            },
      didWarnAboutMessageChannel = !1,
      enqueueTaskImpl = null,
      actScopeDepth = 0,
      didWarnNoAwaitAct = !1,
      isFlushing = !1,
      queueSeveralMicrotasks =
        "function" === typeof queueMicrotask
          ? function (callback) {
              queueMicrotask(function () {
                return queueMicrotask(callback);
              });
            }
          : enqueueTask;
    deprecatedAPIs = Object.freeze({
      __proto__: null,
      c: function (size) {
        return resolveDispatcher().useMemoCache(size);
      }
    });
    exports.Children = {
      map: mapChildren,
      forEach: function (children, forEachFunc, forEachContext) {
        mapChildren(
          children,
          function () {
            forEachFunc.apply(this, arguments);
          },
          forEachContext
        );
      },
      count: function (children) {
        var n = 0;
        mapChildren(children, function () {
          n++;
        });
        return n;
      },
      toArray: function (children) {
        return (
          mapChildren(children, function (child) {
            return child;
          }) || []
        );
      },
      only: function (children) {
        if (!isValidElement(children))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return children;
      }
    };
    exports.Component = Component;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
      ReactSharedInternals;
    exports.__COMPILER_RUNTIME = deprecatedAPIs;
    exports.act = function (callback) {
      var prevActQueue = ReactSharedInternals.actQueue,
        prevActScopeDepth = actScopeDepth;
      actScopeDepth++;
      var queue = (ReactSharedInternals.actQueue =
          null !== prevActQueue ? prevActQueue : []),
        didAwaitActCall = !1;
      try {
        var result = callback();
      } catch (error) {
        ReactSharedInternals.thrownErrors.push(error);
      }
      if (0 < ReactSharedInternals.thrownErrors.length)
        throw (
          (popActScope(prevActQueue, prevActScopeDepth),
          (callback = aggregateErrors(ReactSharedInternals.thrownErrors)),
          (ReactSharedInternals.thrownErrors.length = 0),
          callback)
        );
      if (
        null !== result &&
        "object" === typeof result &&
        "function" === typeof result.then
      ) {
        var thenable = result;
        queueSeveralMicrotasks(function () {
          didAwaitActCall ||
            didWarnNoAwaitAct ||
            ((didWarnNoAwaitAct = !0),
            console.error(
              "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
            ));
        });
        return {
          then: function (resolve, reject) {
            didAwaitActCall = !0;
            thenable.then(
              function (returnValue) {
                popActScope(prevActQueue, prevActScopeDepth);
                if (0 === prevActScopeDepth) {
                  try {
                    flushActQueue(queue),
                      enqueueTask(function () {
                        return recursivelyFlushAsyncActWork(
                          returnValue,
                          resolve,
                          reject
                        );
                      });
                  } catch (error$0) {
                    ReactSharedInternals.thrownErrors.push(error$0);
                  }
                  if (0 < ReactSharedInternals.thrownErrors.length) {
                    var _thrownError = aggregateErrors(
                      ReactSharedInternals.thrownErrors
                    );
                    ReactSharedInternals.thrownErrors.length = 0;
                    reject(_thrownError);
                  }
                } else resolve(returnValue);
              },
              function (error) {
                popActScope(prevActQueue, prevActScopeDepth);
                0 < ReactSharedInternals.thrownErrors.length
                  ? ((error = aggregateErrors(
                      ReactSharedInternals.thrownErrors
                    )),
                    (ReactSharedInternals.thrownErrors.length = 0),
                    reject(error))
                  : reject(error);
              }
            );
          }
        };
      }
      var returnValue$jscomp$0 = result;
      popActScope(prevActQueue, prevActScopeDepth);
      0 === prevActScopeDepth &&
        (flushActQueue(queue),
        0 !== queue.length &&
          queueSeveralMicrotasks(function () {
            didAwaitActCall ||
              didWarnNoAwaitAct ||
              ((didWarnNoAwaitAct = !0),
              console.error(
                "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
              ));
          }),
        (ReactSharedInternals.actQueue = null));
      if (0 < ReactSharedInternals.thrownErrors.length)
        throw (
          ((callback = aggregateErrors(ReactSharedInternals.thrownErrors)),
          (ReactSharedInternals.thrownErrors.length = 0),
          callback)
        );
      return {
        then: function (resolve, reject) {
          didAwaitActCall = !0;
          0 === prevActScopeDepth
            ? ((ReactSharedInternals.actQueue = queue),
              enqueueTask(function () {
                return recursivelyFlushAsyncActWork(
                  returnValue$jscomp$0,
                  resolve,
                  reject
                );
              }))
            : resolve(returnValue$jscomp$0);
        }
      };
    };
    exports.cache = function (fn) {
      return function () {
        return fn.apply(null, arguments);
      };
    };
    exports.captureOwnerStack = function () {
      var getCurrentStack = ReactSharedInternals.getCurrentStack;
      return null === getCurrentStack ? null : getCurrentStack();
    };
    exports.cloneElement = function (element, config, children) {
      if (null === element || void 0 === element)
        throw Error(
          "The argument must be a React element, but you passed " +
            element +
            "."
        );
      var props = assign({}, element.props),
        key = element.key,
        owner = element._owner;
      if (null != config) {
        var JSCompiler_inline_result;
        a: {
          if (
            hasOwnProperty.call(config, "ref") &&
            (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
              config,
              "ref"
            ).get) &&
            JSCompiler_inline_result.isReactWarning
          ) {
            JSCompiler_inline_result = !1;
            break a;
          }
          JSCompiler_inline_result = void 0 !== config.ref;
        }
        JSCompiler_inline_result && (owner = getOwner());
        hasValidKey(config) &&
          (checkKeyStringCoercion(config.key), (key = "" + config.key));
        for (propName in config)
          !hasOwnProperty.call(config, propName) ||
            "key" === propName ||
            "__self" === propName ||
            "__source" === propName ||
            ("ref" === propName && void 0 === config.ref) ||
            (props[propName] = config[propName]);
      }
      var propName = arguments.length - 2;
      if (1 === propName) props.children = children;
      else if (1 < propName) {
        JSCompiler_inline_result = Array(propName);
        for (var i = 0; i < propName; i++)
          JSCompiler_inline_result[i] = arguments[i + 2];
        props.children = JSCompiler_inline_result;
      }
      props = ReactElement(
        element.type,
        key,
        void 0,
        void 0,
        owner,
        props,
        element._debugStack,
        element._debugTask
      );
      for (key = 2; key < arguments.length; key++)
        (owner = arguments[key]),
          isValidElement(owner) && owner._store && (owner._store.validated = 1);
      return props;
    };
    exports.createContext = function (defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      defaultValue._currentRenderer = null;
      defaultValue._currentRenderer2 = null;
      return defaultValue;
    };
    exports.createElement = function (type, config, children) {
      for (var i = 2; i < arguments.length; i++) {
        var node = arguments[i];
        isValidElement(node) && node._store && (node._store.validated = 1);
      }
      i = {};
      node = null;
      if (null != config)
        for (propName in (didWarnAboutOldJSXRuntime ||
          !("__self" in config) ||
          "key" in config ||
          ((didWarnAboutOldJSXRuntime = !0),
          console.warn(
            "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
          )),
        hasValidKey(config) &&
          (checkKeyStringCoercion(config.key), (node = "" + config.key)),
        config))
          hasOwnProperty.call(config, propName) &&
            "key" !== propName &&
            "__self" !== propName &&
            "__source" !== propName &&
            (i[propName] = config[propName]);
      var childrenLength = arguments.length - 2;
      if (1 === childrenLength) i.children = children;
      else if (1 < childrenLength) {
        for (
          var childArray = Array(childrenLength), _i = 0;
          _i < childrenLength;
          _i++
        )
          childArray[_i] = arguments[_i + 2];
        Object.freeze && Object.freeze(childArray);
        i.children = childArray;
      }
      if (type && type.defaultProps)
        for (propName in ((childrenLength = type.defaultProps), childrenLength))
          void 0 === i[propName] && (i[propName] = childrenLength[propName]);
      node &&
        defineKeyPropWarningGetter(
          i,
          "function" === typeof type
            ? type.displayName || type.name || "Unknown"
            : type
        );
      var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return ReactElement(
        type,
        node,
        void 0,
        void 0,
        getOwner(),
        i,
        propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
        propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask
      );
    };
    exports.createRef = function () {
      var refObject = { current: null };
      Object.seal(refObject);
      return refObject;
    };
    exports.forwardRef = function (render) {
      null != render && render.$$typeof === REACT_MEMO_TYPE
        ? console.error(
            "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
          )
        : "function" !== typeof render
          ? console.error(
              "forwardRef requires a render function but was given %s.",
              null === render ? "null" : typeof render
            )
          : 0 !== render.length &&
            2 !== render.length &&
            console.error(
              "forwardRef render functions accept exactly two parameters: props and ref. %s",
              1 === render.length
                ? "Did you forget to use the ref parameter?"
                : "Any additional parameter will be undefined."
            );
      null != render &&
        null != render.defaultProps &&
        console.error(
          "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
        );
      var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render: render },
        ownName;
      Object.defineProperty(elementType, "displayName", {
        enumerable: !1,
        configurable: !0,
        get: function () {
          return ownName;
        },
        set: function (name) {
          ownName = name;
          render.name ||
            render.displayName ||
            (Object.defineProperty(render, "name", { value: name }),
            (render.displayName = name));
        }
      });
      return elementType;
    };
    exports.isValidElement = isValidElement;
    exports.lazy = function (ctor) {
      return {
        $$typeof: REACT_LAZY_TYPE,
        _payload: { _status: -1, _result: ctor },
        _init: lazyInitializer
      };
    };
    exports.memo = function (type, compare) {
      null == type &&
        console.error(
          "memo: The first argument must be a component. Instead received: %s",
          null === type ? "null" : typeof type
        );
      compare = {
        $$typeof: REACT_MEMO_TYPE,
        type: type,
        compare: void 0 === compare ? null : compare
      };
      var ownName;
      Object.defineProperty(compare, "displayName", {
        enumerable: !1,
        configurable: !0,
        get: function () {
          return ownName;
        },
        set: function (name) {
          ownName = name;
          type.name ||
            type.displayName ||
            (Object.defineProperty(type, "name", { value: name }),
            (type.displayName = name));
        }
      });
      return compare;
    };
    exports.startTransition = function (scope) {
      var prevTransition = ReactSharedInternals.T,
        currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      currentTransition._updatedFibers = new Set();
      try {
        var returnValue = scope(),
          onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish &&
          onStartTransitionFinish(currentTransition, returnValue);
        "object" === typeof returnValue &&
          null !== returnValue &&
          "function" === typeof returnValue.then &&
          returnValue.then(noop, reportGlobalError);
      } catch (error) {
        reportGlobalError(error);
      } finally {
        null === prevTransition &&
          currentTransition._updatedFibers &&
          ((scope = currentTransition._updatedFibers.size),
          currentTransition._updatedFibers.clear(),
          10 < scope &&
            console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            )),
          (ReactSharedInternals.T = prevTransition);
      }
    };
    exports.unstable_useCacheRefresh = function () {
      return resolveDispatcher().useCacheRefresh();
    };
    exports.use = function (usable) {
      return resolveDispatcher().use(usable);
    };
    exports.useActionState = function (action, initialState, permalink) {
      return resolveDispatcher().useActionState(
        action,
        initialState,
        permalink
      );
    };
    exports.useCallback = function (callback, deps) {
      return resolveDispatcher().useCallback(callback, deps);
    };
    exports.useContext = function (Context) {
      var dispatcher = resolveDispatcher();
      Context.$$typeof === REACT_CONSUMER_TYPE &&
        console.error(
          "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
        );
      return dispatcher.useContext(Context);
    };
    exports.useDebugValue = function (value, formatterFn) {
      return resolveDispatcher().useDebugValue(value, formatterFn);
    };
    exports.useDeferredValue = function (value, initialValue) {
      return resolveDispatcher().useDeferredValue(value, initialValue);
    };
    exports.useEffect = function (create, createDeps, update) {
      null == create &&
        console.warn(
          "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
      var dispatcher = resolveDispatcher();
      if ("function" === typeof update)
        throw Error(
          "useEffect CRUD overload is not enabled in this build of React."
        );
      return dispatcher.useEffect(create, createDeps);
    };
    exports.useId = function () {
      return resolveDispatcher().useId();
    };
    exports.useImperativeHandle = function (ref, create, deps) {
      return resolveDispatcher().useImperativeHandle(ref, create, deps);
    };
    exports.useInsertionEffect = function (create, deps) {
      null == create &&
        console.warn(
          "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
      return resolveDispatcher().useInsertionEffect(create, deps);
    };
    exports.useLayoutEffect = function (create, deps) {
      null == create &&
        console.warn(
          "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
      return resolveDispatcher().useLayoutEffect(create, deps);
    };
    exports.useMemo = function (create, deps) {
      return resolveDispatcher().useMemo(create, deps);
    };
    exports.useOptimistic = function (passthrough, reducer) {
      return resolveDispatcher().useOptimistic(passthrough, reducer);
    };
    exports.useReducer = function (reducer, initialArg, init) {
      return resolveDispatcher().useReducer(reducer, initialArg, init);
    };
    exports.useRef = function (initialValue) {
      return resolveDispatcher().useRef(initialValue);
    };
    exports.useState = function (initialState) {
      return resolveDispatcher().useState(initialState);
    };
    exports.useSyncExternalStore = function (
      subscribe,
      getSnapshot,
      getServerSnapshot
    ) {
      return resolveDispatcher().useSyncExternalStore(
        subscribe,
        getSnapshot,
        getServerSnapshot
      );
    };
    exports.useTransition = function () {
      return resolveDispatcher().useTransition();
    };
    exports.version = "19.1.0";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/react/jsx-runtime.js":
/*!*******************************************!*\
  !*** ./node_modules/react/jsx-runtime.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ "./node_modules/react/cjs/react-jsx-runtime.development.js");
}


/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


 true &&
  (function () {
    function performWorkUntilDeadline() {
      needsPaint = !1;
      if (isMessageLoopRunning) {
        var currentTime = exports.unstable_now();
        startTime = currentTime;
        var hasMoreWork = !0;
        try {
          a: {
            isHostCallbackScheduled = !1;
            isHostTimeoutScheduled &&
              ((isHostTimeoutScheduled = !1),
              localClearTimeout(taskTimeoutID),
              (taskTimeoutID = -1));
            isPerformingWork = !0;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              b: {
                advanceTimers(currentTime);
                for (
                  currentTask = peek(taskQueue);
                  null !== currentTask &&
                  !(
                    currentTask.expirationTime > currentTime &&
                    shouldYieldToHost()
                  );

                ) {
                  var callback = currentTask.callback;
                  if ("function" === typeof callback) {
                    currentTask.callback = null;
                    currentPriorityLevel = currentTask.priorityLevel;
                    var continuationCallback = callback(
                      currentTask.expirationTime <= currentTime
                    );
                    currentTime = exports.unstable_now();
                    if ("function" === typeof continuationCallback) {
                      currentTask.callback = continuationCallback;
                      advanceTimers(currentTime);
                      hasMoreWork = !0;
                      break b;
                    }
                    currentTask === peek(taskQueue) && pop(taskQueue);
                    advanceTimers(currentTime);
                  } else pop(taskQueue);
                  currentTask = peek(taskQueue);
                }
                if (null !== currentTask) hasMoreWork = !0;
                else {
                  var firstTimer = peek(timerQueue);
                  null !== firstTimer &&
                    requestHostTimeout(
                      handleTimeout,
                      firstTimer.startTime - currentTime
                    );
                  hasMoreWork = !1;
                }
              }
              break a;
            } finally {
              (currentTask = null),
                (currentPriorityLevel = previousPriorityLevel),
                (isPerformingWork = !1);
            }
            hasMoreWork = void 0;
          }
        } finally {
          hasMoreWork
            ? schedulePerformWorkUntilDeadline()
            : (isMessageLoopRunning = !1);
        }
      }
    }
    function push(heap, node) {
      var index = heap.length;
      heap.push(node);
      a: for (; 0 < index; ) {
        var parentIndex = (index - 1) >>> 1,
          parent = heap[parentIndex];
        if (0 < compare(parent, node))
          (heap[parentIndex] = node),
            (heap[index] = parent),
            (index = parentIndex);
        else break a;
      }
    }
    function peek(heap) {
      return 0 === heap.length ? null : heap[0];
    }
    function pop(heap) {
      if (0 === heap.length) return null;
      var first = heap[0],
        last = heap.pop();
      if (last !== first) {
        heap[0] = last;
        a: for (
          var index = 0, length = heap.length, halfLength = length >>> 1;
          index < halfLength;

        ) {
          var leftIndex = 2 * (index + 1) - 1,
            left = heap[leftIndex],
            rightIndex = leftIndex + 1,
            right = heap[rightIndex];
          if (0 > compare(left, last))
            rightIndex < length && 0 > compare(right, left)
              ? ((heap[index] = right),
                (heap[rightIndex] = last),
                (index = rightIndex))
              : ((heap[index] = left),
                (heap[leftIndex] = last),
                (index = leftIndex));
          else if (rightIndex < length && 0 > compare(right, last))
            (heap[index] = right),
              (heap[rightIndex] = last),
              (index = rightIndex);
          else break a;
        }
      }
      return first;
    }
    function compare(a, b) {
      var diff = a.sortIndex - b.sortIndex;
      return 0 !== diff ? diff : a.id - b.id;
    }
    function advanceTimers(currentTime) {
      for (var timer = peek(timerQueue); null !== timer; ) {
        if (null === timer.callback) pop(timerQueue);
        else if (timer.startTime <= currentTime)
          pop(timerQueue),
            (timer.sortIndex = timer.expirationTime),
            push(taskQueue, timer);
        else break;
        timer = peek(timerQueue);
      }
    }
    function handleTimeout(currentTime) {
      isHostTimeoutScheduled = !1;
      advanceTimers(currentTime);
      if (!isHostCallbackScheduled)
        if (null !== peek(taskQueue))
          (isHostCallbackScheduled = !0),
            isMessageLoopRunning ||
              ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline());
        else {
          var firstTimer = peek(timerQueue);
          null !== firstTimer &&
            requestHostTimeout(
              handleTimeout,
              firstTimer.startTime - currentTime
            );
        }
    }
    function shouldYieldToHost() {
      return needsPaint
        ? !0
        : exports.unstable_now() - startTime < frameInterval
          ? !1
          : !0;
    }
    function requestHostTimeout(callback, ms) {
      taskTimeoutID = localSetTimeout(function () {
        callback(exports.unstable_now());
      }, ms);
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    exports.unstable_now = void 0;
    if (
      "object" === typeof performance &&
      "function" === typeof performance.now
    ) {
      var localPerformance = performance;
      exports.unstable_now = function () {
        return localPerformance.now();
      };
    } else {
      var localDate = Date,
        initialTime = localDate.now();
      exports.unstable_now = function () {
        return localDate.now() - initialTime;
      };
    }
    var taskQueue = [],
      timerQueue = [],
      taskIdCounter = 1,
      currentTask = null,
      currentPriorityLevel = 3,
      isPerformingWork = !1,
      isHostCallbackScheduled = !1,
      isHostTimeoutScheduled = !1,
      needsPaint = !1,
      localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
      localClearTimeout =
        "function" === typeof clearTimeout ? clearTimeout : null,
      localSetImmediate =
        "undefined" !== typeof setImmediate ? setImmediate : null,
      isMessageLoopRunning = !1,
      taskTimeoutID = -1,
      frameInterval = 5,
      startTime = -1;
    if ("function" === typeof localSetImmediate)
      var schedulePerformWorkUntilDeadline = function () {
        localSetImmediate(performWorkUntilDeadline);
      };
    else if ("undefined" !== typeof MessageChannel) {
      var channel = new MessageChannel(),
        port = channel.port2;
      channel.port1.onmessage = performWorkUntilDeadline;
      schedulePerformWorkUntilDeadline = function () {
        port.postMessage(null);
      };
    } else
      schedulePerformWorkUntilDeadline = function () {
        localSetTimeout(performWorkUntilDeadline, 0);
      };
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function (task) {
      task.callback = null;
    };
    exports.unstable_forceFrameRate = function (fps) {
      0 > fps || 125 < fps
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);
    };
    exports.unstable_getCurrentPriorityLevel = function () {
      return currentPriorityLevel;
    };
    exports.unstable_next = function (eventHandler) {
      switch (currentPriorityLevel) {
        case 1:
        case 2:
        case 3:
          var priorityLevel = 3;
          break;
        default:
          priorityLevel = currentPriorityLevel;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_requestPaint = function () {
      needsPaint = !0;
    };
    exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {
      switch (priorityLevel) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          priorityLevel = 3;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_scheduleCallback = function (
      priorityLevel,
      callback,
      options
    ) {
      var currentTime = exports.unstable_now();
      "object" === typeof options && null !== options
        ? ((options = options.delay),
          (options =
            "number" === typeof options && 0 < options
              ? currentTime + options
              : currentTime))
        : (options = currentTime);
      switch (priorityLevel) {
        case 1:
          var timeout = -1;
          break;
        case 2:
          timeout = 250;
          break;
        case 5:
          timeout = 1073741823;
          break;
        case 4:
          timeout = 1e4;
          break;
        default:
          timeout = 5e3;
      }
      timeout = options + timeout;
      priorityLevel = {
        id: taskIdCounter++,
        callback: callback,
        priorityLevel: priorityLevel,
        startTime: options,
        expirationTime: timeout,
        sortIndex: -1
      };
      options > currentTime
        ? ((priorityLevel.sortIndex = options),
          push(timerQueue, priorityLevel),
          null === peek(taskQueue) &&
            priorityLevel === peek(timerQueue) &&
            (isHostTimeoutScheduled
              ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))
              : (isHostTimeoutScheduled = !0),
            requestHostTimeout(handleTimeout, options - currentTime)))
        : ((priorityLevel.sortIndex = timeout),
          push(taskQueue, priorityLevel),
          isHostCallbackScheduled ||
            isPerformingWork ||
            ((isHostCallbackScheduled = !0),
            isMessageLoopRunning ||
              ((isMessageLoopRunning = !0),
              schedulePerformWorkUntilDeadline())));
      return priorityLevel;
    };
    exports.unstable_shouldYield = shouldYieldToHost;
    exports.unstable_wrapCallback = function (callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function () {
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;
        try {
          return callback.apply(this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();


/***/ }),

/***/ "./node_modules/scheduler/index.js":
/*!*****************************************!*\
  !*** ./node_modules/scheduler/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ "./node_modules/scheduler/cjs/scheduler.development.js");
}


/***/ }),

/***/ "./node_modules/stylis/src/Enum.js":
/*!*****************************************!*\
  !*** ./node_modules/stylis/src/Enum.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CHARSET: () => (/* binding */ CHARSET),
/* harmony export */   COMMENT: () => (/* binding */ COMMENT),
/* harmony export */   COUNTER_STYLE: () => (/* binding */ COUNTER_STYLE),
/* harmony export */   DECLARATION: () => (/* binding */ DECLARATION),
/* harmony export */   DOCUMENT: () => (/* binding */ DOCUMENT),
/* harmony export */   FONT_FACE: () => (/* binding */ FONT_FACE),
/* harmony export */   FONT_FEATURE_VALUES: () => (/* binding */ FONT_FEATURE_VALUES),
/* harmony export */   IMPORT: () => (/* binding */ IMPORT),
/* harmony export */   KEYFRAMES: () => (/* binding */ KEYFRAMES),
/* harmony export */   LAYER: () => (/* binding */ LAYER),
/* harmony export */   MEDIA: () => (/* binding */ MEDIA),
/* harmony export */   MOZ: () => (/* binding */ MOZ),
/* harmony export */   MS: () => (/* binding */ MS),
/* harmony export */   NAMESPACE: () => (/* binding */ NAMESPACE),
/* harmony export */   PAGE: () => (/* binding */ PAGE),
/* harmony export */   RULESET: () => (/* binding */ RULESET),
/* harmony export */   SUPPORTS: () => (/* binding */ SUPPORTS),
/* harmony export */   VIEWPORT: () => (/* binding */ VIEWPORT),
/* harmony export */   WEBKIT: () => (/* binding */ WEBKIT)
/* harmony export */ });
var MS = '-ms-'
var MOZ = '-moz-'
var WEBKIT = '-webkit-'

var COMMENT = 'comm'
var RULESET = 'rule'
var DECLARATION = 'decl'

var PAGE = '@page'
var MEDIA = '@media'
var IMPORT = '@import'
var CHARSET = '@charset'
var VIEWPORT = '@viewport'
var SUPPORTS = '@supports'
var DOCUMENT = '@document'
var NAMESPACE = '@namespace'
var KEYFRAMES = '@keyframes'
var FONT_FACE = '@font-face'
var COUNTER_STYLE = '@counter-style'
var FONT_FEATURE_VALUES = '@font-feature-values'
var LAYER = '@layer'


/***/ }),

/***/ "./node_modules/stylis/src/Middleware.js":
/*!***********************************************!*\
  !*** ./node_modules/stylis/src/Middleware.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   middleware: () => (/* binding */ middleware),
/* harmony export */   namespace: () => (/* binding */ namespace),
/* harmony export */   prefixer: () => (/* binding */ prefixer),
/* harmony export */   rulesheet: () => (/* binding */ rulesheet)
/* harmony export */ });
/* harmony import */ var _Enum_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Enum.js */ "./node_modules/stylis/src/Enum.js");
/* harmony import */ var _Utility_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utility.js */ "./node_modules/stylis/src/Utility.js");
/* harmony import */ var _Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Tokenizer.js */ "./node_modules/stylis/src/Tokenizer.js");
/* harmony import */ var _Serializer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Serializer.js */ "./node_modules/stylis/src/Serializer.js");
/* harmony import */ var _Prefixer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Prefixer.js */ "./node_modules/stylis/src/Prefixer.js");






/**
 * @param {function[]} collection
 * @return {function}
 */
function middleware (collection) {
	var length = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.sizeof)(collection)

	return function (element, index, children, callback) {
		var output = ''

		for (var i = 0; i < length; i++)
			output += collection[i](element, index, children, callback) || ''

		return output
	}
}

/**
 * @param {function} callback
 * @return {function}
 */
function rulesheet (callback) {
	return function (element) {
		if (!element.root)
			if (element = element.return)
				callback(element)
	}
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 * @param {function} callback
 */
function prefixer (element, index, children, callback) {
	if (element.length > -1)
		if (!element.return)
			switch (element.type) {
				case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.DECLARATION: element.return = (0,_Prefixer_js__WEBPACK_IMPORTED_MODULE_2__.prefix)(element.value, element.length, children)
					return
				case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.KEYFRAMES:
					return (0,_Serializer_js__WEBPACK_IMPORTED_MODULE_3__.serialize)([(0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.copy)(element, {value: (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(element.value, '@', '@' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT)})], callback)
				case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.RULESET:
					if (element.length)
						return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.combine)(element.props, function (value) {
							switch ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.match)(value, /(::plac\w+|:read-\w+)/)) {
								// :read-(only|write)
								case ':read-only': case ':read-write':
									return (0,_Serializer_js__WEBPACK_IMPORTED_MODULE_3__.serialize)([(0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.copy)(element, {props: [(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /:(read-\w+)/, ':' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MOZ + '$1')]})], callback)
								// :placeholder
								case '::placeholder':
									return (0,_Serializer_js__WEBPACK_IMPORTED_MODULE_3__.serialize)([
										(0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.copy)(element, {props: [(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /:(plac\w+)/, ':' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + 'input-$1')]}),
										(0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.copy)(element, {props: [(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /:(plac\w+)/, ':' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MOZ + '$1')]}),
										(0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.copy)(element, {props: [(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /:(plac\w+)/, _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + 'input-$1')]})
									], callback)
							}

							return ''
						})
			}
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 */
function namespace (element) {
	switch (element.type) {
		case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.RULESET:
			element.props = element.props.map(function (value) {
				return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.combine)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.tokenize)(value), function (value, index, children) {
					switch ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, 0)) {
						// \f
						case 12:
							return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.substr)(value, 1, (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.strlen)(value))
						// \0 ( + > ~
						case 0: case 40: case 43: case 62: case 126:
							return value
						// :
						case 58:
							if (children[++index] === 'global')
								children[index] = '', children[++index] = '\f' + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.substr)(children[index], index = 1, -1)
						// \s
						case 32:
							return index === 1 ? '' : value
						default:
							switch (index) {
								case 0: element = value
									return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.sizeof)(children) > 1 ? '' : value
								case index = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.sizeof)(children) - 1: case 2:
									return index === 2 ? value + element + element : value + element
								default:
									return value
							}
					}
				})
			})
	}
}


/***/ }),

/***/ "./node_modules/stylis/src/Parser.js":
/*!*******************************************!*\
  !*** ./node_modules/stylis/src/Parser.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   comment: () => (/* binding */ comment),
/* harmony export */   compile: () => (/* binding */ compile),
/* harmony export */   declaration: () => (/* binding */ declaration),
/* harmony export */   parse: () => (/* binding */ parse),
/* harmony export */   ruleset: () => (/* binding */ ruleset)
/* harmony export */ });
/* harmony import */ var _Enum_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Enum.js */ "./node_modules/stylis/src/Enum.js");
/* harmony import */ var _Utility_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utility.js */ "./node_modules/stylis/src/Utility.js");
/* harmony import */ var _Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tokenizer.js */ "./node_modules/stylis/src/Tokenizer.js");




/**
 * @param {string} value
 * @return {object[]}
 */
function compile (value) {
	return (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.dealloc)(parse('', null, null, null, [''], value = (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.alloc)(value), 0, [0], value))
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {string[]} rule
 * @param {string[]} rules
 * @param {string[]} rulesets
 * @param {number[]} pseudo
 * @param {number[]} points
 * @param {string[]} declarations
 * @return {object}
 */
function parse (value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
	var index = 0
	var offset = 0
	var length = pseudo
	var atrule = 0
	var property = 0
	var previous = 0
	var variable = 1
	var scanning = 1
	var ampersand = 1
	var character = 0
	var type = ''
	var props = rules
	var children = rulesets
	var reference = rule
	var characters = type

	while (scanning)
		switch (previous = character, character = (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.next)()) {
			// (
			case 40:
				if (previous != 108 && (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.charat)(characters, length - 1) == 58) {
					if ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.indexof)(characters += (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.replace)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.delimit)(character), '&', '&\f'), '&\f') != -1)
						ampersand = -1
					break
				}
			// " ' [
			case 34: case 39: case 91:
				characters += (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.delimit)(character)
				break
			// \t \n \r \s
			case 9: case 10: case 13: case 32:
				characters += (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.whitespace)(previous)
				break
			// \
			case 92:
				characters += (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.escaping)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.caret)() - 1, 7)
				continue
			// /
			case 47:
				switch ((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.peek)()) {
					case 42: case 47:
						;(0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.append)(comment((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.commenter)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.next)(), (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.caret)()), root, parent), declarations)
						break
					default:
						characters += '/'
				}
				break
			// {
			case 123 * variable:
				points[index++] = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.strlen)(characters) * ampersand
			// } ; \0
			case 125 * variable: case 59: case 0:
				switch (character) {
					// \0 }
					case 0: case 125: scanning = 0
					// ;
					case 59 + offset: if (ampersand == -1) characters = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.replace)(characters, /\f/g, '')
						if (property > 0 && ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.strlen)(characters) - length))
							(0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.append)(property > 32 ? declaration(characters + ';', rule, parent, length - 1) : declaration((0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.replace)(characters, ' ', '') + ';', rule, parent, length - 2), declarations)
						break
					// @ ;
					case 59: characters += ';'
					// { rule/at-rule
					default:
						;(0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.append)(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets)

						if (character === 123)
							if (offset === 0)
								parse(characters, root, reference, reference, props, rulesets, length, points, children)
							else
								switch (atrule === 99 && (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.charat)(characters, 3) === 110 ? 100 : atrule) {
									// d l m s
									case 100: case 108: case 109: case 115:
										parse(value, reference, reference, rule && (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.append)(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children)
										break
									default:
										parse(characters, reference, reference, reference, [''], children, 0, points, children)
								}
				}

				index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo
				break
			// :
			case 58:
				length = 1 + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.strlen)(characters), property = previous
			default:
				if (variable < 1)
					if (character == 123)
						--variable
					else if (character == 125 && variable++ == 0 && (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.prev)() == 125)
						continue

				switch (characters += (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.from)(character), character * variable) {
					// &
					case 38:
						ampersand = offset > 0 ? 1 : (characters += '\f', -1)
						break
					// ,
					case 44:
						points[index++] = ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.strlen)(characters) - 1) * ampersand, ampersand = 1
						break
					// @
					case 64:
						// -
						if ((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.peek)() === 45)
							characters += (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.delimit)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.next)())

						atrule = (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.peek)(), offset = length = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.strlen)(type = characters += (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.identifier)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.caret)())), character++
						break
					// -
					case 45:
						if (previous === 45 && (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.strlen)(characters) == 2)
							variable = 0
				}
		}

	return rulesets
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} index
 * @param {number} offset
 * @param {string[]} rules
 * @param {number[]} points
 * @param {string} type
 * @param {string[]} props
 * @param {string[]} children
 * @param {number} length
 * @return {object}
 */
function ruleset (value, root, parent, index, offset, rules, points, type, props, children, length) {
	var post = offset - 1
	var rule = offset === 0 ? rules : ['']
	var size = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.sizeof)(rule)

	for (var i = 0, j = 0, k = 0; i < index; ++i)
		for (var x = 0, y = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.substr)(value, post + 1, post = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.abs)(j = points[i])), z = value; x < size; ++x)
			if (z = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.trim)(j > 0 ? rule[x] + ' ' + y : (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.replace)(y, /&\f/g, rule[x])))
				props[k++] = z

	return (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.node)(value, root, parent, offset === 0 ? _Enum_js__WEBPACK_IMPORTED_MODULE_2__.RULESET : type, props, children, length)
}

/**
 * @param {number} value
 * @param {object} root
 * @param {object?} parent
 * @return {object}
 */
function comment (value, root, parent) {
	return (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.node)(value, root, parent, _Enum_js__WEBPACK_IMPORTED_MODULE_2__.COMMENT, (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.from)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.char)()), (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.substr)(value, 2, -2), 0)
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} length
 * @return {object}
 */
function declaration (value, root, parent, length) {
	return (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.node)(value, root, parent, _Enum_js__WEBPACK_IMPORTED_MODULE_2__.DECLARATION, (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.substr)(value, 0, length), (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.substr)(value, length + 1, -1), length)
}


/***/ }),

/***/ "./node_modules/stylis/src/Prefixer.js":
/*!*********************************************!*\
  !*** ./node_modules/stylis/src/Prefixer.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   prefix: () => (/* binding */ prefix)
/* harmony export */ });
/* harmony import */ var _Enum_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Enum.js */ "./node_modules/stylis/src/Enum.js");
/* harmony import */ var _Utility_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utility.js */ "./node_modules/stylis/src/Utility.js");



/**
 * @param {string} value
 * @param {number} length
 * @param {object[]} children
 * @return {string}
 */
function prefix (value, length, children) {
	switch ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.hash)(value, length)) {
		// color-adjust
		case 5103:
			return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + 'print-' + value + value
		// animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
		case 5737: case 4201: case 3177: case 3433: case 1641: case 4457: case 2921:
		// text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
		case 5572: case 6356: case 5844: case 3191: case 6645: case 3005:
		// mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
		case 6391: case 5879: case 5623: case 6135: case 4599: case 4855:
		// background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
		case 4215: case 6389: case 5109: case 5365: case 5621: case 3829:
			return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + value
		// tab-size
		case 4789:
			return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MOZ + value + value
		// appearance, user-select, transform, hyphens, text-size-adjust
		case 5349: case 4246: case 4810: case 6968: case 2756:
			return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MOZ + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + value + value
		// writing-mode
		case 5936:
			switch ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, length + 11)) {
				// vertical-l(r)
				case 114:
					return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /[svh]\w+-[tblr]{2}/, 'tb') + value
				// vertical-r(l)
				case 108:
					return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value
				// horizontal(-)tb
				case 45:
					return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /[svh]\w+-[tblr]{2}/, 'lr') + value
				// default: fallthrough to below
			}
		// flex, flex-direction, scroll-snap-type, writing-mode
		case 6828: case 4268: case 2903:
			return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + value + value
		// order
		case 6165:
			return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + 'flex-' + value + value
		// align-items
		case 5187:
			return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(\w+).+(:[^]+)/, _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + 'box-$1$2' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + 'flex-$1$2') + value
		// align-self
		case 5443:
			return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + 'flex-item-' + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /flex-|-self/g, '') + (!(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.match)(value, /flex-|baseline/) ? _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + 'grid-row-' + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /flex-|-self/g, '') : '') + value
		// align-content
		case 4675:
			return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + 'flex-line-pack' + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /align-content|flex-|-self/g, '') + value
		// flex-shrink
		case 5548:
			return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, 'shrink', 'negative') + value
		// flex-basis
		case 5292:
			return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, 'basis', 'preferred-size') + value
		// flex-grow
		case 6060:
			return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + 'box-' + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, '-grow', '') + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, 'grow', 'positive') + value
		// transition
		case 4554:
			return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /([^-])(transform)/g, '$1' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + '$2') + value
		// cursor
		case 6187:
			return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(zoom-|grab)/, _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + '$1'), /(image-set)/, _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + '$1'), value, '') + value
		// background, background-image
		case 5495: case 3959:
			return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(image-set\([^]*)/, _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + '$1' + '$`$1')
		// justify-content
		case 4968:
			return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(.+:)(flex-)?(.*)/, _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + 'box-pack:$3' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + value
		// justify-self
		case 4200:
			if (!(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.match)(value, /flex-|baseline/)) return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + 'grid-column-align' + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.substr)(value, length) + value
			break
		// grid-template-(columns|rows)
		case 2592: case 3360:
			return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, 'template-', '') + value
		// grid-(row|column)-start
		case 4384: case 3616:
			if (children && children.some(function (element, index) { return length = index, (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.match)(element.props, /grid-\w+-end/) })) {
				return ~(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.indexof)(value + (children = children[length].value), 'span') ? value : (_Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, '-start', '') + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + 'grid-row-span:' + (~(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.indexof)(children, 'span') ? (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.match)(children, /\d+/) : +(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.match)(children, /\d+/) - +(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.match)(value, /\d+/)) + ';')
			}
			return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, '-start', '') + value
		// grid-(row|column)-end
		case 4896: case 4128:
			return (children && children.some(function (element) { return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.match)(element.props, /grid-\w+-start/) })) ? value : _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, '-end', '-span'), 'span ', '') + value
		// (margin|padding)-inline-(start|end)
		case 4095: case 3583: case 4068: case 2532:
			return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(.+)-inline(.+)/, _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + '$1$2') + value
		// (min|max)?(width|height|inline-size|block-size)
		case 8116: case 7059: case 5753: case 5535:
		case 5445: case 5701: case 4933: case 4677:
		case 5533: case 5789: case 5021: case 4765:
			// stretch, max-content, min-content, fill-available
			if ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.strlen)(value) - 1 - length > 6)
				switch ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, length + 1)) {
					// (m)ax-content, (m)in-content
					case 109:
						// -
						if ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, length + 4) !== 45)
							break
					// (f)ill-available, (f)it-content
					case 102:
						return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(.+:)(.+)-([^]+)/, '$1' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + '$2-$3' + '$1' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MOZ + ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, length + 3) == 108 ? '$3' : '$2-$3')) + value
					// (s)tretch
					case 115:
						return ~(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.indexof)(value, 'stretch') ? prefix((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, 'stretch', 'fill-available'), length, children) + value : value
				}
			break
		// grid-(column|row)
		case 5152: case 5920:
			return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function (_, a, b, c, d, e, f) { return (_Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + a + ':' + b + f) + (c ? (_Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + a + '-span:' + (d ? e : +e - +b)) + f : '') + value })
		// position: sticky
		case 4949:
			// stick(y)?
			if ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, length + 6) === 121)
				return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, ':', ':' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT) + value
			break
		// display: (flex|inline-flex|grid|inline-grid)
		case 6444:
			switch ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, 14) === 45 ? 18 : 11)) {
				// (inline-)?fle(x)
				case 120:
					return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, '$1' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + '$2$3' + '$1' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + '$2box$3') + value
				// (inline-)?gri(d)
				case 100:
					return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, ':', ':' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS) + value
			}
			break
		// scroll-margin, scroll-margin-(top|right|bottom|left)
		case 5719: case 2647: case 2135: case 3927: case 2391:
			return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, 'scroll-', 'scroll-snap-') + value
	}

	return value
}


/***/ }),

/***/ "./node_modules/stylis/src/Serializer.js":
/*!***********************************************!*\
  !*** ./node_modules/stylis/src/Serializer.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   serialize: () => (/* binding */ serialize),
/* harmony export */   stringify: () => (/* binding */ stringify)
/* harmony export */ });
/* harmony import */ var _Enum_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Enum.js */ "./node_modules/stylis/src/Enum.js");
/* harmony import */ var _Utility_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utility.js */ "./node_modules/stylis/src/Utility.js");



/**
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */
function serialize (children, callback) {
	var output = ''
	var length = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.sizeof)(children)

	for (var i = 0; i < length; i++)
		output += callback(children[i], i, children, callback) || ''

	return output
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */
function stringify (element, index, children, callback) {
	switch (element.type) {
		case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.LAYER: if (element.children.length) break
		case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.IMPORT: case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.DECLARATION: return element.return = element.return || element.value
		case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.COMMENT: return ''
		case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.KEYFRAMES: return element.return = element.value + '{' + serialize(element.children, callback) + '}'
		case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.RULESET: element.value = element.props.join(',')
	}

	return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.strlen)(children = serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : ''
}


/***/ }),

/***/ "./node_modules/stylis/src/Tokenizer.js":
/*!**********************************************!*\
  !*** ./node_modules/stylis/src/Tokenizer.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   alloc: () => (/* binding */ alloc),
/* harmony export */   caret: () => (/* binding */ caret),
/* harmony export */   char: () => (/* binding */ char),
/* harmony export */   character: () => (/* binding */ character),
/* harmony export */   characters: () => (/* binding */ characters),
/* harmony export */   column: () => (/* binding */ column),
/* harmony export */   commenter: () => (/* binding */ commenter),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   dealloc: () => (/* binding */ dealloc),
/* harmony export */   delimit: () => (/* binding */ delimit),
/* harmony export */   delimiter: () => (/* binding */ delimiter),
/* harmony export */   escaping: () => (/* binding */ escaping),
/* harmony export */   identifier: () => (/* binding */ identifier),
/* harmony export */   length: () => (/* binding */ length),
/* harmony export */   line: () => (/* binding */ line),
/* harmony export */   next: () => (/* binding */ next),
/* harmony export */   node: () => (/* binding */ node),
/* harmony export */   peek: () => (/* binding */ peek),
/* harmony export */   position: () => (/* binding */ position),
/* harmony export */   prev: () => (/* binding */ prev),
/* harmony export */   slice: () => (/* binding */ slice),
/* harmony export */   token: () => (/* binding */ token),
/* harmony export */   tokenize: () => (/* binding */ tokenize),
/* harmony export */   tokenizer: () => (/* binding */ tokenizer),
/* harmony export */   whitespace: () => (/* binding */ whitespace)
/* harmony export */ });
/* harmony import */ var _Utility_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utility.js */ "./node_modules/stylis/src/Utility.js");


var line = 1
var column = 1
var length = 0
var position = 0
var character = 0
var characters = ''

/**
 * @param {string} value
 * @param {object | null} root
 * @param {object | null} parent
 * @param {string} type
 * @param {string[] | string} props
 * @param {object[] | string} children
 * @param {number} length
 */
function node (value, root, parent, type, props, children, length) {
	return {value: value, root: root, parent: parent, type: type, props: props, children: children, line: line, column: column, length: length, return: ''}
}

/**
 * @param {object} root
 * @param {object} props
 * @return {object}
 */
function copy (root, props) {
	return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.assign)(node('', null, null, '', null, null, 0), root, {length: -root.length}, props)
}

/**
 * @return {number}
 */
function char () {
	return character
}

/**
 * @return {number}
 */
function prev () {
	character = position > 0 ? (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(characters, --position) : 0

	if (column--, character === 10)
		column = 1, line--

	return character
}

/**
 * @return {number}
 */
function next () {
	character = position < length ? (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(characters, position++) : 0

	if (column++, character === 10)
		column = 1, line++

	return character
}

/**
 * @return {number}
 */
function peek () {
	return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(characters, position)
}

/**
 * @return {number}
 */
function caret () {
	return position
}

/**
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */
function slice (begin, end) {
	return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.substr)(characters, begin, end)
}

/**
 * @param {number} type
 * @return {number}
 */
function token (type) {
	switch (type) {
		// \0 \t \n \r \s whitespace token
		case 0: case 9: case 10: case 13: case 32:
			return 5
		// ! + , / > @ ~ isolate token
		case 33: case 43: case 44: case 47: case 62: case 64: case 126:
		// ; { } breakpoint token
		case 59: case 123: case 125:
			return 4
		// : accompanied token
		case 58:
			return 3
		// " ' ( [ opening delimit token
		case 34: case 39: case 40: case 91:
			return 2
		// ) ] closing delimit token
		case 41: case 93:
			return 1
	}

	return 0
}

/**
 * @param {string} value
 * @return {any[]}
 */
function alloc (value) {
	return line = column = 1, length = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.strlen)(characters = value), position = 0, []
}

/**
 * @param {any} value
 * @return {any}
 */
function dealloc (value) {
	return characters = '', value
}

/**
 * @param {number} type
 * @return {string}
 */
function delimit (type) {
	return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.trim)(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)))
}

/**
 * @param {string} value
 * @return {string[]}
 */
function tokenize (value) {
	return dealloc(tokenizer(alloc(value)))
}

/**
 * @param {number} type
 * @return {string}
 */
function whitespace (type) {
	while (character = peek())
		if (character < 33)
			next()
		else
			break

	return token(type) > 2 || token(character) > 3 ? '' : ' '
}

/**
 * @param {string[]} children
 * @return {string[]}
 */
function tokenizer (children) {
	while (next())
		switch (token(character)) {
			case 0: (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.append)(identifier(position - 1), children)
				break
			case 2: ;(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.append)(delimit(character), children)
				break
			default: ;(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.append)((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.from)(character), children)
		}

	return children
}

/**
 * @param {number} index
 * @param {number} count
 * @return {string}
 */
function escaping (index, count) {
	while (--count && next())
		// not 0-9 A-F a-f
		if (character < 48 || character > 102 || (character > 57 && character < 65) || (character > 70 && character < 97))
			break

	return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32))
}

/**
 * @param {number} type
 * @return {number}
 */
function delimiter (type) {
	while (next())
		switch (character) {
			// ] ) " '
			case type:
				return position
			// " '
			case 34: case 39:
				if (type !== 34 && type !== 39)
					delimiter(character)
				break
			// (
			case 40:
				if (type === 41)
					delimiter(type)
				break
			// \
			case 92:
				next()
				break
		}

	return position
}

/**
 * @param {number} type
 * @param {number} index
 * @return {number}
 */
function commenter (type, index) {
	while (next())
		// //
		if (type + character === 47 + 10)
			break
		// /*
		else if (type + character === 42 + 42 && peek() === 47)
			break

	return '/*' + slice(index, position - 1) + '*' + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.from)(type === 47 ? type : next())
}

/**
 * @param {number} index
 * @return {string}
 */
function identifier (index) {
	while (!token(peek()))
		next()

	return slice(index, position)
}


/***/ }),

/***/ "./node_modules/stylis/src/Utility.js":
/*!********************************************!*\
  !*** ./node_modules/stylis/src/Utility.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   append: () => (/* binding */ append),
/* harmony export */   assign: () => (/* binding */ assign),
/* harmony export */   charat: () => (/* binding */ charat),
/* harmony export */   combine: () => (/* binding */ combine),
/* harmony export */   from: () => (/* binding */ from),
/* harmony export */   hash: () => (/* binding */ hash),
/* harmony export */   indexof: () => (/* binding */ indexof),
/* harmony export */   match: () => (/* binding */ match),
/* harmony export */   replace: () => (/* binding */ replace),
/* harmony export */   sizeof: () => (/* binding */ sizeof),
/* harmony export */   strlen: () => (/* binding */ strlen),
/* harmony export */   substr: () => (/* binding */ substr),
/* harmony export */   trim: () => (/* binding */ trim)
/* harmony export */ });
/**
 * @param {number}
 * @return {number}
 */
var abs = Math.abs

/**
 * @param {number}
 * @return {string}
 */
var from = String.fromCharCode

/**
 * @param {object}
 * @return {object}
 */
var assign = Object.assign

/**
 * @param {string} value
 * @param {number} length
 * @return {number}
 */
function hash (value, length) {
	return charat(value, 0) ^ 45 ? (((((((length << 2) ^ charat(value, 0)) << 2) ^ charat(value, 1)) << 2) ^ charat(value, 2)) << 2) ^ charat(value, 3) : 0
}

/**
 * @param {string} value
 * @return {string}
 */
function trim (value) {
	return value.trim()
}

/**
 * @param {string} value
 * @param {RegExp} pattern
 * @return {string?}
 */
function match (value, pattern) {
	return (value = pattern.exec(value)) ? value[0] : value
}

/**
 * @param {string} value
 * @param {(string|RegExp)} pattern
 * @param {string} replacement
 * @return {string}
 */
function replace (value, pattern, replacement) {
	return value.replace(pattern, replacement)
}

/**
 * @param {string} value
 * @param {string} search
 * @return {number}
 */
function indexof (value, search) {
	return value.indexOf(search)
}

/**
 * @param {string} value
 * @param {number} index
 * @return {number}
 */
function charat (value, index) {
	return value.charCodeAt(index) | 0
}

/**
 * @param {string} value
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */
function substr (value, begin, end) {
	return value.slice(begin, end)
}

/**
 * @param {string} value
 * @return {number}
 */
function strlen (value) {
	return value.length
}

/**
 * @param {any[]} value
 * @return {number}
 */
function sizeof (value) {
	return value.length
}

/**
 * @param {any} value
 * @param {any[]} array
 * @return {any}
 */
function append (value, array) {
	return array.push(value), value
}

/**
 * @param {string[]} array
 * @param {function} callback
 * @return {string}
 */
function combine (array, callback) {
	return array.map(callback).join('')
}


/***/ }),

/***/ "./node_modules/uqr/dist/index.mjs":
/*!*****************************************!*\
  !*** ./node_modules/uqr/dist/index.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   QrCodeDataType: () => (/* binding */ QrCodeDataType),
/* harmony export */   encode: () => (/* binding */ encode),
/* harmony export */   renderANSI: () => (/* binding */ renderANSI),
/* harmony export */   renderSVG: () => (/* binding */ renderSVG),
/* harmony export */   renderUnicode: () => (/* binding */ renderUnicode),
/* harmony export */   renderUnicodeCompact: () => (/* binding */ renderUnicodeCompact)
/* harmony export */ });
var QrCodeDataType = /* @__PURE__ */ ((QrCodeDataType2) => {
  QrCodeDataType2[QrCodeDataType2["Border"] = -1] = "Border";
  QrCodeDataType2[QrCodeDataType2["Data"] = 0] = "Data";
  QrCodeDataType2[QrCodeDataType2["Function"] = 1] = "Function";
  QrCodeDataType2[QrCodeDataType2["Position"] = 2] = "Position";
  QrCodeDataType2[QrCodeDataType2["Timing"] = 3] = "Timing";
  QrCodeDataType2[QrCodeDataType2["Alignment"] = 4] = "Alignment";
  return QrCodeDataType2;
})(QrCodeDataType || {});

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const LOW = [0, 1];
const MEDIUM = [1, 0];
const QUARTILE = [2, 3];
const HIGH = [3, 2];
const EccMap = {
  L: LOW,
  M: MEDIUM,
  Q: QUARTILE,
  H: HIGH
};
const NUMERIC_REGEX = /^[0-9]*$/;
const ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/;
const ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
const MIN_VERSION = 1;
const MAX_VERSION = 40;
const PENALTY_N1 = 3;
const PENALTY_N2 = 3;
const PENALTY_N3 = 40;
const PENALTY_N4 = 10;
const ECC_CODEWORDS_PER_BLOCK = [
  // Version: (note that index 0 is for padding, and is set to an illegal value)
  // 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
  [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
  // Low
  [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
  // Medium
  [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
  // Quartile
  [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
  // High
];
const NUM_ERROR_CORRECTION_BLOCKS = [
  // Version: (note that index 0 is for padding, and is set to an illegal value)
  // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
  [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
  // Low
  [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
  // Medium
  [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
  // Quartile
  [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
  // High
];
class QrCode {
  /* -- Constructor (low level) and fields -- */
  // Creates a new QR Code with the given version number,
  // error correction level, data codeword bytes, and mask number.
  // This is a low-level API that most users should not use directly.
  // A mid-level API is the encodeSegments() function.
  constructor(version, ecc, dataCodewords, msk) {
    this.version = version;
    this.ecc = ecc;
    /* -- Fields -- */
    // The width and height of this QR Code, measured in modules, between
    // 21 and 177 (inclusive). This is equal to version * 4 + 17.
    __publicField(this, "size");
    // The index of the mask pattern used in this QR Code, which is between 0 and 7 (inclusive).
    // Even if a QR Code is created with automatic masking requested (mask = -1),
    // the resulting object still has a mask value between 0 and 7.
    __publicField(this, "mask");
    // The modules of this QR Code (false = light, true = dark).
    // Immutable after constructor finishes. Accessed through getModule().
    __publicField(this, "modules", []);
    __publicField(this, "types", []);
    if (version < MIN_VERSION || version > MAX_VERSION)
      throw new RangeError("Version value out of range");
    if (msk < -1 || msk > 7)
      throw new RangeError("Mask value out of range");
    this.size = version * 4 + 17;
    const row = Array.from({ length: this.size }, () => false);
    for (let i = 0; i < this.size; i++) {
      this.modules.push(row.slice());
      this.types.push(row.map(() => 0));
    }
    this.drawFunctionPatterns();
    const allCodewords = this.addEccAndInterleave(dataCodewords);
    this.drawCodewords(allCodewords);
    if (msk === -1) {
      let minPenalty = 1e9;
      for (let i = 0; i < 8; i++) {
        this.applyMask(i);
        this.drawFormatBits(i);
        const penalty = this.getPenaltyScore();
        if (penalty < minPenalty) {
          msk = i;
          minPenalty = penalty;
        }
        this.applyMask(i);
      }
    }
    this.mask = msk;
    this.applyMask(msk);
    this.drawFormatBits(msk);
  }
  /* -- Accessor methods -- */
  // Returns the color of the module (pixel) at the given coordinates, which is false
  // for light or true for dark. The top left corner has the coordinates (x=0, y=0).
  // If the given coordinates are out of bounds, then false (light) is returned.
  getModule(x, y) {
    return x >= 0 && x < this.size && y >= 0 && y < this.size && this.modules[y][x];
  }
  /* -- Private helper methods for constructor: Drawing function modules -- */
  // Reads this object's version field, and draws and marks all function modules.
  drawFunctionPatterns() {
    for (let i = 0; i < this.size; i++) {
      this.setFunctionModule(6, i, i % 2 === 0, QrCodeDataType.Timing);
      this.setFunctionModule(i, 6, i % 2 === 0, QrCodeDataType.Timing);
    }
    this.drawFinderPattern(3, 3);
    this.drawFinderPattern(this.size - 4, 3);
    this.drawFinderPattern(3, this.size - 4);
    const alignPatPos = this.getAlignmentPatternPositions();
    const numAlign = alignPatPos.length;
    for (let i = 0; i < numAlign; i++) {
      for (let j = 0; j < numAlign; j++) {
        if (!(i === 0 && j === 0 || i === 0 && j === numAlign - 1 || i === numAlign - 1 && j === 0))
          this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
      }
    }
    this.drawFormatBits(0);
    this.drawVersion();
  }
  // Draws two copies of the format bits (with its own error correction code)
  // based on the given mask and this object's error correction level field.
  drawFormatBits(mask) {
    const data = this.ecc[1] << 3 | mask;
    let rem = data;
    for (let i = 0; i < 10; i++)
      rem = rem << 1 ^ (rem >>> 9) * 1335;
    const bits = (data << 10 | rem) ^ 21522;
    for (let i = 0; i <= 5; i++)
      this.setFunctionModule(8, i, getBit(bits, i));
    this.setFunctionModule(8, 7, getBit(bits, 6));
    this.setFunctionModule(8, 8, getBit(bits, 7));
    this.setFunctionModule(7, 8, getBit(bits, 8));
    for (let i = 9; i < 15; i++)
      this.setFunctionModule(14 - i, 8, getBit(bits, i));
    for (let i = 0; i < 8; i++)
      this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
    for (let i = 8; i < 15; i++)
      this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
    this.setFunctionModule(8, this.size - 8, true);
  }
  // Draws two copies of the version bits (with its own error correction code),
  // based on this object's version field, iff 7 <= version <= 40.
  drawVersion() {
    if (this.version < 7)
      return;
    let rem = this.version;
    for (let i = 0; i < 12; i++)
      rem = rem << 1 ^ (rem >>> 11) * 7973;
    const bits = this.version << 12 | rem;
    for (let i = 0; i < 18; i++) {
      const color = getBit(bits, i);
      const a = this.size - 11 + i % 3;
      const b = Math.floor(i / 3);
      this.setFunctionModule(a, b, color);
      this.setFunctionModule(b, a, color);
    }
  }
  // Draws a 9*9 finder pattern including the border separator,
  // with the center module at (x, y). Modules can be out of bounds.
  drawFinderPattern(x, y) {
    for (let dy = -4; dy <= 4; dy++) {
      for (let dx = -4; dx <= 4; dx++) {
        const dist = Math.max(Math.abs(dx), Math.abs(dy));
        const xx = x + dx;
        const yy = y + dy;
        if (xx >= 0 && xx < this.size && yy >= 0 && yy < this.size)
          this.setFunctionModule(xx, yy, dist !== 2 && dist !== 4, QrCodeDataType.Position);
      }
    }
  }
  // Draws a 5*5 alignment pattern, with the center module
  // at (x, y). All modules must be in bounds.
  drawAlignmentPattern(x, y) {
    for (let dy = -2; dy <= 2; dy++) {
      for (let dx = -2; dx <= 2; dx++) {
        this.setFunctionModule(
          x + dx,
          y + dy,
          Math.max(Math.abs(dx), Math.abs(dy)) !== 1,
          QrCodeDataType.Alignment
        );
      }
    }
  }
  // Sets the color of a module and marks it as a function module.
  // Only used by the constructor. Coordinates must be in bounds.
  setFunctionModule(x, y, isDark, type = QrCodeDataType.Function) {
    this.modules[y][x] = isDark;
    this.types[y][x] = type;
  }
  /* -- Private helper methods for constructor: Codewords and masking -- */
  // Returns a new byte string representing the given data with the appropriate error correction
  // codewords appended to it, based on this object's version and error correction level.
  addEccAndInterleave(data) {
    const ver = this.version;
    const ecl = this.ecc;
    if (data.length !== getNumDataCodewords(ver, ecl))
      throw new RangeError("Invalid argument");
    const numBlocks = NUM_ERROR_CORRECTION_BLOCKS[ecl[0]][ver];
    const blockEccLen = ECC_CODEWORDS_PER_BLOCK[ecl[0]][ver];
    const rawCodewords = Math.floor(getNumRawDataModules(ver) / 8);
    const numShortBlocks = numBlocks - rawCodewords % numBlocks;
    const shortBlockLen = Math.floor(rawCodewords / numBlocks);
    const blocks = [];
    const rsDiv = reedSolomonComputeDivisor(blockEccLen);
    for (let i = 0, k = 0; i < numBlocks; i++) {
      const dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
      k += dat.length;
      const ecc = reedSolomonComputeRemainder(dat, rsDiv);
      if (i < numShortBlocks)
        dat.push(0);
      blocks.push(dat.concat(ecc));
    }
    const result = [];
    for (let i = 0; i < blocks[0].length; i++) {
      blocks.forEach((block, j) => {
        if (i !== shortBlockLen - blockEccLen || j >= numShortBlocks)
          result.push(block[i]);
      });
    }
    return result;
  }
  // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
  // data area of this QR Code. Function modules need to be marked off before this is called.
  drawCodewords(data) {
    if (data.length !== Math.floor(getNumRawDataModules(this.version) / 8))
      throw new RangeError("Invalid argument");
    let i = 0;
    for (let right = this.size - 1; right >= 1; right -= 2) {
      if (right === 6)
        right = 5;
      for (let vert = 0; vert < this.size; vert++) {
        for (let j = 0; j < 2; j++) {
          const x = right - j;
          const upward = (right + 1 & 2) === 0;
          const y = upward ? this.size - 1 - vert : vert;
          if (!this.types[y][x] && i < data.length * 8) {
            this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
            i++;
          }
        }
      }
    }
  }
  // XORs the codeword modules in this QR Code with the given mask pattern.
  // The function modules must be marked and the codeword bits must be drawn
  // before masking. Due to the arithmetic of XOR, calling applyMask() with
  // the same mask value a second time will undo the mask. A final well-formed
  // QR Code needs exactly one (not zero, two, etc.) mask applied.
  applyMask(mask) {
    if (mask < 0 || mask > 7)
      throw new RangeError("Mask value out of range");
    for (let y = 0; y < this.size; y++) {
      for (let x = 0; x < this.size; x++) {
        let invert;
        switch (mask) {
          case 0:
            invert = (x + y) % 2 === 0;
            break;
          case 1:
            invert = y % 2 === 0;
            break;
          case 2:
            invert = x % 3 === 0;
            break;
          case 3:
            invert = (x + y) % 3 === 0;
            break;
          case 4:
            invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 === 0;
            break;
          case 5:
            invert = x * y % 2 + x * y % 3 === 0;
            break;
          case 6:
            invert = (x * y % 2 + x * y % 3) % 2 === 0;
            break;
          case 7:
            invert = ((x + y) % 2 + x * y % 3) % 2 === 0;
            break;
          default:
            throw new Error("Unreachable");
        }
        if (!this.types[y][x] && invert)
          this.modules[y][x] = !this.modules[y][x];
      }
    }
  }
  // Calculates and returns the penalty score based on state of this QR Code's current modules.
  // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
  getPenaltyScore() {
    let result = 0;
    for (let y = 0; y < this.size; y++) {
      let runColor = false;
      let runX = 0;
      const runHistory = [0, 0, 0, 0, 0, 0, 0];
      for (let x = 0; x < this.size; x++) {
        if (this.modules[y][x] === runColor) {
          runX++;
          if (runX === 5)
            result += PENALTY_N1;
          else if (runX > 5)
            result++;
        } else {
          this.finderPenaltyAddHistory(runX, runHistory);
          if (!runColor)
            result += this.finderPenaltyCountPatterns(runHistory) * PENALTY_N3;
          runColor = this.modules[y][x];
          runX = 1;
        }
      }
      result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * PENALTY_N3;
    }
    for (let x = 0; x < this.size; x++) {
      let runColor = false;
      let runY = 0;
      const runHistory = [0, 0, 0, 0, 0, 0, 0];
      for (let y = 0; y < this.size; y++) {
        if (this.modules[y][x] === runColor) {
          runY++;
          if (runY === 5)
            result += PENALTY_N1;
          else if (runY > 5)
            result++;
        } else {
          this.finderPenaltyAddHistory(runY, runHistory);
          if (!runColor)
            result += this.finderPenaltyCountPatterns(runHistory) * PENALTY_N3;
          runColor = this.modules[y][x];
          runY = 1;
        }
      }
      result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * PENALTY_N3;
    }
    for (let y = 0; y < this.size - 1; y++) {
      for (let x = 0; x < this.size - 1; x++) {
        const color = this.modules[y][x];
        if (color === this.modules[y][x + 1] && color === this.modules[y + 1][x] && color === this.modules[y + 1][x + 1])
          result += PENALTY_N2;
      }
    }
    let dark = 0;
    for (const row of this.modules)
      dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);
    const total = this.size * this.size;
    const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
    result += k * PENALTY_N4;
    return result;
  }
  /* -- Private helper functions -- */
  // Returns an ascending list of positions of alignment patterns for this version number.
  // Each position is in the range [0,177), and are used on both the x and y axes.
  // This could be implemented as lookup table of 40 variable-length lists of integers.
  getAlignmentPatternPositions() {
    if (this.version === 1) {
      return [];
    } else {
      const numAlign = Math.floor(this.version / 7) + 2;
      const step = this.version === 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
      const result = [6];
      for (let pos = this.size - 7; result.length < numAlign; pos -= step)
        result.splice(1, 0, pos);
      return result;
    }
  }
  // Can only be called immediately after a light run is added, and
  // returns either 0, 1, or 2. A helper function for getPenaltyScore().
  finderPenaltyCountPatterns(runHistory) {
    const n = runHistory[1];
    const core = n > 0 && runHistory[2] === n && runHistory[3] === n * 3 && runHistory[4] === n && runHistory[5] === n;
    return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);
  }
  // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
  finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
    if (currentRunColor) {
      this.finderPenaltyAddHistory(currentRunLength, runHistory);
      currentRunLength = 0;
    }
    currentRunLength += this.size;
    this.finderPenaltyAddHistory(currentRunLength, runHistory);
    return this.finderPenaltyCountPatterns(runHistory);
  }
  // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
  finderPenaltyAddHistory(currentRunLength, runHistory) {
    if (runHistory[0] === 0)
      currentRunLength += this.size;
    runHistory.pop();
    runHistory.unshift(currentRunLength);
  }
}
function appendBits(val, len, bb) {
  if (len < 0 || len > 31 || val >>> len !== 0)
    throw new RangeError("Value out of range");
  for (let i = len - 1; i >= 0; i--)
    bb.push(val >>> i & 1);
}
function getBit(x, i) {
  return (x >>> i & 1) !== 0;
}
class QrSegment {
  // Creates a new QR Code segment with the given attributes and data.
  // The character count (numChars) must agree with the mode and the bit buffer length,
  // but the constraint isn't checked. The given bit buffer is cloned and stored.
  constructor(mode, numChars, bitData) {
    this.mode = mode;
    this.numChars = numChars;
    this.bitData = bitData;
    if (numChars < 0)
      throw new RangeError("Invalid argument");
    this.bitData = bitData.slice();
  }
  /* -- Methods -- */
  // Returns a new copy of the data bits of this segment.
  getData() {
    return this.bitData.slice();
  }
}
const MODE_NUMERIC = [1, 10, 12, 14];
const MODE_ALPHANUMERIC = [2, 9, 11, 13];
const MODE_BYTE = [4, 8, 16, 16];
function numCharCountBits(mode, ver) {
  return mode[Math.floor((ver + 7) / 17) + 1];
}
function makeBytes(data) {
  const bb = [];
  for (const b of data)
    appendBits(b, 8, bb);
  return new QrSegment(MODE_BYTE, data.length, bb);
}
function makeNumeric(digits) {
  if (!isNumeric(digits))
    throw new RangeError("String contains non-numeric characters");
  const bb = [];
  for (let i = 0; i < digits.length; ) {
    const n = Math.min(digits.length - i, 3);
    appendBits(Number.parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);
    i += n;
  }
  return new QrSegment(MODE_NUMERIC, digits.length, bb);
}
function makeAlphanumeric(text) {
  if (!isAlphanumeric(text))
    throw new RangeError("String contains unencodable characters in alphanumeric mode");
  const bb = [];
  let i;
  for (i = 0; i + 2 <= text.length; i += 2) {
    let temp = ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
    temp += ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
    appendBits(temp, 11, bb);
  }
  if (i < text.length)
    appendBits(ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
  return new QrSegment(MODE_ALPHANUMERIC, text.length, bb);
}
function makeSegments(text) {
  if (text === "")
    return [];
  else if (isNumeric(text))
    return [makeNumeric(text)];
  else if (isAlphanumeric(text))
    return [makeAlphanumeric(text)];
  else
    return [makeBytes(toUtf8ByteArray(text))];
}
function isNumeric(text) {
  return NUMERIC_REGEX.test(text);
}
function isAlphanumeric(text) {
  return ALPHANUMERIC_REGEX.test(text);
}
function getTotalBits(segs, version) {
  let result = 0;
  for (const seg of segs) {
    const ccbits = numCharCountBits(seg.mode, version);
    if (seg.numChars >= 1 << ccbits)
      return Number.POSITIVE_INFINITY;
    result += 4 + ccbits + seg.bitData.length;
  }
  return result;
}
function toUtf8ByteArray(str) {
  str = encodeURI(str);
  const result = [];
  for (let i = 0; i < str.length; i++) {
    if (str.charAt(i) !== "%") {
      result.push(str.charCodeAt(i));
    } else {
      result.push(Number.parseInt(str.substring(i + 1, i + 3), 16));
      i += 2;
    }
  }
  return result;
}
function getNumRawDataModules(ver) {
  if (ver < MIN_VERSION || ver > MAX_VERSION)
    throw new RangeError("Version number out of range");
  let result = (16 * ver + 128) * ver + 64;
  if (ver >= 2) {
    const numAlign = Math.floor(ver / 7) + 2;
    result -= (25 * numAlign - 10) * numAlign - 55;
    if (ver >= 7)
      result -= 36;
  }
  return result;
}
function getNumDataCodewords(ver, ecl) {
  return Math.floor(getNumRawDataModules(ver) / 8) - ECC_CODEWORDS_PER_BLOCK[ecl[0]][ver] * NUM_ERROR_CORRECTION_BLOCKS[ecl[0]][ver];
}
function reedSolomonComputeDivisor(degree) {
  if (degree < 1 || degree > 255)
    throw new RangeError("Degree out of range");
  const result = [];
  for (let i = 0; i < degree - 1; i++)
    result.push(0);
  result.push(1);
  let root = 1;
  for (let i = 0; i < degree; i++) {
    for (let j = 0; j < result.length; j++) {
      result[j] = reedSolomonMultiply(result[j], root);
      if (j + 1 < result.length)
        result[j] ^= result[j + 1];
    }
    root = reedSolomonMultiply(root, 2);
  }
  return result;
}
function reedSolomonComputeRemainder(data, divisor) {
  const result = divisor.map((_) => 0);
  for (const b of data) {
    const factor = b ^ result.shift();
    result.push(0);
    divisor.forEach((coef, i) => result[i] ^= reedSolomonMultiply(coef, factor));
  }
  return result;
}
function reedSolomonMultiply(x, y) {
  if (x >>> 8 !== 0 || y >>> 8 !== 0)
    throw new RangeError("Byte out of range");
  let z = 0;
  for (let i = 7; i >= 0; i--) {
    z = z << 1 ^ (z >>> 7) * 285;
    z ^= (y >>> i & 1) * x;
  }
  return z;
}
function encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
  if (!(MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= MAX_VERSION) || mask < -1 || mask > 7)
    throw new RangeError("Invalid value");
  let version;
  let dataUsedBits;
  for (version = minVersion; ; version++) {
    const dataCapacityBits2 = getNumDataCodewords(version, ecl) * 8;
    const usedBits = getTotalBits(segs, version);
    if (usedBits <= dataCapacityBits2) {
      dataUsedBits = usedBits;
      break;
    }
    if (version >= maxVersion)
      throw new RangeError("Data too long");
  }
  for (const newEcl of [MEDIUM, QUARTILE, HIGH]) {
    if (boostEcl && dataUsedBits <= getNumDataCodewords(version, newEcl) * 8)
      ecl = newEcl;
  }
  const bb = [];
  for (const seg of segs) {
    appendBits(seg.mode[0], 4, bb);
    appendBits(seg.numChars, numCharCountBits(seg.mode, version), bb);
    for (const b of seg.getData())
      bb.push(b);
  }
  const dataCapacityBits = getNumDataCodewords(version, ecl) * 8;
  appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
  appendBits(0, (8 - bb.length % 8) % 8, bb);
  for (let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17)
    appendBits(padByte, 8, bb);
  const dataCodewords = Array.from({ length: Math.ceil(bb.length / 8) }, () => 0);
  bb.forEach((b, i) => dataCodewords[i >>> 3] |= b << 7 - (i & 7));
  return new QrCode(version, ecl, dataCodewords, mask);
}

function encode(data, options) {
  const {
    ecc = "L",
    boostEcc = false,
    minVersion = 1,
    maxVersion = 40,
    maskPattern = -1,
    border = 1
  } = options || {};
  const segment = typeof data === "string" ? makeSegments(data) : Array.isArray(data) ? [makeBytes(data)] : void 0;
  if (!segment)
    throw new Error(`uqr only supports encoding string and binary data, but got: ${typeof data}`);
  const qr = encodeSegments(
    segment,
    EccMap[ecc],
    minVersion,
    maxVersion,
    maskPattern,
    boostEcc
  );
  const result = addBorder({
    version: qr.version,
    maskPattern: qr.mask,
    size: qr.size,
    data: qr.modules,
    types: qr.types
  }, border);
  if (options?.invert)
    result.data = result.data.map((row) => row.map((mod) => !mod));
  options?.onEncoded?.(result);
  return result;
}
function addBorder(input, border = 1) {
  if (!border)
    return input;
  const { size } = input;
  const newSize = size + border * 2;
  input.size = newSize;
  input.data.forEach((row) => {
    for (let i = 0; i < border; i++) {
      row.unshift(false);
      row.push(false);
    }
  });
  for (let i = 0; i < border; i++) {
    input.data.unshift(Array.from({ length: newSize }, (_) => false));
    input.data.push(Array.from({ length: newSize }, (_) => false));
  }
  const b = QrCodeDataType.Border;
  input.types.forEach((row) => {
    for (let i = 0; i < border; i++) {
      row.unshift(b);
      row.push(b);
    }
  });
  for (let i = 0; i < border; i++) {
    input.types.unshift(Array.from({ length: newSize }, (_) => b));
    input.types.push(Array.from({ length: newSize }, (_) => b));
  }
  return input;
}
function getDataAt(data, x, y, defaults = false) {
  if (x < 0 || y < 0 || x >= data.length || y >= data.length)
    return defaults;
  return data[y][x];
}

function renderUnicode(data, options = {}) {
  const {
    whiteChar = "\u2588",
    blackChar = "\u2591"
  } = options;
  const result = encode(data, options);
  return result.data.map((row) => {
    return row.map((mod) => mod ? blackChar : whiteChar).join("");
  }).join("\n");
}
function renderANSI(data, options = {}) {
  return renderUnicode(data, {
    ...options,
    blackChar: "\x1B[40m\u3000\x1B[0m",
    whiteChar: "\x1B[47m\u3000\x1B[0m"
  });
}
function renderUnicodeCompact(data, options = {}) {
  const platte = {
    WHITE_ALL: "\u2588",
    WHITE_BLACK: "\u2580",
    BLACK_WHITE: "\u2584",
    BLACK_ALL: " "
  };
  const result = encode(data, options);
  const WHITE = false;
  const BLACK = true;
  const at = (x, y) => getDataAt(result.data, x, y, true);
  const lines = [];
  let line = "";
  for (let row = 0; row < result.size; row += 2) {
    for (let col = 0; col < result.size; col++) {
      if (at(col, row) === WHITE && at(col, row + 1) === WHITE)
        line += platte.WHITE_ALL;
      else if (at(col, row) === WHITE && at(col, row + 1) === BLACK)
        line += platte.WHITE_BLACK;
      else if (at(col, row) === BLACK && at(col, row + 1) === WHITE)
        line += platte.BLACK_WHITE;
      else
        line += platte.BLACK_ALL;
    }
    lines.push(line);
    line = "";
  }
  return lines.join("\n");
}

function renderSVG(data, options = {}) {
  const result = encode(data, options);
  const {
    pixelSize = 10,
    whiteColor = "white",
    blackColor = "black"
  } = options;
  const height = result.size * pixelSize;
  const width = result.size * pixelSize;
  let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}">`;
  const pathes = [];
  for (let row = 0; row < result.size; row++) {
    for (let col = 0; col < result.size; col++) {
      const x = col * pixelSize;
      const y = row * pixelSize;
      if (result.data[row][col])
        pathes.push(`M${x},${y}h${pixelSize}v${pixelSize}h-${pixelSize}z`);
    }
  }
  svg += `<rect fill="${whiteColor}" width="${width}" height="${height}"/>`;
  svg += `<path fill="${blackColor}" d="${pathes.join("")}"/>`;
  svg += "</svg>";
  return svg;
}




/***/ }),

/***/ "./src/const.js":
/*!**********************!*\
  !*** ./src/const.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ARCHER: () => (/* binding */ ARCHER),
/* harmony export */   ATLAS: () => (/* binding */ ATLAS),
/* harmony export */   BUILDING_STATE: () => (/* binding */ BUILDING_STATE),
/* harmony export */   GAME_AUDIO_TYPES: () => (/* binding */ GAME_AUDIO_TYPES),
/* harmony export */   GAME_EVENTS: () => (/* binding */ GAME_EVENTS),
/* harmony export */   GAME_OBJECTS: () => (/* binding */ GAME_OBJECTS),
/* harmony export */   GAME_STAGES: () => (/* binding */ GAME_STAGES),
/* harmony export */   GAME_UNITS: () => (/* binding */ GAME_UNITS),
/* harmony export */   GOBLIN_TORCH: () => (/* binding */ GOBLIN_TORCH),
/* harmony export */   GOBLIN_TOWER: () => (/* binding */ GOBLIN_TOWER),
/* harmony export */   GOLD_MINE_GOLD_AMOUNT: () => (/* binding */ GOLD_MINE_GOLD_AMOUNT),
/* harmony export */   KNIGHT: () => (/* binding */ KNIGHT),
/* harmony export */   PEASANT: () => (/* binding */ PEASANT),
/* harmony export */   STAGE_TEXTS: () => (/* binding */ STAGE_TEXTS),
/* harmony export */   TREE_FULL_HEALTH: () => (/* binding */ TREE_FULL_HEALTH),
/* harmony export */   TREE_STUB_INDEX: () => (/* binding */ TREE_STUB_INDEX),
/* harmony export */   UNIT_DIRECTION: () => (/* binding */ UNIT_DIRECTION),
/* harmony export */   UNIT_TACTIC: () => (/* binding */ UNIT_TACTIC),
/* harmony export */   UNIT_VIEW_RANGE: () => (/* binding */ UNIT_VIEW_RANGE)
/* harmony export */ });
var BUILDING_STATE = {
  READY: "READY",
  BUILDING_SELF: "BUILDING_SELF",
  BUILDING_UNIT: "BUILDING_UNIT"
};
var TREE_FULL_HEALTH = 100;
var GOLD_MINE_GOLD_AMOUNT = 10000;
var treesIndexes = [61, 62, 63];
var TREE_STUB_INDEX = 69;
var UNIT_VIEW_RANGE = 300;
var GAME_EVENTS = {
  GOLD_GRAB: "GOLD_GRAB",
  GOLD_MINED: "GOLD_MINED",
  WOOD_GRAB: "WOOD_GRAB",
  WOOD_MINED: "WOOD_MINED",
  GOLD_MINE_EMPTY: "GOLD_MINE_EMPTY",
  TREE_EMPTY: "TREE_EMPTY",
  REQUEST_FOR_CLOSEST_TREE: "REQUEST_FOR_CLOSEST_TREE",
  PEASANT_BUILT: "PEASANT_BUILT",
  BUILDING_DONE: "BUILDING_DONE",
  CREATE_ARROW: "CREATE_ARROW",
  SYSTEM_EVENTS: {
    OPEN_DIALOG: "openDialog",
    CHANGE_DIALOG_STYLE: "changeStyle",
    START_LEVEL: "startLevel"
  },
  DIALOG_EVENTS: {
    CHANGE_OPTIONS: "changeOptions",
    CLOSED: "closed"
  }
};
var UNIT_DIRECTION = {
  LEFT: "LEFT",
  RIGHT: "RIGHT"
};
var GAME_AUDIO_TYPES = {
  WHAT: "WHAT",
  YES: "YES",
  ATTACK: "ATTACK",
  FIGHT: "FIGHT",
  DEATH: "DEATH"
};
var PEASANT = {
  ACTIONS: {
    IDLE: "IDLE",
    MOVE: "MOVE",
    FIGHT: "FIGHT",
    BUILD: "BUILD",
    DRAG_GOLD: "DRAG_GOLD",
    CHOP_WOOD: "CHOP_WOOD",
    DRAG_WOOD: "DRAG_WOOD"
  },
  ANIMATIONS: {
    IDLE_LEFT: "IDLE_LEFT",
    IDLE_RIGHT: "IDLE_RIGHT",
    MOVE_LEFT: "MOVE_LEFT",
    MOVE_RIGHT: "MOVE_RIGHT",
    BUILD_LEFT: "BUILD_LEFT",
    BUILD_RIGHT: "BUILD_RIGHT",
    CHOP_LEFT: "CHOP_LEFT",
    CHOP_RIGHT: "CHOP_RIGHT",
    CARRY_IDLE_LEFT: "CARRY_IDLE_LEFT",
    CARRY_IDLE_RIGHT: "CARRY_IDLE_RIGHT",
    CARRY_LEFT: "CARRY_LEFT",
    CARRY_RIGHT: "CARRY_RIGHT"
  },
  AUDIO: {
    WHAT1: "WHAT1",
    WHAT2: "WHAT2",
    WHAT3: "WHAT3",
    YES1: "YES1",
    YES2: "YES2",
    YES3: "YES3",
    DEATH1: "DEATH1"
  }
};
var KNIGHT = {
  ACTIONS: {
    IDLE: "IDLE",
    MOVE: "MOVE",
    FIGHT: "FIGHT"
  },
  ANIMATIONS: {
    IDLE_RIGHT: "IDLE_RIGHT",
    MOVE_RIGHT: "MOVE_RIGHT",
    FIGHT_RIGHT_1: "FIGHT_RIGHT_1",
    FIGHT_RIGHT_2: "FIGHT_RIGHT_2",
    IDLE_LEFT: "IDLE_LEFT",
    MOVE_LEFT: "MOVE_LEFT",
    FIGHT_LEFT_1: "FIGHT_LEFT_1",
    FIGHT_LEFT_2: "FIGHT_LEFT_2",
    FIGHT_UP_1: "FIGHT_UP_1",
    FIGHT_UP_2: "FIGHT_UP_2",
    FIGHT_DOWN_1: "FIGHT_DOWN_1",
    FIGHT_DOWN_2: "FIGHT_DOWN_2"
  },
  AUDIO: {
    WHAT1: "K_WHAT1",
    WHAT2: "K_WHAT2",
    WHAT3: "K_WHAT3",
    YES1: "K_YES1",
    YES2: "K_YES2",
    YES3: "K_YES3",
    ATTACK1: "K_ATTACK1",
    ATTACK2: "K_ATTACK2",
    FIGHT1: "K_FIGHT1",
    FIGHT2: "K_FIGHT2",
    DEATH1: "K_DEATH1"
  }
};
var ARCHER = {
  ACTIONS: {
    IDLE: "IDLE",
    MOVE: "MOVE",
    FIGHT: "FIGHT"
  },
  ANIMATIONS: {
    IDLE_RIGHT: "IDLE_RIGHT",
    MOVE_RIGHT: "MOVE_RIGHT",
    IDLE_LEFT: "IDLE_LEFT",
    MOVE_LEFT: "MOVE_LEFT",
    FIGHT_UP: "FIGHT_UP",
    FIGHT_UP_RIGHT: "FIGHT_UP_RIGHT",
    FIGHT_RIGHT: "FIGHT_RIGHT",
    FIGHT_DOWN_RIGHT: "FIGHT_DOWN_RIGHT",
    FIGHT_DOWN: "FIGHT_DOWN",
    FIGHT_UP_LEFT: "FIGHT_UP_LEFT",
    FIGHT_LEFT: "FIGHT_LEFT",
    FIGHT_DOWN_LEFT: "FIGHT_DOWN_LEFT"
  },
  AUDIO: {
    WHAT1: "K_WHAT1",
    WHAT2: "K_WHAT2",
    WHAT3: "K_WHAT3",
    YES1: "K_YES1",
    YES2: "K_YES2",
    YES3: "K_YES3",
    ATTACK1: "K_ATTACK1",
    ATTACK2: "K_ATTACK2",
    FIGHT1: "K_FIGHT1",
    FIGHT2: "K_FIGHT2",
    DEATH1: "K_DEATH1"
  }
};
var GOBLIN_TORCH = {
  ACTIONS: {
    IDLE: "IDLE",
    MOVE: "MOVE",
    FIGHT: "FIGHT"
  },
  ANIMATIONS: {
    IDLE_RIGHT: "IDLE_RIGHT",
    IDLE_LEFT: "IDLE_LEFT",
    MOVE_RIGHT: "MOVE_RIGHT",
    MOVE_LEFT: "MOVE_LEFT",
    FIGHT_RIGHT_1: "FIGHT_RIGHT",
    FIGHT_LEFT_1: "FIGHT_LEFT",
    FIGHT_UP_1: "FIGHT_UP",
    FIGHT_DOWN_1: "FIGHT_DOWN"
  },
  AUDIO: {
    WHAT1: "G_WHAT1",
    WHAT2: "G_WHAT2",
    WHAT3: "G_WHAT3",
    YES1: "G_YES1",
    YES2: "G_YES2",
    YES3: "G_YES3",
    DEATH1: "G_DEATH1"
  }
};
var GOBLIN_TOWER = {
  ANIMATIONS: {
    IDLE: "IDLE"
  }
};
var ATLAS = {
  "64x64": "tinyswords64x64",
  "192x192": "192x192",
  "192Units": "192Units"
};
var GAME_UNITS = {
  PEASANT: {
    name: "PEASANT",
    atlasKey: ATLAS["192Units"],
    cost: {
      g: 100,
      w: 0
    },
    duration: 1000,
    attackSpeed: 800,
    attackDamage: 10,
    health: 100
  },
  KNIGHT: {
    name: "KNIGHT",
    atlasKey: ATLAS["192Units"],
    cost: {
      g: 400,
      w: 0
    },
    duration: 2000,
    attackSpeed: 1000,
    attackDamage: 30,
    health: 150
  },
  ARCHER: {
    name: "ARCHER",
    atlasKey: ATLAS["192Units"],
    cost: {
      g: 300,
      w: 100
    },
    duration: 2000,
    attackSpeed: 2000,
    attackRange: 300,
    attackDamage: 15,
    health: 100
  },
  GOBLIN_TORCH: {
    name: "GOBLIN_TORCH",
    atlasKey: ATLAS["192Units"],
    cost: {
      g: 200,
      w: 100
    },
    duration: 2000,
    attackSpeed: 1000,
    attackDamage: 20,
    health: 100
  },
  BARRACKS: {
    name: "BARRACKS",
    cost: {
      g: 800,
      w: 500
    },
    duration: 5000,
    health: 1000
  },
  HOUSE: {
    name: "HOUSE",
    cost: {
      g: 300,
      w: 300
    },
    duration: 3000,
    health: 500
  },
  TOWN_CENTER: {
    name: "TOWN_CENTER",
    cost: {
      g: 1000,
      w: 1000
    },
    duration: 10000,
    health: 5000
  },
  GOBLIN_HOUSE: {
    name: "GOBLIN_HOUSE",
    atlasKey: ATLAS["192x192"],
    duration: 3000,
    health: 500
  },
  GOBLIN_TOWER: {
    name: "GOBLIN_TOWER",
    atlasKey: ATLAS["192x192"],
    duration: 3000,
    health: 1000
  },
  GOLD_MINE: {
    name: "GOLD_MINE"
  }
};
var GAME_OBJECTS = {
  SKILL: {
    name: "SKILL",
    atlasKey: ATLAS["192Units"]
  }
};
var GAME_STAGES = {
  START: "START",
  STAGE_1: "STAGE_1",
  STAGE_2: "STAGE_2"
};
var STAGE_TEXTS = {
  STAGE_1: {
    START: {
      key: "START",
      title: " 1.",
      text: "     ,    .     !"
    },
    WIN: {
      key: "WIN",
      title: "!",
      text: " , !"
    }
  },
  STAGE_2: {
    START: {
      key: "START",
      title: " 2.",
      text: "    -   2"
    },
    WIN_1_BATTLE: {
      key: "WIN_1_BATTLE",
      title: "!",
      text: "     .   ,      ."
    },
    WIN: {
      key: "WIN",
      title: "!",
      text: " -   2"
    }
  }
};
var UNIT_TACTIC = {
  AGGRESSIVE: "aggressive",
  DEFENSE: "defense",
  RUN_AWAY: "run_away"
};


/***/ }),

/***/ "./src/stage1.js":
/*!***********************!*\
  !*** ./src/stage1.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Stage1: () => (/* binding */ Stage1)
/* harmony export */ });
/* harmony import */ var jsge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsge */ "./node_modules/jsge/src/index.js");
/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const.js */ "./src/const.js");
/* harmony import */ var _units_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./units.js */ "./src/units.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }




var isPointInsidePolygon = jsge__WEBPACK_IMPORTED_MODULE_0__.utils.isPointInsidePolygon,
  countDistance = jsge__WEBPACK_IMPORTED_MODULE_0__.utils.countDistance,
  randomFromArray = jsge__WEBPACK_IMPORTED_MODULE_0__.utils.randomFromArray;
var _SLOW_SCROLL_POINT = /*#__PURE__*/new WeakMap();
var _QUICK_SCROLL_POINT = /*#__PURE__*/new WeakMap();
var _imageConverter = /*#__PURE__*/new WeakMap();
var _playerGold = /*#__PURE__*/new WeakMap();
var _playerGoldCounter = /*#__PURE__*/new WeakMap();
var _playerWood = /*#__PURE__*/new WeakMap();
var _playerWoodCounter = /*#__PURE__*/new WeakMap();
var _playerPeopleLimit = /*#__PURE__*/new WeakMap();
var _playerPeopleLimitCounter = /*#__PURE__*/new WeakMap();
var _playerUnits = /*#__PURE__*/new WeakMap();
var _playerBuildings = /*#__PURE__*/new WeakMap();
var _neutralBuildings = /*#__PURE__*/new WeakMap();
var _enemyUnits = /*#__PURE__*/new WeakMap();
var _enemyBuildings = /*#__PURE__*/new WeakMap();
var _treesLayer = /*#__PURE__*/new WeakMap();
var _treesCutHealth = /*#__PURE__*/new WeakMap();
var _selectedItemText = /*#__PURE__*/new WeakMap();
var _buildItems = /*#__PURE__*/new WeakMap();
var _buildTemplate = /*#__PURE__*/new WeakMap();
var _isBuildPlaceClear = /*#__PURE__*/new WeakMap();
var _buildTemplateOverlap = /*#__PURE__*/new WeakMap();
var _mouseX = /*#__PURE__*/new WeakMap();
var _mouseY = /*#__PURE__*/new WeakMap();
var _unitsCount = /*#__PURE__*/new WeakMap();
var _addUnitPosX = /*#__PURE__*/new WeakMap();
var _isWin = /*#__PURE__*/new WeakMap();
var _crossArr = /*#__PURE__*/new WeakMap();
var _attachAudio = /*#__PURE__*/new WeakMap();
var _onDialogClosed = /*#__PURE__*/new WeakMap();
var _Stage1_brand = /*#__PURE__*/new WeakSet();
var _createUserInterface = /*#__PURE__*/new WeakMap();
var _pressKeyAction = /*#__PURE__*/new WeakMap();
var _removeKeyAction = /*#__PURE__*/new WeakMap();
var _mouseMoveAction = /*#__PURE__*/new WeakMap();
var _mouseClickAction = /*#__PURE__*/new WeakMap();
var _processNewBuild = /*#__PURE__*/new WeakMap();
var _processImageClick = /*#__PURE__*/new WeakMap();
var _orderToBuildUnit = /*#__PURE__*/new WeakMap();
var _orderToBuildBuilding = /*#__PURE__*/new WeakMap();
var _processMapClick = /*#__PURE__*/new WeakMap();
var _drawCross = /*#__PURE__*/new WeakMap();
var _configureUnitUI = /*#__PURE__*/new WeakMap();
var _configureBuildingUI = /*#__PURE__*/new WeakMap();
var _clickedBuildPeasant = /*#__PURE__*/new WeakMap();
var _render = /*#__PURE__*/new WeakMap();
var _createGoldBag = /*#__PURE__*/new WeakMap();
var _createWoodBunch = /*#__PURE__*/new WeakMap();
var _goldMined = /*#__PURE__*/new WeakMap();
var _woodMined = /*#__PURE__*/new WeakMap();
var _goldMineEmpty = /*#__PURE__*/new WeakMap();
var _requestForClosestTree = /*#__PURE__*/new WeakMap();
var _treeEmpty = /*#__PURE__*/new WeakMap();
var _peasantBuilt = /*#__PURE__*/new WeakMap();
var _buildingDone = /*#__PURE__*/new WeakMap();
var _activateVictory = /*#__PURE__*/new WeakMap();
var Stage1 = /*#__PURE__*/function (_GameStage) {
  function Stage1() {
    var _this;
    _classCallCheck(this, Stage1);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper(this, Stage1, [].concat(args));
    _classPrivateMethodInitSpec(_this, _Stage1_brand);
    _classPrivateFieldInitSpec(_this, _SLOW_SCROLL_POINT, 100);
    _classPrivateFieldInitSpec(_this, _QUICK_SCROLL_POINT, 50);
    _classPrivateFieldInitSpec(_this, _imageConverter, document.createElement("canvas"));
    _classPrivateFieldInitSpec(_this, _playerGold, 0);
    _classPrivateFieldInitSpec(_this, _playerGoldCounter, void 0);
    _classPrivateFieldInitSpec(_this, _playerWood, 0);
    _classPrivateFieldInitSpec(_this, _playerWoodCounter, void 0);
    _classPrivateFieldInitSpec(_this, _playerPeopleLimit, 5);
    // lets say town center increase limit to 5 and house to 3
    _classPrivateFieldInitSpec(_this, _playerPeopleLimitCounter, void 0);
    _classPrivateFieldInitSpec(_this, _playerUnits, []);
    _classPrivateFieldInitSpec(_this, _playerBuildings, []);
    _classPrivateFieldInitSpec(_this, _neutralBuildings, []);
    _classPrivateFieldInitSpec(_this, _enemyUnits, []);
    _classPrivateFieldInitSpec(_this, _enemyBuildings, []);
    _classPrivateFieldInitSpec(_this, _treesLayer, void 0);
    _classPrivateFieldInitSpec(_this, _treesCutHealth, new Map());
    _classPrivateFieldInitSpec(_this, _selectedItemText, void 0);
    _classPrivateFieldInitSpec(_this, _buildItems, void 0);
    _classPrivateFieldInitSpec(_this, _buildTemplate, void 0);
    _classPrivateFieldInitSpec(_this, _isBuildPlaceClear, void 0);
    _classPrivateFieldInitSpec(_this, _buildTemplateOverlap, void 0);
    _classPrivateFieldInitSpec(_this, _mouseX, void 0);
    _classPrivateFieldInitSpec(_this, _mouseY, void 0);
    _classPrivateFieldInitSpec(_this, _unitsCount, 0);
    _classPrivateFieldInitSpec(_this, _addUnitPosX, 0);
    _classPrivateFieldInitSpec(_this, _isWin, false);
    _classPrivateFieldInitSpec(_this, _crossArr, []);
    _classPrivateFieldInitSpec(_this, _attachAudio, function () {
      _this.chopTreeSound = _this.iLoader.getAudio("chopTree");
      _this.knightAudio = new Map();
      _this.knightAudio.set(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.YES, [_this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.YES1), _this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.YES2), _this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.YES3)]);
      _this.knightAudio.set(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.WHAT, [_this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.WHAT1), _this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.WHAT2), _this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.WHAT3)]);
      _this.knightAudio.set(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.ATTACK, [_this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.ATTACK1), _this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.ATTACK2)]);
      _this.knightAudio.set(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.FIGHT, [_this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.FIGHT1), _this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.FIGHT2)]);
      _this.knightAudio.set(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.DEATH, [_this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.DEATH1)]);
      _this.peasantAudio = new Map();
      _this.peasantAudio.set(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.WHAT, [_this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.AUDIO.WHAT1), _this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.AUDIO.WHAT2), _this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.AUDIO.WHAT3)]);
      _this.goblinAudio = new Map();
      _this.goblinAudio.set(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.DEATH, [_this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.AUDIO.DEATH1)]);
    });
    _classPrivateFieldInitSpec(_this, _onDialogClosed, function (e) {
      var _e$data$ = e.data[0],
        currentLevel = _e$data$.currentLevel,
        currentState = _e$data$.currentState;
      if (currentLevel === 1) {
        if (currentState === _const_js__WEBPACK_IMPORTED_MODULE_1__.STAGE_TEXTS.STAGE_1.START.key) {
          _this.registerListeners();
        } else if (currentState === _const_js__WEBPACK_IMPORTED_MODULE_1__.STAGE_TEXTS.STAGE_1.WIN.key) {
          _this.iSystem.stopGameStage(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_STAGES.STAGE_1);
          _this.iSystem.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.SYSTEM_EVENTS.OPEN_DIALOG, {
            level: 2,
            messageKey: _const_js__WEBPACK_IMPORTED_MODULE_1__.STAGE_TEXTS.STAGE_2.START.key,
            title: _const_js__WEBPACK_IMPORTED_MODULE_1__.STAGE_TEXTS.STAGE_2.START.title,
            text: _const_js__WEBPACK_IMPORTED_MODULE_1__.STAGE_TEXTS.STAGE_2.START.text
          });
          _this.iSystem.startGameStage(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_STAGES.STAGE_2);
        }
      }
    });
    _classPrivateFieldInitSpec(_this, _createUserInterface, function () {
      var windowWidth = document.body.offsetWidth,
        sidebar = document.createElement("div");
      sidebar.id = "sidebar";
      sidebar.style.width = windowWidth + "px";
      sidebar.style.height = "48px";
      sidebar.style.padding = "6px";
      sidebar.style.backgroundColor = "#ccc";
      sidebar.style.position = "fixed";
      sidebar.style.top = 0 + "px";
      sidebar.style.left = 0 + "px";
      sidebar.style.display = "flex";
      sidebar.style.fontSize = "1.4rem";
      sidebar.style.fontWeight = "bold";
      document.body.appendChild(sidebar);
      var resourcesInfo = document.createElement("div");
      resourcesInfo.style.display = "flex";
      resourcesInfo.style.flexFlow = "column";
      sidebar.appendChild(resourcesInfo);
      var resourceWrap = document.createElement("div");
      resourceWrap.style.display = "flex";
      var playerGoldCounterText = document.createElement("div");
      playerGoldCounterText.innerText = "Gold: ";
      resourceWrap.appendChild(playerGoldCounterText);
      _classPrivateFieldSet(_playerGoldCounter, _this, document.createElement("div"));
      _classPrivateFieldGet(_playerGoldCounter, _this).innerText = _classPrivateFieldGet(_playerGold, _this).toString();
      _classPrivateFieldGet(_playerGoldCounter, _this).style.marginRight = "6px";
      resourceWrap.appendChild(_classPrivateFieldGet(_playerGoldCounter, _this));
      var playerWoodCounterText = document.createElement("div");
      playerWoodCounterText.innerText = "Wood: ";
      resourceWrap.appendChild(playerWoodCounterText);
      _classPrivateFieldSet(_playerWoodCounter, _this, document.createElement("div"));
      _classPrivateFieldGet(_playerWoodCounter, _this).innerText = _classPrivateFieldGet(_playerWood, _this).toString();
      _classPrivateFieldGet(_playerWoodCounter, _this).style.marginRight = "6px";
      resourceWrap.appendChild(_classPrivateFieldGet(_playerWoodCounter, _this));
      resourcesInfo.appendChild(resourceWrap);
      var playerInfoWrap = document.createElement("div");
      playerInfoWrap.style.display = "flex";
      var playerPeopleCounterText = document.createElement("div");
      playerPeopleCounterText.innerText = "People limits: ";
      playerInfoWrap.appendChild(playerPeopleCounterText);
      _classPrivateFieldSet(_playerPeopleLimitCounter, _this, document.createElement("div"));
      _classPrivateFieldGet(_playerPeopleLimitCounter, _this).innerText = _classPrivateFieldGet(_playerUnits, _this).length + "/" + _classPrivateFieldGet(_playerPeopleLimit, _this).toString();
      playerInfoWrap.appendChild(_classPrivateFieldGet(_playerPeopleLimitCounter, _this));
      resourcesInfo.appendChild(playerInfoWrap);
      var buildMenuContainer = document.createElement("div");
      buildMenuContainer.style.display = "flex";
      buildMenuContainer.style.marginLeft = "30px";
      sidebar.appendChild(buildMenuContainer);
      _classPrivateFieldSet(_selectedItemText, _this, document.createElement("div"));
      _classPrivateFieldGet(_selectedItemText, _this).innerText = "Nothing is selected";
      buildMenuContainer.appendChild(_classPrivateFieldGet(_selectedItemText, _this));
      _classPrivateFieldSet(_buildItems, _this, document.createElement("div"));
      buildMenuContainer.appendChild(_classPrivateFieldGet(_buildItems, _this));
    });
    _classPrivateFieldInitSpec(_this, _pressKeyAction, function (event) {
      var code = event.code;
      if (code === "Space") {
        var _this$unitsCount, _this$unitsCount2, _this$unitsCount3, _this$unitsCount4;
        var townCenter = _classPrivateFieldGet(_playerBuildings, _this).find(function (building) {
          return building.key === _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.TOWN_CENTER.name;
        });
        var newPeasant = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitPeasant(0, 0, townCenter, _this.draw, _this.iSystem.systemSettings.gameOptions.showLifeLines, _this.eventsAggregator);
        var newPeasant2 = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitPeasant(0, 0, townCenter, _this.draw, _this.iSystem.systemSettings.gameOptions.showLifeLines, _this.eventsAggregator);
        newPeasant.x = townCenter.x - _classPrivateFieldGet(_addUnitPosX, _this);
        newPeasant.y = townCenter.y;
        newPeasant2.x = townCenter.x - _classPrivateFieldGet(_addUnitPosX, _this);
        newPeasant2.y = townCenter.y - 16;
        _this.addRenderObject(newPeasant);
        _this.addRenderObject(newPeasant2);
        _classPrivateFieldGet(_playerUnits, _this).push(newPeasant);
        _classPrivateFieldGet(_playerUnits, _this).push(newPeasant2);
        _classPrivateFieldSet(_unitsCount, _this, (_this$unitsCount = _classPrivateFieldGet(_unitsCount, _this), _this$unitsCount2 = _this$unitsCount++, _this$unitsCount)), _this$unitsCount2;
        _classPrivateFieldSet(_unitsCount, _this, (_this$unitsCount3 = _classPrivateFieldGet(_unitsCount, _this), _this$unitsCount4 = _this$unitsCount3++, _this$unitsCount3)), _this$unitsCount4;
        newPeasant.activateMoveToTargetPoint(1500, 1500);
        newPeasant2.activateMoveToTargetPoint(1500, 1500);
        _classPrivateFieldSet(_addUnitPosX, _this, _classPrivateFieldGet(_addUnitPosX, _this) - 20);
      }
    });
    _classPrivateFieldInitSpec(_this, _removeKeyAction, function (event) {
      var code = event.code;
      if (code === "Space") {
        _classPrivateFieldSet(_addUnitPosX, _this, 0);
      }
    });
    _classPrivateFieldInitSpec(_this, _mouseMoveAction, function (e) {
      var _this$stageData$world = _slicedToArray(_this.stageData.worldOffset, 2),
        xOffset = _this$stageData$world[0],
        yOffset = _this$stageData$world[1],
        x = e.offsetX,
        y = e.offsetY,
        cursorPosX = x + xOffset,
        cursorPosY = y + yOffset,
        _this$stageData$canva = _slicedToArray(_this.stageData.canvasDimensions, 2),
        viewWidth = _this$stageData$canva[0],
        viewHeight = _this$stageData$canva[1],
        xShiftRight = viewWidth - x,
        yShiftBottom = viewHeight - y,
        xShift = viewWidth / 2 + xOffset,
        yShift = viewHeight / 2 + yOffset;
      var newPosX = xShift,
        newPosY = yShift;
      document.getElementsByTagName("canvas")[0].style.cursor = "default";
      if (x < _classPrivateFieldGet(_QUICK_SCROLL_POINT, _this)) {
        //console.log("quick scroll left");
        newPosX = xShift - 20;
        document.getElementsByTagName("canvas")[0].style.cursor = "url('assets/cursor-pack-kenney/Outline/Default/navigation_w.png'), auto";
      } else if (x < _classPrivateFieldGet(_SLOW_SCROLL_POINT, _this)) {
        //console.log("slow scroll left");
        newPosX = xShift - 5;
        document.getElementsByTagName("canvas")[0].style.cursor = "url('assets/cursor-pack-kenney/Outline/Default/navigation_w.png'), auto";
        console.log("sss");
      }
      if (xShiftRight < _classPrivateFieldGet(_QUICK_SCROLL_POINT, _this)) {
        //console.log("quick scroll right");
        newPosX = xShift + 20;
        document.getElementsByTagName("canvas")[0].style.cursor = "url('assets/cursor-pack-kenney/Outline/Default/navigation_e.png'), auto";
      } else if (xShiftRight < _classPrivateFieldGet(_SLOW_SCROLL_POINT, _this)) {
        //console.log("slow scroll right");
        newPosX = xShift + 20;
        document.getElementsByTagName("canvas")[0].style.cursor = "url('assets/cursor-pack-kenney/Outline/Default/navigation_e.png'), auto";
      }
      if (y < _classPrivateFieldGet(_QUICK_SCROLL_POINT, _this)) {
        //console.log("quick scroll up");
        newPosY = yShift - 20;
        document.getElementsByTagName("canvas")[0].style.cursor = "url('assets/cursor-pack-kenney/Outline/Default/navigation_n.png'), auto";
      } else if (y < _classPrivateFieldGet(_SLOW_SCROLL_POINT, _this)) {
        //console.log("slow scroll up");
        newPosY = yShift - 5;
        document.getElementsByTagName("canvas")[0].style.cursor = "url('assets/cursor-pack-kenney/Outline/Default/navigation_n.png'), auto";
      }
      if (yShiftBottom < _classPrivateFieldGet(_QUICK_SCROLL_POINT, _this)) {
        //console.log("quick scroll down");
        newPosY = yShift + 20;
        document.getElementsByTagName("canvas")[0].style.cursor = "url('assets/cursor-pack-kenney/Outline/Default/navigation_s.png'), auto";
      } else if (yShiftBottom < _classPrivateFieldGet(_SLOW_SCROLL_POINT, _this)) {
        //console.log("slow scroll down");
        newPosY = yShift + 5;
        document.getElementsByTagName("canvas")[0].style.cursor = "url('assets/cursor-pack-kenney/Outline/Default/navigation_s.png'), auto";
      }
      _this.stageData.centerCameraPosition(newPosX, newPosY);
      _classPrivateFieldSet(_mouseX, _this, cursorPosX);
      _classPrivateFieldSet(_mouseY, _this, cursorPosY);
      if (_classPrivateFieldGet(_buildTemplate, _this)) {
        _classPrivateFieldGet(_buildTemplate, _this).x = cursorPosX;
        _classPrivateFieldGet(_buildTemplate, _this).y = cursorPosY;
        _classPrivateFieldGet(_buildTemplateOverlap, _this).x = cursorPosX - _classPrivateFieldGet(_buildTemplateOverlap, _this).width / 2;
        _classPrivateFieldGet(_buildTemplateOverlap, _this).y = cursorPosY - _classPrivateFieldGet(_buildTemplateOverlap, _this).height / 2;
        if (_this.isBoundariesCollision(cursorPosX, cursorPosY, _classPrivateFieldGet(_buildTemplateOverlap, _this)) || _this.isObjectsCollision(cursorPosX, cursorPosY, _classPrivateFieldGet(_buildTemplateOverlap, _this), _classPrivateFieldGet(_playerBuildings, _this)) || _this.isObjectsCollision(cursorPosX, cursorPosY, _classPrivateFieldGet(_buildTemplateOverlap, _this), _classPrivateFieldGet(_neutralBuildings, _this))) {
          _classPrivateFieldGet(_buildTemplateOverlap, _this).bgColor = "rgba(224, 12, 21, 0.6)";
          _classPrivateFieldSet(_isBuildPlaceClear, _this, false);
        } else {
          _classPrivateFieldGet(_buildTemplateOverlap, _this).bgColor = "rgba(0, 0, 0, 0.3";
          _classPrivateFieldSet(_isBuildPlaceClear, _this, true);
        }
      }
    });
    _classPrivateFieldInitSpec(_this, _mouseClickAction, function (e) {
      var target = e.target;
      if (target instanceof Image) {
        _classPrivateFieldGet(_processImageClick, _this).call(_this, e);
      } else if (_classPrivateFieldGet(_buildTemplate, _this)) {
        _classPrivateFieldGet(_processNewBuild, _this).call(_this, _classPrivateFieldGet(_buildTemplate, _this)._building_key);
      } else {
        _classPrivateFieldGet(_processMapClick, _this).call(_this, e);
      }
    });
    _classPrivateFieldInitSpec(_this, _processNewBuild, function (key) {
      var cantBuildAudio = _this.iLoader.getAudio("cantBuildHere");
      if (_classPrivateFieldGet(_isBuildPlaceClear, _this)) {
        _classPrivateFieldGet(_playerUnits, _this).forEach(function (unit) {
          if (unit.isSelected) {
            unit.activateStartBuilding(_classPrivateFieldGet(_buildTemplateOverlap, _this).x, _classPrivateFieldGet(_buildTemplateOverlap, _this).y, key);
            if (unit.isSelected) {
              unit.isSelected = false;
            }
            // cleanup build menu
            _classPrivateFieldGet(_selectedItemText, _this).innerText = "";
            while (_classPrivateFieldGet(_buildItems, _this).lastChild) {
              _classPrivateFieldGet(_buildItems, _this).removeChild(_classPrivateFieldGet(_buildItems, _this).lastChild);
            }
            // remove build helpers
            _classPrivateFieldGet(_buildTemplate, _this).destroy();
            _classPrivateFieldGet(_buildTemplateOverlap, _this).destroy();
            _classPrivateFieldSet(_buildTemplate, _this, null);
            _classPrivateFieldSet(_buildTemplateOverlap, _this, null);
          }
        });
      } else {
        cantBuildAudio.play();
      }
    });
    _classPrivateFieldInitSpec(_this, _processImageClick, function (e) {
      var target = e.target,
        type = target.id;
      switch (type) {
        case _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.PEASANT.name:
          _classPrivateFieldGet(_orderToBuildUnit, _this).call(_this, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.PEASANT.name);
          break;
        case _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.HOUSE.name:
          _classPrivateFieldGet(_orderToBuildBuilding, _this).call(_this, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.HOUSE.name);
          break;
        case _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.BARRACKS.name:
          _classPrivateFieldGet(_orderToBuildBuilding, _this).call(_this, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.BARRACKS.name);
          break;
      }
    });
    _classPrivateFieldInitSpec(_this, _orderToBuildUnit, function (type) {
      console.log("order build ", type);
      var costWood = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS[type].cost.w,
        costGold = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS[type].cost.g;
      if (!_assertClassBrand(_Stage1_brand, _this, _isEnoughGold).call(_this, costGold)) {
        console.log("not enough gold");
        _this.iLoader.getAudio("needMoreGold").play();
      } else if (!_assertClassBrand(_Stage1_brand, _this, _isEnoughWood).call(_this, costWood)) {
        console.log("not enough wood");
      } else if (!_assertClassBrand(_Stage1_brand, _this, _isEnoughHouses).call(_this)) {
        _this.iLoader.getAudio("needFood").play();
        console.log("not enough houses");
      } else {
        var townCenter = _classPrivateFieldGet(_playerBuildings, _this).find(function (building) {
          return building.key === _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.TOWN_CENTER.name;
        });
        if (!townCenter.isBuildingUnit) {
          _classPrivateFieldSet(_playerGold, _this, _classPrivateFieldGet(_playerGold, _this) - costGold);
          _classPrivateFieldSet(_playerWood, _this, _classPrivateFieldGet(_playerWood, _this) - costWood);
          townCenter.buildUnit(type);
        } else {
          console.log("already building");
        }
      }
    });
    _classPrivateFieldInitSpec(_this, _orderToBuildBuilding, function (type) {
      var costWood = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS[type].cost.w,
        costGold = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS[type].cost.g;
      if (!_assertClassBrand(_Stage1_brand, _this, _isEnoughGold).call(_this, costGold)) {
        console.log("not enough gold");
        _this.iLoader.getAudio("needMoreGold").play();
      } else if (!_assertClassBrand(_Stage1_brand, _this, _isEnoughWood).call(_this, costWood)) {
        console.log("not enough wood");
      } else {
        _classPrivateFieldSet(_playerGold, _this, _classPrivateFieldGet(_playerGold, _this) - costGold);
        _classPrivateFieldSet(_playerWood, _this, _classPrivateFieldGet(_playerWood, _this) - costWood);
        var imageType = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.HOUSE.name;
        // a small workaround to use image atlas, instead of separate images
        switch (type) {
          case _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.BARRACKS.name:
            imageType = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.HOUSE.name;
            break;
        }
        _classPrivateFieldSet(_buildTemplate, _this, _this.draw.image(_classPrivateFieldGet(_mouseX, _this), _classPrivateFieldGet(_mouseY, _this), 128, 192, imageType, 9));
        _classPrivateFieldGet(_buildTemplate, _this)._building_key = type;
        _classPrivateFieldSet(_buildTemplateOverlap, _this, _this.draw.rect(_classPrivateFieldGet(_mouseX, _this) - 8, _classPrivateFieldGet(_mouseY, _this) - 8, 128, 192, "rgba(0, 0, 0, 0.3"));
        _classPrivateFieldSet(_isBuildPlaceClear, _this, false);
      }
    });
    _classPrivateFieldInitSpec(_this, _processMapClick, function (e) {
      var selectPlayerUnit = null,
        isTreeSelected = false,
        selectedNeutralBuilding = null,
        _this$stageData$world2 = _slicedToArray(_this.stageData.worldOffset, 2),
        offsetX = _this$stageData$world2[0],
        offsetY = _this$stageData$world2[1],
        clickXWithOffset = e.offsetX + offsetX,
        clickYWithOffset = e.offsetY + offsetY;
      _classPrivateFieldGet(_playerUnits, _this).forEach(function (unit) {
        if (isPointInsidePolygon(clickXWithOffset - unit.x, clickYWithOffset - unit.y, unit.boundaries)) {
          _classPrivateFieldGet(_playerUnits, _this).forEach(function (unit) {
            console.log(unit.isSelected);
            if (unit.isSelected) {
              console.log("deselect");
              unit.isSelected = false;
            }
          });
          _classPrivateFieldGet(_playerBuildings, _this).forEach(function (unit) {
            if (unit.isSelected) {
              unit.isSelected = false;
            }
          });
          selectPlayerUnit = unit;
          selectPlayerUnit.isSelected = true;
          _classPrivateFieldGet(_configureUnitUI, _this).call(_this, unit);
          unit.activateIdle(true);
        }
      });
      if (selectPlayerUnit && selectPlayerUnit.isSelected === true) {
        return;
      }
      _classPrivateFieldGet(_playerBuildings, _this).forEach(function (building) {
        if (isPointInsidePolygon(clickXWithOffset - building.x, clickYWithOffset - building.y, building.boundaries)) {
          _classPrivateFieldGet(_playerUnits, _this).forEach(function (unit) {
            if (unit.isSelected) {
              unit.isSelected = false;
            }
          });
          _classPrivateFieldGet(_playerBuildings, _this).forEach(function (unit) {
            if (unit.isSelected) {
              unit.isSelected = false;
            }
          });
          selectPlayerUnit = building;
          selectPlayerUnit.isSelected = true;
          _classPrivateFieldGet(_configureBuildingUI, _this).call(_this, building);
        }
      });
      _classPrivateFieldGet(_neutralBuildings, _this).forEach(function (unit) {
        if (isPointInsidePolygon(clickXWithOffset - unit.x, clickYWithOffset - unit.y, unit.boundaries)) {
          console.log("clicked gold mine: ", unit);
          console.log("gold amount: ", unit.goldAmount);
          selectedNeutralBuilding = unit;
        }
      });
      var xCell = Math.floor(clickXWithOffset / _classPrivateFieldGet(_treesLayer, _this).tilemap.tilewidth),
        yCell = Math.floor(clickYWithOffset / _classPrivateFieldGet(_treesLayer, _this).tilemap.tileheight),
        clickedCellIndex = _classPrivateFieldGet(_treesLayer, _this).layerData.height * yCell + xCell,
        clickedCellTile = _classPrivateFieldGet(_treesLayer, _this).layerData.data[clickedCellIndex];
      if (clickedCellTile !== 0 && clickedCellTile !== _const_js__WEBPACK_IMPORTED_MODULE_1__.TREE_STUB_INDEX) {
        console.log(clickedCellIndex);
        console.log("tree cell clicked");
        isTreeSelected = true;
      }

      // if no new units selected, move selected units to click point
      if (!selectPlayerUnit) {
        _classPrivateFieldGet(_playerUnits, _this).forEach(function (unit) {
          if (unit.isSelected) {
            if (unit instanceof _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitPeasant) {
              if (selectedNeutralBuilding) {
                console.log("do something with building: ", selectedNeutralBuilding);
                if (selectedNeutralBuilding.key === _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.GOLD_MINE.name && unit instanceof _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitPeasant) {
                  unit.activateGrabGold(selectedNeutralBuilding);
                }
              } else if (isTreeSelected) {
                console.log("go, and cut tree");
                var tree = _classPrivateFieldGet(_treesCutHealth, _this).get(clickedCellIndex);
                if (!tree) {
                  tree = new Tree(clickXWithOffset, clickYWithOffset, _const_js__WEBPACK_IMPORTED_MODULE_1__.TREE_FULL_HEALTH, clickedCellIndex);
                  _classPrivateFieldGet(_treesCutHealth, _this).set(clickedCellIndex, tree);
                }
                unit.activateDragTree(tree);
              } else {
                unit.activateMoveToTargetPoint(clickXWithOffset, clickYWithOffset, true);
                _classPrivateFieldGet(_drawCross, _this).call(_this, clickXWithOffset, clickYWithOffset);
              }
            } else if (unit instanceof _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitKnight) {
              unit.activateMoveToTargetPoint(clickXWithOffset, clickYWithOffset, true);
              _classPrivateFieldGet(_drawCross, _this).call(_this, clickXWithOffset, clickYWithOffset);
            }
          }
        });
      }
    });
    _classPrivateFieldInitSpec(_this, _drawCross, function (x, y) {
      var cross = _this.draw.image(x, y, 64, 64, _const_js__WEBPACK_IMPORTED_MODULE_1__.ATLAS["64x64"], 42);
      cross.addAnimation("markMoveT", [42, 43, 44, 45], false);
      cross.emit("markMoveT");
      _classPrivateFieldGet(_crossArr, _this).push(cross);
    });
    _classPrivateFieldInitSpec(_this, _configureUnitUI, function (unit) {
      while (_classPrivateFieldGet(_buildItems, _this).lastChild) {
        _classPrivateFieldGet(_buildItems, _this).removeChild(_classPrivateFieldGet(_buildItems, _this).lastChild);
      }
      if (unit instanceof _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitPeasant) {
        _classPrivateFieldGet(_selectedItemText, _this).innerText = "Peasant: ";
        var peasantFrameHouse = _this.iLoader.getImage(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.HOUSE.name); //this.draw.image(startX, startY, 16, 16, "houses", randomFromArray([9, 10, 11]));
        var helper = _classPrivateFieldGet(_imageConverter, _this).getContext("2d");
        _classPrivateFieldGet(_imageConverter, _this).width = 32;
        _classPrivateFieldGet(_imageConverter, _this).height = 48;
        helper.clearRect(0, 0, window.innerWidth, window.innerHeight);
        helper.drawImage(peasantFrameHouse, 0, 0, 128, 192, 0, 0, 32, 48);
        var imageDataHouse = _classPrivateFieldGet(_imageConverter, _this).toDataURL();
        var houseImage = new Image(32, 48);
        houseImage.src = imageDataHouse;
        houseImage.id = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.HOUSE.name;
        var peasantFrameBarracks = _this.iLoader.getImage(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.HOUSE.name); //this.draw.image(startX + 18, startY, 16, 16, "barracks", 1);
        helper.clearRect(0, 0, window.innerWidth, window.innerHeight);
        helper.drawImage(peasantFrameBarracks, 0, 192, 128, 192, 0, 0, 32, 48);
        var imageDataBarracks = _classPrivateFieldGet(_imageConverter, _this).toDataURL();
        var barracksImage = new Image(32, 48);
        barracksImage.src = imageDataBarracks;
        barracksImage.id = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.BARRACKS.name;
        _classPrivateFieldGet(_buildItems, _this).appendChild(houseImage);
        _classPrivateFieldGet(_buildItems, _this).appendChild(barracksImage);
      } else if (unit instanceof _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitKnight) {
        _classPrivateFieldGet(_selectedItemText, _this).innerText = "Knight";
      }
    });
    _classPrivateFieldInitSpec(_this, _configureBuildingUI, function (building) {
      while (_classPrivateFieldGet(_buildItems, _this).lastChild) {
        _classPrivateFieldGet(_buildItems, _this).removeChild(_classPrivateFieldGet(_buildItems, _this).lastChild);
      }
      if (building.key === _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.TOWN_CENTER.name) {
        _classPrivateFieldGet(_selectedItemText, _this).innerText = "TownCenter: ";
        var peasantImage = _this.iLoader.getImage(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.PEASANT.name);
        var helper = _classPrivateFieldGet(_imageConverter, _this).getContext("2d");
        _classPrivateFieldGet(_imageConverter, _this).width = 32;
        _classPrivateFieldGet(_imageConverter, _this).height = 32;
        helper.clearRect(0, 0, window.innerWidth, window.innerHeight);
        helper.drawImage(peasantImage, 66, 66, 60, 60, 0, 0, 32, 32);
        var peasantData = _classPrivateFieldGet(_imageConverter, _this).toDataURL();
        var peasantImageHTML = new Image(32, 32);
        peasantImageHTML.src = peasantData;
        peasantImageHTML.id = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.PEASANT.name;
        _classPrivateFieldGet(_buildItems, _this).appendChild(peasantImageHTML);
      }
    });
    _classPrivateFieldInitSpec(_this, _clickedBuildPeasant, function (e) {
      console.log("clicked build peasant");
      console.log(e);
    });
    _classPrivateFieldInitSpec(_this, _render, function () {
      var crossLen = _classPrivateFieldGet(_crossArr, _this).length;
      for (var index = 0; index < crossLen; index++) {
        var cross = _classPrivateFieldGet(_crossArr, _this)[index];
        if (cross.imageIndex === 45) {
          _classPrivateFieldGet(_crossArr, _this).splice(index, 1);
          index--;
          crossLen--;
        }
      }
      var pUnitsLen = _classPrivateFieldGet(_playerUnits, _this).length;
      for (var _index = 0; _index < pUnitsLen; _index++) {
        var unit = _classPrivateFieldGet(_playerUnits, _this)[_index];
        if (unit.isRemoved) {
          _classPrivateFieldGet(_playerUnits, _this).splice(_index, 1);
          _index--;
          pUnitsLen--;
          continue;
        }
        if (unit instanceof _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitPeasant) {
          var action = unit.activeAction;
          switch (action) {
            case _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ACTIONS.MOVE:
              // check for obstacles
              unit.stepMove();
              break;
            case _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ACTIONS.DRAG_GOLD:
              unit.grabGold();
              break;
            case _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ACTIONS.DRAG_WOOD:
              unit.dragWood();
              break;
            case _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ACTIONS.CHOP_WOOD:
              _this.chopTreeSound.play();
              unit.chopTree();
              break;
            case _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ACTIONS.BUILD:
              if (countDistance(unit, {
                x: unit.targetPoint[0],
                y: unit.targetPoint[1]
              }) < 5) {
                console.log('start building here');
                // to avoid duplicate call, check isSelected prop
                // remove peasant
                unit.stopRepeatedAnimation(unit.activeAnimation);
                unit.destroy();
                // remove from array
                _classPrivateFieldGet(_playerUnits, _this).splice(_index, 1);
                var type = unit.buildingType;
                var startIndex = 1,
                  imageType = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.HOUSE.name;
                switch (type) {
                  case _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.HOUSE.name:
                    startIndex = 1;
                    break;
                  case _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.BARRACKS.name:
                    startIndex = 4;
                    imageType = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.HOUSE.name;
                    break;
                }
                var _unit$targetPoint = _slicedToArray(unit.targetPoint, 2),
                  x = _unit$targetPoint[0],
                  y = _unit$targetPoint[1];
                var newBuilding = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitBuilding(x + 60, y + 96, 128, 192, imageType, startIndex, _this.draw, _this.iSystem.systemSettings.gameOptions.showLifeLines, _this.eventsAggregator);
                _classPrivateFieldGet(_playerBuildings, _this).push(newBuilding);
                _this.addRenderObject(newBuilding);
              } else {
                unit.stepMove();
              }
              break;
            case _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ACTIONS.IDLE:
              break;
          }
        }
        if (unit instanceof _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitKnight) {
          var _action = unit.activeAction;
          switch (_action) {
            case _const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ACTIONS.MOVE:
              // check for obstacles
              var collisionUnits = _this.isObjectsCollision(unit.x, unit.y, unit, _classPrivateFieldGet(_enemyUnits, _this)),
                collisionBuildings = _this.isObjectsCollision(unit.x, unit.y, unit, _classPrivateFieldGet(_enemyBuildings, _this));
              if (collisionUnits) {
                var minDist = void 0,
                  closeEnemy = void 0;
                if (collisionUnits.length > 1) {
                  var len = collisionUnits.length;
                  for (var _index2 = 0; _index2 < len; _index2++) {
                    var enemy = collisionUnits[_index2],
                      dist = countDistance(unit, enemy);
                    if (!minDist || minDist > dist) {
                      minDist = dist;
                      closeEnemy = enemy;
                    }
                  }
                } else {
                  closeEnemy = collisionUnits[0];
                }
                //console.log("closest enemy:", closeEnemy);
                unit.activateAttack(closeEnemy);
              } else if (collisionBuildings) {
                var _minDist = void 0,
                  _closeEnemy = void 0;
                if (collisionBuildings.length > 1) {
                  var _len2 = collisionBuildings.length;
                  for (var _index3 = 0; _index3 < _len2; _index3++) {
                    var _enemy = collisionBuildings[_index3],
                      _dist = countDistance(unit, _enemy);
                    if (!_minDist || _minDist > _dist) {
                      _minDist = _dist;
                      _closeEnemy = _enemy;
                    }
                  }
                } else {
                  _closeEnemy = collisionBuildings[0];
                }
                //console.log("closest enemy:", closeEnemy);
                unit.activateAttack(_closeEnemy);
              } else {
                var _unit$countNextStep = unit.countNextStep(),
                  _x = _unit$countNextStep.x,
                  _y = _unit$countNextStep.y;
                if (_this.isBoundariesCollision(_x, _y, unit)) {
                  unit.activateIdle();
                } else {
                  unit.stepMove(_x, _y);
                }
              }
              break;
            case _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ACTIONS.IDLE:
              break;
          }
        }
      }
      var eUnitsLen = _classPrivateFieldGet(_enemyUnits, _this).length;
      for (var _index4 = 0; _index4 < eUnitsLen; _index4++) {
        var _unit = _classPrivateFieldGet(_enemyUnits, _this)[_index4];
        if (_unit.isRemoved) {
          _classPrivateFieldGet(_enemyUnits, _this).splice(_index4, 1);
          _index4--;
          eUnitsLen--;
          continue;
        }
        if (_unit instanceof _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitGoblinTorch) {
          var isCollisionUnit = _this.isObjectsCollision(_unit.x, _unit.y, _unit, _classPrivateFieldGet(_playerUnits, _this)),
            isCollisionBuilding = _this.isObjectsCollision(_unit.x, _unit.y, _unit, _classPrivateFieldGet(_playerBuildings, _this));
          if (isCollisionUnit) {
            var _len3 = _classPrivateFieldGet(_playerUnits, _this).length;
            var _minDist2 = void 0,
              _closeEnemy2 = void 0;
            for (var _index5 = 0; _index5 < _len3; _index5++) {
              var _enemy2 = _classPrivateFieldGet(_playerUnits, _this)[_index5],
                _dist2 = countDistance(_unit, _enemy2);
              if (!_minDist2 || _minDist2 > _dist2) {
                _minDist2 = _dist2;
                _closeEnemy2 = _enemy2;
              }
            }
            //console.log("closest enemy:", closeEnemy);
            _unit.activateAttack(_closeEnemy2);
          }
        }
      }
      var eBuildingsLen = _classPrivateFieldGet(_enemyBuildings, _this).length;
      for (var _index6 = 0; _index6 < eBuildingsLen; _index6++) {
        var _unit2 = _classPrivateFieldGet(_enemyBuildings, _this)[_index6];
        if (_unit2.isRemoved) {
          _classPrivateFieldGet(_enemyBuildings, _this).splice(_index6, 1);
          _index6--;
          eBuildingsLen--;
          continue;
        }
      }
      if (eUnitsLen === 0 && eBuildingsLen === 0 && _classPrivateFieldGet(_isWin, _this) === false) {
        _classPrivateFieldGet(_activateVictory, _this).call(_this);
      }
    });
    _classPrivateFieldInitSpec(_this, _createGoldBag, function (e) {
      var peasantId = e.detail.peasantId,
        peasant = _classPrivateFieldGet(_playerUnits, _this).find(function (unit) {
          return unit.id === peasantId;
        });
      var goldBag = _this.draw.gold(peasant.x, peasant.y);
      goldBag.sortIndex = 1;
      peasant.addGoldBag(goldBag);
    });
    _classPrivateFieldInitSpec(_this, _createWoodBunch, function (e) {
      console.log("create wood");
      var peasantId = e.detail.peasantId,
        peasant = _classPrivateFieldGet(_playerUnits, _this).find(function (unit) {
          return unit.id === peasantId;
        });
      var woodBunch = _this.draw.wood(peasant.x, peasant.y);
      woodBunch.sortIndex = 1;
      peasant.addWoodBunch(woodBunch);
    });
    _classPrivateFieldInitSpec(_this, _goldMined, function (e) {
      var amount = e.detail;
      _classPrivateFieldSet(_playerGold, _this, _classPrivateFieldGet(_playerGold, _this) + 10);
      _classPrivateFieldGet(_playerGoldCounter, _this).innerText = _classPrivateFieldGet(_playerGold, _this);
    });
    _classPrivateFieldInitSpec(_this, _woodMined, function (e) {
      var amount = e.detail.amount;
      _classPrivateFieldSet(_playerWood, _this, _classPrivateFieldGet(_playerWood, _this) + amount);
      _classPrivateFieldGet(_playerWoodCounter, _this).innerText = _classPrivateFieldGet(_playerWood, _this);
    });
    _classPrivateFieldInitSpec(_this, _goldMineEmpty, function (e) {
      _this.goldMine1.imageIndex = 10;
    });
    _classPrivateFieldInitSpec(_this, _requestForClosestTree, function (e) {
      var peasant = e.detail.peasant,
        oldTreeIndex = e.detail.tree.index,
        tressLayer = _classPrivateFieldGet(_treesLayer, _this).layerData.data,
        layerWidth = _classPrivateFieldGet(_treesLayer, _this).layerData.width,
        layerHeight = _classPrivateFieldGet(_treesLayer, _this).layerData.height,
        layerSize = layerWidth * layerHeight,
        nearestCellsIndexes = [],
        tilewidth = _classPrivateFieldGet(_treesLayer, _this).tilemap.tilewidth,
        tileheight = _classPrivateFieldGet(_treesLayer, _this).tilemap.tileheight; // -5; +5 on width and height

      for (var i = -5; i <= 5; i++) {
        var startItemIndex = oldTreeIndex + i * _classPrivateFieldGet(_treesLayer, _this).layerData.height; // *100

        var rowIndex = Math.floor(startItemIndex / _classPrivateFieldGet(_treesLayer, _this).layerData.height);
        if (startItemIndex >= 0 && startItemIndex <= layerSize) {
          // remove top and bottom indexes overflow
          for (var k = -5; k <= 5; k++) {
            var itemIndex = startItemIndex + k,
              colIndex = itemIndex - rowIndex * _classPrivateFieldGet(_treesLayer, _this).layerData.height;
            if (itemIndex >= 0 && colIndex >= 0 && colIndex <= layerWidth) {
              // remove left and right indexes overflow
              nearestCellsIndexes.push([rowIndex, colIndex, itemIndex]);
            }
          }
        }
      }
      var closestTree, closestDistance;
      nearestCellsIndexes.forEach(function (indexes) {
        var rowIndex = indexes[0],
          colIndex = indexes[1],
          itemIndex = indexes[2],
          cellItem = tressLayer[itemIndex];
        if (cellItem !== 0 && cellItem !== _const_js__WEBPACK_IMPORTED_MODULE_1__.TREE_STUB_INDEX) {
          console.log("item x: ", colIndex);
          console.log("item y: ", rowIndex);
          var cellItemPosX = colIndex * tilewidth + tilewidth / 2,
            cellItemPosY = rowIndex * tileheight + tileheight / 2,
            distance = countDistance({
              x: peasant.x,
              y: peasant.y
            }, {
              x: cellItemPosX,
              y: cellItemPosY
            });
          //console.log("distance: ", distance);
          //console.log("closest distance: ", closestDistance);
          if (!closestDistance || closestDistance > distance) {
            closestTree = _classPrivateFieldGet(_treesCutHealth, _this).get(itemIndex);
            if (!closestTree) {
              closestTree = new Tree(cellItemPosX, cellItemPosY, _const_js__WEBPACK_IMPORTED_MODULE_1__.TREE_FULL_HEALTH, itemIndex);
              _classPrivateFieldGet(_treesCutHealth, _this).set(itemIndex, closestTree);
            }
            //console.log("set closest distance: ", distance);
            //console.log("tree: ", closestTree);
            closestDistance = distance;
          }
        }
      });
      //console.log("old tree is ", oldTreeIndex);
      //console.log("closest tree is ", closestTree.index);
      if (closestDistance) {
        _classPrivateFieldGet(_treesCutHealth, _this).set(closestTree.index, closestTree);
        var playerUnit = _classPrivateFieldGet(_playerUnits, _this).find(function (unit) {
          return unit.id === peasant.id;
        });
        playerUnit.activateDragTree(closestTree);
      }
    });
    _defineProperty(_this, "recursiveSearchForClosestTree", function () {});
    _classPrivateFieldInitSpec(_this, _treeEmpty, function (e) {
      var treeIndex = e.detail.index;
      _classPrivateFieldGet(_treesCutHealth, _this)["delete"](treeIndex);
      _classPrivateFieldGet(_treesLayer, _this).layerData.data[treeIndex] = _const_js__WEBPACK_IMPORTED_MODULE_1__.TREE_STUB_INDEX;
    });
    _classPrivateFieldInitSpec(_this, _peasantBuilt, function (e) {
      var townCenter = e.detail,
        newPeasant = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitPeasant(0, 0, townCenter, _this.draw, _this.iSystem.systemSettings.gameOptions.showLifeLines, _this.eventsAggregator);
      var posX = 80,
        posY = 120;
      while (_this.isObjectsCollision(townCenter.x + posX, townCenter.y + posY, newPeasant, _classPrivateFieldGet(_playerUnits, _this))) {
        posX -= 18;
        console.log("collision shift left");
      }
      //console.log("no collision adding unit");
      newPeasant.x = townCenter.x + posX;
      newPeasant.y = townCenter.y + posY;
      _this.addRenderObject(newPeasant);
      _classPrivateFieldGet(_playerUnits, _this).push(newPeasant);
      _classPrivateFieldGet(_playerPeopleLimitCounter, _this).innerText = _classPrivateFieldGet(_playerUnits, _this).length + "/" + _classPrivateFieldGet(_playerPeopleLimit, _this).toString();
    });
    _classPrivateFieldInitSpec(_this, _buildingDone, function (e) {
      var house = e.detail,
        newPeasant = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitPeasant(0, 0, house, _this.draw, _this.iSystem.systemSettings.gameOptions.showLifeLines, _this.eventsAggregator);
      console.log(e.detail);
      var posX = 20,
        posY = 20;
      while (_this.isObjectsCollision(house.x + posX, house.y + posY, newPeasant, _classPrivateFieldGet(_playerUnits, _this))) {
        posX -= 18;
        console.log("collision shift left");
      }
      newPeasant.x = house.x + posX;
      newPeasant.y = house.y + posY;
      _this.addRenderObject(newPeasant);
      _classPrivateFieldGet(_playerUnits, _this).push(newPeasant);
      var doneIndex = 0;
      switch (house.imageIndex) {
        case 1:
          // house
          break;
        case 4:
          // barracks
          doneIndex = 3;
          break;
      }
      house.imageIndex = doneIndex;
      _classPrivateFieldSet(_playerPeopleLimit, _this, _classPrivateFieldGet(_playerPeopleLimit, _this) + 3);
      _classPrivateFieldGet(_playerPeopleLimitCounter, _this).innerText = _classPrivateFieldGet(_playerUnits, _this).length + "/" + _classPrivateFieldGet(_playerPeopleLimit, _this).toString();
    });
    _defineProperty(_this, "stopAction", function () {
      clearInterval(_this.timer);
      _this.timer = null;
    });
    _defineProperty(_this, "fireAction", function () {
      _this.person.emit("fire");
    });
    _classPrivateFieldInitSpec(_this, _activateVictory, function () {
      _classPrivateFieldSet(_isWin, _this, true);
      _this.iSystem.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.SYSTEM_EVENTS.OPEN_DIALOG, {
        level: 1,
        messageKey: _const_js__WEBPACK_IMPORTED_MODULE_1__.STAGE_TEXTS.STAGE_1.WIN.key,
        title: _const_js__WEBPACK_IMPORTED_MODULE_1__.STAGE_TEXTS.STAGE_1.WIN.title,
        text: _const_js__WEBPACK_IMPORTED_MODULE_1__.STAGE_TEXTS.STAGE_1.WIN.text
      });
    });
    return _this;
  }
  _inherits(Stage1, _GameStage);
  return _createClass(Stage1, [{
    key: "register",
    value: function register() {
      this.iLoader.addTileMap("level1_map", "./assets/level1.tmx");
      this.iLoader.addImage(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.GOLD_MINE.name, "./assets/Tiny Swords (Update 010)/Resources/Gold Mine/GoldMine_Inactive.png");
      this.iLoader.addImage(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.TOWN_CENTER.name, "./assets/Tiny Swords (Update 010)/Factions/Knights/Buildings/Castle/Castle_Blue.png");
      this.iLoader.addImage(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.HOUSE.name, "./assets/house128x192.png");
      this.iLoader.addImage(_const_js__WEBPACK_IMPORTED_MODULE_1__.ATLAS["192x192"], "./assets/tinyswords192x192.png");
      this.iLoader.addImage(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.PEASANT.name, "./assets/Tiny Swords (Update 010)/Factions/Knights/Troops/Pawn/Blue/Pawn_Blue.png");
      this.iLoader.addImage(_const_js__WEBPACK_IMPORTED_MODULE_1__.ATLAS["192Units"], "./assets/Warriors192x192.png");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.AUDIO.WHAT1, "./assets/audio/peasantwhat1.mp3");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.AUDIO.WHAT2, "./assets/audio/peasantwhat2.mp3");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.AUDIO.WHAT3, "./assets/audio/peasantwhat3.mp3");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.WHAT1, "./assets/audio/capitan/CaptainWhat1.wav");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.WHAT2, "./assets/audio/capitan/CaptainWhat2.wav");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.WHAT3, "./assets/audio/capitan/CaptainWhat3.wav");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.YES1, "./assets/audio/capitan/CaptainYes1.wav");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.YES2, "./assets/audio/capitan/CaptainYes2.wav");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.YES3, "./assets/audio/capitan/CaptainYes3.wav");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.ATTACK1, "./assets/audio/capitan/CaptainWarcry1.wav");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.ATTACK2, "./assets/audio/capitan/CaptainYesAttack1.wav");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.FIGHT1, "./assets/audio/AxeMissile1.wav");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.FIGHT2, "./assets/audio/AxeMissile2.wav");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.DEATH1, "./assets/audio/FootmanDeath.wav");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.AUDIO.DEATH1, "./assets/audio/GruntDeath.wav");
      this.iLoader.addAudio("needMoreGold", "./assets/audio/gruntnogold1.mp3");
      this.iLoader.addAudio("needFood", "./assets/audio/upkeepring.mp3");
      this.iLoader.addAudio("chopTree", "./assets/audio/axemediumchopwood2.mp3");
      this.iLoader.addAudio("cantBuildHere", "./assets/audio/peasantcannotbuildthere1.mp3");
      this.timer = null;
      this.eventsAggregator = new EventTarget();
      document.body.style.margin = 0;
    }
  }, {
    key: "init",
    value: function init() {
      var _this$stageData$canva2 = _slicedToArray(this.stageData.canvasDimensions, 2),
        w = _this$stageData$canva2[0],
        h = _this$stageData$canva2[1];
      // x, y, width, height, imageKey
      var water = this.draw.tiledLayer("water", "level1_map", true),
        water_anim = this.draw.tiledLayer("water_a", "level1_map"),
        sand = this.draw.tiledLayer("sand", "level1_map"),
        ground = this.draw.tiledLayer("ground", "level1_map"),
        groundStuff = this.draw.tiledLayer("ground_stuff", "level1_map"),
        boundariesLayer = this.draw.tiledLayer("boundaries_layer", "level1_map", true);
      //	cliff = this.draw.tiledLayer("cliff", "s_map", true),
      //	bridge = this.draw.tiledLayer("bridge", "s_map");

      _classPrivateFieldSet(_treesLayer, this, this.draw.tiledLayer("trees", "level1_map"));
      _classPrivateFieldGet(_treesLayer, this).sortIndex = 4;
      //this.shadowRect = this.draw.rect(0, 0, w, h, "rgba(0, 0, 0, 1)");  
      //this.shadowRect.blendFunc = [WebGLRenderingContext.ONE, WebGLRenderingContext.DST_COLOR];
      //this.shadowRect.turnOffOffset();
      /************* audio ******/
      _classPrivateFieldGet(_attachAudio, this).call(this);
      /***************************** */
      // units
      var knight1 = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitKnight(450, 550, this.draw, this.iSystem.systemSettings.gameOptions.showLifeLines, this.eventsAggregator, this.knightAudio),
        knight2 = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitKnight(480, 610, this.draw, this.iSystem.systemSettings.gameOptions.showLifeLines, this.eventsAggregator, this.knightAudio);

      //const knight1View = this.draw.circle(knight1.x, knight1.y, 300, "rgba(0,0,0,1)"),
      //	knight2View = this.draw.circle(knight2.x, knight2.y, 300, "rgba(0,0,0,1)");

      //this.shadowRect.setMask(knight1View);
      //knight2View._isMask = true;
      //knight1.activateIdle();
      knight2.activateIdle();
      this.addRenderObject(knight1);
      this.addRenderObject(knight2);
      _classPrivateFieldGet(_playerUnits, this).push(knight1);
      _classPrivateFieldGet(_playerUnits, this).push(knight2);
      var goblin1 = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitGoblinTorch(850, 550, this.draw, this.iSystem.systemSettings.gameOptions.showLifeLines, this.eventsAggregator, this.goblinAudio);
      goblin1.activateIdle();
      var goblin2 = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitGoblinTorch(1400, 850, this.draw, this.iSystem.systemSettings.gameOptions.showLifeLines, this.eventsAggregator, this.goblinAudio);
      goblin2.activateIdle();
      this.addRenderObject(goblin1);
      this.addRenderObject(goblin2);
      _classPrivateFieldGet(_enemyUnits, this).push(goblin1);
      _classPrivateFieldGet(_enemyUnits, this).push(goblin2);
      var goblinHouse1 = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitGoblinHouse(650, 1400, this.draw, this.iSystem.systemSettings.gameOptions.showLifeLines),
        goblinHouse2 = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitGoblinHouse(850, 1500, this.draw, this.iSystem.systemSettings.gameOptions.showLifeLines),
        goblinTower = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitGoblinTower(950, 1200, this.draw, this.iSystem.systemSettings.gameOptions.showLifeLines);
      goblinTower.activateIdle();
      this.addRenderObject(goblinHouse1);
      this.addRenderObject(goblinHouse2);
      this.addRenderObject(goblinTower);
      _classPrivateFieldGet(_enemyBuildings, this).push(goblinHouse1);
      _classPrivateFieldGet(_enemyBuildings, this).push(goblinHouse2);
      _classPrivateFieldGet(_enemyBuildings, this).push(goblinTower);
      /*
      const townCenter = new UnitBuilding(600, 600, 320, 256, GAME_UNITS.TOWN_CENTER.name, 0, this.draw, this.eventsAggregator, 1);
      
      this.#playerBuildings.push(townCenter);
      		const peasant1 = new UnitPeasant(800, 580, 192, 192, townCenter, this.draw, this.eventsAggregator),
      	peasant2 = new UnitPeasant(800, 640, 192, 192, townCenter, this.draw, this.eventsAggregator),
      	peasant3 = new UnitPeasant(800, 700, 192, 192, townCenter, this.draw, this.eventsAggregator);
      		this.addRenderObject(townCenter);
      this.addRenderObject(peasant1);
      this.addRenderObject(peasant2);
      this.addRenderObject(peasant3);
      		this.#playerUnits.push(peasant1);
      this.#playerUnits.push(peasant2);
      this.#playerUnits.push(peasant3);
      */
      this.iSystem.addEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.DIALOG_EVENTS.CLOSED, _classPrivateFieldGet(_onDialogClosed, this));
    }
  }, {
    key: "start",
    value: function start() {
      var _this2 = this;
      this.stageData.centerCameraPosition(100, 300);
      _classPrivateFieldGet(_createUserInterface, this).call(this);
      setTimeout(function () {
        var _this2$stageData$canv = _slicedToArray(_this2.stageData.canvasDimensions, 2),
          w = _this2$stageData$canv[0],
          h = _this2$stageData$canv[1];
      }, 100);
      _classPrivateFieldSet(_unitsCount, this, _classPrivateFieldGet(_playerUnits, this).length);
      console.log("level1 started");
    }
  }, {
    key: "stop",
    value: function stop() {
      this.unregisterListeners();
      document.getElementById("sidebar").remove();
    }
  }, {
    key: "registerListeners",
    value: function registerListeners() {
      _assertClassBrand(_Stage1_brand, this, _registerMouseListeners).call(this);
      _assertClassBrand(_Stage1_brand, this, _registerKeyboardListeners).call(this);
      _assertClassBrand(_Stage1_brand, this, _registerSystemEventsListeners).call(this);
    }
  }, {
    key: "unregisterListeners",
    value: function unregisterListeners() {
      _assertClassBrand(_Stage1_brand, this, _unregisterMouseListeners).call(this);
      _assertClassBrand(_Stage1_brand, this, _unregisterKeyboardListeners).call(this);
      _assertClassBrand(_Stage1_brand, this, _unregisterSystemEventsListeners).call(this);
    }
  }, {
    key: "move",
    value: function move(dir) {
      var newX = this.tank.x,
        newY = this.tank.y;
      switch (dir) {
        case "left":
          newX = newX - 1;
          break;
        case "right":
          newX = newX + 1;
          break;
        case "top":
          newY = newY - 1;
          break;
        case "bottom":
          newY = newY + 1;
          break;
      }
      if (!this.isBoundariesCollision(newX, newY, this.tank)) {
        this.tank.x = newX;
        this.tank.y = newY;
        this.gun.x = newX;
        this.gun.y = newY;
        this.stageData.centerCameraPosition(newX, newY);
      }
    }
  }]);
}(jsge__WEBPACK_IMPORTED_MODULE_0__.GameStage);
function _registerKeyboardListeners() {
  document.addEventListener("keydown", _classPrivateFieldGet(_pressKeyAction, this));
  document.addEventListener("keyup", _classPrivateFieldGet(_removeKeyAction, this));
}
function _unregisterKeyboardListeners() {
  document.removeEventListener("keydown", _classPrivateFieldGet(_pressKeyAction, this));
  document.removeEventListener("keyup", _classPrivateFieldGet(_removeKeyAction, this));
}
function _registerMouseListeners() {
  document.addEventListener("mousemove", _classPrivateFieldGet(_mouseMoveAction, this));
  document.addEventListener("click", _classPrivateFieldGet(_mouseClickAction, this));
}
function _unregisterMouseListeners() {
  document.removeEventListener("mousemove", _classPrivateFieldGet(_mouseMoveAction, this));
  document.removeEventListener("click", _classPrivateFieldGet(_mouseClickAction, this));
}
function _isEnoughGold(costGold) {
  var gold = _classPrivateFieldGet(_playerGold, this);
  return costGold <= gold;
}
function _isEnoughWood(costWood) {
  var wood = _classPrivateFieldGet(_playerWood, this);
  return costWood <= wood;
}
function _isEnoughHouses() {
  var units = _classPrivateFieldGet(_playerUnits, this).length,
    maxUnits = _classPrivateFieldGet(_playerPeopleLimit, this);
  return maxUnits > units;
}
function _registerSystemEventsListeners() {
  this.iSystem.addEventListener(jsge__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.SYSTEM.RENDER.START, _classPrivateFieldGet(_render, this));
}
function _unregisterSystemEventsListeners() {
  this.iSystem.removeEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.DIALOG_EVENTS.CLOSED, _classPrivateFieldGet(_onDialogClosed, this));
  this.iSystem.removeEventListener(jsge__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.SYSTEM.RENDER.START, _classPrivateFieldGet(_render, this));
}
var _x2 = /*#__PURE__*/new WeakMap();
var _y2 = /*#__PURE__*/new WeakMap();
var _health = /*#__PURE__*/new WeakMap();
var _index7 = /*#__PURE__*/new WeakMap();
var Tree = /*#__PURE__*/function () {
  function Tree(x, y, treeHealth, index) {
    _classCallCheck(this, Tree);
    _classPrivateFieldInitSpec(this, _x2, void 0);
    _classPrivateFieldInitSpec(this, _y2, void 0);
    _classPrivateFieldInitSpec(this, _health, void 0);
    _classPrivateFieldInitSpec(this, _index7, void 0);
    _classPrivateFieldSet(_x2, this, x);
    _classPrivateFieldSet(_y2, this, y);
    _classPrivateFieldSet(_index7, this, index);
    _classPrivateFieldSet(_health, this, treeHealth);
  }
  return _createClass(Tree, [{
    key: "index",
    get: function get() {
      return _classPrivateFieldGet(_index7, this);
    }
  }, {
    key: "x",
    get: function get() {
      return _classPrivateFieldGet(_x2, this);
    }
  }, {
    key: "y",
    get: function get() {
      return _classPrivateFieldGet(_y2, this);
    }
  }, {
    key: "health",
    get: function get() {
      return _classPrivateFieldGet(_health, this);
    },
    set: function set(value) {
      _classPrivateFieldSet(_health, this, value);
    }
  }]);
}();

/***/ }),

/***/ "./src/stage2.js":
/*!***********************!*\
  !*** ./src/stage2.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Stage2: () => (/* binding */ Stage2)
/* harmony export */ });
/* harmony import */ var jsge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsge */ "./node_modules/jsge/src/index.js");
/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const.js */ "./src/const.js");
/* harmony import */ var _units_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./units.js */ "./src/units.js");
/* harmony import */ var jsge_src_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! jsge/src/utils.js */ "./node_modules/jsge/src/utils.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }






var isPointInsidePolygon = jsge__WEBPACK_IMPORTED_MODULE_0__.utils.isPointInsidePolygon,
  countDistance = jsge__WEBPACK_IMPORTED_MODULE_0__.utils.countDistance,
  randomFromArray = jsge__WEBPACK_IMPORTED_MODULE_0__.utils.randomFromArray;
var _SLOW_SCROLL_POINT = /*#__PURE__*/new WeakMap();
var _QUICK_SCROLL_POINT = /*#__PURE__*/new WeakMap();
var _imageConverter = /*#__PURE__*/new WeakMap();
var _playerGold = /*#__PURE__*/new WeakMap();
var _playerGoldCounter = /*#__PURE__*/new WeakMap();
var _playerWood = /*#__PURE__*/new WeakMap();
var _playerWoodCounter = /*#__PURE__*/new WeakMap();
var _playerPeopleLimit = /*#__PURE__*/new WeakMap();
var _playerPeopleLimitCounter = /*#__PURE__*/new WeakMap();
var _playerUnits = /*#__PURE__*/new WeakMap();
var _playerArrows = /*#__PURE__*/new WeakMap();
var _playerBuildings = /*#__PURE__*/new WeakMap();
var _neutralBuildings = /*#__PURE__*/new WeakMap();
var _enemyUnits = /*#__PURE__*/new WeakMap();
var _enemyBuildings = /*#__PURE__*/new WeakMap();
var _treesLayer = /*#__PURE__*/new WeakMap();
var _treesCutHealth = /*#__PURE__*/new WeakMap();
var _selectedItemText = /*#__PURE__*/new WeakMap();
var _buildItems = /*#__PURE__*/new WeakMap();
var _buildTemplate = /*#__PURE__*/new WeakMap();
var _isBuildPlaceClear = /*#__PURE__*/new WeakMap();
var _buildTemplateOverlap = /*#__PURE__*/new WeakMap();
var _mouseX = /*#__PURE__*/new WeakMap();
var _mouseY = /*#__PURE__*/new WeakMap();
var _unitsCount = /*#__PURE__*/new WeakMap();
var _addUnitPosX = /*#__PURE__*/new WeakMap();
var _isGamePaused = /*#__PURE__*/new WeakMap();
var _firstBattleOrcsLeft = /*#__PURE__*/new WeakMap();
var _showWinFirstBattle = /*#__PURE__*/new WeakMap();
var _crossArr = /*#__PURE__*/new WeakMap();
var _Stage2_brand = /*#__PURE__*/new WeakSet();
var _onDialogClosed = /*#__PURE__*/new WeakMap();
var _createUserInterface = /*#__PURE__*/new WeakMap();
var _pressKeyAction = /*#__PURE__*/new WeakMap();
var _removeKeyAction = /*#__PURE__*/new WeakMap();
var _mouseMoveAction = /*#__PURE__*/new WeakMap();
var _mouseClickAction = /*#__PURE__*/new WeakMap();
var _processNewBuild = /*#__PURE__*/new WeakMap();
var _processImageClick = /*#__PURE__*/new WeakMap();
var _orderToBuildUnit = /*#__PURE__*/new WeakMap();
var _orderToBuildBuilding = /*#__PURE__*/new WeakMap();
var _processMapClick = /*#__PURE__*/new WeakMap();
var _drawCross = /*#__PURE__*/new WeakMap();
var _configureUnitUI = /*#__PURE__*/new WeakMap();
var _configureBuildingUI = /*#__PURE__*/new WeakMap();
var _clickedBuildPeasant = /*#__PURE__*/new WeakMap();
var _createBattle = /*#__PURE__*/new WeakMap();
var _attachAudio = /*#__PURE__*/new WeakMap();
var _render = /*#__PURE__*/new WeakMap();
var _createArrow = /*#__PURE__*/new WeakMap();
var _createGoldBag = /*#__PURE__*/new WeakMap();
var _createWoodBunch = /*#__PURE__*/new WeakMap();
var _goldMined = /*#__PURE__*/new WeakMap();
var _woodMined = /*#__PURE__*/new WeakMap();
var _goldMineEmpty = /*#__PURE__*/new WeakMap();
var _requestForClosestTree = /*#__PURE__*/new WeakMap();
var _treeEmpty = /*#__PURE__*/new WeakMap();
var _peasantBuilt = /*#__PURE__*/new WeakMap();
var _recalculatePeopleLimits = /*#__PURE__*/new WeakMap();
var _buildingDone = /*#__PURE__*/new WeakMap();
var Stage2 = /*#__PURE__*/function (_GameStage) {
  function Stage2() {
    var _this;
    _classCallCheck(this, Stage2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper(this, Stage2, [].concat(args));
    _classPrivateMethodInitSpec(_this, _Stage2_brand);
    _classPrivateFieldInitSpec(_this, _SLOW_SCROLL_POINT, 100);
    _classPrivateFieldInitSpec(_this, _QUICK_SCROLL_POINT, 50);
    _classPrivateFieldInitSpec(_this, _imageConverter, document.createElement("canvas"));
    _classPrivateFieldInitSpec(_this, _playerGold, 0);
    _classPrivateFieldInitSpec(_this, _playerGoldCounter, void 0);
    _classPrivateFieldInitSpec(_this, _playerWood, 0);
    _classPrivateFieldInitSpec(_this, _playerWoodCounter, void 0);
    _classPrivateFieldInitSpec(_this, _playerPeopleLimit, 5);
    // lets say town center increase limit to 5 and house to 3
    _classPrivateFieldInitSpec(_this, _playerPeopleLimitCounter, void 0);
    _classPrivateFieldInitSpec(_this, _playerUnits, []);
    _classPrivateFieldInitSpec(_this, _playerArrows, []);
    _classPrivateFieldInitSpec(_this, _playerBuildings, []);
    _classPrivateFieldInitSpec(_this, _neutralBuildings, []);
    _classPrivateFieldInitSpec(_this, _enemyUnits, []);
    _classPrivateFieldInitSpec(_this, _enemyBuildings, []);
    _classPrivateFieldInitSpec(_this, _treesLayer, void 0);
    _classPrivateFieldInitSpec(_this, _treesCutHealth, new Map());
    _classPrivateFieldInitSpec(_this, _selectedItemText, void 0);
    _classPrivateFieldInitSpec(_this, _buildItems, void 0);
    _classPrivateFieldInitSpec(_this, _buildTemplate, void 0);
    _classPrivateFieldInitSpec(_this, _isBuildPlaceClear, void 0);
    _classPrivateFieldInitSpec(_this, _buildTemplateOverlap, void 0);
    _classPrivateFieldInitSpec(_this, _mouseX, void 0);
    _classPrivateFieldInitSpec(_this, _mouseY, void 0);
    _classPrivateFieldInitSpec(_this, _unitsCount, 0);
    _classPrivateFieldInitSpec(_this, _addUnitPosX, 0);
    _classPrivateFieldInitSpec(_this, _isGamePaused, true);
    _classPrivateFieldInitSpec(_this, _firstBattleOrcsLeft, 15);
    _classPrivateFieldInitSpec(_this, _showWinFirstBattle, false);
    _classPrivateFieldInitSpec(_this, _crossArr, []);
    _classPrivateFieldInitSpec(_this, _onDialogClosed, function (e) {
      var _e$data$ = e.data[0],
        currentLevel = _e$data$.currentLevel,
        currentState = _e$data$.currentState;
      console.log("start level", currentLevel);
      if (currentLevel === 2) {
        if (currentState === _const_js__WEBPACK_IMPORTED_MODULE_1__.STAGE_TEXTS.STAGE_2.START.key) {
          _classPrivateFieldSet(_isGamePaused, _this, false);
          _this.registerListeners();
        } else if (currentState === _const_js__WEBPACK_IMPORTED_MODULE_1__.STAGE_TEXTS.STAGE_2.WIN_1_BATTLE.key) {
          _classPrivateFieldSet(_isGamePaused, _this, false);
          _this.stageData.centerCameraPosition(850, 600);
        }
      }
    });
    _classPrivateFieldInitSpec(_this, _createUserInterface, function () {
      var windowWidth = document.body.offsetWidth,
        sidebar = document.createElement("div");
      sidebar.id = "sidebar";
      sidebar.style.width = windowWidth + "px";
      sidebar.style.height = "48px";
      sidebar.style.padding = "6px";
      sidebar.style.backgroundColor = "#ccc";
      sidebar.style.position = "fixed";
      sidebar.style.top = 0 + "px";
      sidebar.style.left = 0 + "px";
      sidebar.style.display = "flex";
      sidebar.style.fontSize = "1.4rem";
      sidebar.style.fontWeight = "bold";
      document.body.appendChild(sidebar);
      var resourcesInfo = document.createElement("div");
      resourcesInfo.style.display = "flex";
      resourcesInfo.style.flexFlow = "column";
      sidebar.appendChild(resourcesInfo);
      var resourceWrap = document.createElement("div");
      resourceWrap.style.display = "flex";
      var playerGoldCounterText = document.createElement("div");
      playerGoldCounterText.innerText = "Gold: ";
      resourceWrap.appendChild(playerGoldCounterText);
      _classPrivateFieldSet(_playerGoldCounter, _this, document.createElement("div"));
      _classPrivateFieldGet(_playerGoldCounter, _this).innerText = _classPrivateFieldGet(_playerGold, _this).toString();
      _classPrivateFieldGet(_playerGoldCounter, _this).style.marginRight = "6px";
      resourceWrap.appendChild(_classPrivateFieldGet(_playerGoldCounter, _this));
      var playerWoodCounterText = document.createElement("div");
      playerWoodCounterText.innerText = "Wood: ";
      resourceWrap.appendChild(playerWoodCounterText);
      _classPrivateFieldSet(_playerWoodCounter, _this, document.createElement("div"));
      _classPrivateFieldGet(_playerWoodCounter, _this).innerText = _classPrivateFieldGet(_playerWood, _this).toString();
      _classPrivateFieldGet(_playerWoodCounter, _this).style.marginRight = "6px";
      resourceWrap.appendChild(_classPrivateFieldGet(_playerWoodCounter, _this));
      resourcesInfo.appendChild(resourceWrap);
      var playerInfoWrap = document.createElement("div");
      playerInfoWrap.style.display = "flex";
      var playerPeopleCounterText = document.createElement("div");
      playerPeopleCounterText.innerText = "People limits: ";
      playerInfoWrap.appendChild(playerPeopleCounterText);
      _classPrivateFieldSet(_playerPeopleLimitCounter, _this, document.createElement("div"));
      _classPrivateFieldGet(_playerPeopleLimitCounter, _this).innerText = _classPrivateFieldGet(_playerUnits, _this).length + "/" + _classPrivateFieldGet(_playerPeopleLimit, _this).toString();
      playerInfoWrap.appendChild(_classPrivateFieldGet(_playerPeopleLimitCounter, _this));
      resourcesInfo.appendChild(playerInfoWrap);
      var buildMenuContainer = document.createElement("div");
      buildMenuContainer.style.display = "flex";
      buildMenuContainer.style.marginLeft = "30px";
      sidebar.appendChild(buildMenuContainer);
      _classPrivateFieldSet(_selectedItemText, _this, document.createElement("div"));
      _classPrivateFieldGet(_selectedItemText, _this).innerText = "Nothing is selected";
      buildMenuContainer.appendChild(_classPrivateFieldGet(_selectedItemText, _this));
      _classPrivateFieldSet(_buildItems, _this, document.createElement("div"));
      buildMenuContainer.appendChild(_classPrivateFieldGet(_buildItems, _this));
    });
    _classPrivateFieldInitSpec(_this, _pressKeyAction, function (event) {
      var code = event.code;
      console.log("pressed: ", code);
      if (code === "Space") {
        var _this$unitsCount, _this$unitsCount2, _this$unitsCount3, _this$unitsCount4;
        var townCenter = _classPrivateFieldGet(_playerBuildings, _this).find(function (building) {
          return building.key === _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.TOWN_CENTER.name;
        });
        var newPeasant = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitPeasant(0, 0, townCenter, _this.draw, _this.iSystem.systemSettings.gameOptions.showLifeLines, _this.eventsAggregator);
        var newPeasant2 = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitPeasant(0, 0, townCenter, _this.draw, _this.iSystem.systemSettings.gameOptions.showLifeLines, _this.eventsAggregator);
        newPeasant.x = townCenter.x - _classPrivateFieldGet(_addUnitPosX, _this);
        newPeasant.y = townCenter.y;
        newPeasant2.x = townCenter.x - _classPrivateFieldGet(_addUnitPosX, _this);
        newPeasant2.y = townCenter.y - 16;
        _this.addRenderObject(newPeasant);
        _this.addRenderObject(newPeasant2);
        _classPrivateFieldGet(_playerUnits, _this).push(newPeasant);
        _classPrivateFieldGet(_playerUnits, _this).push(newPeasant2);
        _classPrivateFieldSet(_unitsCount, _this, (_this$unitsCount = _classPrivateFieldGet(_unitsCount, _this), _this$unitsCount2 = _this$unitsCount++, _this$unitsCount)), _this$unitsCount2;
        _classPrivateFieldSet(_unitsCount, _this, (_this$unitsCount3 = _classPrivateFieldGet(_unitsCount, _this), _this$unitsCount4 = _this$unitsCount3++, _this$unitsCount3)), _this$unitsCount4;
        newPeasant.activateMoveToTargetPoint(1500, 1500);
        newPeasant2.activateMoveToTargetPoint(1500, 1500);
        console.log("units: ", _classPrivateFieldGet(_unitsCount, _this));
        _classPrivateFieldSet(_addUnitPosX, _this, _classPrivateFieldGet(_addUnitPosX, _this) - 20);
      }
    });
    _classPrivateFieldInitSpec(_this, _removeKeyAction, function (event) {
      var code = event.code;
      if (code === "Space") {
        _classPrivateFieldSet(_addUnitPosX, _this, 0);
      }
    });
    _classPrivateFieldInitSpec(_this, _mouseMoveAction, function (e) {
      if (!_classPrivateFieldGet(_isGamePaused, _this)) {
        var _this$stageData$world = _slicedToArray(_this.stageData.worldOffset, 2),
          xOffset = _this$stageData$world[0],
          yOffset = _this$stageData$world[1],
          x = e.offsetX,
          y = e.offsetY,
          cursorPosX = x + xOffset,
          cursorPosY = y + yOffset,
          _this$stageData$canva = _slicedToArray(_this.stageData.canvasDimensions, 2),
          viewWidth = _this$stageData$canva[0],
          viewHeight = _this$stageData$canva[1],
          xShiftRight = viewWidth - x,
          yShiftBottom = viewHeight - y,
          xShift = viewWidth / 2 + xOffset,
          yShift = viewHeight / 2 + yOffset;
        var newPosX = xShift,
          newPosY = yShift;
        document.getElementsByTagName("canvas")[0].style.cursor = "default";
        if (x < _classPrivateFieldGet(_QUICK_SCROLL_POINT, _this)) {
          //console.log("quick scroll left");
          newPosX = xShift - 20;
          document.getElementsByTagName("canvas")[0].style.cursor = "url('assets/cursor-pack-kenney/Outline/Default/navigation_w.png'), auto";
        } else if (x < _classPrivateFieldGet(_SLOW_SCROLL_POINT, _this)) {
          //console.log("slow scroll left");
          newPosX = xShift - 5;
          document.getElementsByTagName("canvas")[0].style.cursor = "url('assets/cursor-pack-kenney/Outline/Default/navigation_w.png'), auto";
          console.log("sss");
        }
        if (xShiftRight < _classPrivateFieldGet(_QUICK_SCROLL_POINT, _this)) {
          //console.log("quick scroll right");
          newPosX = xShift + 20;
          document.getElementsByTagName("canvas")[0].style.cursor = "url('assets/cursor-pack-kenney/Outline/Default/navigation_e.png'), auto";
        } else if (xShiftRight < _classPrivateFieldGet(_SLOW_SCROLL_POINT, _this)) {
          //console.log("slow scroll right");
          newPosX = xShift + 20;
          document.getElementsByTagName("canvas")[0].style.cursor = "url('assets/cursor-pack-kenney/Outline/Default/navigation_e.png'), auto";
        }
        if (y < _classPrivateFieldGet(_QUICK_SCROLL_POINT, _this)) {
          //console.log("quick scroll up");
          newPosY = yShift - 20;
          document.getElementsByTagName("canvas")[0].style.cursor = "url('assets/cursor-pack-kenney/Outline/Default/navigation_n.png'), auto";
        } else if (y < _classPrivateFieldGet(_SLOW_SCROLL_POINT, _this)) {
          //console.log("slow scroll up");
          newPosY = yShift - 5;
          document.getElementsByTagName("canvas")[0].style.cursor = "url('assets/cursor-pack-kenney/Outline/Default/navigation_n.png'), auto";
        }
        if (yShiftBottom < _classPrivateFieldGet(_QUICK_SCROLL_POINT, _this)) {
          //console.log("quick scroll down");
          newPosY = yShift + 20;
          document.getElementsByTagName("canvas")[0].style.cursor = "url('assets/cursor-pack-kenney/Outline/Default/navigation_s.png'), auto";
        } else if (yShiftBottom < _classPrivateFieldGet(_SLOW_SCROLL_POINT, _this)) {
          //console.log("slow scroll down");
          newPosY = yShift + 5;
          document.getElementsByTagName("canvas")[0].style.cursor = "url('assets/cursor-pack-kenney/Outline/Default/navigation_s.png'), auto";
        }
        _this.stageData.centerCameraPosition(newPosX, newPosY);
        _classPrivateFieldSet(_mouseX, _this, cursorPosX);
        _classPrivateFieldSet(_mouseY, _this, cursorPosY);
        if (_classPrivateFieldGet(_buildTemplate, _this)) {
          _classPrivateFieldGet(_buildTemplate, _this).x = cursorPosX;
          _classPrivateFieldGet(_buildTemplate, _this).y = cursorPosY;
          _classPrivateFieldGet(_buildTemplateOverlap, _this).x = cursorPosX - _classPrivateFieldGet(_buildTemplateOverlap, _this).width / 2;
          _classPrivateFieldGet(_buildTemplateOverlap, _this).y = cursorPosY - _classPrivateFieldGet(_buildTemplateOverlap, _this).height / 2;
          if (_this.isBoundariesCollision(cursorPosX, cursorPosY, _classPrivateFieldGet(_buildTemplateOverlap, _this)) || _this.isObjectsCollision(cursorPosX, cursorPosY, _classPrivateFieldGet(_buildTemplateOverlap, _this), _classPrivateFieldGet(_playerBuildings, _this)) || _this.isObjectsCollision(cursorPosX, cursorPosY, _classPrivateFieldGet(_buildTemplateOverlap, _this), _classPrivateFieldGet(_neutralBuildings, _this))) {
            _classPrivateFieldGet(_buildTemplateOverlap, _this).bgColor = "rgba(224, 12, 21, 0.6)";
            _classPrivateFieldSet(_isBuildPlaceClear, _this, false);
          } else {
            _classPrivateFieldGet(_buildTemplateOverlap, _this).bgColor = "rgba(0, 0, 0, 0.3";
            _classPrivateFieldSet(_isBuildPlaceClear, _this, true);
          }
        }
      }
    });
    _classPrivateFieldInitSpec(_this, _mouseClickAction, function (e) {
      if (!_classPrivateFieldGet(_isGamePaused, _this)) {
        var target = e.target;
        if (target instanceof Image) {
          _classPrivateFieldGet(_processImageClick, _this).call(_this, e);
        } else if (_classPrivateFieldGet(_buildTemplate, _this)) {
          _classPrivateFieldGet(_processNewBuild, _this).call(_this, _classPrivateFieldGet(_buildTemplate, _this)._building_key);
        } else {
          _classPrivateFieldGet(_processMapClick, _this).call(_this, e);
        }
      }
    });
    _classPrivateFieldInitSpec(_this, _processNewBuild, function (key) {
      var cantBuildAudio = _this.iLoader.getAudio("cantBuildHere");
      if (_classPrivateFieldGet(_isBuildPlaceClear, _this)) {
        _classPrivateFieldGet(_playerUnits, _this).forEach(function (unit) {
          if (unit.isSelected) {
            unit.activateStartBuilding(_classPrivateFieldGet(_buildTemplateOverlap, _this).x, _classPrivateFieldGet(_buildTemplateOverlap, _this).y, key);
            if (unit.isSelected) {
              unit.isSelected = false;
            }
            // cleanup build menu
            _classPrivateFieldGet(_selectedItemText, _this).innerText = "";
            while (_classPrivateFieldGet(_buildItems, _this).lastChild) {
              _classPrivateFieldGet(_buildItems, _this).removeChild(_classPrivateFieldGet(_buildItems, _this).lastChild);
            }
            // remove build helpers
            _classPrivateFieldGet(_buildTemplate, _this).destroy();
            _classPrivateFieldGet(_buildTemplateOverlap, _this).destroy();
            _classPrivateFieldSet(_buildTemplate, _this, null);
            _classPrivateFieldSet(_buildTemplateOverlap, _this, null);
          }
        });
      } else {
        cantBuildAudio.play();
      }
    });
    _classPrivateFieldInitSpec(_this, _processImageClick, function (e) {
      var target = e.target,
        type = target.id;
      switch (type) {
        case _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.PEASANT.name:
          _classPrivateFieldGet(_orderToBuildUnit, _this).call(_this, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.PEASANT.name);
          break;
        case _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.HOUSE.name:
          _classPrivateFieldGet(_orderToBuildBuilding, _this).call(_this, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.HOUSE.name);
          break;
        case _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.BARRACKS.name:
          _classPrivateFieldGet(_orderToBuildBuilding, _this).call(_this, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.BARRACKS.name);
          break;
      }
    });
    _classPrivateFieldInitSpec(_this, _orderToBuildUnit, function (type) {
      console.log("order build ", type);
      var costWood = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS[type].cost.w,
        costGold = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS[type].cost.g;
      if (!_assertClassBrand(_Stage2_brand, _this, _isEnoughGold).call(_this, costGold)) {
        console.log("not enough gold");
        _this.iLoader.getAudio("needMoreGold").play();
      } else if (!_assertClassBrand(_Stage2_brand, _this, _isEnoughWood).call(_this, costWood)) {
        console.log("not enough wood");
      } else if (!_assertClassBrand(_Stage2_brand, _this, _isEnoughHouses).call(_this)) {
        _this.iLoader.getAudio("needFood").play();
        console.log("not enough houses");
      } else {
        var townCenter = _classPrivateFieldGet(_playerBuildings, _this).find(function (building) {
          return building.key === _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.TOWN_CENTER.name;
        });
        if (!townCenter.isBuildingUnit) {
          _classPrivateFieldSet(_playerGold, _this, _classPrivateFieldGet(_playerGold, _this) - costGold);
          _classPrivateFieldSet(_playerWood, _this, _classPrivateFieldGet(_playerWood, _this) - costWood);
          townCenter.buildUnit(type);
        } else {
          console.log("already building");
        }
      }
    });
    _classPrivateFieldInitSpec(_this, _orderToBuildBuilding, function (type) {
      console.log("order build ", type);
      var costWood = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS[type].cost.w,
        costGold = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS[type].cost.g;
      if (!_assertClassBrand(_Stage2_brand, _this, _isEnoughGold).call(_this, costGold)) {
        console.log("not enough gold");
        _this.iLoader.getAudio("needMoreGold").play();
      } else if (!_assertClassBrand(_Stage2_brand, _this, _isEnoughWood).call(_this, costWood)) {
        console.log("not enough wood");
      } else {
        _classPrivateFieldSet(_playerGold, _this, _classPrivateFieldGet(_playerGold, _this) - costGold);
        _classPrivateFieldSet(_playerWood, _this, _classPrivateFieldGet(_playerWood, _this) - costWood);
        var imageType = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.HOUSE.name;
        // a small workaround to use image atlas, instead of separate images
        switch (type) {
          case _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.BARRACKS.name:
            imageType = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.HOUSE.name;
            break;
        }
        _classPrivateFieldSet(_buildTemplate, _this, _this.draw.image(_classPrivateFieldGet(_mouseX, _this), _classPrivateFieldGet(_mouseY, _this), 128, 192, imageType, 9));
        _classPrivateFieldGet(_buildTemplate, _this)._building_key = type;
        _classPrivateFieldSet(_buildTemplateOverlap, _this, _this.draw.rect(_classPrivateFieldGet(_mouseX, _this) - 8, _classPrivateFieldGet(_mouseY, _this) - 8, 128, 192, "rgba(0, 0, 0, 0.3"));
        _classPrivateFieldSet(_isBuildPlaceClear, _this, false);
      }
    });
    _classPrivateFieldInitSpec(_this, _processMapClick, function (e) {
      var selectPlayerUnit = null,
        isTreeSelected = false,
        selectedNeutralBuilding = null,
        _this$stageData$world2 = _slicedToArray(_this.stageData.worldOffset, 2),
        offsetX = _this$stageData$world2[0],
        offsetY = _this$stageData$world2[1],
        clickXWithOffset = e.offsetX + offsetX,
        clickYWithOffset = e.offsetY + offsetY;
      _classPrivateFieldGet(_playerUnits, _this).forEach(function (unit) {
        if (isPointInsidePolygon(clickXWithOffset - unit.x, clickYWithOffset - unit.y, unit.boundaries)) {
          _classPrivateFieldGet(_playerUnits, _this).forEach(function (unit) {
            console.log(unit.isSelected);
            if (unit.isSelected) {
              console.log("deselect");
              unit.isSelected = false;
            }
          });
          _classPrivateFieldGet(_playerBuildings, _this).forEach(function (unit) {
            if (unit.isSelected) {
              unit.isSelected = false;
            }
          });
          selectPlayerUnit = unit;
          selectPlayerUnit.isSelected = true;
          _classPrivateFieldGet(_configureUnitUI, _this).call(_this, unit);
          unit.activateIdle(true);
        }
      });
      if (selectPlayerUnit && selectPlayerUnit.isSelected === true) {
        return;
      }
      _classPrivateFieldGet(_playerBuildings, _this).forEach(function (building) {
        if (isPointInsidePolygon(clickXWithOffset - building.x, clickYWithOffset - building.y, building.boundaries)) {
          _classPrivateFieldGet(_playerUnits, _this).forEach(function (unit) {
            if (unit.isSelected) {
              unit.isSelected = false;
            }
          });
          _classPrivateFieldGet(_playerBuildings, _this).forEach(function (unit) {
            if (unit.isSelected) {
              unit.isSelected = false;
            }
          });
          selectPlayerUnit = building;
          selectPlayerUnit.isSelected = true;
          _classPrivateFieldGet(_configureBuildingUI, _this).call(_this, building);
        }
      });
      _classPrivateFieldGet(_neutralBuildings, _this).forEach(function (unit) {
        if (isPointInsidePolygon(clickXWithOffset - unit.x, clickYWithOffset - unit.y, unit.boundaries)) {
          console.log("clicked gold mine: ", unit);
          console.log("gold amount: ", unit.goldAmount);
          selectedNeutralBuilding = unit;
        }
      });
      var xCell = Math.floor(clickXWithOffset / _classPrivateFieldGet(_treesLayer, _this).tilemap.tilewidth),
        yCell = Math.floor(clickYWithOffset / _classPrivateFieldGet(_treesLayer, _this).tilemap.tileheight),
        clickedCellIndex = _classPrivateFieldGet(_treesLayer, _this).layerData.height * yCell + xCell,
        clickedCellTile = _classPrivateFieldGet(_treesLayer, _this).layerData.data[clickedCellIndex];
      console.log("x cell: ", xCell);
      console.log("y cell: ", yCell);
      if (clickedCellTile !== 0 && clickedCellTile !== _const_js__WEBPACK_IMPORTED_MODULE_1__.TREE_STUB_INDEX) {
        console.log(clickedCellIndex);
        console.log("tree cell clicked");
        isTreeSelected = true;
      }

      // if no new units selected, move selected units to click point
      if (!selectPlayerUnit) {
        _classPrivateFieldGet(_playerUnits, _this).forEach(function (unit) {
          if (unit.isSelected) {
            if (unit instanceof _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitPeasant) {
              if (selectedNeutralBuilding) {
                console.log("do something with building: ", selectedNeutralBuilding);
                if (selectedNeutralBuilding.key === _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.GOLD_MINE.name && unit instanceof _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitPeasant) {
                  unit.activateGrabGold(selectedNeutralBuilding);
                }
              } else if (isTreeSelected) {
                console.log("go, and cut tree");
                var tree = _classPrivateFieldGet(_treesCutHealth, _this).get(clickedCellIndex);
                if (!tree) {
                  tree = new Tree(clickXWithOffset, clickYWithOffset, _const_js__WEBPACK_IMPORTED_MODULE_1__.TREE_FULL_HEALTH, clickedCellIndex);
                  _classPrivateFieldGet(_treesCutHealth, _this).set(clickedCellIndex, tree);
                }
                unit.activateDragTree(tree);
              } else {
                unit.activateMoveToTargetPoint(clickXWithOffset, clickYWithOffset, true);
                _classPrivateFieldGet(_drawCross, _this).call(_this, clickXWithOffset, clickYWithOffset);
              }
            } else if (unit instanceof _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitKnight || unit instanceof _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitArcher) {
              unit.activateMoveToTargetPoint(clickXWithOffset, clickYWithOffset, true);
              _classPrivateFieldGet(_drawCross, _this).call(_this, clickXWithOffset, clickYWithOffset);
            }
          }
        });
      }
    });
    _classPrivateFieldInitSpec(_this, _drawCross, function (x, y) {
      var cross = _this.draw.image(x, y, 64, 64, _const_js__WEBPACK_IMPORTED_MODULE_1__.ATLAS["64x64"], 42);
      cross.addAnimation("markMoveT", [42, 43, 44, 45], false);
      cross.emit("markMoveT");
      _classPrivateFieldGet(_crossArr, _this).push(cross);
    });
    _classPrivateFieldInitSpec(_this, _configureUnitUI, function (unit) {
      while (_classPrivateFieldGet(_buildItems, _this).lastChild) {
        _classPrivateFieldGet(_buildItems, _this).removeChild(_classPrivateFieldGet(_buildItems, _this).lastChild);
      }
      if (unit instanceof _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitPeasant) {
        _classPrivateFieldGet(_selectedItemText, _this).innerText = "Peasant: ";
        var peasantFrameHouse = _this.iLoader.getImage(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.HOUSE.name); //this.draw.image(startX, startY, 16, 16, "houses", randomFromArray([9, 10, 11]));
        var helper = _classPrivateFieldGet(_imageConverter, _this).getContext("2d");
        _classPrivateFieldGet(_imageConverter, _this).width = 32;
        _classPrivateFieldGet(_imageConverter, _this).height = 48;
        helper.clearRect(0, 0, window.innerWidth, window.innerHeight);
        helper.drawImage(peasantFrameHouse, 0, 0, 128, 192, 0, 0, 32, 48);
        var imageDataHouse = _classPrivateFieldGet(_imageConverter, _this).toDataURL();
        var houseImage = new Image(32, 48);
        houseImage.src = imageDataHouse;
        houseImage.id = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.HOUSE.name;
        var peasantFrameBarracks = _this.iLoader.getImage(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.HOUSE.name); //this.draw.image(startX + 18, startY, 16, 16, "barracks", 1);
        helper.clearRect(0, 0, window.innerWidth, window.innerHeight);
        helper.drawImage(peasantFrameBarracks, 0, 192, 128, 192, 0, 0, 32, 48);
        var imageDataBarracks = _classPrivateFieldGet(_imageConverter, _this).toDataURL();
        var barracksImage = new Image(32, 48);
        barracksImage.src = imageDataBarracks;
        barracksImage.id = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.BARRACKS.name;
        _classPrivateFieldGet(_buildItems, _this).appendChild(houseImage);
        _classPrivateFieldGet(_buildItems, _this).appendChild(barracksImage);
      } else if (unit instanceof _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitKnight) {
        _classPrivateFieldGet(_selectedItemText, _this).innerText = "Knight";
      }
    });
    _classPrivateFieldInitSpec(_this, _configureBuildingUI, function (building) {
      while (_classPrivateFieldGet(_buildItems, _this).lastChild) {
        _classPrivateFieldGet(_buildItems, _this).removeChild(_classPrivateFieldGet(_buildItems, _this).lastChild);
      }
      if (building.key === _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.TOWN_CENTER.name) {
        _classPrivateFieldGet(_selectedItemText, _this).innerText = "TownCenter: ";
        var peasantImage = _this.iLoader.getImage(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.PEASANT.name);
        var helper = _classPrivateFieldGet(_imageConverter, _this).getContext("2d");
        _classPrivateFieldGet(_imageConverter, _this).width = 32;
        _classPrivateFieldGet(_imageConverter, _this).height = 32;
        helper.clearRect(0, 0, window.innerWidth, window.innerHeight);
        helper.drawImage(peasantImage, 66, 66, 60, 60, 0, 0, 32, 32);
        var peasantData = _classPrivateFieldGet(_imageConverter, _this).toDataURL();
        var peasantImageHTML = new Image(32, 32);
        peasantImageHTML.src = peasantData;
        peasantImageHTML.id = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.PEASANT.name;
        _classPrivateFieldGet(_buildItems, _this).appendChild(peasantImageHTML);
      }
    });
    _classPrivateFieldInitSpec(_this, _clickedBuildPeasant, function (e) {
      console.log("clicked build peasant");
      console.log(e);
    });
    _classPrivateFieldInitSpec(_this, _createBattle, function () {
      var pUnits = _classPrivateFieldGet(_playerUnits, _this),
        eUnits = _classPrivateFieldGet(_enemyUnits, _this);
      var startX = 550,
        startY = 1250;
      for (var i = 0; i < 4; ++i) {
        var unitArcher = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitArcher(startX, startY, _this.draw, _this.iSystem.systemSettings.gameOptions.showLifeLines, _this.eventsAggregator, _this.knightAudio);
        unitArcher.activateIdle();
        _this.addRenderObject(unitArcher);
        pUnits.push(unitArcher);
        startX += 60;
      }
      startX = 550, startY = 1400;
      for (var _i = 0; _i < 5; ++_i) {
        var unitKnight = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitKnight(startX, startY, _this.draw, _this.iSystem.systemSettings.gameOptions.showLifeLines, _this.eventsAggregator, _this.knightAudio),
          unitGoblinTorch = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitGoblinTorch(startX, startY + 100, _this.draw, _this.iSystem.systemSettings.gameOptions.showLifeLines, _this.eventsAggregator, _this.goblinAudio);
        unitKnight.activateIdle();
        unitGoblinTorch.activateIdle();
        _this.addRenderObject(unitKnight);
        _this.addRenderObject(unitGoblinTorch);
        pUnits.push(unitKnight);
        eUnits.push(unitGoblinTorch);
        startX += 60;
      }
      for (var _i2 = 0; _i2 < 2; ++_i2) {
        var _unitGoblinTorch = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitGoblinTorch(startX, startY + 100, _this.draw, _this.iSystem.systemSettings.gameOptions.showLifeLines, _this.eventsAggregator, _this.goblinAudio);
        _unitGoblinTorch.activateIdle();
        _this.addRenderObject(_unitGoblinTorch);
        eUnits.push(_unitGoblinTorch);
        startX += 60;
      }
      startX = 550;
      startY += 60;
      for (var _i3 = 0; _i3 < 8; ++_i3) {
        var _unitGoblinTorch2 = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitGoblinTorch(startX, startY + 100, _this.draw, _this.iSystem.systemSettings.gameOptions.showLifeLines, _this.eventsAggregator, _this.goblinAudio);
        _unitGoblinTorch2.activateIdle();
        _this.addRenderObject(_unitGoblinTorch2);
        eUnits.push(_unitGoblinTorch2);
        startX += 60;
      }
    });
    _classPrivateFieldInitSpec(_this, _attachAudio, function () {
      _this.chopTreeSound = _this.iLoader.getAudio("chopTree");
      _this.knightAudio = new Map();
      _this.knightAudio.set(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.YES, [_this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.YES1), _this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.YES2), _this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.YES3)]);
      _this.knightAudio.set(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.WHAT, [_this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.WHAT1), _this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.WHAT2), _this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.WHAT3)]);
      _this.knightAudio.set(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.ATTACK, [_this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.ATTACK1), _this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.ATTACK2)]);
      _this.knightAudio.set(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.FIGHT, [_this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.FIGHT1), _this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.FIGHT2)]);
      _this.knightAudio.set(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.DEATH, [_this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.DEATH1)]);
      _this.peasantAudio = new Map();
      _this.peasantAudio.set(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.WHAT, [_this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.AUDIO.WHAT1), _this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.AUDIO.WHAT2), _this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.AUDIO.WHAT3)]);
      _this.goblinAudio = new Map();
      _this.goblinAudio.set(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.DEATH, [_this.iLoader.getAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.AUDIO.DEATH1)]);
    });
    _classPrivateFieldInitSpec(_this, _render, function () {
      var crossLen = _classPrivateFieldGet(_crossArr, _this).length;
      for (var index = 0; index < crossLen; index++) {
        var cross = _classPrivateFieldGet(_crossArr, _this)[index];
        if (cross.imageIndex === 45) {
          _classPrivateFieldGet(_crossArr, _this).splice(index, 1);
          index--;
          crossLen--;
        }
      }
      var pArrows = _classPrivateFieldGet(_playerArrows, _this),
        paLen = pArrows.length;
      for (var _index = 0; _index < paLen; _index++) {
        var arrow = _classPrivateFieldGet(_playerArrows, _this)[_index];
        var forceToUse = 1.5,
          //this.#moveSpeed,
          newCoordX = arrow.x + forceToUse * Math.cos(arrow.rotation),
          newCoordY = arrow.y + forceToUse * Math.sin(arrow.rotation);
        var collisionUnits = _this.isObjectsCollision(arrow.x, arrow.y, arrow, _classPrivateFieldGet(_enemyUnits, _this)),
          collisionBuildings = _this.isObjectsCollision(arrow.x, arrow.y, arrow, _classPrivateFieldGet(_enemyBuildings, _this));
        if (collisionUnits) {
          var minDist = void 0,
            closeEnemy = void 0;
          if (collisionUnits.length > 1) {
            var len = collisionUnits.length;
            for (var _index2 = 0; _index2 < len; _index2++) {
              var enemy = collisionUnits[_index2],
                dist = countDistance(arrow, enemy);
              if (!minDist || minDist > dist) {
                minDist = dist;
                closeEnemy = enemy;
              }
            }
          } else {
            closeEnemy = collisionUnits[0];
          }
          closeEnemy.reduceHealth(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.ARCHER.attackDamage);
          if (closeEnemy.health <= 0 && closeEnemy.isRemoved === false) {
            closeEnemy.die();
          }
          arrow.destroy();
          _classPrivateFieldGet(_playerArrows, _this).splice(_index, 1);
          _index--;
          paLen--;
          continue;
        } else if (countDistance({
          x: newCoordX,
          y: newCoordY
        }, {
          x: arrow.tX,
          y: arrow.tY
        }) <= 10) {
          arrow.destroy();
          _classPrivateFieldGet(_playerArrows, _this).splice(_index, 1);
          _index--;
          paLen--;
          continue;
        }
        arrow.x = newCoordX;
        arrow.y = newCoordY;
      }
      var pUnitsLen = _classPrivateFieldGet(_playerUnits, _this).length;
      for (var _index3 = 0; _index3 < pUnitsLen; _index3++) {
        var unit = _classPrivateFieldGet(_playerUnits, _this)[_index3];
        if (unit.isRemoved) {
          _classPrivateFieldGet(_playerUnits, _this).splice(_index3, 1);
          _index3--;
          pUnitsLen--;
          _classPrivateFieldGet(_recalculatePeopleLimits, _this).call(_this);
          continue;
        }
        if (unit instanceof _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitPeasant) {
          var action = unit.activeAction;
          switch (action) {
            case _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ACTIONS.MOVE:
              // check for obstacles
              unit.stepMove();
              break;
            case _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ACTIONS.DRAG_GOLD:
              unit.grabGold();
              break;
            case _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ACTIONS.DRAG_WOOD:
              unit.dragWood();
              break;
            case _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ACTIONS.CHOP_WOOD:
              _this.chopTreeSound.play();
              unit.chopTree();
              break;
            case _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ACTIONS.BUILD:
              if (countDistance(unit, {
                x: unit.targetPoint[0],
                y: unit.targetPoint[1]
              }) < 5) {
                console.log('start building here');
                // to avoid duplicate call, check isSelected prop
                // remove peasant
                unit.stopRepeatedAnimation(unit.activeAnimation);
                unit.destroy();
                // remove from array
                _classPrivateFieldGet(_playerUnits, _this).splice(_index3, 1);
                var type = unit.buildingType;
                var startIndex = 1,
                  imageType = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.HOUSE.name;
                switch (type) {
                  case _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.HOUSE.name:
                    startIndex = 1;
                    break;
                  case _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.BARRACKS.name:
                    startIndex = 4;
                    imageType = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.HOUSE.name;
                    break;
                }
                var _unit$targetPoint = _slicedToArray(unit.targetPoint, 2),
                  x = _unit$targetPoint[0],
                  y = _unit$targetPoint[1];
                var newBuilding = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitBuilding(x + 60, y + 96, 128, 192, imageType, startIndex, _this.draw, _this.iSystem.systemSettings.gameOptions.showLifeLines, _this.eventsAggregator);
                _classPrivateFieldGet(_playerBuildings, _this).push(newBuilding);
                _this.addRenderObject(newBuilding);
              } else {
                unit.stepMove();
              }
              break;
            case _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ACTIONS.IDLE:
              break;
          }
        }
        if (unit instanceof _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitKnight) {
          var _action = unit.activeAction;
          switch (_action) {
            case _const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ACTIONS.MOVE:
              // check for obstacles
              var _collisionUnits = _this.isObjectsCollision(unit.x, unit.y, unit, _classPrivateFieldGet(_enemyUnits, _this)),
                _collisionBuildings = _this.isObjectsCollision(unit.x, unit.y, unit, _classPrivateFieldGet(_enemyBuildings, _this));
              if (_collisionUnits) {
                var _minDist = void 0,
                  _closeEnemy = void 0;
                if (_collisionUnits.length > 1) {
                  var _len2 = _collisionUnits.length;
                  for (var _index4 = 0; _index4 < _len2; _index4++) {
                    var _enemy = _collisionUnits[_index4],
                      _dist = countDistance(unit, _enemy);
                    if (!_minDist || _minDist > _dist) {
                      _minDist = _dist;
                      _closeEnemy = _enemy;
                    }
                  }
                } else {
                  _closeEnemy = _collisionUnits[0];
                }
                //console.log("closest enemy:", closeEnemy);
                unit.activateAttack(_closeEnemy);
              } else if (_collisionBuildings) {
                var _minDist2 = void 0,
                  _closeEnemy2 = void 0;
                if (_collisionBuildings.length > 1) {
                  var _len3 = _collisionBuildings.length;
                  for (var _index5 = 0; _index5 < _len3; _index5++) {
                    var _enemy2 = _collisionBuildings[_index5],
                      _dist2 = countDistance(unit, _enemy2);
                    if (!_minDist2 || _minDist2 > _dist2) {
                      _minDist2 = _dist2;
                      _closeEnemy2 = _enemy2;
                    }
                  }
                } else {
                  _closeEnemy2 = _collisionBuildings[0];
                }
                //console.log("closest enemy:", closeEnemy);
                unit.activateAttack(_closeEnemy2);
              } else {
                var _unit$countNextStep = unit.countNextStep(),
                  _x = _unit$countNextStep.x,
                  _y = _unit$countNextStep.y;
                if (_this.isBoundariesCollision(_x, _y, unit)) {
                  unit.activateIdle();
                } else {
                  unit.stepMove(_x, _y);
                }
              }
              break;
            case _const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ACTIONS.IDLE:
              if (!_classPrivateFieldGet(_isGamePaused, _this) && unit.unitTactic === _const_js__WEBPACK_IMPORTED_MODULE_1__.UNIT_TACTIC.AGGRESSIVE) {
                var enemyObjects = _classPrivateFieldGet(_enemyUnits, _this),
                  _len4 = enemyObjects.length;
                var closestDistance = void 0,
                  closesUnit = void 0;
                for (var i = 0; i < _len4; ++i) {
                  var object = enemyObjects[i],
                    distance = (0,jsge_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.pointToCircleDistance)(unit.x, unit.y, {
                      x: object.x,
                      y: object.y,
                      r: object.width / 2
                    });
                  if (distance < _const_js__WEBPACK_IMPORTED_MODULE_1__.UNIT_VIEW_RANGE) {
                    if (!closestDistance || distance < closestDistance) {
                      closestDistance = distance;
                      closesUnit = object;
                    }
                  }
                }
                if (closestDistance) {
                  unit.activateMoveToTargetPoint(closesUnit.x, closesUnit.y);
                }
              }
              break;
          }
        }
        if (unit instanceof _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitArcher) {
          var _action2 = unit.activeAction;
          switch (_action2) {
            case _const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ACTIONS.MOVE:
              var _unit$countNextStep2 = unit.countNextStep(),
                _x2 = _unit$countNextStep2.x,
                _y2 = _unit$countNextStep2.y;
              // check for obstacles
              if (_this.isBoundariesCollision(_x2, _y2, unit)) {
                unit.activateIdle();
              } else {
                unit.stepMove(_x2, _y2);
              }
              break;
            case _const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ACTIONS.IDLE:
              if (!_classPrivateFieldGet(_isGamePaused, _this) && unit.unitTactic === _const_js__WEBPACK_IMPORTED_MODULE_1__.UNIT_TACTIC.AGGRESSIVE) {
                var _enemyObjects = _classPrivateFieldGet(_enemyUnits, _this),
                  _len5 = _enemyObjects.length;
                var _closestDistance = void 0,
                  _closesUnit = void 0;
                for (var _i4 = 0; _i4 < _len5; ++_i4) {
                  var _object = _enemyObjects[_i4],
                    _distance = (0,jsge_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.pointToCircleDistance)(unit.x, unit.y, {
                      x: _object.x,
                      y: _object.y,
                      r: _object.width / 2
                    });
                  if (_distance < _const_js__WEBPACK_IMPORTED_MODULE_1__.UNIT_VIEW_RANGE) {
                    if (!_closestDistance || _distance < _closestDistance) {
                      _closestDistance = _distance;
                      _closesUnit = _object;
                    }
                  }
                }
                if (_closestDistance && _closestDistance > _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.ARCHER.attackRange) {
                  unit.activateMoveToTargetPointInRange(_closesUnit.x, _closesUnit.y);
                } else if (_closestDistance) {
                  unit.activateAttack(_closesUnit);
                }
              }
              break;
          }
        }
      }
      var eUnitsLen = _classPrivateFieldGet(_enemyUnits, _this).length;
      for (var _index6 = 0; _index6 < eUnitsLen; _index6++) {
        var _unit = _classPrivateFieldGet(_enemyUnits, _this)[_index6];
        if (_unit.isRemoved) {
          var _this$firstBattleOrcs, _this$firstBattleOrcs2;
          _classPrivateFieldGet(_enemyUnits, _this).splice(_index6, 1);
          _index6--;
          eUnitsLen--;
          _classPrivateFieldSet(_firstBattleOrcsLeft, _this, (_this$firstBattleOrcs = _classPrivateFieldGet(_firstBattleOrcsLeft, _this), _this$firstBattleOrcs2 = _this$firstBattleOrcs--, _this$firstBattleOrcs)), _this$firstBattleOrcs2;
          if (_classPrivateFieldGet(_firstBattleOrcsLeft, _this) === 0 && _classPrivateFieldGet(_showWinFirstBattle, _this) === false) {
            // WIN_1_BATTLE
            _this.iSystem.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.SYSTEM_EVENTS.OPEN_DIALOG, {
              level: 2,
              messageKey: _const_js__WEBPACK_IMPORTED_MODULE_1__.STAGE_TEXTS.STAGE_2.WIN_1_BATTLE.key,
              title: _const_js__WEBPACK_IMPORTED_MODULE_1__.STAGE_TEXTS.STAGE_2.WIN_1_BATTLE.title,
              text: _const_js__WEBPACK_IMPORTED_MODULE_1__.STAGE_TEXTS.STAGE_2.WIN_1_BATTLE.text
            });
            _classPrivateFieldSet(_showWinFirstBattle, _this, true);
            _classPrivateFieldSet(_isGamePaused, _this, true);
          }
          continue;
        }
        if (_unit instanceof _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitGoblinTorch) {
          var _action3 = _unit.activeAction;
          switch (_action3) {
            case _const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.ACTIONS.MOVE:
              var isCollisionUnit = _this.isObjectsCollision(_unit.x, _unit.y, _unit, _classPrivateFieldGet(_playerUnits, _this)),
                isCollisionBuilding = _this.isObjectsCollision(_unit.x, _unit.y, _unit, _classPrivateFieldGet(_playerBuildings, _this));
              if (isCollisionUnit) {
                var _len6 = _classPrivateFieldGet(_playerUnits, _this).length;
                var _minDist3 = void 0,
                  _closeEnemy3 = void 0;
                for (var _index7 = 0; _index7 < _len6; _index7++) {
                  var _enemy3 = _classPrivateFieldGet(_playerUnits, _this)[_index7],
                    _dist3 = countDistance(_unit, _enemy3);
                  if (!_minDist3 || _minDist3 > _dist3) {
                    _minDist3 = _dist3;
                    _closeEnemy3 = _enemy3;
                  }
                }
                //console.log("closest enemy:", closeEnemy);
                _unit.activateAttack(_closeEnemy3);
              } else if (isCollisionBuilding) {} else {
                var _unit$countNextStep3 = _unit.countNextStep(),
                  _x3 = _unit$countNextStep3.x,
                  _y3 = _unit$countNextStep3.y;
                if (_this.isBoundariesCollision(_x3, _y3, _unit)) {
                  _unit.activateIdle();
                } else {
                  _unit.stepMove(_x3, _y3);
                }
              }
              break;
            case _const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.ACTIONS.IDLE:
              if (!_classPrivateFieldGet(_isGamePaused, _this) && _unit.unitTactic === _const_js__WEBPACK_IMPORTED_MODULE_1__.UNIT_TACTIC.AGGRESSIVE) {
                var _enemyObjects2 = _classPrivateFieldGet(_playerUnits, _this),
                  _len7 = _enemyObjects2.length;
                var _closestDistance2 = void 0,
                  _closesUnit2 = void 0;
                for (var _i5 = 0; _i5 < _len7; ++_i5) {
                  var _object2 = _enemyObjects2[_i5],
                    _distance2 = (0,jsge_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.pointToCircleDistance)(_unit.x, _unit.y, {
                      x: _object2.x,
                      y: _object2.y,
                      r: _object2.width / 2
                    });
                  if (_distance2 < _const_js__WEBPACK_IMPORTED_MODULE_1__.UNIT_VIEW_RANGE) {
                    if (!_closestDistance2 || _distance2 < _closestDistance2) {
                      _closestDistance2 = _distance2;
                      _closesUnit2 = _object2;
                    }
                  }
                }
                if (_closestDistance2) {
                  _unit.activateMoveToTargetPoint(_closesUnit2.x, _closesUnit2.y);
                }
              }
              break;
          }
        }
      }
      var eBuildingsLen = _classPrivateFieldGet(_enemyBuildings, _this).length;
      for (var _index8 = 0; _index8 < eBuildingsLen; _index8++) {
        var _unit2 = _classPrivateFieldGet(_enemyBuildings, _this)[_index8];
        if (_unit2.isRemoved) {
          _classPrivateFieldGet(_enemyBuildings, _this).splice(_index8, 1);
          _index8--;
          eBuildingsLen--;
          continue;
        }
      }
    });
    _classPrivateFieldInitSpec(_this, _createArrow, function (e) {
      var _e$detail = _slicedToArray(e.detail, 6),
        player = _e$detail[0],
        x = _e$detail[1],
        y = _e$detail[2],
        tX = _e$detail[3],
        tY = _e$detail[4],
        direction = _e$detail[5];
      var arrow = _this.draw.image(x, y, 192, 192, "192Units", 182, [{
        x: -30,
        y: 0
      }, {
        x: 30,
        y: 0
      }]);
      arrow.rotation = direction;
      arrow.x = x;
      arrow.y = y;
      arrow.tX = tX;
      arrow.tY = tY;
      arrow.sortIndex = 3;
      _classPrivateFieldGet(_playerArrows, _this).push(arrow);
    });
    _classPrivateFieldInitSpec(_this, _createGoldBag, function (e) {
      var peasantId = e.detail.peasantId,
        peasant = _classPrivateFieldGet(_playerUnits, _this).find(function (unit) {
          return unit.id === peasantId;
        });
      var goldBag = _this.draw.gold(peasant.x, peasant.y - peasant.height / 4);
      goldBag.sortIndex = 3;
      peasant.addGoldBag(goldBag);
    });
    _classPrivateFieldInitSpec(_this, _createWoodBunch, function (e) {
      console.log("create wood");
      var peasantId = e.detail.peasantId,
        peasant = _classPrivateFieldGet(_playerUnits, _this).find(function (unit) {
          return unit.id === peasantId;
        });
      var woodBunch = _this.draw.wood(peasant.x, peasant.y + peasant.height / 4);
      woodBunch.sortIndex = 3;
      peasant.addWoodBunch(woodBunch);
    });
    _classPrivateFieldInitSpec(_this, _goldMined, function (e) {
      var amount = e.detail;
      _classPrivateFieldSet(_playerGold, _this, _classPrivateFieldGet(_playerGold, _this) + 10);
      _classPrivateFieldGet(_playerGoldCounter, _this).innerText = _classPrivateFieldGet(_playerGold, _this);
    });
    _classPrivateFieldInitSpec(_this, _woodMined, function (e) {
      var amount = e.detail.amount;
      _classPrivateFieldSet(_playerWood, _this, _classPrivateFieldGet(_playerWood, _this) + amount);
      _classPrivateFieldGet(_playerWoodCounter, _this).innerText = _classPrivateFieldGet(_playerWood, _this);
    });
    _classPrivateFieldInitSpec(_this, _goldMineEmpty, function (e) {
      _this.goldMine1.imageIndex = 10;
    });
    _classPrivateFieldInitSpec(_this, _requestForClosestTree, function (e) {
      var peasant = e.detail.peasant,
        oldTreeIndex = e.detail.tree.index,
        tressLayer = _classPrivateFieldGet(_treesLayer, _this).layerData.data,
        layerWidth = _classPrivateFieldGet(_treesLayer, _this).layerData.width,
        layerHeight = _classPrivateFieldGet(_treesLayer, _this).layerData.height,
        layerSize = layerWidth * layerHeight,
        nearestCellsIndexes = [],
        tilewidth = _classPrivateFieldGet(_treesLayer, _this).tilemap.tilewidth,
        tileheight = _classPrivateFieldGet(_treesLayer, _this).tilemap.tileheight; // -5; +5 on width and height

      for (var i = -5; i <= 5; i++) {
        var startItemIndex = oldTreeIndex + i * _classPrivateFieldGet(_treesLayer, _this).layerData.height; // *100

        var rowIndex = Math.floor(startItemIndex / _classPrivateFieldGet(_treesLayer, _this).layerData.height);
        if (startItemIndex >= 0 && startItemIndex <= layerSize) {
          // remove top and bottom indexes overflow
          for (var k = -5; k <= 5; k++) {
            var itemIndex = startItemIndex + k,
              colIndex = itemIndex - rowIndex * _classPrivateFieldGet(_treesLayer, _this).layerData.height;
            if (itemIndex >= 0 && colIndex >= 0 && colIndex <= layerWidth) {
              // remove left and right indexes overflow
              nearestCellsIndexes.push([rowIndex, colIndex, itemIndex]);
            }
          }
        }
      }
      var closestTree, closestDistance;
      nearestCellsIndexes.forEach(function (indexes) {
        var rowIndex = indexes[0],
          colIndex = indexes[1],
          itemIndex = indexes[2],
          cellItem = tressLayer[itemIndex];
        if (cellItem !== 0 && cellItem !== _const_js__WEBPACK_IMPORTED_MODULE_1__.TREE_STUB_INDEX) {
          console.log("item x: ", colIndex);
          console.log("item y: ", rowIndex);
          var cellItemPosX = colIndex * tilewidth + tilewidth / 2,
            cellItemPosY = rowIndex * tileheight + tileheight / 2,
            distance = countDistance({
              x: peasant.x,
              y: peasant.y
            }, {
              x: cellItemPosX,
              y: cellItemPosY
            });

          //console.log("distance: ", distance);
          //console.log("closest distance: ", closestDistance);
          if (!closestDistance || closestDistance > distance) {
            closestTree = _classPrivateFieldGet(_treesCutHealth, _this).get(itemIndex);
            if (!closestTree) {
              closestTree = new Tree(cellItemPosX, cellItemPosY, _const_js__WEBPACK_IMPORTED_MODULE_1__.TREE_FULL_HEALTH, itemIndex);
              _classPrivateFieldGet(_treesCutHealth, _this).set(itemIndex, closestTree);
            }
            //console.log("set closest distance: ", distance);
            //console.log("tree: ", closestTree);
            closestDistance = distance;
          }
        }
      });
      //console.log("old tree is ", oldTreeIndex);
      //console.log("closest tree is ", closestTree.index);
      if (closestDistance) {
        _classPrivateFieldGet(_treesCutHealth, _this).set(closestTree.index, closestTree);
        var playerUnit = _classPrivateFieldGet(_playerUnits, _this).find(function (unit) {
          return unit.id === peasant.id;
        });
        playerUnit.activateDragTree(closestTree);
      }
    });
    _defineProperty(_this, "recursiveSearchForClosestTree", function () {});
    _classPrivateFieldInitSpec(_this, _treeEmpty, function (e) {
      var treeIndex = e.detail.index;
      _classPrivateFieldGet(_treesCutHealth, _this)["delete"](treeIndex);
      _classPrivateFieldGet(_treesLayer, _this).layerData.data[treeIndex] = _const_js__WEBPACK_IMPORTED_MODULE_1__.TREE_STUB_INDEX;
    });
    _classPrivateFieldInitSpec(_this, _peasantBuilt, function (e) {
      var townCenter = e.detail,
        newPeasant = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitPeasant(0, 0, townCenter, _this.draw, _this.iSystem.systemSettings.gameOptions.showLifeLines, _this.eventsAggregator, _this.peasantAudio);
      var posX = 80,
        posY = 120;
      while (_this.isObjectsCollision(townCenter.x + posX, townCenter.y + posY, newPeasant, _classPrivateFieldGet(_playerUnits, _this))) {
        posX -= 18;
        console.log("collision shift left");
      }
      //console.log("no collision adding unit");
      newPeasant.x = townCenter.x + posX;
      newPeasant.y = townCenter.y + posY;
      _this.addRenderObject(newPeasant);
      _classPrivateFieldGet(_playerUnits, _this).push(newPeasant);
      _classPrivateFieldGet(_recalculatePeopleLimits, _this).call(_this);
    });
    _classPrivateFieldInitSpec(_this, _recalculatePeopleLimits, function () {
      _classPrivateFieldGet(_playerPeopleLimitCounter, _this).innerText = _classPrivateFieldGet(_playerUnits, _this).length + "/" + _classPrivateFieldGet(_playerPeopleLimit, _this).toString();
    });
    _classPrivateFieldInitSpec(_this, _buildingDone, function (e) {
      var house = e.detail,
        newPeasant = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitPeasant(0, 0, house, _this.draw, _this.iSystem.systemSettings.gameOptions.showLifeLines, _this.eventsAggregator, _this.peasantAudio);
      console.log(e.detail);
      var posX = 20,
        posY = 20;
      while (_this.isObjectsCollision(house.x + posX, house.y + posY, newPeasant, _classPrivateFieldGet(_playerUnits, _this))) {
        posX -= 18;
        console.log("collision shift left");
      }
      newPeasant.x = house.x + posX;
      newPeasant.y = house.y + posY;
      _this.addRenderObject(newPeasant);
      _classPrivateFieldGet(_playerUnits, _this).push(newPeasant);
      var doneIndex = 0;
      switch (house.imageIndex) {
        case 1:
          // house
          break;
        case 4:
          // barracks
          doneIndex = 3;
          break;
      }
      house.imageIndex = doneIndex;
      _classPrivateFieldSet(_playerPeopleLimit, _this, _classPrivateFieldGet(_playerPeopleLimit, _this) + 3);
      _classPrivateFieldGet(_playerPeopleLimitCounter, _this).innerText = _classPrivateFieldGet(_playerUnits, _this).length + "/" + _classPrivateFieldGet(_playerPeopleLimit, _this).toString();
    });
    _defineProperty(_this, "stopAction", function () {
      clearInterval(_this.timer);
      _this.timer = null;
    });
    _defineProperty(_this, "fireAction", function () {
      _this.person.emit("fire");
    });
    return _this;
  }
  _inherits(Stage2, _GameStage);
  return _createClass(Stage2, [{
    key: "register",
    value: function register() {
      this.iLoader.addTileMap("s_map", "./assets/level2.tmx");
      this.iLoader.addImage(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.GOLD_MINE.name, "./assets/Tiny Swords (Update 010)/Resources/Gold Mine/GoldMine_Inactive.png");
      this.iLoader.addImage(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.TOWN_CENTER.name, "./assets/Tiny Swords (Update 010)/Factions/Knights/Buildings/Castle/Castle_Blue.png");
      this.iLoader.addImage(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.HOUSE.name, "./assets/house128x192.png");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.AUDIO.WHAT1, "./assets/audio/peasantwhat1.mp3");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.AUDIO.WHAT2, "./assets/audio/peasantwhat2.mp3");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.AUDIO.WHAT3, "./assets/audio/peasantwhat3.mp3");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.WHAT1, "./assets/audio/capitan/CaptainWhat1.wav");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.WHAT2, "./assets/audio/capitan/CaptainWhat2.wav");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.WHAT3, "./assets/audio/capitan/CaptainWhat3.wav");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.YES1, "./assets/audio/capitan/CaptainYes1.wav");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.YES2, "./assets/audio/capitan/CaptainYes2.wav");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.YES3, "./assets/audio/capitan/CaptainYes3.wav");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.ATTACK1, "./assets/audio/capitan/CaptainWarcry1.wav");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.ATTACK2, "./assets/audio/capitan/CaptainYesAttack1.wav");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.FIGHT1, "./assets/audio/AxeMissile1.wav");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.FIGHT2, "./assets/audio/AxeMissile2.wav");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.AUDIO.DEATH1, "./assets/audio/FootmanDeath.wav");
      this.iLoader.addAudio(_const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.AUDIO.DEATH1, "./assets/audio/GruntDeath.wav");
      this.iLoader.addAudio("needMoreGold", "./assets/audio/gruntnogold1.mp3");
      this.iLoader.addAudio("needFood", "./assets/audio/upkeepring.mp3");
      this.iLoader.addAudio("chopTree", "./assets/audio/axemediumchopwood2.mp3");
      this.iLoader.addAudio("cantBuildHere", "./assets/audio/peasantcannotbuildthere1.mp3");
      this.timer = null;
      this.eventsAggregator = new EventTarget();
      document.body.style.margin = 0;
    }
  }, {
    key: "init",
    value: function init() {
      var _this$stageData$canva2 = _slicedToArray(this.stageData.canvasDimensions, 2),
        w = _this$stageData$canva2[0],
        h = _this$stageData$canva2[1];
      // x, y, width, height, imageKey
      //const water = this.draw.tiledLayer("water", "s_map", true),
      //	water_anim = this.draw.tiledLayer("water_a", "s_map"),
      var sand = this.draw.tiledLayer("sand", "s_map"),
        ground = this.draw.tiledLayer("ground", "s_map"),
        ground_stuff = this.draw.tiledLayer("ground_stuff", "s_map");
      //	cliff = this.draw.tiledLayer("cliff", "s_map", true),
      //	bridge = this.draw.tiledLayer("bridge", "s_map");

      _classPrivateFieldSet(_treesLayer, this, this.draw.tiledLayer("trees", "s_map", true));
      this.goldMine1 = this.draw.image(1100, 360, 192, 128, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.GOLD_MINE.name, 0);
      this.goldMine1.goldAmount = _const_js__WEBPACK_IMPORTED_MODULE_1__.GOLD_MINE_GOLD_AMOUNT;
      _classPrivateFieldGet(_neutralBuildings, this).push(this.goldMine1);
      _classPrivateFieldGet(_attachAudio, this).call(this);

      // this.shadowRect = this.draw.rect(0, 0, w, h, "rgba(0, 0, 0, 0.5)");  
      // this.shadowRect.blendFunc = [WebGLRenderingContext.ONE, WebGLRenderingContext.DST_COLOR];
      // this.shadowRect.turnOffOffset();

      // units

      var townCenter = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitBuilding(850, 600, 320, 256, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.TOWN_CENTER.name, 0, this.draw, this.iSystem.systemSettings.gameOptions.showLifeLines, this.eventsAggregator);
      townCenter.sortIndex = 4;
      _classPrivateFieldGet(_playerBuildings, this).push(townCenter);
      var peasant1 = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitPeasant(1050, 580, townCenter, this.draw, this.iSystem.systemSettings.gameOptions.showLifeLines, this.eventsAggregator, this.peasantAudio),
        peasant2 = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitPeasant(1050, 640, townCenter, this.draw, this.iSystem.systemSettings.gameOptions.showLifeLines, this.eventsAggregator, this.peasantAudio),
        peasant3 = new _units_js__WEBPACK_IMPORTED_MODULE_2__.UnitPeasant(1050, 700, townCenter, this.draw, this.iSystem.systemSettings.gameOptions.showLifeLines, this.eventsAggregator, this.peasantAudio);
      this.addRenderObject(townCenter);
      this.addRenderObject(peasant1);
      this.addRenderObject(peasant2);
      this.addRenderObject(peasant3);
      _classPrivateFieldGet(_playerUnits, this).push(peasant1);
      _classPrivateFieldGet(_playerUnits, this).push(peasant2);
      _classPrivateFieldGet(_playerUnits, this).push(peasant3);
      this.chopTreeSound = this.iLoader.getAudio("chopTree");
      // this.personSightView = this.draw.conus(55, 250, 200, "rgba(0,0,0,1)", Math.PI/3);
      // this.personSightView.rotation = -Math.PI/6;
      // this.personSightView._isMask = true;
      _classPrivateFieldGet(_createBattle, this).call(this);
      this.iSystem.addEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.DIALOG_EVENTS.CLOSED, _classPrivateFieldGet(_onDialogClosed, this));
    }
  }, {
    key: "start",
    value: function start() {
      var _this2 = this;
      _classPrivateFieldGet(_createUserInterface, this).call(this);
      setTimeout(function () {
        var _this2$stageData$canv = _slicedToArray(_this2.stageData.canvasDimensions, 2),
          w = _this2$stageData$canv[0],
          h = _this2$stageData$canv[1];
        _this2.stageData.centerCameraPosition(720, 1400);
      }, 100);
      _classPrivateFieldSet(_unitsCount, this, _classPrivateFieldGet(_playerUnits, this).length);
      console.log("strategy started x:" + 2000);
    }
  }, {
    key: "stop",
    value: function stop() {
      this.unregisterListeners();
      document.getElementById("sidebar").remove();
    }
  }, {
    key: "registerListeners",
    value: function registerListeners() {
      _assertClassBrand(_Stage2_brand, this, _registerMouseListeners).call(this);
      _assertClassBrand(_Stage2_brand, this, _registerKeyboardListeners).call(this);
      _assertClassBrand(_Stage2_brand, this, _registerSystemEventsListeners).call(this);
    }
  }, {
    key: "unregisterListeners",
    value: function unregisterListeners() {
      _assertClassBrand(_Stage2_brand, this, _unregisterMouseListeners).call(this);
      _assertClassBrand(_Stage2_brand, this, _unregisterKeyboardListeners).call(this);
      _assertClassBrand(_Stage2_brand, this, _unregisterSystemEventsListeners).call(this);
    }
  }, {
    key: "move",
    value: function move(dir) {
      var newX = this.tank.x,
        newY = this.tank.y;
      switch (dir) {
        case "left":
          newX = newX - 1;
          break;
        case "right":
          newX = newX + 1;
          break;
        case "top":
          newY = newY - 1;
          break;
        case "bottom":
          newY = newY + 1;
          break;
      }
      if (!this.isBoundariesCollision(newX, newY, this.tank)) {
        this.tank.x = newX;
        this.tank.y = newY;
        this.gun.x = newX;
        this.gun.y = newY;
        this.stageData.centerCameraPosition(newX, newY);
      }
    }
  }]);
}(jsge__WEBPACK_IMPORTED_MODULE_0__.GameStage);
function _registerKeyboardListeners() {
  document.addEventListener("keydown", _classPrivateFieldGet(_pressKeyAction, this));
  document.addEventListener("keyup", _classPrivateFieldGet(_removeKeyAction, this));
}
function _unregisterKeyboardListeners() {
  document.removeEventListener("keydown", _classPrivateFieldGet(_pressKeyAction, this));
  document.removeEventListener("keyup", _classPrivateFieldGet(_removeKeyAction, this));
}
function _registerMouseListeners() {
  document.addEventListener("mousemove", _classPrivateFieldGet(_mouseMoveAction, this));
  document.addEventListener("click", _classPrivateFieldGet(_mouseClickAction, this));
}
function _unregisterMouseListeners() {
  this.iSystem.removeEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.SYSTEM_EVENTS.START_LEVEL, _classPrivateFieldGet(_onDialogClosed, this));
  document.removeEventListener("mousemove", _classPrivateFieldGet(_mouseMoveAction, this));
  document.removeEventListener("click", _classPrivateFieldGet(_mouseClickAction, this));
}
function _isEnoughGold(costGold) {
  var gold = _classPrivateFieldGet(_playerGold, this);
  return costGold <= gold;
}
function _isEnoughWood(costWood) {
  var wood = _classPrivateFieldGet(_playerWood, this);
  return costWood <= wood;
}
function _isEnoughHouses() {
  var units = _classPrivateFieldGet(_playerUnits, this).length,
    maxUnits = _classPrivateFieldGet(_playerPeopleLimit, this);
  console.log("u: ", units);
  console.log("l: ", maxUnits);
  return maxUnits > units;
}
function _registerSystemEventsListeners() {
  this.iSystem.addEventListener(jsge__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.SYSTEM.RENDER.START, _classPrivateFieldGet(_render, this));
  this.eventsAggregator.addEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.GOLD_GRAB, _classPrivateFieldGet(_createGoldBag, this));
  this.eventsAggregator.addEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.GOLD_MINED, _classPrivateFieldGet(_goldMined, this));
  this.eventsAggregator.addEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.WOOD_GRAB, _classPrivateFieldGet(_createWoodBunch, this));
  this.eventsAggregator.addEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.WOOD_MINED, _classPrivateFieldGet(_woodMined, this));
  this.eventsAggregator.addEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.GOLD_MINE_EMPTY, _classPrivateFieldGet(_goldMineEmpty, this));
  this.eventsAggregator.addEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.TREE_EMPTY, _classPrivateFieldGet(_treeEmpty, this));
  this.eventsAggregator.addEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.REQUEST_FOR_CLOSEST_TREE, _classPrivateFieldGet(_requestForClosestTree, this));
  this.eventsAggregator.addEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.PEASANT_BUILT, _classPrivateFieldGet(_peasantBuilt, this));
  this.eventsAggregator.addEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.BUILDING_DONE, _classPrivateFieldGet(_buildingDone, this));
  this.eventsAggregator.addEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.CREATE_ARROW, _classPrivateFieldGet(_createArrow, this));
}
function _unregisterSystemEventsListeners() {
  this.iSystem.removeEventListener(jsge__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.SYSTEM.RENDER.START, _classPrivateFieldGet(_render, this));
  this.eventsAggregator.removeEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.GOLD_GRAB, _classPrivateFieldGet(_createGoldBag, this));
  this.eventsAggregator.removeEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.GOLD_MINED, _classPrivateFieldGet(_goldMined, this));
  this.eventsAggregator.removeEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.WOOD_GRAB, _classPrivateFieldGet(_createWoodBunch, this));
  this.eventsAggregator.removeEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.WOOD_MINED, _classPrivateFieldGet(_woodMined, this));
  this.eventsAggregator.removeEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.GOLD_MINE_EMPTY, _classPrivateFieldGet(_goldMineEmpty, this));
  this.eventsAggregator.removeEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.TREE_EMPTY, _classPrivateFieldGet(_treeEmpty, this));
  this.eventsAggregator.removeEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.REQUEST_FOR_CLOSEST_TREE, _classPrivateFieldGet(_requestForClosestTree, this));
  this.eventsAggregator.removeEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.PEASANT_BUILT, _classPrivateFieldGet(_peasantBuilt, this));
  this.eventsAggregator.removeEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.BUILDING_DONE, _classPrivateFieldGet(_buildingDone, this));
  this.eventsAggregator.removeEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.CREATE_ARROW, _classPrivateFieldGet(_createArrow, this));
}
var EvensAggregator = /*#__PURE__*/function (_EventTarget) {
  function EvensAggregator() {
    _classCallCheck(this, EvensAggregator);
    return _callSuper(this, EvensAggregator, arguments);
  }
  _inherits(EvensAggregator, _EventTarget);
  return _createClass(EvensAggregator);
}(/*#__PURE__*/_wrapNativeSuper(EventTarget));
var _x4 = /*#__PURE__*/new WeakMap();
var _y4 = /*#__PURE__*/new WeakMap();
var _health = /*#__PURE__*/new WeakMap();
var _index9 = /*#__PURE__*/new WeakMap();
var Tree = /*#__PURE__*/function () {
  function Tree(x, y, treeHealth, index) {
    _classCallCheck(this, Tree);
    _classPrivateFieldInitSpec(this, _x4, void 0);
    _classPrivateFieldInitSpec(this, _y4, void 0);
    _classPrivateFieldInitSpec(this, _health, void 0);
    _classPrivateFieldInitSpec(this, _index9, void 0);
    _classPrivateFieldSet(_x4, this, x);
    _classPrivateFieldSet(_y4, this, y);
    _classPrivateFieldSet(_index9, this, index);
    _classPrivateFieldSet(_health, this, treeHealth);
  }
  return _createClass(Tree, [{
    key: "index",
    get: function get() {
      return _classPrivateFieldGet(_index9, this);
    }
  }, {
    key: "x",
    get: function get() {
      return _classPrivateFieldGet(_x4, this);
    }
  }, {
    key: "y",
    get: function get() {
      return _classPrivateFieldGet(_y4, this);
    }
  }, {
    key: "health",
    get: function get() {
      return _classPrivateFieldGet(_health, this);
    },
    set: function set(value) {
      _classPrivateFieldSet(_health, this, value);
    }
  }]);
}();

/***/ }),

/***/ "./src/start.js":
/*!**********************!*\
  !*** ./src/start.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StartStage: () => (/* binding */ StartStage)
/* harmony export */ });
/* harmony import */ var jsge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsge */ "./node_modules/jsge/src/index.js");
/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const.js */ "./src/const.js");
/* harmony import */ var _ui_ui_init_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ui/ui-init.js */ "./src/ui/ui-init.js");
/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom/client */ "./node_modules/react-dom/client.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _ui_options_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ui/options.js */ "./src/ui/options.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }







var isPointRectIntersect = jsge__WEBPACK_IMPORTED_MODULE_0__.utils.isPointRectIntersect;
var LEFT_SHIFT = -70;
var MENU_CLICK_AUDIO_NAME = "menu_click";
var _menuClickMediaElement = /*#__PURE__*/new WeakMap();
var _showWinMessage = /*#__PURE__*/new WeakMap();
var _drawOptions = /*#__PURE__*/new WeakMap();
var _changeOptions = /*#__PURE__*/new WeakMap();
var _mouseHoverEvent = /*#__PURE__*/new WeakMap();
var _mouseClickEvent = /*#__PURE__*/new WeakMap();
var _loaderErrorHandler = /*#__PURE__*/new WeakMap();
var _pressKeyAction = /*#__PURE__*/new WeakMap();
var StartStage = /*#__PURE__*/function (_GameStage) {
  function StartStage() {
    var _this;
    _classCallCheck(this, StartStage);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper(this, StartStage, [].concat(args));
    _classPrivateFieldInitSpec(_this, _menuClickMediaElement, void 0);
    _defineProperty(_this, "uiApp", void 0);
    _classPrivateFieldInitSpec(_this, _showWinMessage, function (e) {
      console.log("show win ", e);
    });
    _classPrivateFieldInitSpec(_this, _drawOptions, function () {
      var _this$stageData$canva = _slicedToArray(_this.stageData.canvasDimensions, 2),
        w = _this$stageData$canva[0],
        h = _this$stageData$canva[1];
      _this.iSystem.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.SYSTEM_EVENTS.CHANGE_DIALOG_STYLE, w / 2 + LEFT_SHIFT + LEFT_SHIFT - 40, _this.navItemLevel2.y + 20);
    });
    _classPrivateFieldInitSpec(_this, _changeOptions, function (e) {
      var options = e.data[0];
      //console.log("changed options: ", options);
      //console.log(this.iSystem.systemSettings.gameOptions);
      if (options["showBoundaries"] === true) {
        _this.iSystem.systemSettings.gameOptions.debug.boundaries.drawLayerBoundaries = true;
        _this.iSystem.systemSettings.gameOptions.debug.boundaries.drawObjectBoundaries = true;
      } else if (options["showBoundaries"] === false) {
        _this.iSystem.systemSettings.gameOptions.debug.boundaries.drawLayerBoundaries = false;
        _this.iSystem.systemSettings.gameOptions.debug.boundaries.drawObjectBoundaries = false;
      } else if (options["showLifeLines"] === true) {
        _this.iSystem.systemSettings.gameOptions.showLifeLines = true;
      } else if (options["showLifeLines"] === false) {
        _this.iSystem.systemSettings.gameOptions.showLifeLines = false;
      }
    });
    _classPrivateFieldInitSpec(_this, _mouseHoverEvent, function (event) {
      var canvas = _this.canvasHtmlElement,
        isNav1Traversed = isPointRectIntersect(event.offsetX, event.offsetY, _this.navItemLevel1.boundariesBox),
        isNav2Trav = isPointRectIntersect(event.offsetX, event.offsetY, _this.navItemLevel2.boundariesBox);
      if (isNav1Traversed) {
        _this.navItemLevel1.strokeStyle = "rgba(0, 0, 0, 0.3)";
      } else if (_this.navItemLevel1.strokeStyle) {
        _this.navItemLevel1.strokeStyle = undefined;
      }
      if (isNav2Trav) {
        _this.navItemLevel2.strokeStyle = "rgba(0, 0, 0, 0.3)";
      } else if (_this.navItemLevel2.strokeStyle) {
        _this.navItemLevel2.strokeStyle = undefined;
      }
      if (isNav1Traversed || isNav2Trav) {
        canvas.style.cursor = "pointer";
      } else {
        canvas.style.cursor = "default";
      }
    });
    _classPrivateFieldInitSpec(_this, _mouseClickEvent, function (event) {
      if (isPointRectIntersect(event.offsetX, event.offsetY, _this.navItemLevel1.boundariesBox)) {
        _classPrivateFieldGet(_menuClickMediaElement, _this).play();
        _this.iSystem.stopGameStage(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_STAGES.START);
        _this.iSystem.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.SYSTEM_EVENTS.OPEN_DIALOG, {
          level: 1,
          messageKey: _const_js__WEBPACK_IMPORTED_MODULE_1__.STAGE_TEXTS.STAGE_1.START.key,
          title: _const_js__WEBPACK_IMPORTED_MODULE_1__.STAGE_TEXTS.STAGE_1.START.title,
          text: _const_js__WEBPACK_IMPORTED_MODULE_1__.STAGE_TEXTS.STAGE_1.START.text
        });
        _this.iSystem.startGameStage(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_STAGES.STAGE_1);
      }
      if (isPointRectIntersect(event.offsetX, event.offsetY, _this.navItemLevel2.boundariesBox)) {
        _classPrivateFieldGet(_menuClickMediaElement, _this).play();
        _this.iSystem.stopGameStage(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_STAGES.START);
        _this.iSystem.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.SYSTEM_EVENTS.OPEN_DIALOG, {
          level: 2,
          messageKey: _const_js__WEBPACK_IMPORTED_MODULE_1__.STAGE_TEXTS.STAGE_2.START.key,
          title: _const_js__WEBPACK_IMPORTED_MODULE_1__.STAGE_TEXTS.STAGE_2.START.title,
          text: _const_js__WEBPACK_IMPORTED_MODULE_1__.STAGE_TEXTS.STAGE_2.START.text
        });
        _this.iSystem.startGameStage(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_STAGES.STAGE_2);
      }
    });
    _classPrivateFieldInitSpec(_this, _loaderErrorHandler, function (error) {
      console.log("--->>>>error");
      console.log(error);
    });
    _classPrivateFieldInitSpec(_this, _pressKeyAction, function (event) {
      console.log("press key, " + event.code);
    });
    return _this;
  }
  _inherits(StartStage, _GameStage);
  return _createClass(StartStage, [{
    key: "register",
    value: function register() {
      this.iLoader.addAudio(MENU_CLICK_AUDIO_NAME, "./assets/audio/select_001.ogg");
      this.iLoader.addEventListener("error", _classPrivateFieldGet(_loaderErrorHandler, this));
      var domNode = document.getElementById("ui-root");
      window.React = react__WEBPACK_IMPORTED_MODULE_4__;
      var root = (0,react_dom_client__WEBPACK_IMPORTED_MODULE_3__.createRoot)(domNode);
      this.uiApp = (0,_ui_ui_init_js__WEBPACK_IMPORTED_MODULE_2__["default"])(this.iSystem);
      root.render(this.uiApp);
    }
  }, {
    key: "init",
    value: function init() {
      var _this$stageData$canva2 = _slicedToArray(this.stageData.canvasDimensions, 2),
        w = _this$stageData$canva2[0],
        h = _this$stageData$canva2[1];
      this.background = this.draw.rect(0, 0, w, h, "rgba(120, 120, 120, 0.6)");
      this.navItemLevel1 = this.draw.text(w / 2 + LEFT_SHIFT, h / 2, "Start level 1", "20px sans-serif", "black");
      this.navItemLevel2 = this.draw.text(w / 2 + LEFT_SHIFT, h / 2 + 40, "Start level 2", "20px sans-serif", "black");
      //this.#createOptionsBlock();
      this.audio.registerAudio(MENU_CLICK_AUDIO_NAME);
      _classPrivateFieldSet(_menuClickMediaElement, this, this.audio.getAudio(MENU_CLICK_AUDIO_NAME));
      _classPrivateFieldGet(_drawOptions, this).call(this);
    }
  }, {
    key: "start",
    value: function start() {
      console.log("start stage");
      this.registerEventListeners();
    }
  }, {
    key: "stop",
    value: function stop() {
      this.unregisterEventListeners();
    }
  }, {
    key: "registerEventListeners",
    value: function registerEventListeners() {
      var canvas = this.canvasHtmlElement;
      canvas.addEventListener("mousemove", _classPrivateFieldGet(_mouseHoverEvent, this));
      canvas.addEventListener("click", _classPrivateFieldGet(_mouseClickEvent, this));
      document.addEventListener("keydown", _classPrivateFieldGet(_pressKeyAction, this));
      this.iSystem.addEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.DIALOG_EVENTS.CHANGE_OPTIONS, _classPrivateFieldGet(_changeOptions, this));
    }
  }, {
    key: "unregisterEventListeners",
    value: function unregisterEventListeners() {
      var canvas = this.canvasHtmlElement;
      canvas.removeEventListener("mousemove", _classPrivateFieldGet(_mouseHoverEvent, this));
      canvas.removeEventListener("click", _classPrivateFieldGet(_mouseClickEvent, this));
      document.removeEventListener("keydown", _classPrivateFieldGet(_pressKeyAction, this));
      canvas.style.cursor = "default";
      this.iSystem.removeEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.DIALOG_EVENTS.CHANGE_OPTIONS, _classPrivateFieldGet(_changeOptions, this));
    }
  }]);
}(jsge__WEBPACK_IMPORTED_MODULE_0__.GameStage);

/***/ }),

/***/ "./src/ui/dialog.js":
/*!**************************!*\
  !*** ./src/ui/dialog.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LevelDialog: () => (/* binding */ LevelDialog)
/* harmony export */ });
/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @chakra-ui/react */ "./node_modules/@chakra-ui/react/dist/esm/components/dialog/dialog.js");
/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @chakra-ui/react */ "./node_modules/@ark-ui/react/dist/components/portal/portal.js");
/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @chakra-ui/react */ "./node_modules/@chakra-ui/react/dist/esm/components/button/button.js");
/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @chakra-ui/react */ "./node_modules/@chakra-ui/react/dist/esm/components/button/close-button.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../const.js */ "./src/const.js");
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }



var LevelDialog = function LevelDialog(_ref) {
  var eventManger = _ref.eventManger;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
    _useState2 = _slicedToArray(_useState, 2),
    isOpen = _useState2[0],
    setState = _useState2[1];
  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
    _useState4 = _slicedToArray(_useState3, 2),
    title = _useState4[0],
    setTitle = _useState4[1];
  var _useState5 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
    _useState6 = _slicedToArray(_useState5, 2),
    text = _useState6[0],
    setText = _useState6[1];
  var _useState7 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0),
    _useState8 = _slicedToArray(_useState7, 2),
    level = _useState8[0],
    setLevel = _useState8[1];
  var _useState9 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
    _useState0 = _slicedToArray(_useState9, 2),
    messageKey = _useState0[0],
    setMessageKey = _useState0[1];
  console.log("======>>>>>>level dialog, open: ", open);
  console.log(eventManger);
  eventManger.addEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.SYSTEM_EVENTS.OPEN_DIALOG, function (e) {
    var _e$data$ = e.data[0],
      level = _e$data$.level,
      messageKey = _e$data$.messageKey,
      title = _e$data$.title,
      text = _e$data$.text;
    setTitle(title);
    setText(text);
    setLevel(level);
    setState(true);
    setMessageKey(messageKey);
  });
  function closeDialog() {
    setState(false);
    eventManger.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.DIALOG_EVENTS.CLOSED, {
      currentLevel: level,
      currentState: messageKey
    });
  }
  return /*#__PURE__*/React.createElement(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_2__.DialogRoot, {
    lazyMount: true,
    open: isOpen
  }, /*#__PURE__*/React.createElement(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_3__.Portal, null, /*#__PURE__*/React.createElement(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_2__.DialogBackdrop, null), /*#__PURE__*/React.createElement(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_2__.DialogPositioner, null, /*#__PURE__*/React.createElement(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_2__.DialogContent, null, /*#__PURE__*/React.createElement(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_2__.DialogHeader, null, /*#__PURE__*/React.createElement(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_2__.DialogTitle, null, title)), /*#__PURE__*/React.createElement(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_2__.DialogBody, null, /*#__PURE__*/React.createElement("p", null, text)), /*#__PURE__*/React.createElement(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_2__.DialogFooter, null, /*#__PURE__*/React.createElement(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_4__.Button, {
    onClick: function onClick() {
      return closeDialog();
    }
  }, "\u041F\u043E\u043D\u044F\u0442\u043D\u043E")), /*#__PURE__*/React.createElement(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_2__.DialogCloseTrigger, {
    asChild: true
  }, /*#__PURE__*/React.createElement(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_5__.CloseButton, {
    onClick: function onClick() {
      return closeDialog();
    },
    size: "sm"
  }))))));
};

/***/ }),

/***/ "./src/ui/options.js":
/*!***************************!*\
  !*** ./src/ui/options.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OptionsCard: () => (/* binding */ OptionsCard)
/* harmony export */ });
/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @chakra-ui/react */ "./node_modules/@chakra-ui/react/dist/esm/components/checkbox/checkbox.js");
/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @chakra-ui/react */ "./node_modules/@chakra-ui/react/dist/esm/components/typography/text.js");
/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @chakra-ui/react */ "./node_modules/@chakra-ui/react/dist/esm/components/flex/flex.js");
/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @chakra-ui/react */ "./node_modules/@chakra-ui/react/dist/esm/components/checkbox-card/checkbox-card.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../const.js */ "./src/const.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }



var OptionsCard = function OptionsCard(_ref) {
  var eventManger = _ref.eventManger;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
      showBoundaries: false,
      showLifeLines: false
    }),
    _useState2 = _slicedToArray(_useState, 2),
    options = _useState2[0],
    setOptions = _useState2[1];
  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
      x: 0,
      y: 0
    }),
    _useState4 = _slicedToArray(_useState3, 2),
    position = _useState4[0],
    setPosition = _useState4[1];
  var _useState5 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
    _useState6 = _slicedToArray(_useState5, 2),
    isVisible = _useState6[0],
    setVisible = _useState6[1];
  eventManger.addEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.SYSTEM_EVENTS.CHANGE_DIALOG_STYLE, function (e) {
    var _e$data = _slicedToArray(e.data, 2),
      x = _e$data[0],
      y = _e$data[1];
    console.log(e.data);
    setPosition({
      x: x,
      y: y
    });
    setVisible(true);
  });
  eventManger.addEventListener(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.SYSTEM_EVENTS.OPEN_DIALOG, function (e) {
    var _e$data2 = _slicedToArray(e.data, 2),
      open = _e$data2[0],
      level = _e$data2[1];
    setVisible(false);
  });
  function onChange(e) {
    var target = e.target;
    var bool = false;
    if (target.checked) {
      bool = true;
    }
    setOptions(_objectSpread(_objectSpread({}, options), {}, _defineProperty({}, target.value, bool)));
    eventManger.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.DIALOG_EVENTS.CHANGE_OPTIONS, _defineProperty({}, target.value, bool));
  }
  return /*#__PURE__*/React.createElement(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_2__.CheckboxGroup, {
    defaultValue: ["next"],
    style: {
      display: isVisible ? "block" : "none",
      position: "absolute",
      left: position.x,
      top: position.y
    }
  }, /*#__PURE__*/React.createElement(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_3__.Text, {
    textStyle: "sm",
    fontWeight: "bold"
  }, "Options"), /*#__PURE__*/React.createElement(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_4__.Flex, {
    gap: "2"
  }, items.map(function (item) {
    return /*#__PURE__*/React.createElement(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_5__.CheckboxCardRoot, {
      key: item.value,
      value: item.value,
      onChange: onChange,
      checked: options[item.value]
    }, /*#__PURE__*/React.createElement(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_5__.CheckboxCardHiddenInput, null), /*#__PURE__*/React.createElement(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_5__.CheckboxCardControl, null, /*#__PURE__*/React.createElement(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_5__.CheckboxCardContent, null, /*#__PURE__*/React.createElement(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_5__.CheckboxCardLabel, null, item.title)), /*#__PURE__*/React.createElement(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_5__.CheckboxCardIndicator, null)));
  })));
};
var items = [{
  value: "showBoundaries",
  title: "Show Boundaries"
}, {
  value: "showLifeLines",
  title: "Show Health"
}];

/***/ }),

/***/ "./src/ui/ui-init.js":
/*!***************************!*\
  !*** ./src/ui/ui-init.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UiApp)
/* harmony export */ });
/* harmony import */ var _dialog_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dialog.js */ "./src/ui/dialog.js");
/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @chakra-ui/react */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/config.js");
/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @chakra-ui/react */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/system.js");
/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @chakra-ui/react */ "./node_modules/@chakra-ui/react/dist/esm/preset.js");
/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @chakra-ui/react */ "./node_modules/@chakra-ui/react/dist/esm/styled-system/provider.js");
/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./options.js */ "./src/ui/options.js");



var config = (0,_chakra_ui_react__WEBPACK_IMPORTED_MODULE_2__.defineConfig)({
  theme: {
    tokens: {
      colors: {}
    }
  }
});
var system = (0,_chakra_ui_react__WEBPACK_IMPORTED_MODULE_3__.createSystem)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_4__.defaultConfig, config);
function UiApp(eventManger) {
  console.log("=====>>>>>>>>create ui app");
  return /*#__PURE__*/React.createElement(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_5__.ChakraProvider, {
    value: system
  }, /*#__PURE__*/React.createElement(_options_js__WEBPACK_IMPORTED_MODULE_1__.OptionsCard, {
    eventManger: eventManger
  }), /*#__PURE__*/React.createElement(_dialog_js__WEBPACK_IMPORTED_MODULE_0__.LevelDialog, {
    eventManger: eventManger
  }));
}

/***/ }),

/***/ "./src/units.js":
/*!**********************!*\
  !*** ./src/units.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UnitArcher: () => (/* binding */ UnitArcher),
/* harmony export */   UnitBuilding: () => (/* binding */ BaseBuilding),
/* harmony export */   UnitGoblinHouse: () => (/* binding */ UnitGoblinHouse),
/* harmony export */   UnitGoblinTorch: () => (/* binding */ UnitGoblinTorch),
/* harmony export */   UnitGoblinTower: () => (/* binding */ UnitGoblinTower),
/* harmony export */   UnitKnight: () => (/* binding */ UnitKnight),
/* harmony export */   UnitPeasant: () => (/* binding */ UnitPeasant)
/* harmony export */ });
/* harmony import */ var jsge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsge */ "./node_modules/jsge/src/index.js");
/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const.js */ "./src/const.js");
/* harmony import */ var jsge_src_base_2d_Primitives_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsge/src/base/2d/Primitives.js */ "./node_modules/jsge/src/base/2d/Primitives.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }


var countDistance = jsge__WEBPACK_IMPORTED_MODULE_0__.utils.countDistance,
  angle_2points = jsge__WEBPACK_IMPORTED_MODULE_0__.utils.angle_2points,
  randomFromArray = jsge__WEBPACK_IMPORTED_MODULE_0__.utils.randomFromArray;


var _draw = /*#__PURE__*/new WeakMap();
var _frame = /*#__PURE__*/new WeakMap();
var _isSelected = /*#__PURE__*/new WeakMap();
var _isShowHealth = /*#__PURE__*/new WeakMap();
var _healthMax = /*#__PURE__*/new WeakMap();
var _healthLeft = /*#__PURE__*/new WeakMap();
var _healthBarMaxWidth = /*#__PURE__*/new WeakMap();
var _healthBar = /*#__PURE__*/new WeakMap();
var BaseEntity = /*#__PURE__*/function (_DrawImageObject) {
  function BaseEntity(mapX, mapY, width, height, imageKey) {
    var _this;
    var imageIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    var drawImageFactory = arguments.length > 6 ? arguments[6] : undefined;
    var isShowHealth = arguments.length > 7 ? arguments[7] : undefined;
    var health = arguments.length > 8 ? arguments[8] : undefined;
    var boundaries = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;
    var spacing = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;
    var margin = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;
    _classCallCheck(this, BaseEntity);
    _this = _callSuper(this, BaseEntity, [mapX, mapY, width, height, imageKey, imageIndex, boundaries, null, spacing, margin]);
    /**
     * @type {undefined | DrawObjectFactory} 
     */
    _classPrivateFieldInitSpec(_this, _draw, void 0);
    /**
     * @type {undefined | null | DrawRectObject}
     */

    _classPrivateFieldInitSpec(_this, _frame, void 0);
    /**
     * @type {boolean}
     */
    _classPrivateFieldInitSpec(_this, _isSelected, false);
    _classPrivateFieldInitSpec(_this, _isShowHealth, false);
    _classPrivateFieldInitSpec(_this, _healthMax, void 0);
    _classPrivateFieldInitSpec(_this, _healthLeft, void 0);
    _classPrivateFieldInitSpec(_this, _healthBarMaxWidth, void 0);
    _classPrivateFieldInitSpec(_this, _healthBar, void 0);
    _classPrivateFieldSet(_draw, _this, drawImageFactory);
    _classPrivateFieldSet(_healthMax, _this, health);
    _classPrivateFieldSet(_healthLeft, _this, health);
    _classPrivateFieldSet(_isShowHealth, _this, isShowHealth);
    if (_classPrivateFieldGet(_isShowHealth, _this)) {
      _classPrivateFieldSet(_healthBarMaxWidth, _this, width / 3);
      _classPrivateFieldSet(_healthBar, _this, _classPrivateFieldGet(_draw, _this).rect(mapX - width / 5, mapY - height / 4, width / 3, 4, "rgba(255, 0, 0, 0.77)"));
      _classPrivateFieldGet(_healthBar, _this).sortIndex = 5;
    }
    console.log("set entity with key: ", imageKey, " health: ", health);
    return _this;
  }
  _inherits(BaseEntity, _DrawImageObject);
  return _createClass(BaseEntity, [{
    key: "health",
    get: function get() {
      return _classPrivateFieldGet(_healthLeft, this);
    },
    set: function set(value) {
      _classPrivateFieldSet(_healthLeft, this, value);
    }
  }, {
    key: "isSelected",
    get: function get() {
      return _classPrivateFieldGet(_isSelected, this);
    },
    set: function set(value) {
      _classPrivateFieldSet(_isSelected, this, value);
      if (value === true) {
        if (this.circleBoundaries) {
          _classPrivateFieldSet(_frame, this, _classPrivateFieldGet(_draw, this).circle(this.x, this.y, this.circleBoundaries.r, "rgba(255,255,255,0.2)"));
        } else {
          _classPrivateFieldSet(_frame, this, _classPrivateFieldGet(_draw, this).rect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height, "rgba(255,255,255,0.2)"));
        }
      } else if (_classPrivateFieldGet(_frame, this)) {
        console.log("remove frame");
        _classPrivateFieldGet(_frame, this).destroy();
      }
    }
  }, {
    key: "xPos",
    set: function set(newCoordX) {
      this.x = newCoordX;
      if (_classPrivateFieldGet(_isShowHealth, this)) {
        _classPrivateFieldGet(_healthBar, this).x = newCoordX - this.width / 5;
      }
      if (this.isSelected) {
        if (this.circleBoundaries) {
          this.frame.x = newCoordX;
        } else {
          this.frame.x = newCoordX - this.width / 2;
        }
      }
    }
  }, {
    key: "yPos",
    set: function set(newCoordY) {
      this.y = newCoordY;
      if (_classPrivateFieldGet(_isShowHealth, this)) {
        _classPrivateFieldGet(_healthBar, this).y = newCoordY - this.height / 4;
      }
      if (this.isSelected) {
        if (this.circleBoundaries) {
          this.frame.y = newCoordY;
        } else {
          this.frame.y = newCoordY - this.height / 2;
        }
      }
    }
  }, {
    key: "frame",
    get: function get() {
      return _classPrivateFieldGet(_frame, this);
    }
  }, {
    key: "healthBar",
    get: function get() {
      return _classPrivateFieldGet(_healthBar, this);
    }
  }, {
    key: "draw",
    get: function get() {
      return _classPrivateFieldGet(_draw, this);
    }
  }, {
    key: "reduceHealth",
    value: function reduceHealth(damage) {
      var healthLeft = this.health - damage,
        healthLeftPers = healthLeft > 0 ? healthLeft / _classPrivateFieldGet(_healthMax, this) : 0;
      this.health = healthLeft;
      if (_classPrivateFieldGet(_isShowHealth, this)) {
        _classPrivateFieldGet(_healthBar, this).width = healthLeftPers * _classPrivateFieldGet(_healthBarMaxWidth, this);
      }
    }
  }]);
}(jsge__WEBPACK_IMPORTED_MODULE_0__.DrawImageObject);
var _PROGRESS_STEP = /*#__PURE__*/new WeakMap();
var _unitBuildProgress = /*#__PURE__*/new WeakMap();
var _unitBuildDuration = /*#__PURE__*/new WeakMap();
var _selfBuildingDuration = /*#__PURE__*/new WeakMap();
var _selfBuildingProgress = /*#__PURE__*/new WeakMap();
var _eventsAggregator = /*#__PURE__*/new WeakMap();
var _unitProgressTimer = /*#__PURE__*/new WeakMap();
var _selfProgressTimer = /*#__PURE__*/new WeakMap();
var _progressLine = /*#__PURE__*/new WeakMap();
var _state = /*#__PURE__*/new WeakMap();
var _createProgressLine = /*#__PURE__*/new WeakMap();
var _startBuildUnitProgress = /*#__PURE__*/new WeakMap();
var _startSelfBuilding = /*#__PURE__*/new WeakMap();
var BaseBuilding = /*#__PURE__*/function (_BaseEntity2) {
  function BaseBuilding(mapX, mapY, width, height, entityKey) {
    var _this2;
    var imageIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    var drawFactory = arguments.length > 6 ? arguments[6] : undefined;
    var isShowHealth = arguments.length > 7 ? arguments[7] : undefined;
    var eventsAggregator = arguments.length > 8 ? arguments[8] : undefined;
    var isBuildDone = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : true;
    _classCallCheck(this, BaseBuilding);
    var imageKey = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS[entityKey].atlasKey ? _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS[entityKey].atlasKey : _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS[entityKey].name;
    console.log("base building set health: ", _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS[entityKey].health);
    _this2 = _callSuper(this, BaseBuilding, [mapX, mapY, width, height, imageKey, imageIndex, drawFactory, isShowHealth, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS[entityKey].health]);
    _classPrivateFieldInitSpec(_this2, _PROGRESS_STEP, 50);
    _classPrivateFieldInitSpec(_this2, _unitBuildProgress, 0);
    _classPrivateFieldInitSpec(_this2, _unitBuildDuration, 0);
    _classPrivateFieldInitSpec(_this2, _selfBuildingDuration, 0);
    /**
     * 0 - 1
     */
    _classPrivateFieldInitSpec(_this2, _selfBuildingProgress, void 0);
    _classPrivateFieldInitSpec(_this2, _eventsAggregator, void 0);
    _classPrivateFieldInitSpec(_this2, _unitProgressTimer, void 0);
    _classPrivateFieldInitSpec(_this2, _selfProgressTimer, void 0);
    _classPrivateFieldInitSpec(_this2, _progressLine, void 0);
    _classPrivateFieldInitSpec(_this2, _state, _const_js__WEBPACK_IMPORTED_MODULE_1__.BUILDING_STATE.BUILDING_SELF);
    _defineProperty(_this2, "buildUnit", function (unitType) {
      console.log("build unit: ", unitType);
      _classPrivateFieldSet(_state, _this2, _const_js__WEBPACK_IMPORTED_MODULE_1__.BUILDING_STATE.BUILDING_UNIT);
      switch (unitType) {
        case _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.PEASANT.name:
          _classPrivateFieldSet(_unitBuildDuration, _this2, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.PEASANT.duration);
          _classPrivateFieldGet(_createProgressLine, _this2).call(_this2);
          _classPrivateFieldGet(_startBuildUnitProgress, _this2).call(_this2);
          break;
      }
    });
    _classPrivateFieldInitSpec(_this2, _createProgressLine, function () {
      _classPrivateFieldSet(_progressLine, _this2, document.createElement("div")), console.log("create progress line");
      _classPrivateFieldGet(_progressLine, _this2).style.width = 0 + "px";
      _classPrivateFieldGet(_progressLine, _this2).style.height = "2px";
      _classPrivateFieldGet(_progressLine, _this2).style.backgroundColor = "#666";
      _classPrivateFieldGet(_progressLine, _this2).style.position = "fixed";
      _classPrivateFieldGet(_progressLine, _this2).style.top = 28 + "px";
      _classPrivateFieldGet(_progressLine, _this2).style.left = 0 + "px";
      document.body.appendChild(_classPrivateFieldGet(_progressLine, _this2));
    });
    _classPrivateFieldInitSpec(_this2, _startBuildUnitProgress, function () {
      console.log("start build progress");
      if (_classPrivateFieldGet(_unitProgressTimer, _this2)) {
        console.log("already building");
        return;
      }
      var duration = _classPrivateFieldGet(_selfBuildingDuration, _this2),
        windowWidth = document.body.offsetWidth,
        step = _classPrivateFieldGet(_PROGRESS_STEP, _this2),
        stepWidth = windowWidth / duration * 100;
      var currentWidth = stepWidth;
      _classPrivateFieldSet(_unitProgressTimer, _this2, setInterval(function () {
        if (_classPrivateFieldGet(_unitBuildProgress, _this2) < duration) {
          _classPrivateFieldSet(_unitBuildProgress, _this2, _classPrivateFieldGet(_unitBuildProgress, _this2) + step);
          currentWidth += stepWidth;
          _classPrivateFieldGet(_progressLine, _this2).style.width = currentWidth + "px";
          console.log("progress build");
        } else {
          console.log("progress done");
          clearInterval(_classPrivateFieldGet(_unitProgressTimer, _this2));
          _classPrivateFieldSet(_unitProgressTimer, _this2, null);
          _classPrivateFieldSet(_unitBuildProgress, _this2, 0);
          _classPrivateFieldGet(_progressLine, _this2).style.width = 0 + "px";
          _classPrivateFieldGet(_eventsAggregator, _this2).dispatchEvent(new CustomEvent(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.PEASANT_BUILT, {
            detail: _this2
          }));
          _classPrivateFieldSet(_state, _this2, _const_js__WEBPACK_IMPORTED_MODULE_1__.BUILDING_STATE.READY);
        }
      }, _classPrivateFieldGet(_PROGRESS_STEP, _this2)));
    });
    _classPrivateFieldInitSpec(_this2, _startSelfBuilding, function () {
      console.log("start self building");
      var duration = _classPrivateFieldGet(_selfBuildingDuration, _this2),
        windowWidth = document.body.offsetWidth,
        step = _classPrivateFieldGet(_PROGRESS_STEP, _this2),
        stepWidth = windowWidth / duration * 100;
      var currentWidth = stepWidth;
      _classPrivateFieldSet(_selfProgressTimer, _this2, setInterval(function () {
        if (_classPrivateFieldGet(_selfBuildingProgress, _this2) < duration) {
          _classPrivateFieldSet(_selfBuildingProgress, _this2, _classPrivateFieldGet(_selfBuildingProgress, _this2) + step);
          currentWidth += stepWidth;
          //this.#progressLine.style.width = currentWidth + "px";
          console.log("progress build");
        } else {
          console.log("progress done");
          clearInterval(_classPrivateFieldGet(_selfProgressTimer, _this2));
          _classPrivateFieldSet(_selfProgressTimer, _this2, null);
          _classPrivateFieldSet(_selfBuildingProgress, _this2, 0);
          //this.#progressLine.style.width = 0 + "px";
          _classPrivateFieldGet(_eventsAggregator, _this2).dispatchEvent(new CustomEvent(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.BUILDING_DONE, {
            detail: _this2
          }));
          _classPrivateFieldSet(_state, _this2, _const_js__WEBPACK_IMPORTED_MODULE_1__.BUILDING_STATE.READY);
        }
      }, _classPrivateFieldGet(_PROGRESS_STEP, _this2)));
    });
    _classPrivateFieldSet(_eventsAggregator, _this2, eventsAggregator);
    _classPrivateFieldSet(_selfBuildingDuration, _this2, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS[entityKey].duration);
    if (isBuildDone === false) {
      _classPrivateFieldGet(_startSelfBuilding, _this2).call(_this2);
      _classPrivateFieldSet(_selfBuildingProgress, _this2, 0);
    } else {
      _classPrivateFieldSet(_selfBuildingProgress, _this2, 100);
    }
    return _this2;
  }
  _inherits(BaseBuilding, _BaseEntity2);
  return _createClass(BaseBuilding, [{
    key: "isBuildingUnit",
    get: function get() {
      return !!_classPrivateFieldGet(_unitProgressTimer, this);
    }
  }, {
    key: "state",
    get: function get() {
      return _classPrivateFieldGet(_state, this);
    }
  }, {
    key: "die",
    value: function die() {
      if (this.frame) {
        this.frame.destroy();
      }
      if (this.healthBar) {
        this.healthBar.destroy();
      }
      this.destroy();
    }
  }]);
}(BaseEntity);
var UnitGoblinHouse = /*#__PURE__*/function (_BaseBuilding2) {
  function UnitGoblinHouse(mapX, mapY, drawImageFactory, isShowHealth) {
    var _this3;
    _classCallCheck(this, UnitGoblinHouse);
    console.log("set g house, with key: ", _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.GOBLIN_HOUSE.name);
    _this3 = _callSuper(this, UnitGoblinHouse, [mapX, mapY, 192, 192, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.GOBLIN_HOUSE.name, 20, drawImageFactory, isShowHealth]);
    _defineProperty(_this3, "die", function () {
      var grave = _this3.draw.image(_this3.x, _this3.y, 192, 192, "192x192", 21, "rgba(0, 0, 0, 1)");
      grave.sortIndex = 1;
      _this3.imageIndex = 22;
      _superPropGet((_this3, UnitGoblinHouse), "die", _this3, 3)([]);
    });
    return _this3;
  }
  _inherits(UnitGoblinHouse, _BaseBuilding2);
  return _createClass(UnitGoblinHouse);
}(BaseBuilding);
var UnitGoblinTower = /*#__PURE__*/function (_BaseBuilding3) {
  function UnitGoblinTower(mapX, mapY, drawImageFactory, isShowHealth) {
    var _this4;
    _classCallCheck(this, UnitGoblinTower);
    console.log("set g house, with key: ", _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.GOBLIN_TOWER.name);
    _this4 = _callSuper(this, UnitGoblinTower, [mapX, mapY, 192, 192, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.GOBLIN_TOWER.name, 24, drawImageFactory, isShowHealth]);
    _defineProperty(_this4, "activateIdle", function () {
      ;
      _this4.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TOWER.ANIMATIONS.IDLE);
    });
    _defineProperty(_this4, "die", function () {
      var grave = _this4.draw.image(_this4.x, _this4.y, 192, 192, "192x192", 22, "rgba(0, 0, 0, 1)");
      grave.sortIndex = 1;
      _this4.imageIndex = 22;
      _superPropGet((_this4, UnitGoblinTower), "die", _this4, 3)([]);
    });
    _this4.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TOWER.ANIMATIONS.IDLE, [{
      duration: 200,
      id: 24
    }, {
      duration: 200,
      id: 25
    }, {
      duration: 200,
      id: 26
    }, {
      duration: 200,
      id: 27
    }], true);
    return _this4;
  }
  _inherits(UnitGoblinTower, _BaseBuilding3);
  return _createClass(UnitGoblinTower);
}(BaseBuilding);
var _targetPoint = /*#__PURE__*/new WeakMap();
var _unitTactic = /*#__PURE__*/new WeakMap();
var BaseUnit = /*#__PURE__*/function (_BaseEntity3) {
  function BaseUnit(_x, _y, w, h, entityKey, imageIndex, drawFactory, isShowHealth, boundaries, spacing, margin) {
    var _this5;
    _classCallCheck(this, BaseUnit);
    var imageKey = _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS[entityKey].atlasKey ? _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS[entityKey].atlasKey : _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS[entityKey].name;
    _this5 = _callSuper(this, BaseUnit, [_x, _y, w, h, imageKey, imageIndex, drawFactory, isShowHealth, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS[entityKey].health, boundaries, spacing, margin]);
    _classPrivateFieldInitSpec(_this5, _targetPoint, void 0);
    _classPrivateFieldInitSpec(_this5, _unitTactic, _const_js__WEBPACK_IMPORTED_MODULE_1__.UNIT_TACTIC.AGGRESSIVE);
    _defineProperty(_this5, "countNextStep", function () {
      var x = _this5.x,
        y = _this5.y,
        tX = _classPrivateFieldGet(_targetPoint, _this5)[0],
        tY = _classPrivateFieldGet(_targetPoint, _this5)[1],
        forceToUse = 0.4,
        //this.#moveSpeed,
        direction = angle_2points(x, y, tX, tY),
        newCoordX = x + forceToUse * Math.cos(direction),
        newCoordY = y + forceToUse * Math.sin(direction);
      return {
        x: newCoordX,
        y: newCoordY
      };
    });
    return _this5;
  }
  _inherits(BaseUnit, _BaseEntity3);
  return _createClass(BaseUnit, [{
    key: "die",
    value: function die() {
      var grave = this.draw.image(this.x, this.y, 192, 192, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_OBJECTS.SKILL.atlasKey, 160, "rgba(0, 0, 0, 1)");
      grave.sortIndex = 1;
      grave.addAnimation("graveAppear", [160, 161, 162, 163, 164, 165, 168, 169, 170, 171, 172, 173, 174]);
      grave.emit("graveAppear");
      if (this.frame) {
        this.frame.destroy();
      }
      if (this.healthBar) {
        this.healthBar.destroy();
      }
      this.destroy();
    }
  }, {
    key: "unitTactic",
    get: function get() {
      return _classPrivateFieldGet(_unitTactic, this);
    },
    set: function set(value) {
      _classPrivateFieldSet(_unitTactic, this, value);
    }
  }, {
    key: "targetPoint",
    get: function get() {
      return _classPrivateFieldGet(_targetPoint, this);
    },
    set: function set(tp) {
      _classPrivateFieldSet(_targetPoint, this, tp);
    }
  }]);
}(BaseEntity);
var _activeAction = /*#__PURE__*/new WeakMap();
var _targetTree = /*#__PURE__*/new WeakMap();
var _grabGoldmine = /*#__PURE__*/new WeakMap();
var _closestTownCenter = /*#__PURE__*/new WeakMap();
var _hasGold = /*#__PURE__*/new WeakMap();
var _hasWood = /*#__PURE__*/new WeakMap();
var _woodAmount = /*#__PURE__*/new WeakMap();
var _buildingType = /*#__PURE__*/new WeakMap();
var _eventsAggregator2 = /*#__PURE__*/new WeakMap();
var _goldBag = /*#__PURE__*/new WeakMap();
var _woodBunch = /*#__PURE__*/new WeakMap();
var _audio = /*#__PURE__*/new WeakMap();
var _createGoldBunch = /*#__PURE__*/new WeakMap();
var _removeGoldBunch = /*#__PURE__*/new WeakMap();
var _createWoodBunch = /*#__PURE__*/new WeakMap();
var _removeWoodBunch = /*#__PURE__*/new WeakMap();
var UnitPeasant = /*#__PURE__*/function (_BaseUnit2) {
  function UnitPeasant(mapX, mapY, closestTownCenter, drawFactory, isShowHealth, eventsAggregator, audio) {
    var _this6;
    _classCallCheck(this, UnitPeasant);
    _this6 = _callSuper(this, UnitPeasant, [mapX, mapY, 192, 192, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.PEASANT.name, 272, drawFactory, isShowHealth, {
      r: 30
    }]);
    /**
     * @type {string}
     */
    _classPrivateFieldInitSpec(_this6, _activeAction, void 0);
    _classPrivateFieldInitSpec(_this6, _targetTree, void 0);
    _classPrivateFieldInitSpec(_this6, _grabGoldmine, void 0);
    _classPrivateFieldInitSpec(_this6, _closestTownCenter, void 0);
    _classPrivateFieldInitSpec(_this6, _hasGold, void 0);
    _classPrivateFieldInitSpec(_this6, _hasWood, void 0);
    _classPrivateFieldInitSpec(_this6, _woodAmount, 0);
    _classPrivateFieldInitSpec(_this6, _buildingType, void 0);
    _classPrivateFieldInitSpec(_this6, _eventsAggregator2, void 0);
    _classPrivateFieldInitSpec(_this6, _goldBag, null);
    _classPrivateFieldInitSpec(_this6, _woodBunch, null);
    _classPrivateFieldInitSpec(_this6, _audio, void 0);
    _defineProperty(_this6, "activateGrabGold", function (mine) {
      console.log("start collecting gold");
      _classPrivateFieldSet(_grabGoldmine, _this6, mine);
      _classPrivateFieldSet(_activeAction, _this6, _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ACTIONS.DRAG_GOLD);
    });
    _defineProperty(_this6, "activateIdle", function () {
      var isClicked = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      _classPrivateFieldSet(_activeAction, _this6, _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ACTIONS.IDLE);
      var activeAnimation = _this6.activeAnimation;
      if (activeAnimation) {
        _this6.stopRepeatedAnimation(activeAnimation);
      }
      if (_classPrivateFieldGet(_hasGold, _this6) || _classPrivateFieldGet(_hasWood, _this6)) {
        _this6.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.CARRY_IDLE_RIGHT);
      } else {
        _this6.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.IDLE_RIGHT);
      }
      if (isClicked) {
        randomFromArray(_classPrivateFieldGet(_audio, _this6).get(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.WHAT)).play();
      }
    });
    _defineProperty(_this6, "activateDragTree", function (tree) {
      _classPrivateFieldSet(_activeAction, _this6, _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ACTIONS.DRAG_WOOD);
      if (tree) {
        _classPrivateFieldSet(_targetTree, _this6, tree);
      }
    });
    _defineProperty(_this6, "activateChopTree", function () {
      _classPrivateFieldSet(_activeAction, _this6, _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ACTIONS.CHOP_WOOD);
    });
    _defineProperty(_this6, "askForClosestTree", function () {
      _classPrivateFieldGet(_eventsAggregator2, _this6).dispatchEvent(new CustomEvent(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.REQUEST_FOR_CLOSEST_TREE, {
        detail: {
          peasant: _this6,
          tree: _classPrivateFieldGet(_targetTree, _this6)
        }
      }));
    });
    _defineProperty(_this6, "dragWood", function () {
      if (_classPrivateFieldGet(_hasWood, _this6)) {
        // move to the TownCenter
        var tX = _classPrivateFieldGet(_closestTownCenter, _this6).x,
          tY = _classPrivateFieldGet(_closestTownCenter, _this6).y;
        if (countDistance(_this6, {
          x: tX,
          y: tY
        }) < 25) {
          // reached
          _classPrivateFieldGet(_removeWoodBunch, _this6).call(_this6);
        } else {
          _this6.targetPoint = [tX, tY];
          _this6.stepMoveWith();
        }
      } else {
        // move to the Gold mine
        var _tX = _classPrivateFieldGet(_targetTree, _this6).x,
          _tY = _classPrivateFieldGet(_targetTree, _this6).y;
        if (_classPrivateFieldGet(_targetTree, _this6).health <= 0) {
          console.log("stop drag tree");
          _this6.activateIdle();
          _this6.askForClosestTree();
        } else if (countDistance(_this6, {
          x: _tX,
          y: _tY
        }) < 8) {
          // reached
          _this6.activateChopTree();
        } else {
          _this6.targetPoint = [_tX, _tY];
          _this6.stepMoveWith();
        }
      }
    });
    _defineProperty(_this6, "grabGold", function () {
      if (_classPrivateFieldGet(_hasGold, _this6)) {
        // move to the TownCenter
        var tX = _classPrivateFieldGet(_closestTownCenter, _this6).x,
          tY = _classPrivateFieldGet(_closestTownCenter, _this6).y;
        if (countDistance(_this6, {
          x: tX,
          y: tY
        }) < 25) {
          _classPrivateFieldGet(_removeGoldBunch, _this6).call(_this6);
        } else {
          _this6.targetPoint = [tX, tY];
          _this6.stepMoveWith();
        }
      } else {
        // move to the Gold mine
        var _tX2 = _classPrivateFieldGet(_grabGoldmine, _this6).x,
          _tY2 = _classPrivateFieldGet(_grabGoldmine, _this6).y;
        if (_classPrivateFieldGet(_grabGoldmine, _this6).goldAmount <= 0) {
          console.log("gold mine is empty");
          _this6.activateIdle();
        } else if (countDistance(_this6, {
          x: _tX2,
          y: _tY2
        }) < 8) {
          _classPrivateFieldGet(_createGoldBunch, _this6).call(_this6);
        } else {
          _this6.targetPoint = [_tX2, _tY2];
          _this6.stepMoveWith();
        }
      }
    });
    _defineProperty(_this6, "chopTree", function () {
      if (_classPrivateFieldGet(_woodAmount, _this6) < 10) {
        _classPrivateFieldSet(_woodAmount, _this6, Math.round((_classPrivateFieldGet(_woodAmount, _this6) + .05) * 100) / 100);
        _classPrivateFieldGet(_targetTree, _this6).health = Math.round((_classPrivateFieldGet(_targetTree, _this6).health - .05) * 100) / 100;
        var direction = angle_2points(_this6.x, _this6.y, _classPrivateFieldGet(_targetTree, _this6).x, _classPrivateFieldGet(_targetTree, _this6).y);
        if (direction >= -Math.PI / 2 && direction <= Math.PI / 2) {
          //console.log("chop right");
          if (_this6.activeAnimation !== _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.CHOP_RIGHT) {
            _this6.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.CHOP_RIGHT);
          }
        } else if (direction > Math.PI / 2 || direction < -Math.PI / 2) {
          //console.log("chop left");
          if (_this6.activeAnimation !== _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.CHOP_LEFT) {
            _this6.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.CHOP_LEFT);
          }
        }
      } else {
        console.log(_classPrivateFieldGet(_woodAmount, _this6));
        _classPrivateFieldGet(_createWoodBunch, _this6).call(_this6);
      }
    });
    _defineProperty(_this6, "stepMoveWith", function () {
      var x = _this6.x,
        y = _this6.y,
        tX = _this6.targetPoint[0],
        tY = _this6.targetPoint[1],
        hasGold = _classPrivateFieldGet(_hasGold, _this6) || _classPrivateFieldGet(_hasWood, _this6);
      var forceToUse = 0.4,
        //this.#moveSpeed,
        direction = angle_2points(x, y, tX, tY),
        newCoordX = x + forceToUse * Math.cos(direction),
        newCoordY = y + forceToUse * Math.sin(direction);
      if (direction >= -Math.PI / 2 && direction <= Math.PI / 2) {
        //console.log("move right");
        if (hasGold && _this6.activeAnimation !== _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.CARRY_RIGHT) {
          _this6.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.CARRY_RIGHT);
        } else if (!hasGold && _this6.activeAnimation !== _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.MOVE_RIGHT) _this6.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.MOVE_RIGHT);
      } else if (direction > Math.PI / 2 || direction < -Math.PI / 2) {
        //console.log("move left");
        if (hasGold && _this6.activeAnimation !== _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.CARRY_LEFT) {
          _this6.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.CARRY_LEFT);
        } else if (!hasGold && _this6.activeAnimation !== _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.MOVE_LEFT) _this6.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.MOVE_LEFT);
      } else {
        console.log("unrecognized move to ", direction);
      }
      _this6.xPos = newCoordX;
      _this6.yPos = newCoordY;
      if (_classPrivateFieldGet(_hasGold, _this6)) {
        _classPrivateFieldGet(_goldBag, _this6).x = newCoordX;
        _classPrivateFieldGet(_goldBag, _this6).y = newCoordY - _this6.height / 4;
      }
      if (_classPrivateFieldGet(_hasWood, _this6)) {
        _classPrivateFieldGet(_woodBunch, _this6).x = newCoordX;
        _classPrivateFieldGet(_woodBunch, _this6).y = newCoordY - _this6.height / 4;
      }
    });
    _defineProperty(_this6, "stepMove", function () {
      var x = _this6.x,
        y = _this6.y,
        tX = _this6.targetPoint[0],
        tY = _this6.targetPoint[1];
      if (countDistance(_this6, {
        x: tX,
        y: tY
      }) < 5) {
        console.log("reached");
        _this6.activateIdle();
      } else {
        var forceToUse = 0.4,
          //this.#moveSpeed,
          direction = angle_2points(x, y, tX, tY),
          newCoordX = x + forceToUse * Math.cos(direction),
          newCoordY = y + forceToUse * Math.sin(direction);
        if (direction >= -Math.PI / 2 && direction <= Math.PI / 2) {
          //console.log("move right");
          if (_this6.activeAnimation !== _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.MOVE_RIGHT) _this6.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.MOVE_RIGHT);
        } else if (direction > Math.PI / 2 || direction < -Math.PI / 2) {
          //console.log("move left");
          if (_this6.activeAnimation !== _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.MOVE_LEFT) _this6.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.MOVE_LEFT);
        } else {
          console.log("unrecognized move to ", direction);
        }
        _this6.xPos = newCoordX;
        _this6.yPos = newCoordY;
      }
    });
    _classPrivateFieldInitSpec(_this6, _createGoldBunch, function () {
      // reached
      _classPrivateFieldGet(_eventsAggregator2, _this6).dispatchEvent(new CustomEvent(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.GOLD_GRAB, {
        detail: {
          peasantId: _this6.id
        }
      }));
    });
    _classPrivateFieldInitSpec(_this6, _removeGoldBunch, function () {
      // reached
      _classPrivateFieldSet(_hasGold, _this6, false);
      _classPrivateFieldGet(_goldBag, _this6).destroy();
      //console.log("+ 10 gold milord!!");
      _classPrivateFieldGet(_eventsAggregator2, _this6).dispatchEvent(new CustomEvent(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.GOLD_MINED, {
        detail: {
          peasantId: _this6.id,
          amount: 10
        }
      }));
    });
    _classPrivateFieldInitSpec(_this6, _createWoodBunch, function () {
      _classPrivateFieldGet(_eventsAggregator2, _this6).dispatchEvent(new CustomEvent(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.WOOD_GRAB, {
        detail: {
          peasantId: _this6.id
        }
      }));
    });
    _classPrivateFieldInitSpec(_this6, _removeWoodBunch, function () {
      _classPrivateFieldSet(_hasWood, _this6, false);
      _classPrivateFieldSet(_woodAmount, _this6, 0);
      _classPrivateFieldGet(_woodBunch, _this6).destroy();
      //console.log("+ 10 gold milord!!");
      _classPrivateFieldGet(_eventsAggregator2, _this6).dispatchEvent(new CustomEvent(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.WOOD_MINED, {
        detail: {
          peasantId: _this6.id,
          amount: 10
        }
      }));
    });
    _defineProperty(_this6, "activateStartBuilding", function (targetX, targetY, type) {
      _classPrivateFieldSet(_activeAction, _this6, _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ACTIONS.BUILD);
      _this6.targetPoint = [targetX, targetY];
      _classPrivateFieldSet(_buildingType, _this6, type);
    });
    _defineProperty(_this6, "activateMoveToTargetPoint", function (targetX, targetY) {
      var saySomething = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      _classPrivateFieldSet(_activeAction, _this6, _const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ACTIONS.MOVE);
      _this6.targetPoint = [targetX, targetY];
      if (saySomething && _classPrivateFieldGet(_audio, _this6).has(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.YES)) {
        randomFromArray(_classPrivateFieldGet(_audio, _this6).get(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.YES)).play();
      }
    });
    _defineProperty(_this6, "addGoldBag", function (goldBag) {
      _classPrivateFieldSet(_hasGold, _this6, true);
      _classPrivateFieldSet(_goldBag, _this6, goldBag);
      _classPrivateFieldGet(_grabGoldmine, _this6).goldAmount -= 10;
      if (_classPrivateFieldGet(_grabGoldmine, _this6).goldAmount <= 0) {
        _classPrivateFieldGet(_eventsAggregator2, _this6).dispatchEvent(new CustomEvent(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.GOLD_MINE_EMPTY, {
          detail: _classPrivateFieldGet(_grabGoldmine, _this6)
        }));
      }
    });
    _defineProperty(_this6, "addWoodBunch", function (woodBunch) {
      _classPrivateFieldSet(_hasWood, _this6, true);
      _classPrivateFieldSet(_woodBunch, _this6, woodBunch);
      _this6.activateDragTree();
      if (_classPrivateFieldGet(_targetTree, _this6).health <= 0) {
        _classPrivateFieldGet(_eventsAggregator2, _this6).dispatchEvent(new CustomEvent(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.TREE_EMPTY, {
          detail: _classPrivateFieldGet(_targetTree, _this6)
        }));
      }
    });
    _this6.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.IDLE_RIGHT, [272, 273, 274, 275, 276, 277], true);
    _this6.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.IDLE_LEFT, [285, 284, 283, 282, 281, 280], true);
    _this6.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.MOVE_RIGHT, [288, 289, 290, 291, 292, 293], true);
    _this6.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.MOVE_LEFT, [301, 300, 299, 298, 297, 296], true);
    _this6.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.BUILD_RIGHT, [304, 305, 306, 307, 308, 309], true);
    _this6.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.BUILD_LEFT, [317, 316, 315, 314, 313, 312], true);
    _this6.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.CHOP_RIGHT, [320, 321, 322, 323, 324, 325], true);
    _this6.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.CHOP_LEFT, [333, 332, 331, 330, 329, 328], true);
    _this6.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.CARRY_IDLE_RIGHT, [336, 337, 338, 339, 340, 341], true);
    _this6.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.CARRY_IDLE_LEFT, [349, 348, 347, 346, 345, 344], true);
    _this6.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.CARRY_RIGHT, [352, 353, 354, 355, 356, 357], true);
    _this6.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.PEASANT.ANIMATIONS.CARRY_LEFT, [365, 364, 363, 362, 361, 360], true);
    _classPrivateFieldSet(_closestTownCenter, _this6, closestTownCenter);
    _classPrivateFieldSet(_eventsAggregator2, _this6, eventsAggregator);
    _classPrivateFieldSet(_audio, _this6, audio);
    _this6.sortIndex = 2;
    _this6.unitTactic = _const_js__WEBPACK_IMPORTED_MODULE_1__.UNIT_TACTIC.RUN_AWAY;
    return _this6;
  }
  _inherits(UnitPeasant, _BaseUnit2);
  return _createClass(UnitPeasant, [{
    key: "activeAction",
    get: function get() {
      return _classPrivateFieldGet(_activeAction, this);
    }
  }, {
    key: "targetTree",
    get: function get() {
      return _classPrivateFieldGet(_targetTree, this);
    }
  }, {
    key: "buildingType",
    get: function get() {
      return _classPrivateFieldGet(_buildingType, this);
    }
  }, {
    key: "die",
    value: function die() {
      this.activateIdle();
      _superPropGet(UnitPeasant, "die", this, 3)([]);
    }
  }]);
}(BaseUnit);
var _activeAction2 = /*#__PURE__*/new WeakMap();
var _buildingType2 = /*#__PURE__*/new WeakMap();
var _eventsAggregator3 = /*#__PURE__*/new WeakMap();
var _attackInterval = /*#__PURE__*/new WeakMap();
var _audio2 = /*#__PURE__*/new WeakMap();
var _audioInProgress = /*#__PURE__*/new WeakMap();
var _attackAction = /*#__PURE__*/new WeakMap();
var _stopActiveAudio = /*#__PURE__*/new WeakMap();
var _playAudio = /*#__PURE__*/new WeakMap();
var UnitKnight = /*#__PURE__*/function (_BaseUnit3) {
  function UnitKnight(mapX, mapY, drawFactory, isShowHealth, eventsAggregator, audio) {
    var _this7;
    _classCallCheck(this, UnitKnight);
    _this7 = _callSuper(this, UnitKnight, [mapX, mapY, 192, 192, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.KNIGHT.name, 0, drawFactory, isShowHealth, {
      r: 30
    }]);
    /**
     * @type {string}
     */
    _classPrivateFieldInitSpec(_this7, _activeAction2, void 0);
    _classPrivateFieldInitSpec(_this7, _buildingType2, void 0);
    _classPrivateFieldInitSpec(_this7, _eventsAggregator3, void 0);
    _classPrivateFieldInitSpec(_this7, _attackInterval, void 0);
    _classPrivateFieldInitSpec(_this7, _audio2, void 0);
    _classPrivateFieldInitSpec(_this7, _audioInProgress, void 0);
    _defineProperty(_this7, "activateIdle", function () {
      var isClicked = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      _classPrivateFieldSet(_activeAction2, _this7, _const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ACTIONS.IDLE);
      var activeAnimation = _this7.activeAnimation;
      if (activeAnimation === _const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.MOVE_LEFT || activeAnimation === _const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.IDLE_LEFT) {
        _this7.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.IDLE_LEFT);
      } else {
        _this7.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.IDLE_RIGHT);
      }
      _classPrivateFieldGet(_stopActiveAudio, _this7).call(_this7);
      if (isClicked) {
        randomFromArray(_classPrivateFieldGet(_audio2, _this7).get(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.WHAT)).play();
      }
      if (_classPrivateFieldGet(_attackInterval, _this7)) {
        clearInterval(_classPrivateFieldGet(_attackInterval, _this7));
        _classPrivateFieldSet(_attackInterval, _this7, null);
      }
    });
    _defineProperty(_this7, "activateAttack", function (unit) {
      if (_classPrivateFieldGet(_activeAction2, _this7) !== _const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ACTIONS.FIGHT) {
        clearInterval(_classPrivateFieldGet(_attackInterval, _this7));
        _classPrivateFieldSet(_activeAction2, _this7, _const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ACTIONS.FIGHT);
        _classPrivateFieldGet(_attackAction, _this7).call(_this7, unit);
        _classPrivateFieldSet(_attackInterval, _this7, setInterval(function () {
          return _classPrivateFieldGet(_attackAction, _this7).call(_this7, unit);
        }, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.KNIGHT.attackSpeed));
      }
    });
    _classPrivateFieldInitSpec(_this7, _attackAction, function (unit) {
      if (unit && unit.health > 0) {
        var x = _this7.x,
          y = _this7.y,
          tX = unit.x,
          tY = unit.y,
          direction = angle_2points(x, y, tX, tY);
        _classPrivateFieldGet(_stopActiveAudio, _this7).call(_this7);
        _classPrivateFieldGet(_playAudio, _this7).call(_this7, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.FIGHT);
        console.log("enemy direction: ", direction);
        if (direction >= -Math.PI / 4 && direction <= Math.PI / 4) {
          //console.log("move right");
          _this7.emit(jsge__WEBPACK_IMPORTED_MODULE_0__.utils.randomFromArray([_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.FIGHT_RIGHT_1, _const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.FIGHT_RIGHT_2]));
        } else if (direction >= Math.PI / 4 && direction < 3 * Math.PI / 4) {
          //	//console.log("move down");
          _this7.emit(jsge__WEBPACK_IMPORTED_MODULE_0__.utils.randomFromArray([_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.FIGHT_DOWN_1, _const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.FIGHT_DOWN_2]));
        } else if (direction >= 3 * Math.PI / 4 || direction <= -3 * Math.PI / 4) {
          //console.log("move left");
          _this7.emit(jsge__WEBPACK_IMPORTED_MODULE_0__.utils.randomFromArray([_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.FIGHT_LEFT_1, _const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.FIGHT_LEFT_2]));
        } else if (direction > -3 * Math.PI / 4 && direction < Math.PI / 4) {
          //console.log("move up");
          _this7.emit(jsge__WEBPACK_IMPORTED_MODULE_0__.utils.randomFromArray([_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.FIGHT_UP_1, _const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.FIGHT_UP_2]));
        } else {
          console.log("unrecognized move to ", direction);
        }
        unit.reduceHealth(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.KNIGHT.attackDamage);
      } else {
        console.log("die!");
        if (unit && unit.isRemoved === false) {
          unit.die();
        }
        _this7.activateIdle();
      }
    });
    _defineProperty(_this7, "stepMove", function (newCoordX, newCoordY) {
      var x = _this7.x,
        y = _this7.y,
        tX = _this7.targetPoint[0],
        tY = _this7.targetPoint[1];
      if (countDistance(_this7, {
        x: tX,
        y: tY
      }) < 5) {
        console.log("reached");
        _this7.activateIdle();
      } else {
        var direction = angle_2points(x, y, tX, tY);
        if (direction > -Math.PI / 4 && direction < Math.PI / 4) {
          //console.log("move right");
          //this.emit(KNIGHT.ANIMATIONS.MOVE);
        } else if (direction >= Math.PI / 4 && direction < 3 * Math.PI / 4) {
          //console.log("move down");
          //this.emit(KNIGHT.ANIMATIONS.MOVE);
        } else if (direction > 3 * Math.PI / 4 || direction < -3 * Math.PI / 4) {
          //console.log("move left");
          //this.emit(KNIGHT.ANIMATIONS.MOVE);
        } else if (direction > -3 * Math.PI / 4 && direction < Math.PI / 4) {
          //console.log("move up");
          //this.emit(KNIGHT.ANIMATIONS.MOVE);
        } else {
          console.log("unrecognized move to ", direction);
        }
        _this7.xPos = newCoordX;
        _this7.yPos = newCoordY;
      }
    });
    _defineProperty(_this7, "activateMoveToTargetPoint", function (targetX, targetY) {
      var saySomething = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      _classPrivateFieldSet(_activeAction2, _this7, _const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ACTIONS.MOVE);
      _this7.targetPoint = [targetX, targetY];
      //this.emit(KNIGHT.ANIMATIONS.MOVE);
      var direction = angle_2points(_this7.x, _this7.y, targetX, targetY);
      if (direction >= -Math.PI / 2 && direction <= Math.PI / 2) {
        //console.log("move right");
        _this7.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.MOVE_RIGHT);
      } else if (direction > Math.PI / 2 || direction < -Math.PI / 2) {
        //console.log("move left");
        _this7.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.MOVE_LEFT);
      } else {
        console.log("unrecognized move to ", direction);
      }
      if (_classPrivateFieldGet(_attackInterval, _this7)) {
        clearInterval(_classPrivateFieldGet(_attackInterval, _this7));
        _classPrivateFieldSet(_attackInterval, _this7, null);
      }
      if (saySomething) {
        randomFromArray(_classPrivateFieldGet(_audio2, _this7).get(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.YES)).play();
      }
    });
    _classPrivateFieldInitSpec(_this7, _stopActiveAudio, function () {
      if (_classPrivateFieldGet(_audioInProgress, _this7)) {
        //this.#audioInProgress.pause();
      }
    });
    _classPrivateFieldInitSpec(_this7, _playAudio, function (audioType) {
      var loop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (_classPrivateFieldGet(_audioInProgress, _this7)) {
        //this.#audioInProgress.pause();
      }
      var audioEl = _classPrivateFieldGet(_audio2, _this7).get(audioType);
      if (audioEl) {
        _classPrivateFieldSet(_audioInProgress, _this7, randomFromArray(_classPrivateFieldGet(_audio2, _this7).get(audioType)));
        //console.log(audio);
        _classPrivateFieldGet(_audioInProgress, _this7).loop = loop;
        _classPrivateFieldGet(_audioInProgress, _this7).play();
      } else {
        throw new Error("audio " + audioType + " is not defined");
      }
    });
    _defineProperty(_this7, "die", function () {
      _this7.activateIdle();
      _classPrivateFieldGet(_playAudio, _this7).call(_this7, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.DEATH);
      _superPropGet((_this7, UnitKnight), "die", _this7, 3)([]);
    });
    _this7.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.IDLE_RIGHT, [0, 1, 2, 3, 4, 5], true);
    _this7.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.MOVE_RIGHT, [8, 9, 10, 11, 12, 13], true);
    _this7.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.FIGHT_RIGHT_1, [16, 17, 18, 19, 20, 21], true);
    _this7.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.FIGHT_RIGHT_2, [24, 25, 26, 27, 28, 29], true);
    _this7.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.IDLE_LEFT, [37, 36, 35, 34, 33, 32], true);
    _this7.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.MOVE_LEFT, [45, 44, 43, 42, 41, 40], true);
    _this7.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.FIGHT_LEFT_1, [53, 52, 51, 50, 49, 48], true);
    _this7.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.FIGHT_LEFT_2, [61, 60, 59, 58, 57, 56], true);
    _this7.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.FIGHT_DOWN_1, [64, 65, 66, 67, 68, 69], true);
    _this7.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.FIGHT_DOWN_2, [72, 73, 74, 75, 76, 77], true);
    _this7.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.FIGHT_UP_1, [80, 81, 82, 83, 84, 85], true);
    _this7.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.KNIGHT.ANIMATIONS.FIGHT_UP_2, [88, 89, 90, 91, 92, 93], true);
    _classPrivateFieldSet(_eventsAggregator3, _this7, eventsAggregator);
    _classPrivateFieldSet(_audio2, _this7, audio);
    _this7.sortIndex = 2;
    return _this7;
  }
  _inherits(UnitKnight, _BaseUnit3);
  return _createClass(UnitKnight, [{
    key: "activeAction",
    get: function get() {
      return _classPrivateFieldGet(_activeAction2, this);
    }
  }, {
    key: "buildingType",
    get: function get() {
      return _classPrivateFieldGet(_buildingType2, this);
    }
  }]);
}(BaseUnit);
var _activeAction3 = /*#__PURE__*/new WeakMap();
var _buildingType3 = /*#__PURE__*/new WeakMap();
var _eventsAggregator4 = /*#__PURE__*/new WeakMap();
var _attackInterval2 = /*#__PURE__*/new WeakMap();
var _audio3 = /*#__PURE__*/new WeakMap();
var _audioInProgress2 = /*#__PURE__*/new WeakMap();
var _attackAction2 = /*#__PURE__*/new WeakMap();
var _stopActiveAudio2 = /*#__PURE__*/new WeakMap();
var _playAudio2 = /*#__PURE__*/new WeakMap();
var UnitArcher = /*#__PURE__*/function (_BaseUnit4) {
  function UnitArcher(mapX, mapY, drawFactory, isShowHealth, eventsAggregator, audio) {
    var _this8;
    _classCallCheck(this, UnitArcher);
    _this8 = _callSuper(this, UnitArcher, [mapX, mapY, 192, 192, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.ARCHER.name, 176, drawFactory, isShowHealth, {
      r: 30
    }]);
    /**
     * @type {string}
     */
    _classPrivateFieldInitSpec(_this8, _activeAction3, void 0);
    _classPrivateFieldInitSpec(_this8, _buildingType3, void 0);
    _classPrivateFieldInitSpec(_this8, _eventsAggregator4, void 0);
    _classPrivateFieldInitSpec(_this8, _attackInterval2, void 0);
    _classPrivateFieldInitSpec(_this8, _audio3, void 0);
    _classPrivateFieldInitSpec(_this8, _audioInProgress2, void 0);
    _defineProperty(_this8, "activateIdle", function () {
      var isClicked = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      _classPrivateFieldSet(_activeAction3, _this8, _const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ACTIONS.IDLE);
      var activeAnimation = _this8.activeAnimation;
      console.log("idle++++>>>>");
      console.log(activeAnimation);
      if (activeAnimation === _const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ANIMATIONS.MOVE_LEFT || activeAnimation === _const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ANIMATIONS.IDLE_LEFT) {
        _this8.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ANIMATIONS.IDLE_LEFT);
      } else {
        _this8.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ANIMATIONS.IDLE_RIGHT);
      }
      _classPrivateFieldGet(_stopActiveAudio2, _this8).call(_this8);
      if (isClicked) {
        randomFromArray(_classPrivateFieldGet(_audio3, _this8).get(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.WHAT)).play();
      }
      if (_classPrivateFieldGet(_attackInterval2, _this8)) {
        clearInterval(_classPrivateFieldGet(_attackInterval2, _this8));
        _classPrivateFieldSet(_attackInterval2, _this8, null);
      }
    });
    _defineProperty(_this8, "activateAttack", function (unit) {
      if (_classPrivateFieldGet(_activeAction3, _this8) !== _const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ACTIONS.FIGHT) {
        clearInterval(_classPrivateFieldGet(_attackInterval2, _this8));
        _classPrivateFieldSet(_activeAction3, _this8, _const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ACTIONS.FIGHT);
        _classPrivateFieldGet(_attackAction2, _this8).call(_this8, unit);
        _classPrivateFieldSet(_attackInterval2, _this8, setInterval(function () {
          return _classPrivateFieldGet(_attackAction2, _this8).call(_this8, unit);
        }, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.ARCHER.attackSpeed));
      }
    });
    _classPrivateFieldInitSpec(_this8, _attackAction2, function (unit) {
      if (unit && unit.health > 0) {
        var x = _this8.x,
          y = _this8.y,
          tX = unit.x,
          tY = unit.y,
          direction = angle_2points(x, y, tX, tY);
        _classPrivateFieldGet(_stopActiveAudio2, _this8).call(_this8);
        _classPrivateFieldGet(_playAudio2, _this8).call(_this8, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.FIGHT);
        if (direction >= -Math.PI / 4 && direction <= Math.PI / 4) {
          //console.log("move right");
          _this8.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ANIMATIONS.FIGHT_RIGHT);
        } else if (direction >= Math.PI / 4 && direction < 3 * Math.PI / 4) {
          //	//console.log("move down");
          _this8.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ANIMATIONS.FIGHT_DOWN);
        } else if (direction >= 3 * Math.PI / 4 || direction <= -3 * Math.PI / 4) {
          //console.log("move left");
          _this8.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ANIMATIONS.FIGHT_LEFT);
        } else if (direction > -3 * Math.PI / 4 && direction < Math.PI / 4) {
          //console.log("move up");
          _this8.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ANIMATIONS.FIGHT_UP);
        } else {
          console.log("unrecognized move to ", direction);
        }
        _classPrivateFieldGet(_eventsAggregator4, _this8).dispatchEvent(new CustomEvent(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_EVENTS.CREATE_ARROW, {
          detail: ["p1", x, y, tX, tY, direction]
        }));
      } else {
        _this8.activateIdle();
      }
    });
    _defineProperty(_this8, "stepMove", function (newCoordX, newCoordY) {
      var x = _this8.x,
        y = _this8.y,
        tX = _this8.targetPoint[0],
        tY = _this8.targetPoint[1];
      if (countDistance(_this8, {
        x: tX,
        y: tY
      }) < 5) {
        _this8.activateIdle();
      } else {
        var direction = angle_2points(x, y, tX, tY);
        if (direction > -Math.PI / 4 && direction < Math.PI / 4) {
          //console.log("move right");
          //this.emit(ARCHER.ANIMATIONS.MOVE);
        } else if (direction >= Math.PI / 4 && direction < 3 * Math.PI / 4) {
          //console.log("move down");
          //this.emit(ARCHER.ANIMATIONS.MOVE);
        } else if (direction > 3 * Math.PI / 4 || direction < -3 * Math.PI / 4) {
          //console.log("move left");
          //this.emit(ARCHER.ANIMATIONS.MOVE);
        } else if (direction > -3 * Math.PI / 4 && direction < Math.PI / 4) {
          //console.log("move up");
          //this.emit(ARCHER.ANIMATIONS.MOVE);
        } else {
          console.log("unrecognized move to ", direction);
        }
        _this8.xPos = newCoordX;
        _this8.yPos = newCoordY;
      }
    });
    _defineProperty(_this8, "activateMoveToTargetPoint", function (targetX, targetY) {
      var saySomething = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      _classPrivateFieldSet(_activeAction3, _this8, _const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ACTIONS.MOVE);
      _this8.targetPoint = [targetX, targetY];
      //this.emit(ARCHER.ANIMATIONS.MOVE);
      var direction = angle_2points(_this8.x, _this8.y, targetX, targetY);
      if (direction >= -Math.PI / 2 && direction <= Math.PI / 2) {
        //console.log("move right");
        _this8.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ANIMATIONS.MOVE_RIGHT);
      } else if (direction > Math.PI / 2 || direction < -Math.PI / 2) {
        //console.log("move left");
        _this8.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ANIMATIONS.MOVE_LEFT);
      } else {
        console.log("unrecognized move to ", direction);
      }
      if (_classPrivateFieldGet(_attackInterval2, _this8)) {
        clearInterval(_classPrivateFieldGet(_attackInterval2, _this8));
        _classPrivateFieldSet(_attackInterval2, _this8, null);
      }
      if (saySomething) {
        randomFromArray(_classPrivateFieldGet(_audio3, _this8).get(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.YES)).play();
      }
    });
    _defineProperty(_this8, "activateMoveToTargetPointInRange", function (targetX, targetY) {
      // not sure this is correct formula CHAT GPT make this ---->>>>
      var len = Math.sqrt(Math.pow(targetX - _this8.x, 2) + Math.pow(targetY - _this8.y, 2)),
        x = _this8.x + _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.ARCHER.attackRange * ((targetX - _this8.x) / len),
        y = _this8.y + _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.ARCHER.attackRange * ((targetY - _this8.y) / len);
      _this8.activateMoveToTargetPoint(x, y);
    });
    _classPrivateFieldInitSpec(_this8, _stopActiveAudio2, function () {
      if (_classPrivateFieldGet(_audioInProgress2, _this8)) {
        //this.#audioInProgress.pause();
      }
    });
    _classPrivateFieldInitSpec(_this8, _playAudio2, function (audioType) {
      var loop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (_classPrivateFieldGet(_audioInProgress2, _this8)) {
        //this.#audioInProgress.pause();
      }
      var audioEl = _classPrivateFieldGet(_audio3, _this8).get(audioType);
      if (audioEl) {
        _classPrivateFieldSet(_audioInProgress2, _this8, randomFromArray(_classPrivateFieldGet(_audio3, _this8).get(audioType)));
        //console.log(audio);
        _classPrivateFieldGet(_audioInProgress2, _this8).loop = loop;
        _classPrivateFieldGet(_audioInProgress2, _this8).play();
      } else {
        throw new Error("audio " + audioType + " is not defined");
      }
    });
    _defineProperty(_this8, "die", function () {
      _this8.activateIdle();
      _classPrivateFieldGet(_playAudio2, _this8).call(_this8, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.DEATH);
      _superPropGet((_this8, UnitArcher), "die", _this8, 3)([]);
    });
    _this8.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ANIMATIONS.IDLE_RIGHT, [176, 177, 178, 179, 180, 181], true);
    _this8.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ANIMATIONS.MOVE_RIGHT, [184, 185, 186, 187, 188, 189], true);
    _this8.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ANIMATIONS.IDLE_LEFT, [199, 198, 197, 196, 195, 194], true);
    _this8.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ANIMATIONS.MOVE_LEFT, [207, 206, 205, 204, 203, 202], true);
    _this8.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ANIMATIONS.FIGHT_UP, [208, 209, 210, 211, 212, 213, 214, 215], true);
    _this8.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ANIMATIONS.FIGHT_UP_RIGHT, [216, 217, 218, 219, 220, 221, 222, 223], true);
    _this8.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ANIMATIONS.FIGHT_RIGHT, [224, 225, 226, 227, 228, 229, 230, 231], true);
    _this8.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ANIMATIONS.FIGHT_DOWN_RIGHT, [232, 233, 234, 235, 236, 237, 238, 239], true);
    _this8.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ANIMATIONS.FIGHT_DOWN, [240, 241, 242, 243, 244, 245, 246, 247], true);
    _this8.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ANIMATIONS.FIGHT_UP_LEFT, [255, 254, 253, 252, 251, 250, 249, 248], true);
    _this8.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ANIMATIONS.FIGHT_LEFT, [263, 262, 261, 260, 259, 258, 257, 256], true);
    _this8.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.ARCHER.ANIMATIONS.FIGHT_DOWN_LEFT, [271, 270, 269, 268, 267, 266, 265, 264], true);
    _classPrivateFieldSet(_eventsAggregator4, _this8, eventsAggregator);
    _classPrivateFieldSet(_audio3, _this8, audio);
    _this8.sortIndex = 2;
    return _this8;
  }
  _inherits(UnitArcher, _BaseUnit4);
  return _createClass(UnitArcher, [{
    key: "activeAction",
    get: function get() {
      return _classPrivateFieldGet(_activeAction3, this);
    }
  }, {
    key: "buildingType",
    get: function get() {
      return _classPrivateFieldGet(_buildingType3, this);
    }
  }]);
}(BaseUnit);
var _activeAction4 = /*#__PURE__*/new WeakMap();
var _targetPoint2 = /*#__PURE__*/new WeakMap();
var _buildingType4 = /*#__PURE__*/new WeakMap();
var _eventsAggregator5 = /*#__PURE__*/new WeakMap();
var _audioInProgress3 = /*#__PURE__*/new WeakMap();
var _audio4 = /*#__PURE__*/new WeakMap();
var _attackInterval3 = /*#__PURE__*/new WeakMap();
var _attackAction3 = /*#__PURE__*/new WeakMap();
var _playAudio3 = /*#__PURE__*/new WeakMap();
var UnitGoblinTorch = /*#__PURE__*/function (_BaseUnit5) {
  function UnitGoblinTorch(mapX, mapY, drawFactory, isShowHealth, eventsAggregator, audio) {
    var _this9;
    _classCallCheck(this, UnitGoblinTorch);
    _this9 = _callSuper(this, UnitGoblinTorch, [mapX, mapY, 192, 192, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.GOBLIN_TORCH.name, 96, drawFactory, isShowHealth, {
      r: 30
    }]);
    /**
     * @type {string}
     */
    _classPrivateFieldInitSpec(_this9, _activeAction4, void 0);
    _classPrivateFieldInitSpec(_this9, _targetPoint2, void 0);
    _classPrivateFieldInitSpec(_this9, _buildingType4, void 0);
    _classPrivateFieldInitSpec(_this9, _eventsAggregator5, void 0);
    _classPrivateFieldInitSpec(_this9, _audioInProgress3, void 0);
    _classPrivateFieldInitSpec(_this9, _audio4, void 0);
    _classPrivateFieldInitSpec(_this9, _attackInterval3, void 0);
    _defineProperty(_this9, "activateIdle", function () {
      _classPrivateFieldSet(_activeAction4, _this9, _const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.ACTIONS.IDLE);
      _this9.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.ANIMATIONS.IDLE_LEFT);
      if (_classPrivateFieldGet(_attackInterval3, _this9)) {
        clearInterval(_classPrivateFieldGet(_attackInterval3, _this9));
        _classPrivateFieldSet(_attackInterval3, _this9, null);
      }
    });
    _defineProperty(_this9, "activateAttack", function (unit) {
      if (_classPrivateFieldGet(_activeAction4, _this9) !== _const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.ACTIONS.FIGHT) {
        clearInterval(_classPrivateFieldGet(_attackInterval3, _this9));
        _classPrivateFieldSet(_activeAction4, _this9, _const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.ACTIONS.FIGHT);
        _classPrivateFieldGet(_attackAction3, _this9).call(_this9, unit);
        _classPrivateFieldSet(_attackInterval3, _this9, setInterval(function () {
          return _classPrivateFieldGet(_attackAction3, _this9).call(_this9, unit);
        }, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.GOBLIN_TORCH.attackSpeed));
      }
    });
    _classPrivateFieldInitSpec(_this9, _attackAction3, function (unit) {
      if (unit && unit.health > 0) {
        var x = _this9.x,
          y = _this9.y,
          tX = unit.x,
          tY = unit.y,
          direction = angle_2points(x, y, tX, tY);
        if (direction >= -Math.PI / 4 && direction <= Math.PI / 4) {
          //console.log("move right");
          _this9.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.ANIMATIONS.FIGHT_RIGHT_1);
        } else if (direction >= Math.PI / 4 && direction < 3 * Math.PI / 4) {
          //	//console.log("move down");
          _this9.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.ANIMATIONS.FIGHT_DOWN_1);
        } else if (direction >= 3 * Math.PI / 4 || direction <= -3 * Math.PI / 4) {
          //console.log("move left");
          _this9.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.ANIMATIONS.FIGHT_LEFT_1);
        } else if (direction > -3 * Math.PI / 4 && direction < Math.PI / 4) {
          //console.log("move up");
          _this9.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.ANIMATIONS.FIGHT_UP_1);
        } else {
          console.log("unrecognized move to ", direction);
        }
        unit.reduceHealth(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_UNITS.GOBLIN_TORCH.attackDamage);
      } else {
        console.log("die!");
        if (unit && unit.isRemoved === false) {
          unit.die();
        }
        _this9.activateIdle();
      }
    });
    _defineProperty(_this9, "stepMove", function (newCoordX, newCoordY) {
      var x = _this9.x,
        y = _this9.y,
        tX = _this9.targetPoint[0],
        tY = _this9.targetPoint[1];
      if (countDistance(_this9, {
        x: tX,
        y: tY
      }) < 5) {
        _this9.activateIdle();
      } else {
        _this9.xPos = newCoordX;
        _this9.yPos = newCoordY;
      }
    });
    _defineProperty(_this9, "activateMoveToTargetPoint", function (targetX, targetY) {
      var saySomething = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      _classPrivateFieldSet(_activeAction4, _this9, _const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.ACTIONS.MOVE);
      _this9.targetPoint = [targetX, targetY];
      var direction = angle_2points(_this9.x, _this9.y, targetX, targetY);
      if (direction >= -Math.PI / 2 && direction <= Math.PI / 2) {
        //console.log("move right");
        _this9.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.ANIMATIONS.MOVE_RIGHT);
      } else if (direction > Math.PI / 2 || direction < -Math.PI / 2) {
        //console.log("move left");
        _this9.emit(_const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.ANIMATIONS.MOVE_LEFT);
      } else {
        console.log("unrecognized move to ", direction);
      }
      if (_classPrivateFieldGet(_attackInterval3, _this9)) {
        clearInterval(_classPrivateFieldGet(_attackInterval3, _this9));
        _classPrivateFieldSet(_attackInterval3, _this9, null);
      }
      if (saySomething) {
        randomFromArray(_this9.knightYesAudioArr.get(_const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.ATTACK)).play();
      }
    });
    _classPrivateFieldInitSpec(_this9, _playAudio3, function (audioType) {
      var loop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (_classPrivateFieldGet(_audioInProgress3, _this9)) {
        console.log(_classPrivateFieldGet(_audioInProgress3, _this9));
        //this.#audioInProgress.pause();
      }
      _classPrivateFieldSet(_audioInProgress3, _this9, randomFromArray(_classPrivateFieldGet(_audio4, _this9).get(audioType)));
      _classPrivateFieldGet(_audioInProgress3, _this9).loop = loop;
      _classPrivateFieldGet(_audioInProgress3, _this9).play();
    });
    _this9.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.ANIMATIONS.IDLE_RIGHT, [96, 97, 98, 99, 100, 101, 102], true);
    _this9.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.ANIMATIONS.MOVE_RIGHT, [104, 105, 106, 107, 108, 109], true);
    _this9.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.ANIMATIONS.FIGHT_RIGHT_1, [112, 113, 114, 115, 116, 117], true);
    _this9.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.ANIMATIONS.FIGHT_DOWN_1, [120, 121, 122, 123, 124, 125], true);
    _this9.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.ANIMATIONS.FIGHT_UP_1, [128, 129, 130, 131, 132, 133], true);
    _this9.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.ANIMATIONS.IDLE_LEFT, [142, 141, 140, 139, 138, 137, 136], true);
    _this9.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.ANIMATIONS.MOVE_LEFT, [150, 149, 148, 147, 146, 145], true);
    _this9.addAnimation(_const_js__WEBPACK_IMPORTED_MODULE_1__.GOBLIN_TORCH.ANIMATIONS.FIGHT_LEFT_1, [158, 157, 156, 155, 154, 153], true);
    _classPrivateFieldSet(_eventsAggregator5, _this9, eventsAggregator);
    _classPrivateFieldSet(_audio4, _this9, audio);
    _this9.sortIndex = 2;
    return _this9;
  }
  _inherits(UnitGoblinTorch, _BaseUnit5);
  return _createClass(UnitGoblinTorch, [{
    key: "activeAction",
    get: function get() {
      return _classPrivateFieldGet(_activeAction4, this);
    }
  }, {
    key: "buildingType",
    get: function get() {
      return _classPrivateFieldGet(_buildingType4, this);
    }
  }, {
    key: "die",
    value: function die() {
      this.activateIdle();
      _classPrivateFieldGet(_playAudio3, this).call(this, _const_js__WEBPACK_IMPORTED_MODULE_1__.GAME_AUDIO_TYPES.DEATH);
      _superPropGet(UnitGoblinTorch, "die", this, 3)([]);
    }
  }]);
}(BaseUnit);


/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		id: moduleId,
/******/ 		loaded: false,
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Flag the module as loaded
/******/ 	module.loaded = true;
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/******/ // expose the modules object (__webpack_modules__)
/******/ __webpack_require__.m = __webpack_modules__;
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/ensure chunk */
/******/ (() => {
/******/ 	__webpack_require__.f = {};
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = (chunkId) => {
/******/ 		return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 			__webpack_require__.f[key](chunkId, promises);
/******/ 			return promises;
/******/ 		}, []));
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/get javascript chunk filename */
/******/ (() => {
/******/ 	// This function allow to reference async chunks
/******/ 	__webpack_require__.u = (chunkId) => {
/******/ 		// return url for filenames based on template
/******/ 		return "" + chunkId + ".index.es6.js";
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/global */
/******/ (() => {
/******/ 	__webpack_require__.g = (function() {
/******/ 		if (typeof globalThis === 'object') return globalThis;
/******/ 		try {
/******/ 			return this || new Function('return this')();
/******/ 		} catch (e) {
/******/ 			if (typeof window === 'object') return window;
/******/ 		}
/******/ 	})();
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/node module decorator */
/******/ (() => {
/******/ 	__webpack_require__.nmd = (module) => {
/******/ 		module.paths = [];
/******/ 		if (!module.children) module.children = [];
/******/ 		return module;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/import chunk loading */
/******/ (() => {
/******/ 	// no baseURI
/******/ 	
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// [resolve, Promise] = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"main": 0
/******/ 	};
/******/ 	
/******/ 	var installChunk = (data) => {
/******/ 		var {__webpack_ids__, __webpack_modules__, __webpack_runtime__} = data;
/******/ 		// add "modules" to the modules object,
/******/ 		// then flag all "ids" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0;
/******/ 		for(moduleId in __webpack_modules__) {
/******/ 			if(__webpack_require__.o(__webpack_modules__, moduleId)) {
/******/ 				__webpack_require__.m[moduleId] = __webpack_modules__[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(__webpack_runtime__) __webpack_runtime__(__webpack_require__);
/******/ 		for(;i < __webpack_ids__.length; i++) {
/******/ 			chunkId = __webpack_ids__[i];
/******/ 			if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				installedChunks[chunkId][0]();
/******/ 			}
/******/ 			installedChunks[__webpack_ids__[i]] = 0;
/******/ 		}
/******/ 	
/******/ 	}
/******/ 	
/******/ 	__webpack_require__.f.j = (chunkId, promises) => {
/******/ 			// import() chunk loading for javascript
/******/ 			var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 			if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 	
/******/ 				// a Promise means "currently loading".
/******/ 				if(installedChunkData) {
/******/ 					promises.push(installedChunkData[1]);
/******/ 				} else {
/******/ 					if(true) { // all chunks have JS
/******/ 						// setup Promise in chunk cache
/******/ 						var promise = import("./" + __webpack_require__.u(chunkId)).then(installChunk, (e) => {
/******/ 							if(installedChunks[chunkId] !== 0) installedChunks[chunkId] = undefined;
/******/ 							throw e;
/******/ 						});
/******/ 						var promise = Promise.race([promise, new Promise((resolve) => (installedChunkData = installedChunks[chunkId] = [resolve]))])
/******/ 						promises.push(installedChunkData[1] = promise);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 	};
/******/ 	
/******/ 	// no prefetching
/******/ 	
/******/ 	// no preloaded
/******/ 	
/******/ 	// no external install chunk
/******/ 	
/******/ 	// no on chunks loaded
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jsge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsge */ "./node_modules/jsge/src/index.js");
/* harmony import */ var _stage1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stage1.js */ "./src/stage1.js");
/* harmony import */ var _stage2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stage2.js */ "./src/stage2.js");
/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./const.js */ "./src/const.js");
/* harmony import */ var _start_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./start.js */ "./src/start.js");





console.log("index.js file");
var app = new jsge__WEBPACK_IMPORTED_MODULE_0__.System(jsge__WEBPACK_IMPORTED_MODULE_0__.SystemSettings);
var createGoldBag = function createGoldBag(x, y) {
  return new jsge__WEBPACK_IMPORTED_MODULE_0__.DrawImageObject(x, y, 64, 64, "tinyswords64x64", 50);
};
var createWoodBunch = function createWoodBunch(x, y) {
  return new jsge__WEBPACK_IMPORTED_MODULE_0__.DrawImageObject(x, y, 64, 64, "tinyswords64x64", 51);
};
//SystemSettings.gameOptions.debug.boundaries.drawLayerBoundaries = true;
//SystemSettings.gameOptions.debug.boundaries.drawObjectBoundaries = true;
//SystemSettings.gameOptions.debug.checkWebGlErrors = true;
app.registerStage(_const_js__WEBPACK_IMPORTED_MODULE_3__.GAME_STAGES.START, _start_js__WEBPACK_IMPORTED_MODULE_4__.StartStage);
app.registerStage(_const_js__WEBPACK_IMPORTED_MODULE_3__.GAME_STAGES.STAGE_1, _stage1_js__WEBPACK_IMPORTED_MODULE_1__.Stage1);
app.registerStage(_const_js__WEBPACK_IMPORTED_MODULE_3__.GAME_STAGES.STAGE_2, _stage2_js__WEBPACK_IMPORTED_MODULE_2__.Stage2);
app.iSystem.iExtension.registerDrawObject("gold", createGoldBag);
app.iSystem.iExtension.registerDrawObject("wood", createWoodBunch);
app.preloadAllData().then(function () {
  app.iSystem.startGameStage(_const_js__WEBPACK_IMPORTED_MODULE_3__.GAME_STAGES.START);
});
})();


//# sourceMappingURL=index.es6.js.map